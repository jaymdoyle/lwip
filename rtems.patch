From 2d83d4994e578ec339b2b1baef53090bf7a53570 Mon Sep 17 00:00:00 2001
From: Jay Doyle <jay.doyle@vecna.com>
Date: Fri, 4 Sep 2015 17:28:55 -0400
Subject: [PATCH 01/33] rtems changes necessary

---
 Makefile                      | 170 +++++++++++
 ports/include/arch/cc.h       | 123 ++++++++
 ports/include/arch/perf.h     |  38 +++
 ports/include/arch/sys_arch.h |  59 ++++
 ports/include/lwipopts.h      | 178 ++++++++++++
 ports/sys_arch.c              | 663 ++++++++++++++++++++++++++++++++++++++++++
 6 files changed, 1231 insertions(+)
 create mode 100644 Makefile
 create mode 100644 ports/include/arch/cc.h
 create mode 100644 ports/include/arch/perf.h
 create mode 100644 ports/include/arch/sys_arch.h
 create mode 100644 ports/include/lwipopts.h
 create mode 100644 ports/sys_arch.c

diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..0cbae64
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,170 @@
+include $(RTEMS_MAKEFILE_PATH)/Makefile.inc
+include $(RTEMS_CUSTOM)
+include $(PROJECT_ROOT)/make/leaf.cfg
+
+#### CONFIG ####################################################################
+#For debugging symbols add -DLWIP_DEBUG
+# COMPILER/LINKER
+CFLAGS+=-g -O2   \
+ -Wall
+
+# OUTPUT
+LWIP_EXEC=lwip
+
+#### PATHS #####################################################################
+
+# LWIP
+LWIP_PATH=.
+LWIP_SRC_PATH=$(LWIP_PATH)/src
+LWIP_API_PATH=$(LWIP_SRC_PATH)/api
+LWIP_CORE_PATH=$(LWIP_SRC_PATH)/core
+LWIP_INCL_PATH=$(LWIP_SRC_PATH)/include
+LWIP_NETIF_PATH=$(LWIP_SRC_PATH)/netif
+
+# ARCH
+LWIPARCH_PATH=$(LWIP_PATH)/ports
+LWIPARCH_SRC_PATH=$(LWIPARCH_PATH)
+LWIPARCH_INCL_PATH=$(LWIPARCH_PATH)/include
+
+# DRIVER
+LWIPDRIVER_PATH=$(LWIP_PATH)/ports
+LWIPDRIVER_SRC_PATH=$(LWIPDRIVER_PATH)/netif
+LWIPDRIVER_INCL_PATH=$(LWIPDRIVER_PATH)/include/netif
+
+#### SOURCES ###################################################################
+
+## CORE
+CORE_SRC=$(wildcard $(LWIP_CORE_PATH)/*.c)
+
+## IPv4
+IPV4_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv4/*.c)
+
+## IPv6
+IPV6_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv6/*.c)
+
+## SNMP
+SNMP_SRC=$(wildcard $(LWIP_CORE_PATH)/snmp/*.c)
+
+## API
+API_SRC=$(wildcard $(LWIP_API_PATH)/*.c )
+
+## NETIF
+NETIF_SRC=$(wildcard $(LWIP_NETIF_PATH)/*.c) \
+          $(wildcard $(LWIP_NETIF_PATH)/ppp/*.c) \
+          $(wildcard $(LWIP_NETIF_PATH)/ppp/polarssl/*.c)
+
+
+ARCH_SRC=$(wildcard $(LWIPARCH_SRC_PATH)/*.c)
+
+# DRIVER
+DRIVER_SRC=$(wildcard $(LWIPDRIVER_SRC_PATH)/*.c ) \
+           $(wildcard $(LWIPDRIVER_SRC_PATH)/*.S )
+
+
+SOURCES =  $(DRIVER_SRC) $(SNMP_SRC)\
+           $(CORE_SRC) $(IPV4_SRC) $(API_SRC) $(NETIF_SRC) $(ARCH_SRC)
+
+
+#### HEADERS ###################################################################
+
+## CORE
+CORE_H=$(LWIP_INCL_PATH)
+
+## IPv4
+#IPV4_H=$(LWIP_INCL_PATH)/ipv4
+
+## IPv6
+#IPV6_H=$(LWIP_INCL_PATH)/ipv6
+
+## POSIX
+POSIX_H=$(LWIP_INCL_PATH)/posix
+
+##POSIX_SYS
+POSIX_SYS_H=$(LWIP_INCL_PATH)/posix/sys
+
+
+## NETIF
+NETIF_H=$(LWIP_INCL_PATH)/netif
+NETIF_H_PPP=$(LWIP_INCL_PATH)/netif/ppp
+NETIF_H_PPP_POLARSSL=$(LWIP_INCL_PATH)/netif/ppp/polarssl
+
+## ARCH
+ARCH_H=$(LWIPARCH_INCL_PATH)
+
+## DRIVER
+DRIVER_H=$(LWIPDRIVER_INCL_PATH)
+
+# HEADERS
+HEADERS=-I$(CORE_H) -I$(POSIX_H) -I$(POSIX_SYS_H) -I$(NETIF_H) \
+        -I$(NETIF_H_PPP) -I$(NETIF_H_PPP_POLARSSL) -I$(ARCH_H) \
+        -I$(DRIVER_H)
+
+
+################################################################################
+
+
+BIN=${ARCH}/$(LWIP_EXEC).bin
+LIB=${ARCH}/lib$(LWIP_EXEC).a
+
+# optional managers required
+MANAGERS=all
+
+# C source names
+CSRCS=$(filter %.c ,$(SOURCES))
+COBJS=$(patsubst %.c,${ARCH}/%.o,$(notdir $(CSRCS)))
+
+ASMSRCS=$(filter %.S , $(SOURCES))
+ASMOBJS=$(patsubst %.S,${ARCH}/%.o,$(notdir $(ASMSRCS)))
+
+OBJS=$(COBJS) $(ASMOBJS)
+
+all:${ARCH} $(LIB)
+
+$(LIB): $(OBJS)
+	$(AR)  rcs  $@ $^
+
+${ARCH}/%.o: $(LWIP_CORE_PATH)/%.c
+	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+
+${ARCH}/%.o: $(LWIP_CORE_PATH)/ipv4/%.c
+	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+
+${ARCH}/%.o: $(LWIP_CORE_PATH)/ipv6/%.c
+	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+
+${ARCH}/%.o: $(LWIP_CORE_PATH)/snmp/%.c
+	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+
+${ARCH}/%.o: $(LWIP_API_PATH)/%.c
+	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+
+${ARCH}/%.o: $(LWIP_NETIF_PATH)/%.c
+	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+
+${ARCH}/%.o: $(LWIP_NETIF_PATH)/ppp/%.c
+	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+
+${ARCH}/%.o: $(LWIP_NETIF_PATH)/ppp/polarssl/%.c
+	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+
+${ARCH}/%.o: $(LWIPARCH_SRC_PATH)/%.c
+	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+
+${ARCH}/%.o: $(LWIPDRIVER_SRC_PATH)/%.S
+	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+
+${ARCH}/%.o: $(LWIPDRIVER_SRC_PATH)/%.c
+	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+
+INSTALL_DIR=$(RTEMS_MAKEFILE_PATH)/lwip
+
+install:
+	rm -rf $(INSTALL_DIR)
+	mkdir -p $(INSTALL_DIR)/include
+	mkdir -p $(INSTALL_DIR)/lib
+	cp $(LIB) $(INSTALL_DIR)/lib
+	cp -r $(CORE_H) $(INSTALL_DIR)
+	cp $(LWIPARCH_INCL_PATH)/lwipopts.h $(INSTALL_DIR)/include
+	cp -r $(LWIPARCH_INCL_PATH)/arch $(INSTALL_DIR)/include
+
+CPPFLAGS+=$(HEADERS)
diff --git a/ports/include/arch/cc.h b/ports/include/arch/cc.h
new file mode 100644
index 0000000..04ec89f
--- /dev/null
+++ b/ports/include/arch/cc.h
@@ -0,0 +1,123 @@
+/*
+ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __CC_H__
+#define __CC_H__
+
+typedef unsigned    char    u8_t;
+typedef signed      char    s8_t;
+typedef unsigned    short   u16_t;
+typedef signed      short   s16_t;
+typedef unsigned    int    u32_t;
+typedef signed      int    s32_t;
+typedef u32_t           mem_ptr_t;
+
+#ifndef BYTE_ORDER
+#define BYTE_ORDER LITTLE_ENDIAN
+#endif
+
+#if defined(__arm__) && defined(__ARMCC_VERSION)
+    //
+    // Setup PACKing macros for KEIL/RVMDK Tools
+    //
+    #define PACK_STRUCT_BEGIN __packed
+    #define PACK_STRUCT_STRUCT
+    #define PACK_STRUCT_END
+    #define PACK_STRUCT_FIELD(x) x
+#elif defined (__IAR_SYSTEMS_ICC__)
+    //
+    // Setup PACKing macros for IAR Tools
+    //
+    #define PACK_STRUCT_BEGIN
+    #define PACK_STRUCT_STRUCT
+    #define PACK_STRUCT_END
+    #define PACK_STRUCT_FIELD(x) x
+    #define PACK_STRUCT_USE_INCLUDES
+#elif defined (__TMS470__)
+    #define PACK_STRUCT_BEGIN
+    #define PACK_STRUCT_STRUCT
+    #define PACK_STRUCT_END
+    #define PACK_STRUCT_FIELD(x) x
+#else
+    //
+    // Setup PACKing macros for GCC Tools
+    //
+    #define PACK_STRUCT_BEGIN
+    #define PACK_STRUCT_STRUCT __attribute__ ((__packed__))
+    #define PACK_STRUCT_END
+    #define PACK_STRUCT_FIELD(x) x
+#endif
+
+#ifdef LWIP_CACHE_ENABLED
+/**
+ * Make the PBUF POOL cacheline aligned.
+ */
+#ifdef __IAR_SYSTEMS_ICC__
+#pragma data_alignment=SOC_CACHELINE_SIZE_BYTES
+extern u8_t memp_memory_PBUF_POOL_base[];
+#else /*By default, GCC */
+extern u8_t memp_memory_PBUF_POOL_base[] __attribute__ ((aligned (SOC_CACHELINE_SIZE_BYTES)));
+#endif
+#endif
+
+extern u8_t memp_memory_PBUF_POOL_base[] __attribute__ ((aligned (SOC_CACHELINE_SIZE_BYTES)));
+
+/* Define (sn)printf formatters for these lwIP types */
+#define X8_F  "02x"
+#define U16_F "u"
+#define S16_F "d"
+#define X16_F "x"
+#define U32_F "u"
+#define S32_F "d"
+#define X32_F "x"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <bsp.h>
+#define LWIP_PLATFORM_DIAG(x)   do { \
+        printk("[%s - %s - %d] ", __PRETTY_FUNCTION__, __FILE__, __LINE__); \
+        printk x; \
+    } while(0)
+
+#ifdef LWIP_DEBUG  //DEBUG
+extern void __error__(char *pcFilename, unsigned long ulLine);
+#define LWIP_PLATFORM_ASSERT(expr)   printk("[%s - %s - %d] ", expr , __FILE__, __LINE__);
+//{
+    //if(!(expr))
+    //{
+        //__error__(__FILE__, __LINE__);
+    //}
+//}
+#else
+#define LWIP_PLATFORM_ASSERT(expr)
+#endif
+
+#endif /* __CC_H__ */
diff --git a/ports/include/arch/perf.h b/ports/include/arch/perf.h
new file mode 100644
index 0000000..d754157
--- /dev/null
+++ b/ports/include/arch/perf.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __PERF_H__
+#define __PERF_H__
+
+#define PERF_START    /* null definition */
+#define PERF_STOP(x)  /* null definition */
+
+#endif /* __PERF_H__ */
diff --git a/ports/include/arch/sys_arch.h b/ports/include/arch/sys_arch.h
new file mode 100644
index 0000000..32f0d99
--- /dev/null
+++ b/ports/include/arch/sys_arch.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_ARCH_SYS_ARCH_H
+#define LWIP_ARCH_SYS_ARCH_H
+
+#include <errno.h>
+
+#define SYS_MBOX_NULL NULL
+#define SYS_SEM_NULL  NULL
+
+typedef u32_t sys_prot_t;
+
+struct sys_sem;
+typedef struct sys_sem * sys_sem_t;
+#define sys_sem_valid(sem) (((sem) != NULL) && (*(sem) != NULL))
+#define sys_sem_set_invalid(sem) do { if((sem) != NULL) { *(sem) = NULL; }}while(0)
+
+/* let sys.h use binary semaphores for mutexes */
+#define LWIP_COMPAT_MUTEX 1
+
+struct sys_mbox;
+typedef struct sys_mbox *sys_mbox_t;
+#define sys_mbox_valid(mbox) ((*(mbox) != NULL))
+#define sys_mbox_set_invalid(mbox) do { if((mbox) != NULL) { *(mbox) = NULL; }}while(0)
+
+struct sys_thread;
+typedef struct sys_thread * sys_thread_t;
+
+#endif /* LWIP_ARCH_SYS_ARCH_H */
+
diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
new file mode 100644
index 0000000..169ba46
--- /dev/null
+++ b/ports/include/lwipopts.h
@@ -0,0 +1,178 @@
+/**
+ * \file lwipopts.h - Configuration options for lwIP
+ *
+ * Copyright (c) 2010 Texas Instruments Incorporated
+ */
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+
+#ifndef __LWIPOPTS_H__
+#define __LWIPOPTS_H__
+
+/*****************************************************************************
+**                           CONFIGURATIONS
+*****************************************************************************/
+
+/*
+** The below macro should be defined for using lwIP with cache. For cache
+** enabling, pbuf pool shall be cache line aligned. This is done by using
+** separate pool for each memory. The alignment of pbuf pool to cache line
+** size is done in /ports/cpsw/include/arch/cc.h.
+*/
+/*#define LWIP_CACHE_ENABLED*/
+
+#define SOC_CACHELINE_SIZE_BYTES        64            /* Number of bytes in
+                                                         a cache line */
+/*
+** The timeout for DHCP completion. lwIP library will wait for DHCP
+** completion for (LWIP_DHCP_TIMEOUT / 100) seconds.
+*/
+#define LWIP_DHCP_TIMEOUT               500
+
+/*
+** The number of times DHCP is attempted. Each time, the library will wait
+** for (LWIP_DHCP_TIMEOUT / 100) seconds for DHCP completion.
+*/
+#define NUM_DHCP_TRIES                  5
+
+#define LWIP_ETHERNET                   1
+#define LWIP_ARP                        1
+
+/*****************************************************************************
+**            lwIP SPECIFIC DEFINITIONS - To be used by lwIP stack
+*****************************************************************************/
+#define HOST_TMR_INTERVAL               0
+#define DYNAMIC_HTTP_HEADERS
+
+/*****************************************************************************
+**                    Platform specific locking
+*****************************************************************************/
+#define SYS_LIGHTWEIGHT_PROT            1
+#define NO_SYS                          0
+#define NO_SYS_NO_TIMERS                0
+
+/*****************************************************************************
+**                          Memory Options
+*****************************************************************************/
+#define MEM_ALIGNMENT                   4
+#define MEM_SIZE                        (256 * 1024) /* 128K */
+
+#define MEMP_NUM_PBUF                   96
+#define MEMP_NUM_TCP_PCB                32
+#define MEMP_NUM_TCP_SEG                32
+#define PBUF_POOL_SIZE                  512
+
+#ifdef LWIP_CACHE_ENABLED
+#define MEMP_SEPARATE_POOLS             1            /* We want the pbuf
+                                                        pool cache line
+                                                        aligned*/
+#endif
+
+#define MEMP_NUM_SYS_TIMEOUT (LWIP_TCP + IP_REASSEMBLY + LWIP_ARP + (2*LWIP_DHCP) + LWIP_AUTOIP + LWIP_IGMP + LWIP_DNS + PPP_SUPPORT)
+
+/*****************************************************************************
+**                           IP Options
+*****************************************************************************/
+#define IP_REASSEMBLY                   0
+#define IP_FRAG                         0
+
+/*****************************************************************************
+**                           DHCP Options
+*****************************************************************************/
+#define LWIP_DHCP                       1
+#define DHCP_DOES_ARP_CHECK             0
+
+/*****************************************************************************
+**                           Auto IP  Options
+*****************************************************************************/
+#define LWIP_AUTOIP                     1
+#define LWIP_DHCP_AUTOIP_COOP           ((LWIP_DHCP) && (LWIP_AUTOIP))
+
+/*****************************************************************************
+**                           TCP  Options
+*****************************************************************************/
+#define TCP_MSS                         1500
+#define TCP_WND                         (8 * TCP_MSS)
+#define TCP_SND_BUF                     (8 * TCP_MSS)
+#define TCP_OVERSIZE                    TCP_MSS
+
+/*****************************************************************************
+**                           PBUF  Options
+*****************************************************************************/
+#define PBUF_LINK_HLEN                  14
+#define PBUF_POOL_BUFSIZE               1520         /* + size of struct pbuf
+                                                        shall be cache line
+                                                        aligned be enabled */
+#define ETH_PAD_SIZE                    0
+#define LWIP_NETCONN                    1
+
+/*****************************************************************************
+**                           Socket  Options
+*****************************************************************************/
+#define LWIP_SOCKET                     1
+
+/*****************************************************************************
+**                          Debugging options
+*****************************************************************************/
+#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_OFF
+#define LWIP_DBG_TYPES_ON               (LWIP_DBG_ON | LWIP_DBG_TRACE \
+                                         |LWIP_DBG_STATE | LWIP_DBG_FRESH)
+#define DHCP_DEBUG                      LWIP_DBG_OFF
+#define NETIF_DEBUG                     LWIP_DBG_OFF
+#define IP_DEBUG			LWIP_DBG_OFF
+#define UDP_DEBUG			LWIP_DBG_OFF
+#define ETHARP_DEBUG                    LWIP_DBG_OFF
+#define SYS_DEBUG                       LWIP_DBG_OFF
+#define RAW_DEBUG                       LWIP_DBG_OFF
+#define MEM_DEBUG                       LWIP_DBG_OFF
+#define MEMP_DEBUG                      LWIP_DBG_OFF
+#define PBUF_DEBUG			LWIP_DBG_OFF
+#define TCPIP_DEBUG			LWIP_DBG_OFF
+#define APP_DEBUG			LWIP_DBG_OFF
+#define SOCKETS_DEBUG		        LWIP_DBG_OFF
+#define LWIP_STATS                      0
+#define LWIP_STATS_DISPLAY              0
+#define LWIP_STATS_POSIX                0
+
+
+
+/**
+ * LWIP_COMPAT_SOCKETS==1: Enable BSD-style sockets functions names.
+ * (only used if you use sockets.c)
+ */
+#define LWIP_COMPAT_SOCKETS             0
+
+#define LWIP_TIMEVAL_PRIVATE            0
+
+ #define LWIP_RAW                       0
+
+#endif /* __LWIPOPTS_H__ */
diff --git a/ports/sys_arch.c b/ports/sys_arch.c
new file mode 100644
index 0000000..360a4e2
--- /dev/null
+++ b/ports/sys_arch.c
@@ -0,0 +1,663 @@
+/*
+ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+
+/*
+ * Wed Apr 17 16:05:29 EDT 2002 (James Roth)
+ *
+ *  - Fixed an unlikely sys_thread_new() race condition.
+ *
+ *  - Made current_thread() work with threads which where
+ *    not created with sys_thread_new().  This includes
+ *    the main thread and threads made with pthread_create().
+ *
+ *  - Catch overflows where more than SYS_MBOX_SIZE messages
+ *    are waiting to be read.  The sys_mbox_post() routine
+ *    will block until there is more room instead of just
+ *    leaking messages.
+ */
+
+#include <string.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <pthread.h>
+
+#include "lwip/opt.h"
+#include "lwip/sys.h"
+#include "lwip/stats.h"
+#include "lwip/debug.h"
+
+#define UMAX(a, b)      ((a) > (b) ? (a) : (b))
+
+static struct timeval starttime;
+
+#if !NO_SYS
+
+static struct sys_thread *threads = NULL;
+static pthread_mutex_t threads_mutex = PTHREAD_MUTEX_INITIALIZER;
+
+struct sys_mbox_msg {
+  struct sys_mbox_msg *next;
+  void *msg;
+};
+
+#define SYS_MBOX_SIZE 128
+
+struct sys_mbox {
+  int first, last;
+  void *msgs[SYS_MBOX_SIZE];
+  struct sys_sem *not_empty;
+  struct sys_sem *not_full;
+  struct sys_sem *mutex;
+  int wait_send;
+};
+
+struct sys_sem {
+  unsigned int c;
+  pthread_cond_t cond;
+  pthread_mutex_t mutex;
+};
+
+struct sys_thread {
+  struct sys_thread *next;
+  pthread_t pthread;
+};
+
+#if SYS_LIGHTWEIGHT_PROT
+static pthread_mutex_t lwprot_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pthread_t lwprot_thread = (pthread_t)0xDEAD;
+static int lwprot_count = 0;
+#endif /* SYS_LIGHTWEIGHT_PROT */
+
+static struct sys_sem *sys_sem_new_internal(u8_t count);
+static void sys_sem_free_internal(struct sys_sem *sem);
+
+static u32_t cond_wait(pthread_cond_t * cond, pthread_mutex_t * mutex,
+                       u32_t timeout);
+
+/*-----------------------------------------------------------------------------------*/
+static struct sys_thread *
+introduce_thread(pthread_t id)
+{
+  struct sys_thread *thread = NULL;
+
+  thread = (struct sys_thread *)malloc(sizeof(struct sys_thread));
+
+  if (thread != NULL) {
+    pthread_mutex_lock(&threads_mutex);
+    thread->next = threads;
+    thread->pthread = id;
+    threads = thread;
+    pthread_mutex_unlock(&threads_mutex);
+  }
+
+  return thread;
+}
+/*-----------------------------------------------------------------------------------*/
+sys_thread_t
+sys_thread_new(const char *name, lwip_thread_fn function, void *arg, int stacksize, int prio)
+{
+  int code;
+  int rc;
+  pthread_t tmp;
+  pthread_attr_t attr;
+  struct sys_thread *st = NULL;
+  LWIP_UNUSED_ARG(name);
+  LWIP_UNUSED_ARG(stacksize);
+  LWIP_UNUSED_ARG(prio);
+
+  /* Alloc a new pthread with the specified stack size. */
+  if(stacksize > 0) {
+    rc = pthread_attr_init(&attr);
+    if (rc != 0) {
+      LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: pthread_attr_init error = %d\n", rc));
+      return NULL;
+    }
+    rc = pthread_attr_setstacksize(&attr, stacksize);
+    if (rc != 0) {
+      LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: pthread_attr_setstacksize error = %d\n", rc));
+      pthread_attr_destroy(&attr);
+      return NULL;
+    }
+    pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);
+    pthread_attr_setschedpolicy(&attr, SCHED_RR);
+    code = pthread_create(&tmp, &attr, (void *(*)(void *)) function, arg);
+    pthread_attr_destroy(&attr);
+  } else {
+    code = pthread_create(&tmp, NULL, (void *(*)(void *)) function, arg);
+  }
+  LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: thread created [name:%s|stacksize:%d|prio:%d|addr:0x%x]\n",
+                          name, stacksize, prio, (uint)tmp));
+
+  if (0 == code) {
+    st = introduce_thread(tmp);
+  }
+
+  if (NULL == st) {
+    LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: failed to introduce %d, st = %p\n",
+                            code, (void*)st));
+    abort();
+  } else {
+    LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: introduced %d, st = %p\n",
+                            code, (void*)st));
+  }
+
+  return st;
+}
+/*-----------------------------------------------------------------------------------*/
+void sys_thread_signal(sys_thread_t thread, int signal)
+{
+    /* Check received parameters. */
+    if(thread == NULL) {
+        LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_signal: could not send signal to thread. thread = NULL\n"));
+        return;
+    }
+
+    /* Send signal. */
+    pthread_kill(thread->pthread, signal);
+}
+/*-----------------------------------------------------------------------------------*/
+err_t
+sys_mbox_new(struct sys_mbox **mb, int size)
+{
+  struct sys_mbox *mbox = NULL;
+  LWIP_UNUSED_ARG(size);
+
+  mbox = (struct sys_mbox *)malloc(sizeof(struct sys_mbox));
+  if (mbox == NULL) {
+    SYS_STATS_INC(mbox.err);
+    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_new: could not create mbox\n"));
+    return ERR_MEM;
+  }
+  mbox->first = mbox->last = 0;
+  mbox->not_empty = sys_sem_new_internal(0);
+  mbox->not_full = sys_sem_new_internal(0);
+  mbox->mutex = sys_sem_new_internal(1);
+  mbox->wait_send = 0;
+
+  SYS_STATS_INC_USED(mbox);
+
+  if((mbox->not_empty == NULL) || (mbox->not_full == NULL) || (mbox->mutex == NULL)) {
+    SYS_STATS_INC(mbox.err);
+    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_new: could not create mbox internals\n"));
+    sys_mbox_free(&mbox);
+    return ERR_MEM;
+  }
+  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_new: mbox created [not_empty:%X|not_full:%X|mutex:%X] \n",
+                          mbox->not_empty, mbox->not_full, mbox->mutex));
+
+  *mb = mbox;
+  return ERR_OK;
+}
+/*-----------------------------------------------------------------------------------*/
+void
+sys_mbox_free(struct sys_mbox **mb)
+{
+  if ((mb != NULL) && (*mb != SYS_MBOX_NULL)) {
+    struct sys_mbox *mbox = *mb;
+    sys_arch_sem_wait(&mbox->mutex, 0);
+
+    sys_sem_free_internal(mbox->not_empty);
+    sys_sem_free_internal(mbox->not_full);
+    sys_sem_free_internal(mbox->mutex);
+    mbox->not_empty = mbox->not_full = mbox->mutex = NULL;
+    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_free: mbox 0x%lx\n", mbox));
+    free(mbox);
+    SYS_STATS_DEC(mbox.used);
+  }
+}
+/*-----------------------------------------------------------------------------------*/
+err_t
+sys_mbox_trypost(struct sys_mbox **mb, void *msg)
+{
+  u8_t first;
+  struct sys_mbox *mbox;
+  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
+  mbox = *mb;
+  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_trypost: start"));
+  sys_arch_sem_wait(&mbox->mutex, 0);
+
+  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_trypost: mbox %p msg %p\n",
+                          (void *)mbox, (void *)msg));
+
+  if ((mbox->last + 1) >= (mbox->first + SYS_MBOX_SIZE)) {
+    sys_sem_signal(&mbox->mutex);
+    return ERR_MEM;
+  }
+
+  mbox->msgs[mbox->last % SYS_MBOX_SIZE] = msg;
+
+  if (mbox->last == mbox->first) {
+    first = 1;
+  } else {
+    first = 0;
+  }
+
+  mbox->last++;
+
+  if (first) {
+    sys_sem_signal(&mbox->not_empty);
+  }
+
+  sys_sem_signal(&mbox->mutex);
+
+  return ERR_OK;
+}
+/*-----------------------------------------------------------------------------------*/
+void
+sys_mbox_post(struct sys_mbox **mb, void *msg)
+{
+  u8_t first;
+  struct sys_mbox *mbox;
+  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
+  mbox = *mb;
+
+  sys_arch_sem_wait(&mbox->mutex, 0);
+
+  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_post: mbox %p msg %p\n", (void *)mbox, (void *)msg));
+
+  while ((mbox->last + 1) >= (mbox->first + SYS_MBOX_SIZE)) {
+    mbox->wait_send++;
+    sys_sem_signal(&mbox->mutex);
+    sys_arch_sem_wait(&mbox->not_full, 0);
+    sys_arch_sem_wait(&mbox->mutex, 0);
+    mbox->wait_send--;
+  }
+
+  mbox->msgs[mbox->last % SYS_MBOX_SIZE] = msg;
+
+  if (mbox->last == mbox->first) {
+    first = 1;
+  } else {
+    first = 0;
+  }
+
+  mbox->last++;
+
+  if (first) {
+    sys_sem_signal(&mbox->not_empty);
+  }
+
+  sys_sem_signal(&mbox->mutex);
+}
+/*-----------------------------------------------------------------------------------*/
+u32_t
+sys_arch_mbox_tryfetch(struct sys_mbox **mb, void **msg)
+{
+  struct sys_mbox *mbox;
+  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
+  mbox = *mb;
+
+  sys_arch_sem_wait(&mbox->mutex, 0);
+
+  if (mbox->first == mbox->last) {
+    sys_sem_signal(&mbox->mutex);
+    return SYS_MBOX_EMPTY;
+  }
+
+  if (msg != NULL) {
+    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_tryfetch: mbox %p msg %p\n", (void *)mbox, *msg));
+    *msg = mbox->msgs[mbox->first % SYS_MBOX_SIZE];
+  }
+  else{
+    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_tryfetch: mbox %p, null msg\n", (void *)mbox));
+  }
+
+  mbox->first++;
+
+  if (mbox->wait_send) {
+    sys_sem_signal(&mbox->not_full);
+  }
+
+  sys_sem_signal(&mbox->mutex);
+
+  return 0;
+}
+/*-----------------------------------------------------------------------------------*/
+u32_t
+sys_arch_mbox_fetch(struct sys_mbox **mb, void **msg, u32_t timeout)
+{
+  u32_t time_needed = 0;
+  struct sys_mbox *mbox;
+  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
+  mbox = *mb;
+
+  /* The mutex lock is quick so we don't bother with the timeout
+     stuff here. */
+  sys_arch_sem_wait(&mbox->mutex, 0);
+
+  while (mbox->first == mbox->last) {
+    sys_sem_signal(&mbox->mutex);
+
+    /* We block while waiting for a mail to arrive in the mailbox. We
+       must be prepared to timeout. */
+    if (timeout != 0) {
+      time_needed = sys_arch_sem_wait(&mbox->not_empty, timeout);
+
+      if (time_needed == SYS_ARCH_TIMEOUT) {
+        return SYS_ARCH_TIMEOUT;
+      }
+    } else {
+      sys_arch_sem_wait(&mbox->not_empty, 0);
+    }
+
+    sys_arch_sem_wait(&mbox->mutex, 0);
+  }
+
+  if (msg != NULL) {
+    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_fetch: mbox %p msg %p\n", (void *)mbox, *msg));
+    *msg = mbox->msgs[mbox->first % SYS_MBOX_SIZE];
+  }
+  else{
+    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_fetch: mbox %p, null msg\n", (void *)mbox));
+  }
+
+  mbox->first++;
+
+  if (mbox->wait_send) {
+    sys_sem_signal(&mbox->not_full);
+  }
+
+  sys_sem_signal(&mbox->mutex);
+
+  return time_needed;
+}
+/*-----------------------------------------------------------------------------------*/
+static struct sys_sem *
+sys_sem_new_internal(u8_t count)
+{
+  struct sys_sem *sem = NULL;
+  int rc;
+
+  sem = (struct sys_sem *)malloc(sizeof(struct sys_sem));
+  if (sem != NULL) {
+    sem->c = count;
+    rc = pthread_cond_init(&(sem->cond), NULL);
+    if(rc != 0) {
+      LWIP_DEBUGF(SYS_DEBUG, ("sys_sem_new_internal: pthread_cond_init error = %d\n", rc));
+      return NULL;
+    }
+    rc = pthread_mutex_init(&(sem->mutex), NULL);
+    if(rc != 0) {
+      LWIP_DEBUGF(SYS_DEBUG, ("sys_sem_new_internal: pthread_mutex_init error = %d\n", rc));
+      SYS_STATS_INC(mutex.err);
+      pthread_cond_destroy(&(sem->cond));
+      return NULL;
+    }
+    SYS_STATS_INC_USED(mutex);
+    SYS_STATS_INC_USED(sem);
+  } else {
+    LWIP_DEBUGF(SYS_DEBUG, ("sys_sem_new_internal: could not create semaphore\n"));
+    SYS_STATS_INC(sem.err);
+  }
+  return sem;
+}
+/*-----------------------------------------------------------------------------------*/
+err_t
+sys_sem_new(struct sys_sem **sem, u8_t count)
+{
+  *sem = sys_sem_new_internal(count);
+  if (*sem == NULL) {
+    return ERR_MEM;
+  }
+  return ERR_OK;
+}
+/*-----------------------------------------------------------------------------------*/
+static u32_t
+cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex, u32_t timeout)
+{
+  time_t tdiff;
+  time_t sec, usec;
+  struct timeval rtime1, rtime2;
+  struct timespec ts;
+  int retval;
+
+  if (timeout > 0) {
+    /* Get a timestamp and add the timeout value. */
+    gettimeofday(&rtime1, NULL);
+    sec = rtime1.tv_sec;
+    usec = rtime1.tv_usec;
+    usec += timeout % 1000 * 1000;
+    sec += (int)(timeout / 1000) + (int)(usec / 1000000);
+    usec = usec % 1000000;
+    ts.tv_nsec = usec * 1000;
+    ts.tv_sec = sec;
+
+    retval = pthread_cond_timedwait(cond, mutex, &ts);
+
+    if (retval == ETIMEDOUT) {
+      return SYS_ARCH_TIMEOUT;
+    } else {
+      /* Calculate for how long we waited for the cond. */
+      gettimeofday(&rtime2, NULL);
+      tdiff = (rtime2.tv_sec - rtime1.tv_sec) * 1000 +
+        (rtime2.tv_usec - rtime1.tv_usec) / 1000;
+
+      if (tdiff <= 0) {
+        return 0;
+      }
+      return (u32_t)tdiff;
+    }
+  } else {
+    pthread_cond_wait(cond, mutex);
+    return 0;
+  }
+}
+/*-----------------------------------------------------------------------------------*/
+u32_t
+sys_arch_sem_wait(struct sys_sem **s, u32_t timeout)
+{
+  u32_t time_needed = 0;
+  struct sys_sem *sem;
+  LWIP_ASSERT("invalid sem", (s != NULL) && (*s != NULL));
+  sem = *s;
+
+  pthread_mutex_lock(&(sem->mutex));
+  while (sem->c <= 0) {
+    if (timeout > 0) {
+      time_needed = cond_wait(&(sem->cond), &(sem->mutex), timeout);
+
+      if (time_needed == SYS_ARCH_TIMEOUT) {
+        pthread_mutex_unlock(&(sem->mutex));
+        return SYS_ARCH_TIMEOUT;
+      }
+    } else {
+      cond_wait(&(sem->cond), &(sem->mutex), 0);
+    }
+  }
+  sem->c--;
+  pthread_mutex_unlock(&(sem->mutex));
+  return (u32_t)time_needed;
+}
+/*-----------------------------------------------------------------------------------*/
+void
+sys_sem_signal(struct sys_sem **s)
+{
+  struct sys_sem *sem;
+  LWIP_ASSERT("invalid sem", (s != NULL) && (*s != NULL));
+  sem = *s;
+
+  pthread_mutex_lock(&(sem->mutex));
+  sem->c++;
+
+  if (sem->c > 1) {
+    sem->c = 1;
+  }
+
+  pthread_cond_broadcast(&(sem->cond));
+  pthread_mutex_unlock(&(sem->mutex));
+}
+/*-----------------------------------------------------------------------------------*/
+static void
+sys_sem_free_internal(struct sys_sem *sem)
+{
+  if(sem != NULL) {
+    pthread_cond_destroy(&(sem->cond));
+    pthread_mutex_destroy(&(sem->mutex));
+    SYS_STATS_DEC(mutex.used);
+    SYS_STATS_DEC(sem.used);
+    free(sem);
+  }
+}
+/*-----------------------------------------------------------------------------------*/
+void
+sys_sem_free(struct sys_sem **sem)
+{
+  if ((sem != NULL) && (*sem != SYS_SEM_NULL)) {
+    sys_sem_free_internal(*sem);
+  }
+}
+#endif /* !NO_SYS */
+/*-----------------------------------------------------------------------------------*/
+u32_t
+sys_now(void)
+{
+  struct timeval tv;
+  u32_t sec, usec, msec;
+  gettimeofday(&tv, NULL);
+
+  sec = (u32_t)(tv.tv_sec - starttime.tv_sec);
+  usec = (u32_t)(tv.tv_usec - starttime.tv_usec);
+  msec = sec * 1000 + usec / 1000;
+
+  return msec;
+}
+/*-----------------------------------------------------------------------------------*/
+void
+sys_init(void)
+{
+  SYS_STATS_INC_USED(mutex);
+  gettimeofday(&starttime, NULL);
+}
+/*-----------------------------------------------------------------------------------*/
+#if SYS_LIGHTWEIGHT_PROT
+/** sys_prot_t sys_arch_protect(void)
+
+This optional function does a "fast" critical region protection and returns
+the previous protection level. This function is only called during very short
+critical regions. An embedded system which supports ISR-based drivers might
+want to implement this function by disabling interrupts. Task-based systems
+might want to implement this by using a mutex or disabling tasking. This
+function should support recursive calls from the same task or interrupt. In
+other words, sys_arch_protect() could be called while already protected. In
+that case the return value indicates that it is already protected.
+
+sys_arch_protect() is only required if your port is supporting an operating
+system.
+*/
+sys_prot_t
+sys_arch_protect(void)
+{
+    /* Note that for the UNIX port, we are using a lightweight mutex, and our
+     * own counter (which is locked by the mutex). The return code is not actually
+     * used. */
+    if (lwprot_thread != pthread_self())
+    {
+        /* We are locking the mutex where it has not been locked before *
+        * or is being locked by another thread */
+        pthread_mutex_lock(&lwprot_mutex);
+        lwprot_thread = pthread_self();
+        lwprot_count = 1;
+    }
+    else
+    {
+        /* It is already locked by THIS thread */
+        lwprot_count++;
+    }
+    return 0;
+}
+/*-----------------------------------------------------------------------------------*/
+/** void sys_arch_unprotect(sys_prot_t pval)
+
+This optional function does a "fast" set of critical region protection to the
+value specified by pval. See the documentation for sys_arch_protect() for
+more information. This function is only required if your port is supporting
+an operating system.
+*/
+void
+sys_arch_unprotect(sys_prot_t pval)
+{
+    LWIP_UNUSED_ARG(pval);
+    if (lwprot_thread == pthread_self())
+    {
+        if (--lwprot_count == 0)
+        {
+            lwprot_thread = (pthread_t) 0xDEAD;
+            pthread_mutex_unlock(&lwprot_mutex);
+        }
+    }
+}
+#endif /* SYS_LIGHTWEIGHT_PROT */
+
+/*-----------------------------------------------------------------------------------*/
+
+#ifndef MAX_JIFFY_OFFSET
+#define MAX_JIFFY_OFFSET ((~0U >> 1)-1)
+#endif
+
+#ifndef HZ
+#define HZ 100
+#endif
+
+u32_t
+sys_jiffies(void)
+{
+    struct timeval tv;
+    unsigned long sec;
+    long usec;
+
+    gettimeofday(&tv,NULL);
+    sec = tv.tv_sec - starttime.tv_sec;
+    usec = tv.tv_usec;
+
+    if (sec >= (MAX_JIFFY_OFFSET / HZ))
+      return MAX_JIFFY_OFFSET;
+    usec += 1000000L / HZ - 1;
+    usec /= 1000000L / HZ;
+    return HZ * sec + usec;
+}
+
+#if PPP_DEBUG
+
+#include <stdarg.h>
+
+void ppp_trace(int level, const char *format, ...)
+{
+    va_list args;
+
+    (void)level;
+    va_start(args, format);
+    vprintf(format, args);
+    va_end(args);
+}
+#endif
-- 
1.9.1


From d053fa836b445b6736bf82d33a33a59055150aa7 Mon Sep 17 00:00:00 2001
From: Jay Doyle <jay.doyle@vecna.com>
Date: Fri, 4 Sep 2015 17:30:37 -0400
Subject: [PATCH 02/33] changed the compiler options

---
 Makefile | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/Makefile b/Makefile
index 0cbae64..94fcafc 100644
--- a/Makefile
+++ b/Makefile
@@ -5,7 +5,7 @@ include $(PROJECT_ROOT)/make/leaf.cfg
 #### CONFIG ####################################################################
 #For debugging symbols add -DLWIP_DEBUG
 # COMPILER/LINKER
-CFLAGS+=-g -O2   \
+CFLAGS+=-g -O0   \
  -Wall
 
 # OUTPUT
-- 
1.9.1


From 841adb17430bdb9298dcb6d44ac5dad72e82af80 Mon Sep 17 00:00:00 2001
From: Jay Doyle <jay.doyle@vecna.com>
Date: Mon, 7 Sep 2015 08:56:58 -0400
Subject: [PATCH 03/33] disabled any mention of ipv6

---
 Makefile | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/Makefile b/Makefile
index 94fcafc..6efa141 100644
--- a/Makefile
+++ b/Makefile
@@ -40,7 +40,7 @@ CORE_SRC=$(wildcard $(LWIP_CORE_PATH)/*.c)
 IPV4_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv4/*.c)
 
 ## IPv6
-IPV6_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv6/*.c)
+#IPV6_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv6/*.c)
 
 ## SNMP
 SNMP_SRC=$(wildcard $(LWIP_CORE_PATH)/snmp/*.c)
@@ -71,7 +71,7 @@ SOURCES =  $(DRIVER_SRC) $(SNMP_SRC)\
 CORE_H=$(LWIP_INCL_PATH)
 
 ## IPv4
-#IPV4_H=$(LWIP_INCL_PATH)/ipv4
+IPV4_H=$(LWIP_INCL_PATH)/ipv4
 
 ## IPv6
 #IPV6_H=$(LWIP_INCL_PATH)/ipv6
@@ -97,7 +97,7 @@ DRIVER_H=$(LWIPDRIVER_INCL_PATH)
 # HEADERS
 HEADERS=-I$(CORE_H) -I$(POSIX_H) -I$(POSIX_SYS_H) -I$(NETIF_H) \
         -I$(NETIF_H_PPP) -I$(NETIF_H_PPP_POLARSSL) -I$(ARCH_H) \
-        -I$(DRIVER_H)
+        -I$(DRIVER_H) -I$(IPV4_H)
 
 
 ################################################################################
-- 
1.9.1


From a653d818348fef0130e6e497eecb0c3a35822df4 Mon Sep 17 00:00:00 2001
From: Jay Doyle <jay.doyle@vecna.com>
Date: Mon, 7 Sep 2015 09:27:48 -0400
Subject: [PATCH 04/33] added in stm32f low-level driver

---
 src/netif/ethernetif.c | 709 ++++++++++++++++++++++++++++++-------------------
 1 file changed, 435 insertions(+), 274 deletions(-)

diff --git a/src/netif/ethernetif.c b/src/netif/ethernetif.c
index 7982d11..82c85ae 100644
--- a/src/netif/ethernetif.c
+++ b/src/netif/ethernetif.c
@@ -1,335 +1,496 @@
 /**
- * @file
- * Ethernet Interface Skeleton
- *
- */
-
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved. 
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-
-/*
- * This file is a skeleton for developing Ethernet network interface
- * drivers for lwIP. Add code to the low_level functions and do a
- * search-and-replace for the word "ethernetif" to replace it with
- * something that better describes your network interface.
- */
-
+  ******************************************************************************
+  * @file    LwIP/LwIP_HTTP_Server_Netconn_RTOS/Src/ethernetif.c
+  * @author  MCD Application Team
+  * @version V1.0.0
+  * @date    25-June-2015
+  * @brief   This file implements Ethernet network interface drivers for lwIP
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f7xx_hal.h"
 #include "lwip/opt.h"
-
-#if 0 /* don't build, this is only a skeleton, see previous comment */
-
-#include "lwip/def.h"
-#include "lwip/mem.h"
-#include "lwip/pbuf.h"
-#include "lwip/stats.h"
-#include "lwip/snmp.h"
-#include "lwip/ethip6.h"
+#include "lwip/lwip_timers.h"
 #include "netif/etharp.h"
-#include "netif/ppp/pppoe.h"
+#include "hal-ethernetif.h"
+#include <string.h>
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/* The time to block waiting for input. */
+#define TIME_WAITING_FOR_INPUT                 ( 100 )
+/* Stack size of the interface thread */
+#define INTERFACE_THREAD_STACK_SIZE            ( 350 )
 
 /* Define those to better describe your network interface. */
 #define IFNAME0 'e'
 #define IFNAME1 'n'
 
-/**
- * Helper struct to hold private data used to operate your ethernet interface.
- * Keeping the ethernet address of the MAC in this struct is not necessary
- * as it is already kept in the struct netif.
- * But this is only an example, anyway...
- */
-struct ethernetif {
-  struct eth_addr *ethaddr;
-  /* Add whatever per-interface state that is needed here. */
-};
-
-/* Forward declarations. */
-static void  ethernetif_input(struct netif *netif);
+#define LAN8742A_PHY_ADDRESS            0x00
 
-/**
- * In this function, the hardware should be initialized.
- * Called from ethernetif_init().
- *
- * @param netif the already initialized lwip network interface structure
- *        for this ethernetif
- */
-static void
-low_level_init(struct netif *netif)
-{
-  struct ethernetif *ethernetif = netif->state;
-  
-  /* set MAC hardware address length */
-  netif->hwaddr_len = ETHARP_HWADDR_LEN;
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
 
-  /* set MAC hardware address */
-  netif->hwaddr[0] = ;
-  ...
-  netif->hwaddr[5] = ;
+#if defined ( __ICCARM__ ) /*!< IAR Compiler */
 
-  /* maximum transfer unit */
-  netif->mtu = 1500;
-  
-  /* device capabilities */
-  /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
-  netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
- 
-#if LWIP_IPV6 && LWIP_IPV6_MLD
-  /*
-   * For hardware/netifs that implement MAC filtering.
-   * All-nodes link-local is handled by default, so we must let the hardware know
-   * to allow multicast packets in.
-   * Should set mld_mac_filter previously. */
-  if (netif->mld_mac_filter != NULL) {
-    ip6_addr_t ip6_allnodes_ll;
-    ip6_addr_set_allnodes_linklocal(&ip6_allnodes_ll);
-    netif->mld_mac_filter(netif, &ip6_allnodes_ll, MLD6_ADD_MAC_FILTER);
-  }
-#endif /* LWIP_IPV6 && LWIP_IPV6_MLD */
+#pragma location=0x2000E000
+__no_init ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
+#pragma location=0x2000E100
+__no_init ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
+#elif defined ( __CC_ARM   )
+ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((at(0x2000E000)));/* Ethernet Rx MA Descriptor */
+ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((at(0x2000E100)));/* Ethernet Tx DMA Descriptor */
+#elif defined ( __GNUC__   )
+//ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".RxDescripSection")));/* Ethernet Rx MA Descriptor */
+//ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".TxDescripSection")));/* Ethernet Tx DMA Descriptor */
+ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Rx MA Descriptor */
+ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Tx DMA Descriptor */
+
+
+#endif
+#if defined ( __ICCARM__ ) /*!< IAR Compiler */
+#pragma location=0x2000E200
+__no_init uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
+#pragma location=0x2000FFC4
+__no_init uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
+#elif defined ( __CC_ARM   )
+uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((at(0x2000E200)));  /* Ethernet Receive Buffer */
+uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]  __attribute__((at(0x2000FFC4))); /* Ethernet Transmit Buffer */
+#elif defined ( __GNUC__   )
+//uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".RxBUF")));/* Ethernet Receive Buffer */
+//uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".TxBUF")));/* Ethernet Transmit Buffer */
+uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Receive Buffer */
+uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Transmit Buffer */
+
+#endif
+/* Semaphore to signal incoming packets */
+osSemaphoreId s_xSemaphore = NULL;
 
-  /* Do whatever else is needed to initialize interface. */  
+/* Global Ethernet handle*/
+ETH_HandleTypeDef EthHandle;
+
+/* Private function prototypes -----------------------------------------------*/
+static void ethernetif_input( void const * argument );
+
+static void stm32f_ethernet_isr(
+  void* argData
+)
+{
+  ETH_HandleTypeDef* pEth =
+    (ETH_HandleTypeDef*) argData;
+
+  HAL_ETH_IRQHandler(pEth);
 }
 
+/* Private functions ---------------------------------------------------------*/
+/*******************************************************************************
+                       Ethernet MSP Routines
+*******************************************************************************/
 /**
- * This function should do the actual transmission of the packet. The packet is
- * contained in the pbuf that is passed to the function. This pbuf
- * might be chained.
- *
- * @param netif the lwip network interface structure for this ethernetif
- * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
- * @return ERR_OK if the packet could be sent
- *         an err_t value if the packet couldn't be sent
- *
- * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
- *       strange results. You might consider waiting for space in the DMA queue
- *       to become available since the stack doesn't retry to send a packet
- *       dropped because of memory failure (except for the TCP timers).
- */
-
-static err_t
-low_level_output(struct netif *netif, struct pbuf *p)
+  * @brief  Initializes the ETH MSP.
+  * @param  heth: ETH handle
+  * @retval None
+  */
+void HAL_ETH_MspInit(ETH_HandleTypeDef *heth)
 {
-  struct ethernetif *ethernetif = netif->state;
-  struct pbuf *q;
-
-  initiate transfer();
+  GPIO_InitTypeDef GPIO_InitStructure;
   
-#if ETH_PAD_SIZE
-  pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
-#endif
-
-  for(q = p; q != NULL; q = q->next) {
-    /* Send the data from the pbuf to the interface, one pbuf at a
-       time. The size of the data in each pbuf is kept in the ->len
-       variable. */
-    send data from(q->payload, q->len);
-  }
+  /* Enable GPIOs clocks */
+  __HAL_RCC_GPIOA_CLK_ENABLE();
+  __HAL_RCC_GPIOC_CLK_ENABLE();
+  __HAL_RCC_GPIOG_CLK_ENABLE();
 
-  signal that packet should be sent();
+/* Ethernet pins configuration ************************************************/
+  /*
+        RMII_REF_CLK ----------------------> PA1
+        RMII_MDIO -------------------------> PA2
+        RMII_MDC --------------------------> PC1
+        RMII_MII_CRS_DV -------------------> PA7
+        RMII_MII_RXD0 ---------------------> PC4
+        RMII_MII_RXD1 ---------------------> PC5
+        RMII_MII_RXER ---------------------> PG2
+        RMII_MII_TX_EN --------------------> PG11
+        RMII_MII_TXD0 ---------------------> PG13
+        RMII_MII_TXD1 ---------------------> PG14
+  */
+
+  /* Configure PA1, PA2 and PA7 */
+  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
+  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
+  GPIO_InitStructure.Pull = GPIO_NOPULL; 
+  GPIO_InitStructure.Alternate = GPIO_AF11_ETH;
+  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
+  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
+  
+  /* Configure PC1, PC4 and PC5 */
+  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;
+  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
 
-#if ETH_PAD_SIZE
-  pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
-#endif
+  /* Configure PG2, PG11, PG13 and PG14 */
+  GPIO_InitStructure.Pin =  GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14;
+  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
   
-  LINK_STATS_INC(link.xmit);
+  // Install HAL Ethernet ISR
+  rtems_interrupt_handler_install(
+    ETH_IRQn,
+    NULL,
+    0,
+    stm32f_ethernet_isr,
+    heth);
+  
+  /* Enable ETHERNET clock  */
+  __HAL_RCC_ETH_CLK_ENABLE();
+}
 
-  return ERR_OK;
+/**
+  * @brief  Ethernet Rx Transfer completed callback
+  * @param  heth: ETH handle
+  * @retval None
+  */
+void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
+{
+  osSemaphoreRelease(s_xSemaphore);
 }
 
 /**
- * Should allocate a pbuf and transfer the bytes of the incoming
- * packet from the interface into the pbuf.
- *
- * @param netif the lwip network interface structure for this ethernetif
- * @return a pbuf filled with the received packet (including MAC header)
- *         NULL on memory error
- */
-static struct pbuf *
-low_level_input(struct netif *netif)
+  * @brief  Ethernet IRQ Handler
+  * @param  None
+  * @retval None
+  */
+void ETHERNET_IRQHandler(void)
 {
-  struct ethernetif *ethernetif = netif->state;
-  struct pbuf *p, *q;
-  u16_t len;
+  HAL_ETH_IRQHandler(&EthHandle);
+}
 
-  /* Obtain the size of the packet and put it into the "len"
-     variable. */
-  len = ;
+/*******************************************************************************
+                       LL Driver Interface ( LwIP stack --> ETH) 
+*******************************************************************************/
+/**
+  * @brief In this function, the hardware should be initialized.
+  * Called from ethernetif_init().
+  *
+  * @param netif the already initialized lwip network interface structure
+  *        for this ethernetif
+  */
+static void low_level_init(struct netif *netif)
+{
+  uint8_t macaddress[6]= { MAC_ADDR0, MAC_ADDR1, MAC_ADDR2, MAC_ADDR3, MAC_ADDR4, MAC_ADDR5 };
+  
+  EthHandle.Instance = ETH;  
+  EthHandle.Init.MACAddr = macaddress;
+  EthHandle.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
+  EthHandle.Init.Speed = ETH_SPEED_100M;
+  EthHandle.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
+  EthHandle.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
+  EthHandle.Init.RxMode = ETH_RXINTERRUPT_MODE;
+  EthHandle.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
+  EthHandle.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
+  
+  /* configure ethernet peripheral (GPIOs, clocks, MAC, DMA) */
+  if (HAL_ETH_Init(&EthHandle) == HAL_OK)
+  {
+    /* Set netif link flag */
+    netif->flags |= NETIF_FLAG_LINK_UP;
+  }
+  
+  /* Initialize Tx Descriptors list: Chain Mode */
+  HAL_ETH_DMATxDescListInit(&EthHandle, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
+     
+  /* Initialize Rx Descriptors list: Chain Mode  */
+  HAL_ETH_DMARxDescListInit(&EthHandle, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
+  
+  /* set netif MAC hardware address length */
+  netif->hwaddr_len = ETHARP_HWADDR_LEN;
 
-#if ETH_PAD_SIZE
-  len += ETH_PAD_SIZE; /* allow room for Ethernet padding */
-#endif
+  /* set netif MAC hardware address */
+  netif->hwaddr[0] =  MAC_ADDR0;
+  netif->hwaddr[1] =  MAC_ADDR1;
+  netif->hwaddr[2] =  MAC_ADDR2;
+  netif->hwaddr[3] =  MAC_ADDR3;
+  netif->hwaddr[4] =  MAC_ADDR4;
+  netif->hwaddr[5] =  MAC_ADDR5;
 
-  /* We allocate a pbuf chain of pbufs from the pool. */
-  p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
-  
-  if (p != NULL) {
+  /* set netif maximum transfer unit */
+  netif->mtu = 1500;
 
-#if ETH_PAD_SIZE
-    pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
-#endif
+  /* Accept broadcast address and ARP traffic */
+  netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
 
-    /* We iterate over the pbuf chain until we have read the entire
-     * packet into the pbuf. */
-    for(q = p; q != NULL; q = q->next) {
-      /* Read enough bytes to fill this pbuf in the chain. The
-       * available data in the pbuf is given by the q->len
-       * variable.
-       * This does not necessarily have to be a memcpy, you can also preallocate
-       * pbufs for a DMA-enabled MAC and after receiving truncate it to the
-       * actually received size. In this case, ensure the tot_len member of the
-       * pbuf is the sum of the chained pbuf len members.
-       */
-      read data into(q->payload, q->len);
-    }
-    acknowledge that packet has been read();
+  /* create a binary semaphore used for informing ethernetif of frame reception */
+  osSemaphoreDef(SEM);
+  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1 );
+
+  /* create the task that handles the ETH_MAC */
+  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
+  osThreadCreate (osThread(EthIf), netif);
+
+  /* Enable MAC and DMA transmission and reception */
+  HAL_ETH_Start(&EthHandle);
+}
 
-#if ETH_PAD_SIZE
-    pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
-#endif
 
-    LINK_STATS_INC(link.recv);
-  } else {
-    drop packet();
-    LINK_STATS_INC(link.memerr);
-    LINK_STATS_INC(link.drop);
+/**
+  * @brief This function should do the actual transmission of the packet. The packet is
+  * contained in the pbuf that is passed to the function. This pbuf
+  * might be chained.
+  *
+  * @param netif the lwip network interface structure for this ethernetif
+  * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
+  * @return ERR_OK if the packet could be sent
+  *         an err_t value if the packet couldn't be sent
+  *
+  * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
+  *       strange results. You might consider waiting for space in the DMA queue
+  *       to become available since the stack doesn't retry to send a packet
+  *       dropped because of memory failure (except for the TCP timers).
+  */
+static err_t low_level_output(struct netif *netif, struct pbuf *p)
+{
+  err_t errval;
+  struct pbuf *q;
+  uint8_t *buffer = (uint8_t *)(EthHandle.TxDesc->Buffer1Addr);
+  __IO ETH_DMADescTypeDef *DmaTxDesc;
+  uint32_t framelength = 0;
+  uint32_t bufferoffset = 0;
+  uint32_t byteslefttocopy = 0;
+  uint32_t payloadoffset = 0;
+
+  DmaTxDesc = EthHandle.TxDesc;
+  bufferoffset = 0;
+  
+  /* copy frame from pbufs to driver buffers */
+  for(q = p; q != NULL; q = q->next)
+  {
+    /* Is this buffer available? If not, goto error */
+    if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
+    {
+      errval = ERR_USE;
+      goto error;
+    }
+    
+    /* Get bytes in current lwIP buffer */
+    byteslefttocopy = q->len;
+    payloadoffset = 0;
+    
+    /* Check if the length of data to copy is bigger than Tx buffer size*/
+    while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
+    {
+      /* Copy data to Tx buffer*/
+      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
+      
+      /* Point to next descriptor */
+      DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
+      
+      /* Check if the buffer is available */
+      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
+      {
+        errval = ERR_USE;
+        goto error;
+      }
+      
+      buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
+      
+      byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
+      payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
+      framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
+      bufferoffset = 0;
+    }
+    
+    /* Copy the remaining bytes */
+    memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
+    bufferoffset = bufferoffset + byteslefttocopy;
+    framelength = framelength + byteslefttocopy;
+  }
+  
+  /* Prepare transmit descriptors to give to DMA */ 
+  HAL_ETH_TransmitFrame(&EthHandle, framelength);
+  
+  errval = ERR_OK;
+  
+error:
+  
+  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
+  if ((EthHandle.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
+  {
+    /* Clear TUS ETHERNET DMA flag */
+    EthHandle.Instance->DMASR = ETH_DMASR_TUS;
+    
+    /* Resume DMA transmission*/
+    EthHandle.Instance->DMATPDR = 0;
   }
+  return errval;
+}
 
-  return p;  
+/**
+  * @brief Should allocate a pbuf and transfer the bytes of the incoming
+  * packet from the interface into the pbuf.
+  *
+  * @param netif the lwip network interface structure for this ethernetif
+  * @return a pbuf filled with the received packet (including MAC header)
+  *         NULL on memory error
+  */
+static struct pbuf * low_level_input(struct netif *netif)
+{
+  struct pbuf *p = NULL, *q = NULL;
+  uint16_t len = 0;
+  uint8_t *buffer;
+  __IO ETH_DMADescTypeDef *dmarxdesc;
+  uint32_t bufferoffset = 0;
+  uint32_t payloadoffset = 0;
+  uint32_t byteslefttocopy = 0;
+  uint32_t i=0;
+  
+  /* get received frame */
+  if(HAL_ETH_GetReceivedFrame_IT(&EthHandle) != HAL_OK)
+    return NULL;
+  
+  /* Obtain the size of the packet and put it into the "len" variable. */
+  len = EthHandle.RxFrameInfos.length;
+  buffer = (uint8_t *)EthHandle.RxFrameInfos.buffer;
+  
+  if (len > 0)
+  {
+    /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
+    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
+  }
+  
+  if (p != NULL)
+  {
+    dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
+    bufferoffset = 0;
+    
+    for(q = p; q != NULL; q = q->next)
+    {
+      byteslefttocopy = q->len;
+      payloadoffset = 0;
+      
+      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size */
+      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
+      {
+        /* Copy data to pbuf */
+        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
+        
+        /* Point to next descriptor */
+        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
+        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
+        
+        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
+        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
+        bufferoffset = 0;
+      }
+      
+      /* Copy remaining data in pbuf */
+      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
+      bufferoffset = bufferoffset + byteslefttocopy;
+    }
+  }
+    
+  /* Release descriptors to DMA */
+  /* Point to first descriptor */
+  dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
+  /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
+  for (i=0; i< EthHandle.RxFrameInfos.SegCount; i++)
+  {  
+    dmarxdesc->Status |= ETH_DMARXDESC_OWN;
+    dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
+  }
+    
+  /* Clear Segment_Count */
+  EthHandle.RxFrameInfos.SegCount =0;
+  
+  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
+  if ((EthHandle.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
+  {
+    /* Clear RBUS ETHERNET DMA flag */
+    EthHandle.Instance->DMASR = ETH_DMASR_RBUS;
+    /* Resume DMA reception */
+    EthHandle.Instance->DMARPDR = 0;
+  }
+  return p;
 }
 
 /**
- * This function should be called when a packet is ready to be read
- * from the interface. It uses the function low_level_input() that
- * should handle the actual reception of bytes from the network
- * interface. Then the type of the received packet is determined and
- * the appropriate input function is called.
- *
- * @param netif the lwip network interface structure for this ethernetif
- */
-static void
-ethernetif_input(struct netif *netif)
+  * @brief This function is the ethernetif_input task, it is processed when a packet 
+  * is ready to be read from the interface. It uses the function low_level_input() 
+  * that should handle the actual reception of bytes from the network
+  * interface. Then the type of the received packet is determined and
+  * the appropriate input function is called.
+  *
+  * @param netif the lwip network interface structure for this ethernetif
+  */
+void ethernetif_input( void const * argument )
 {
-  struct ethernetif *ethernetif;
-  struct eth_hdr *ethhdr;
   struct pbuf *p;
-
-  ethernetif = netif->state;
-
-  /* move received packet into a new pbuf */
-  p = low_level_input(netif);
-  /* no packet could be read, silently ignore this */
-  if (p == NULL) return;
-  /* points to packet payload, which starts with an Ethernet header */
-  ethhdr = p->payload;
-
-  switch (htons(ethhdr->type)) {
-  /* IP or ARP packet? */
-  case ETHTYPE_IP:
-  case ETHTYPE_IPV6:
-  case ETHTYPE_ARP:
-#if PPPOE_SUPPORT
-  /* PPPoE packet? */
-  case ETHTYPE_PPPOEDISC:
-  case ETHTYPE_PPPOE:
-#endif /* PPPOE_SUPPORT */
-    /* full packet send to tcpip_thread to process */
-    if (netif->input(p, netif)!=ERR_OK)
-     { LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
-       pbuf_free(p);
-       p = NULL;
-     }
-    break;
-
-  default:
-    pbuf_free(p);
-    p = NULL;
-    break;
+  struct netif *netif = (struct netif *) argument;
+  
+  for( ;; )
+  {
+    if (osSemaphoreWait( s_xSemaphore, TIME_WAITING_FOR_INPUT)==osOK)
+    {
+      do
+      {
+        p = low_level_input( netif );
+        if (p != NULL)
+        {
+          if (netif->input( p, netif) != ERR_OK )
+          {
+            pbuf_free(p);
+          }
+        }
+      }while(p!=NULL);
+    }
   }
 }
 
 /**
- * Should be called at the beginning of the program to set up the
- * network interface. It calls the function low_level_init() to do the
- * actual setup of the hardware.
- *
- * This function should be passed as a parameter to netif_add().
- *
- * @param netif the lwip network interface structure for this ethernetif
- * @return ERR_OK if the loopif is initialized
- *         ERR_MEM if private data couldn't be allocated
- *         any other err_t on error
- */
-err_t
-ethernetif_init(struct netif *netif)
+  * @brief Should be called at the beginning of the program to set up the
+  * network interface. It calls the function low_level_init() to do the
+  * actual setup of the hardware.
+  *
+  * This function should be passed as a parameter to netif_add().
+  *
+  * @param netif the lwip network interface structure for this ethernetif
+  * @return ERR_OK if the loopif is initialized
+  *         ERR_MEM if private data couldn't be allocated
+  *         any other err_t on error
+  */
+err_t ethernetif_init(struct netif *netif)
 {
-  struct ethernetif *ethernetif;
-
   LWIP_ASSERT("netif != NULL", (netif != NULL));
-    
-  ethernetif = mem_malloc(sizeof(struct ethernetif));
-  if (ethernetif == NULL) {
-    LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_init: out of memory\n"));
-    return ERR_MEM;
-  }
 
 #if LWIP_NETIF_HOSTNAME
   /* Initialize interface hostname */
   netif->hostname = "lwip";
 #endif /* LWIP_NETIF_HOSTNAME */
 
-  /*
-   * Initialize the snmp variables and counters inside the struct netif.
-   * The last argument should be replaced with your link speed, in units
-   * of bits per second.
-   */
-  NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, LINK_SPEED_OF_YOUR_NETIF_IN_BPS);
-
-  netif->state = ethernetif;
   netif->name[0] = IFNAME0;
   netif->name[1] = IFNAME1;
-  /* We directly use etharp_output() here to save a function call.
-   * You can instead declare your own function an call etharp_output()
-   * from it if you have to do some checks before sending (e.g. if link
-   * is available...) */
+
   netif->output = etharp_output;
-#if LWIP_IPV6
-  netif->output_ip6 = ethip6_output;
-#endif /* LWIP_IPV6 */
   netif->linkoutput = low_level_output;
-  
-  ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
-  
+
   /* initialize the hardware */
   low_level_init(netif);
 
   return ERR_OK;
 }
 
-#endif /* 0 */
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
-- 
1.9.1


From ab97b49d1d41e34fdfdfb457b397c768ee228c9f Mon Sep 17 00:00:00 2001
From: Jay Doyle <jay.doyle@vecna.com>
Date: Mon, 7 Sep 2015 09:39:20 -0400
Subject: [PATCH 05/33] removed ethernetif (it should be in BSP

---
 src/netif/ethernetif.c | 496 -------------------------------------------------
 1 file changed, 496 deletions(-)
 delete mode 100644 src/netif/ethernetif.c

diff --git a/src/netif/ethernetif.c b/src/netif/ethernetif.c
deleted file mode 100644
index 82c85ae..0000000
--- a/src/netif/ethernetif.c
+++ /dev/null
@@ -1,496 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    LwIP/LwIP_HTTP_Server_Netconn_RTOS/Src/ethernetif.c
-  * @author  MCD Application Team
-  * @version V1.0.0
-  * @date    25-June-2015
-  * @brief   This file implements Ethernet network interface drivers for lwIP
-  ******************************************************************************
-  * @attention
-  *
-  * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
-  *
-  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
-  * You may not use this file except in compliance with the License.
-  * You may obtain a copy of the License at:
-  *
-  *        http://www.st.com/software_license_agreement_liberty_v2
-  *
-  * Unless required by applicable law or agreed to in writing, software 
-  * distributed under the License is distributed on an "AS IS" BASIS, 
-  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  * See the License for the specific language governing permissions and
-  * limitations under the License.
-  *
-  ******************************************************************************
-  */
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f7xx_hal.h"
-#include "lwip/opt.h"
-#include "lwip/lwip_timers.h"
-#include "netif/etharp.h"
-#include "hal-ethernetif.h"
-#include <string.h>
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* The time to block waiting for input. */
-#define TIME_WAITING_FOR_INPUT                 ( 100 )
-/* Stack size of the interface thread */
-#define INTERFACE_THREAD_STACK_SIZE            ( 350 )
-
-/* Define those to better describe your network interface. */
-#define IFNAME0 'e'
-#define IFNAME1 'n'
-
-#define LAN8742A_PHY_ADDRESS            0x00
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-
-#if defined ( __ICCARM__ ) /*!< IAR Compiler */
-
-#pragma location=0x2000E000
-__no_init ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
-#pragma location=0x2000E100
-__no_init ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
-#elif defined ( __CC_ARM   )
-ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((at(0x2000E000)));/* Ethernet Rx MA Descriptor */
-ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((at(0x2000E100)));/* Ethernet Tx DMA Descriptor */
-#elif defined ( __GNUC__   )
-//ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".RxDescripSection")));/* Ethernet Rx MA Descriptor */
-//ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".TxDescripSection")));/* Ethernet Tx DMA Descriptor */
-ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Rx MA Descriptor */
-ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Tx DMA Descriptor */
-
-
-#endif
-#if defined ( __ICCARM__ ) /*!< IAR Compiler */
-#pragma location=0x2000E200
-__no_init uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
-#pragma location=0x2000FFC4
-__no_init uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
-#elif defined ( __CC_ARM   )
-uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((at(0x2000E200)));  /* Ethernet Receive Buffer */
-uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]  __attribute__((at(0x2000FFC4))); /* Ethernet Transmit Buffer */
-#elif defined ( __GNUC__   )
-//uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".RxBUF")));/* Ethernet Receive Buffer */
-//uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".TxBUF")));/* Ethernet Transmit Buffer */
-uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Receive Buffer */
-uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Transmit Buffer */
-
-#endif
-/* Semaphore to signal incoming packets */
-osSemaphoreId s_xSemaphore = NULL;
-
-/* Global Ethernet handle*/
-ETH_HandleTypeDef EthHandle;
-
-/* Private function prototypes -----------------------------------------------*/
-static void ethernetif_input( void const * argument );
-
-static void stm32f_ethernet_isr(
-  void* argData
-)
-{
-  ETH_HandleTypeDef* pEth =
-    (ETH_HandleTypeDef*) argData;
-
-  HAL_ETH_IRQHandler(pEth);
-}
-
-/* Private functions ---------------------------------------------------------*/
-/*******************************************************************************
-                       Ethernet MSP Routines
-*******************************************************************************/
-/**
-  * @brief  Initializes the ETH MSP.
-  * @param  heth: ETH handle
-  * @retval None
-  */
-void HAL_ETH_MspInit(ETH_HandleTypeDef *heth)
-{
-  GPIO_InitTypeDef GPIO_InitStructure;
-  
-  /* Enable GPIOs clocks */
-  __HAL_RCC_GPIOA_CLK_ENABLE();
-  __HAL_RCC_GPIOC_CLK_ENABLE();
-  __HAL_RCC_GPIOG_CLK_ENABLE();
-
-/* Ethernet pins configuration ************************************************/
-  /*
-        RMII_REF_CLK ----------------------> PA1
-        RMII_MDIO -------------------------> PA2
-        RMII_MDC --------------------------> PC1
-        RMII_MII_CRS_DV -------------------> PA7
-        RMII_MII_RXD0 ---------------------> PC4
-        RMII_MII_RXD1 ---------------------> PC5
-        RMII_MII_RXER ---------------------> PG2
-        RMII_MII_TX_EN --------------------> PG11
-        RMII_MII_TXD0 ---------------------> PG13
-        RMII_MII_TXD1 ---------------------> PG14
-  */
-
-  /* Configure PA1, PA2 and PA7 */
-  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
-  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
-  GPIO_InitStructure.Pull = GPIO_NOPULL; 
-  GPIO_InitStructure.Alternate = GPIO_AF11_ETH;
-  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
-  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
-  
-  /* Configure PC1, PC4 and PC5 */
-  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;
-  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
-
-  /* Configure PG2, PG11, PG13 and PG14 */
-  GPIO_InitStructure.Pin =  GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14;
-  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
-  
-  // Install HAL Ethernet ISR
-  rtems_interrupt_handler_install(
-    ETH_IRQn,
-    NULL,
-    0,
-    stm32f_ethernet_isr,
-    heth);
-  
-  /* Enable ETHERNET clock  */
-  __HAL_RCC_ETH_CLK_ENABLE();
-}
-
-/**
-  * @brief  Ethernet Rx Transfer completed callback
-  * @param  heth: ETH handle
-  * @retval None
-  */
-void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
-{
-  osSemaphoreRelease(s_xSemaphore);
-}
-
-/**
-  * @brief  Ethernet IRQ Handler
-  * @param  None
-  * @retval None
-  */
-void ETHERNET_IRQHandler(void)
-{
-  HAL_ETH_IRQHandler(&EthHandle);
-}
-
-/*******************************************************************************
-                       LL Driver Interface ( LwIP stack --> ETH) 
-*******************************************************************************/
-/**
-  * @brief In this function, the hardware should be initialized.
-  * Called from ethernetif_init().
-  *
-  * @param netif the already initialized lwip network interface structure
-  *        for this ethernetif
-  */
-static void low_level_init(struct netif *netif)
-{
-  uint8_t macaddress[6]= { MAC_ADDR0, MAC_ADDR1, MAC_ADDR2, MAC_ADDR3, MAC_ADDR4, MAC_ADDR5 };
-  
-  EthHandle.Instance = ETH;  
-  EthHandle.Init.MACAddr = macaddress;
-  EthHandle.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
-  EthHandle.Init.Speed = ETH_SPEED_100M;
-  EthHandle.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
-  EthHandle.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
-  EthHandle.Init.RxMode = ETH_RXINTERRUPT_MODE;
-  EthHandle.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
-  EthHandle.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
-  
-  /* configure ethernet peripheral (GPIOs, clocks, MAC, DMA) */
-  if (HAL_ETH_Init(&EthHandle) == HAL_OK)
-  {
-    /* Set netif link flag */
-    netif->flags |= NETIF_FLAG_LINK_UP;
-  }
-  
-  /* Initialize Tx Descriptors list: Chain Mode */
-  HAL_ETH_DMATxDescListInit(&EthHandle, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
-     
-  /* Initialize Rx Descriptors list: Chain Mode  */
-  HAL_ETH_DMARxDescListInit(&EthHandle, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
-  
-  /* set netif MAC hardware address length */
-  netif->hwaddr_len = ETHARP_HWADDR_LEN;
-
-  /* set netif MAC hardware address */
-  netif->hwaddr[0] =  MAC_ADDR0;
-  netif->hwaddr[1] =  MAC_ADDR1;
-  netif->hwaddr[2] =  MAC_ADDR2;
-  netif->hwaddr[3] =  MAC_ADDR3;
-  netif->hwaddr[4] =  MAC_ADDR4;
-  netif->hwaddr[5] =  MAC_ADDR5;
-
-  /* set netif maximum transfer unit */
-  netif->mtu = 1500;
-
-  /* Accept broadcast address and ARP traffic */
-  netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
-
-  /* create a binary semaphore used for informing ethernetif of frame reception */
-  osSemaphoreDef(SEM);
-  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1 );
-
-  /* create the task that handles the ETH_MAC */
-  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
-  osThreadCreate (osThread(EthIf), netif);
-
-  /* Enable MAC and DMA transmission and reception */
-  HAL_ETH_Start(&EthHandle);
-}
-
-
-/**
-  * @brief This function should do the actual transmission of the packet. The packet is
-  * contained in the pbuf that is passed to the function. This pbuf
-  * might be chained.
-  *
-  * @param netif the lwip network interface structure for this ethernetif
-  * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
-  * @return ERR_OK if the packet could be sent
-  *         an err_t value if the packet couldn't be sent
-  *
-  * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
-  *       strange results. You might consider waiting for space in the DMA queue
-  *       to become available since the stack doesn't retry to send a packet
-  *       dropped because of memory failure (except for the TCP timers).
-  */
-static err_t low_level_output(struct netif *netif, struct pbuf *p)
-{
-  err_t errval;
-  struct pbuf *q;
-  uint8_t *buffer = (uint8_t *)(EthHandle.TxDesc->Buffer1Addr);
-  __IO ETH_DMADescTypeDef *DmaTxDesc;
-  uint32_t framelength = 0;
-  uint32_t bufferoffset = 0;
-  uint32_t byteslefttocopy = 0;
-  uint32_t payloadoffset = 0;
-
-  DmaTxDesc = EthHandle.TxDesc;
-  bufferoffset = 0;
-  
-  /* copy frame from pbufs to driver buffers */
-  for(q = p; q != NULL; q = q->next)
-  {
-    /* Is this buffer available? If not, goto error */
-    if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
-    {
-      errval = ERR_USE;
-      goto error;
-    }
-    
-    /* Get bytes in current lwIP buffer */
-    byteslefttocopy = q->len;
-    payloadoffset = 0;
-    
-    /* Check if the length of data to copy is bigger than Tx buffer size*/
-    while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
-    {
-      /* Copy data to Tx buffer*/
-      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
-      
-      /* Point to next descriptor */
-      DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
-      
-      /* Check if the buffer is available */
-      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
-      {
-        errval = ERR_USE;
-        goto error;
-      }
-      
-      buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
-      
-      byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
-      payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
-      framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
-      bufferoffset = 0;
-    }
-    
-    /* Copy the remaining bytes */
-    memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
-    bufferoffset = bufferoffset + byteslefttocopy;
-    framelength = framelength + byteslefttocopy;
-  }
-  
-  /* Prepare transmit descriptors to give to DMA */ 
-  HAL_ETH_TransmitFrame(&EthHandle, framelength);
-  
-  errval = ERR_OK;
-  
-error:
-  
-  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
-  if ((EthHandle.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
-  {
-    /* Clear TUS ETHERNET DMA flag */
-    EthHandle.Instance->DMASR = ETH_DMASR_TUS;
-    
-    /* Resume DMA transmission*/
-    EthHandle.Instance->DMATPDR = 0;
-  }
-  return errval;
-}
-
-/**
-  * @brief Should allocate a pbuf and transfer the bytes of the incoming
-  * packet from the interface into the pbuf.
-  *
-  * @param netif the lwip network interface structure for this ethernetif
-  * @return a pbuf filled with the received packet (including MAC header)
-  *         NULL on memory error
-  */
-static struct pbuf * low_level_input(struct netif *netif)
-{
-  struct pbuf *p = NULL, *q = NULL;
-  uint16_t len = 0;
-  uint8_t *buffer;
-  __IO ETH_DMADescTypeDef *dmarxdesc;
-  uint32_t bufferoffset = 0;
-  uint32_t payloadoffset = 0;
-  uint32_t byteslefttocopy = 0;
-  uint32_t i=0;
-  
-  /* get received frame */
-  if(HAL_ETH_GetReceivedFrame_IT(&EthHandle) != HAL_OK)
-    return NULL;
-  
-  /* Obtain the size of the packet and put it into the "len" variable. */
-  len = EthHandle.RxFrameInfos.length;
-  buffer = (uint8_t *)EthHandle.RxFrameInfos.buffer;
-  
-  if (len > 0)
-  {
-    /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
-    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
-  }
-  
-  if (p != NULL)
-  {
-    dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
-    bufferoffset = 0;
-    
-    for(q = p; q != NULL; q = q->next)
-    {
-      byteslefttocopy = q->len;
-      payloadoffset = 0;
-      
-      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size */
-      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
-      {
-        /* Copy data to pbuf */
-        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
-        
-        /* Point to next descriptor */
-        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
-        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
-        
-        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
-        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
-        bufferoffset = 0;
-      }
-      
-      /* Copy remaining data in pbuf */
-      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
-      bufferoffset = bufferoffset + byteslefttocopy;
-    }
-  }
-    
-  /* Release descriptors to DMA */
-  /* Point to first descriptor */
-  dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
-  /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
-  for (i=0; i< EthHandle.RxFrameInfos.SegCount; i++)
-  {  
-    dmarxdesc->Status |= ETH_DMARXDESC_OWN;
-    dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
-  }
-    
-  /* Clear Segment_Count */
-  EthHandle.RxFrameInfos.SegCount =0;
-  
-  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
-  if ((EthHandle.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
-  {
-    /* Clear RBUS ETHERNET DMA flag */
-    EthHandle.Instance->DMASR = ETH_DMASR_RBUS;
-    /* Resume DMA reception */
-    EthHandle.Instance->DMARPDR = 0;
-  }
-  return p;
-}
-
-/**
-  * @brief This function is the ethernetif_input task, it is processed when a packet 
-  * is ready to be read from the interface. It uses the function low_level_input() 
-  * that should handle the actual reception of bytes from the network
-  * interface. Then the type of the received packet is determined and
-  * the appropriate input function is called.
-  *
-  * @param netif the lwip network interface structure for this ethernetif
-  */
-void ethernetif_input( void const * argument )
-{
-  struct pbuf *p;
-  struct netif *netif = (struct netif *) argument;
-  
-  for( ;; )
-  {
-    if (osSemaphoreWait( s_xSemaphore, TIME_WAITING_FOR_INPUT)==osOK)
-    {
-      do
-      {
-        p = low_level_input( netif );
-        if (p != NULL)
-        {
-          if (netif->input( p, netif) != ERR_OK )
-          {
-            pbuf_free(p);
-          }
-        }
-      }while(p!=NULL);
-    }
-  }
-}
-
-/**
-  * @brief Should be called at the beginning of the program to set up the
-  * network interface. It calls the function low_level_init() to do the
-  * actual setup of the hardware.
-  *
-  * This function should be passed as a parameter to netif_add().
-  *
-  * @param netif the lwip network interface structure for this ethernetif
-  * @return ERR_OK if the loopif is initialized
-  *         ERR_MEM if private data couldn't be allocated
-  *         any other err_t on error
-  */
-err_t ethernetif_init(struct netif *netif)
-{
-  LWIP_ASSERT("netif != NULL", (netif != NULL));
-
-#if LWIP_NETIF_HOSTNAME
-  /* Initialize interface hostname */
-  netif->hostname = "lwip";
-#endif /* LWIP_NETIF_HOSTNAME */
-
-  netif->name[0] = IFNAME0;
-  netif->name[1] = IFNAME1;
-
-  netif->output = etharp_output;
-  netif->linkoutput = low_level_output;
-
-  /* initialize the hardware */
-  low_level_init(netif);
-
-  return ERR_OK;
-}
-
-/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
-- 
1.9.1


From 31d34fab26b1e3fde99fe7288786725fe5e51b95 Mon Sep 17 00:00:00 2001
From: Jay Doyle <jay.doyle@vecna.com>
Date: Mon, 7 Sep 2015 10:17:32 -0400
Subject: [PATCH 06/33] add low level driver back

---
 src/netif/ethernetif.c | 496 +++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 496 insertions(+)
 create mode 100644 src/netif/ethernetif.c

diff --git a/src/netif/ethernetif.c b/src/netif/ethernetif.c
new file mode 100644
index 0000000..bc429e9
--- /dev/null
+++ b/src/netif/ethernetif.c
@@ -0,0 +1,496 @@
+/**
+  ******************************************************************************
+  * @file    LwIP/LwIP_HTTP_Server_Netconn_RTOS/Src/ethernetif.c
+  * @author  MCD Application Team
+  * @version V1.0.0
+  * @date    25-June-2015
+  * @brief   This file implements Ethernet network interface drivers for lwIP
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
+  *
+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+  * You may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at:
+  *
+  *        http://www.st.com/software_license_agreement_liberty_v2
+  *
+  * Unless required by applicable law or agreed to in writing, software 
+  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include <stm32f7xx_hal.h>
+#include <lwip/opt.h>
+#include <lwip/lwip_timers.h>
+#include <netif/etharp.h>
+#include <hal-ethernetif.h>
+#include <string.h>
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/* The time to block waiting for input. */
+#define TIME_WAITING_FOR_INPUT                 ( 100 )
+/* Stack size of the interface thread */
+#define INTERFACE_THREAD_STACK_SIZE            ( 350 )
+
+/* Define those to better describe your network interface. */
+#define IFNAME0 'e'
+#define IFNAME1 'n'
+
+#define LAN8742A_PHY_ADDRESS            0x00
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+
+#if defined ( __ICCARM__ ) /*!< IAR Compiler */
+
+#pragma location=0x2000E000
+__no_init ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
+#pragma location=0x2000E100
+__no_init ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
+#elif defined ( __CC_ARM   )
+ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((at(0x2000E000)));/* Ethernet Rx MA Descriptor */
+ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((at(0x2000E100)));/* Ethernet Tx DMA Descriptor */
+#elif defined ( __GNUC__   )
+//ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".RxDescripSection")));/* Ethernet Rx MA Descriptor */
+//ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".TxDescripSection")));/* Ethernet Tx DMA Descriptor */
+ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Rx MA Descriptor */
+ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Tx DMA Descriptor */
+
+
+#endif
+#if defined ( __ICCARM__ ) /*!< IAR Compiler */
+#pragma location=0x2000E200
+__no_init uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
+#pragma location=0x2000FFC4
+__no_init uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
+#elif defined ( __CC_ARM   )
+uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((at(0x2000E200)));  /* Ethernet Receive Buffer */
+uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]  __attribute__((at(0x2000FFC4))); /* Ethernet Transmit Buffer */
+#elif defined ( __GNUC__   )
+//uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".RxBUF")));/* Ethernet Receive Buffer */
+//uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".TxBUF")));/* Ethernet Transmit Buffer */
+uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Receive Buffer */
+uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Transmit Buffer */
+
+#endif
+/* Semaphore to signal incoming packets */
+osSemaphoreId s_xSemaphore = NULL;
+
+/* Global Ethernet handle*/
+ETH_HandleTypeDef EthHandle;
+
+/* Private function prototypes -----------------------------------------------*/
+static void ethernetif_input( void const * argument );
+
+static void stm32f_ethernet_isr(
+  void* argData
+)
+{
+  ETH_HandleTypeDef* pEth =
+    (ETH_HandleTypeDef*) argData;
+
+  HAL_ETH_IRQHandler(pEth);
+}
+
+/* Private functions ---------------------------------------------------------*/
+/*******************************************************************************
+                       Ethernet MSP Routines
+*******************************************************************************/
+/**
+  * @brief  Initializes the ETH MSP.
+  * @param  heth: ETH handle
+  * @retval None
+  */
+void HAL_ETH_MspInit(ETH_HandleTypeDef *heth)
+{
+  GPIO_InitTypeDef GPIO_InitStructure;
+  
+  /* Enable GPIOs clocks */
+  __HAL_RCC_GPIOA_CLK_ENABLE();
+  __HAL_RCC_GPIOC_CLK_ENABLE();
+  __HAL_RCC_GPIOG_CLK_ENABLE();
+
+/* Ethernet pins configuration ************************************************/
+  /*
+        RMII_REF_CLK ----------------------> PA1
+        RMII_MDIO -------------------------> PA2
+        RMII_MDC --------------------------> PC1
+        RMII_MII_CRS_DV -------------------> PA7
+        RMII_MII_RXD0 ---------------------> PC4
+        RMII_MII_RXD1 ---------------------> PC5
+        RMII_MII_RXER ---------------------> PG2
+        RMII_MII_TX_EN --------------------> PG11
+        RMII_MII_TXD0 ---------------------> PG13
+        RMII_MII_TXD1 ---------------------> PG14
+  */
+
+  /* Configure PA1, PA2 and PA7 */
+  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
+  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
+  GPIO_InitStructure.Pull = GPIO_NOPULL; 
+  GPIO_InitStructure.Alternate = GPIO_AF11_ETH;
+  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
+  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
+  
+  /* Configure PC1, PC4 and PC5 */
+  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;
+  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
+
+  /* Configure PG2, PG11, PG13 and PG14 */
+  GPIO_InitStructure.Pin =  GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14;
+  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
+  
+  // Install HAL Ethernet ISR
+  rtems_interrupt_handler_install(
+    ETH_IRQn,
+    NULL,
+    0,
+    stm32f_ethernet_isr,
+    heth);
+  
+  /* Enable ETHERNET clock  */
+  __HAL_RCC_ETH_CLK_ENABLE();
+}
+
+/**
+  * @brief  Ethernet Rx Transfer completed callback
+  * @param  heth: ETH handle
+  * @retval None
+  */
+void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
+{
+  osSemaphoreRelease(s_xSemaphore);
+}
+
+/**
+  * @brief  Ethernet IRQ Handler
+  * @param  None
+  * @retval None
+  */
+void ETHERNET_IRQHandler(void)
+{
+  HAL_ETH_IRQHandler(&EthHandle);
+}
+
+/*******************************************************************************
+                       LL Driver Interface ( LwIP stack --> ETH) 
+*******************************************************************************/
+/**
+  * @brief In this function, the hardware should be initialized.
+  * Called from ethernetif_init().
+  *
+  * @param netif the already initialized lwip network interface structure
+  *        for this ethernetif
+  */
+static void low_level_init(struct netif *netif)
+{
+  uint8_t macaddress[6]= { MAC_ADDR0, MAC_ADDR1, MAC_ADDR2, MAC_ADDR3, MAC_ADDR4, MAC_ADDR5 };
+  
+  EthHandle.Instance = ETH;  
+  EthHandle.Init.MACAddr = macaddress;
+  EthHandle.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
+  EthHandle.Init.Speed = ETH_SPEED_100M;
+  EthHandle.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
+  EthHandle.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
+  EthHandle.Init.RxMode = ETH_RXINTERRUPT_MODE;
+  EthHandle.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
+  EthHandle.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
+  
+  /* configure ethernet peripheral (GPIOs, clocks, MAC, DMA) */
+  if (HAL_ETH_Init(&EthHandle) == HAL_OK)
+  {
+    /* Set netif link flag */
+    netif->flags |= NETIF_FLAG_LINK_UP;
+  }
+  
+  /* Initialize Tx Descriptors list: Chain Mode */
+  HAL_ETH_DMATxDescListInit(&EthHandle, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
+     
+  /* Initialize Rx Descriptors list: Chain Mode  */
+  HAL_ETH_DMARxDescListInit(&EthHandle, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
+  
+  /* set netif MAC hardware address length */
+  netif->hwaddr_len = ETHARP_HWADDR_LEN;
+
+  /* set netif MAC hardware address */
+  netif->hwaddr[0] =  MAC_ADDR0;
+  netif->hwaddr[1] =  MAC_ADDR1;
+  netif->hwaddr[2] =  MAC_ADDR2;
+  netif->hwaddr[3] =  MAC_ADDR3;
+  netif->hwaddr[4] =  MAC_ADDR4;
+  netif->hwaddr[5] =  MAC_ADDR5;
+
+  /* set netif maximum transfer unit */
+  netif->mtu = 1500;
+
+  /* Accept broadcast address and ARP traffic */
+  netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
+
+  /* create a binary semaphore used for informing ethernetif of frame reception */
+  osSemaphoreDef(SEM);
+  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1 );
+
+  /* create the task that handles the ETH_MAC */
+  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
+  osThreadCreate (osThread(EthIf), netif);
+
+  /* Enable MAC and DMA transmission and reception */
+  HAL_ETH_Start(&EthHandle);
+}
+
+
+/**
+  * @brief This function should do the actual transmission of the packet. The packet is
+  * contained in the pbuf that is passed to the function. This pbuf
+  * might be chained.
+  *
+  * @param netif the lwip network interface structure for this ethernetif
+  * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
+  * @return ERR_OK if the packet could be sent
+  *         an err_t value if the packet couldn't be sent
+  *
+  * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
+  *       strange results. You might consider waiting for space in the DMA queue
+  *       to become available since the stack doesn't retry to send a packet
+  *       dropped because of memory failure (except for the TCP timers).
+  */
+static err_t low_level_output(struct netif *netif, struct pbuf *p)
+{
+  err_t errval;
+  struct pbuf *q;
+  uint8_t *buffer = (uint8_t *)(EthHandle.TxDesc->Buffer1Addr);
+  __IO ETH_DMADescTypeDef *DmaTxDesc;
+  uint32_t framelength = 0;
+  uint32_t bufferoffset = 0;
+  uint32_t byteslefttocopy = 0;
+  uint32_t payloadoffset = 0;
+
+  DmaTxDesc = EthHandle.TxDesc;
+  bufferoffset = 0;
+  
+  /* copy frame from pbufs to driver buffers */
+  for(q = p; q != NULL; q = q->next)
+  {
+    /* Is this buffer available? If not, goto error */
+    if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
+    {
+      errval = ERR_USE;
+      goto error;
+    }
+    
+    /* Get bytes in current lwIP buffer */
+    byteslefttocopy = q->len;
+    payloadoffset = 0;
+    
+    /* Check if the length of data to copy is bigger than Tx buffer size*/
+    while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
+    {
+      /* Copy data to Tx buffer*/
+      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
+      
+      /* Point to next descriptor */
+      DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
+      
+      /* Check if the buffer is available */
+      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
+      {
+        errval = ERR_USE;
+        goto error;
+      }
+      
+      buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
+      
+      byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
+      payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
+      framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
+      bufferoffset = 0;
+    }
+    
+    /* Copy the remaining bytes */
+    memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
+    bufferoffset = bufferoffset + byteslefttocopy;
+    framelength = framelength + byteslefttocopy;
+  }
+  
+  /* Prepare transmit descriptors to give to DMA */ 
+  HAL_ETH_TransmitFrame(&EthHandle, framelength);
+  
+  errval = ERR_OK;
+  
+error:
+  
+  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
+  if ((EthHandle.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
+  {
+    /* Clear TUS ETHERNET DMA flag */
+    EthHandle.Instance->DMASR = ETH_DMASR_TUS;
+    
+    /* Resume DMA transmission*/
+    EthHandle.Instance->DMATPDR = 0;
+  }
+  return errval;
+}
+
+/**
+  * @brief Should allocate a pbuf and transfer the bytes of the incoming
+  * packet from the interface into the pbuf.
+  *
+  * @param netif the lwip network interface structure for this ethernetif
+  * @return a pbuf filled with the received packet (including MAC header)
+  *         NULL on memory error
+  */
+static struct pbuf * low_level_input(struct netif *netif)
+{
+  struct pbuf *p = NULL, *q = NULL;
+  uint16_t len = 0;
+  uint8_t *buffer;
+  __IO ETH_DMADescTypeDef *dmarxdesc;
+  uint32_t bufferoffset = 0;
+  uint32_t payloadoffset = 0;
+  uint32_t byteslefttocopy = 0;
+  uint32_t i=0;
+  
+  /* get received frame */
+  if(HAL_ETH_GetReceivedFrame_IT(&EthHandle) != HAL_OK)
+    return NULL;
+  
+  /* Obtain the size of the packet and put it into the "len" variable. */
+  len = EthHandle.RxFrameInfos.length;
+  buffer = (uint8_t *)EthHandle.RxFrameInfos.buffer;
+  
+  if (len > 0)
+  {
+    /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
+    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
+  }
+  
+  if (p != NULL)
+  {
+    dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
+    bufferoffset = 0;
+    
+    for(q = p; q != NULL; q = q->next)
+    {
+      byteslefttocopy = q->len;
+      payloadoffset = 0;
+      
+      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size */
+      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
+      {
+        /* Copy data to pbuf */
+        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
+        
+        /* Point to next descriptor */
+        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
+        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
+        
+        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
+        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
+        bufferoffset = 0;
+      }
+      
+      /* Copy remaining data in pbuf */
+      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
+      bufferoffset = bufferoffset + byteslefttocopy;
+    }
+  }
+    
+  /* Release descriptors to DMA */
+  /* Point to first descriptor */
+  dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
+  /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
+  for (i=0; i< EthHandle.RxFrameInfos.SegCount; i++)
+  {  
+    dmarxdesc->Status |= ETH_DMARXDESC_OWN;
+    dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
+  }
+    
+  /* Clear Segment_Count */
+  EthHandle.RxFrameInfos.SegCount =0;
+  
+  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
+  if ((EthHandle.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
+  {
+    /* Clear RBUS ETHERNET DMA flag */
+    EthHandle.Instance->DMASR = ETH_DMASR_RBUS;
+    /* Resume DMA reception */
+    EthHandle.Instance->DMARPDR = 0;
+  }
+  return p;
+}
+
+/**
+  * @brief This function is the ethernetif_input task, it is processed when a packet 
+  * is ready to be read from the interface. It uses the function low_level_input() 
+  * that should handle the actual reception of bytes from the network
+  * interface. Then the type of the received packet is determined and
+  * the appropriate input function is called.
+  *
+  * @param netif the lwip network interface structure for this ethernetif
+  */
+void ethernetif_input( void const * argument )
+{
+  struct pbuf *p;
+  struct netif *netif = (struct netif *) argument;
+  
+  for( ;; )
+  {
+    if (osSemaphoreWait( s_xSemaphore, TIME_WAITING_FOR_INPUT)==osOK)
+    {
+      do
+      {
+        p = low_level_input( netif );
+        if (p != NULL)
+        {
+          if (netif->input( p, netif) != ERR_OK )
+          {
+            pbuf_free(p);
+          }
+        }
+      }while(p!=NULL);
+    }
+  }
+}
+
+/**
+  * @brief Should be called at the beginning of the program to set up the
+  * network interface. It calls the function low_level_init() to do the
+  * actual setup of the hardware.
+  *
+  * This function should be passed as a parameter to netif_add().
+  *
+  * @param netif the lwip network interface structure for this ethernetif
+  * @return ERR_OK if the loopif is initialized
+  *         ERR_MEM if private data couldn't be allocated
+  *         any other err_t on error
+  */
+err_t ethernetif_init(struct netif *netif)
+{
+  LWIP_ASSERT("netif != NULL", (netif != NULL));
+
+#if LWIP_NETIF_HOSTNAME
+  /* Initialize interface hostname */
+  netif->hostname = "lwip";
+#endif /* LWIP_NETIF_HOSTNAME */
+
+  netif->name[0] = IFNAME0;
+  netif->name[1] = IFNAME1;
+
+  netif->output = etharp_output;
+  netif->linkoutput = low_level_output;
+
+  /* initialize the hardware */
+  low_level_init(netif);
+
+  return ERR_OK;
+}
+
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
-- 
1.9.1


From 81eded01bb2bc35a9b627e5cf35b2021efb5972c Mon Sep 17 00:00:00 2001
From: Jay Doyle <jay.doyle@vecna.com>
Date: Mon, 7 Sep 2015 10:22:57 -0400
Subject: [PATCH 07/33] Added bsp path

---
 Makefile | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/Makefile b/Makefile
index 6efa141..a855d9f 100644
--- a/Makefile
+++ b/Makefile
@@ -13,6 +13,8 @@ LWIP_EXEC=lwip
 
 #### PATHS #####################################################################
 
+BSP_PATH=/opt/rtems-4.11/arm-rtems4.11/stm32f7x/lib/include/bsp
+
 # LWIP
 LWIP_PATH=.
 LWIP_SRC_PATH=$(LWIP_PATH)/src
@@ -97,7 +99,7 @@ DRIVER_H=$(LWIPDRIVER_INCL_PATH)
 # HEADERS
 HEADERS=-I$(CORE_H) -I$(POSIX_H) -I$(POSIX_SYS_H) -I$(NETIF_H) \
         -I$(NETIF_H_PPP) -I$(NETIF_H_PPP_POLARSSL) -I$(ARCH_H) \
-        -I$(DRIVER_H) -I$(IPV4_H)
+        -I$(DRIVER_H) -I$(IPV4_H) -I$(BSP_PATH)
 
 
 ################################################################################
-- 
1.9.1


From f114529d5af1e2a83b49b67d631b10c02648e8d8 Mon Sep 17 00:00:00 2001
From: Jay Doyle <jay.doyle@vecna.com>
Date: Mon, 7 Sep 2015 10:54:26 -0400
Subject: [PATCH 08/33] removed ethernetif.c

---
 src/netif/ethernetif.c | 496 -------------------------------------------------
 1 file changed, 496 deletions(-)
 delete mode 100644 src/netif/ethernetif.c

diff --git a/src/netif/ethernetif.c b/src/netif/ethernetif.c
deleted file mode 100644
index bc429e9..0000000
--- a/src/netif/ethernetif.c
+++ /dev/null
@@ -1,496 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    LwIP/LwIP_HTTP_Server_Netconn_RTOS/Src/ethernetif.c
-  * @author  MCD Application Team
-  * @version V1.0.0
-  * @date    25-June-2015
-  * @brief   This file implements Ethernet network interface drivers for lwIP
-  ******************************************************************************
-  * @attention
-  *
-  * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
-  *
-  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
-  * You may not use this file except in compliance with the License.
-  * You may obtain a copy of the License at:
-  *
-  *        http://www.st.com/software_license_agreement_liberty_v2
-  *
-  * Unless required by applicable law or agreed to in writing, software 
-  * distributed under the License is distributed on an "AS IS" BASIS, 
-  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  * See the License for the specific language governing permissions and
-  * limitations under the License.
-  *
-  ******************************************************************************
-  */
-
-/* Includes ------------------------------------------------------------------*/
-#include <stm32f7xx_hal.h>
-#include <lwip/opt.h>
-#include <lwip/lwip_timers.h>
-#include <netif/etharp.h>
-#include <hal-ethernetif.h>
-#include <string.h>
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* The time to block waiting for input. */
-#define TIME_WAITING_FOR_INPUT                 ( 100 )
-/* Stack size of the interface thread */
-#define INTERFACE_THREAD_STACK_SIZE            ( 350 )
-
-/* Define those to better describe your network interface. */
-#define IFNAME0 'e'
-#define IFNAME1 'n'
-
-#define LAN8742A_PHY_ADDRESS            0x00
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-
-#if defined ( __ICCARM__ ) /*!< IAR Compiler */
-
-#pragma location=0x2000E000
-__no_init ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
-#pragma location=0x2000E100
-__no_init ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
-#elif defined ( __CC_ARM   )
-ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((at(0x2000E000)));/* Ethernet Rx MA Descriptor */
-ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((at(0x2000E100)));/* Ethernet Tx DMA Descriptor */
-#elif defined ( __GNUC__   )
-//ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".RxDescripSection")));/* Ethernet Rx MA Descriptor */
-//ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".TxDescripSection")));/* Ethernet Tx DMA Descriptor */
-ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Rx MA Descriptor */
-ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Tx DMA Descriptor */
-
-
-#endif
-#if defined ( __ICCARM__ ) /*!< IAR Compiler */
-#pragma location=0x2000E200
-__no_init uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
-#pragma location=0x2000FFC4
-__no_init uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
-#elif defined ( __CC_ARM   )
-uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((at(0x2000E200)));  /* Ethernet Receive Buffer */
-uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]  __attribute__((at(0x2000FFC4))); /* Ethernet Transmit Buffer */
-#elif defined ( __GNUC__   )
-//uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".RxBUF")));/* Ethernet Receive Buffer */
-//uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".TxBUF")));/* Ethernet Transmit Buffer */
-uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Receive Buffer */
-uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Transmit Buffer */
-
-#endif
-/* Semaphore to signal incoming packets */
-osSemaphoreId s_xSemaphore = NULL;
-
-/* Global Ethernet handle*/
-ETH_HandleTypeDef EthHandle;
-
-/* Private function prototypes -----------------------------------------------*/
-static void ethernetif_input( void const * argument );
-
-static void stm32f_ethernet_isr(
-  void* argData
-)
-{
-  ETH_HandleTypeDef* pEth =
-    (ETH_HandleTypeDef*) argData;
-
-  HAL_ETH_IRQHandler(pEth);
-}
-
-/* Private functions ---------------------------------------------------------*/
-/*******************************************************************************
-                       Ethernet MSP Routines
-*******************************************************************************/
-/**
-  * @brief  Initializes the ETH MSP.
-  * @param  heth: ETH handle
-  * @retval None
-  */
-void HAL_ETH_MspInit(ETH_HandleTypeDef *heth)
-{
-  GPIO_InitTypeDef GPIO_InitStructure;
-  
-  /* Enable GPIOs clocks */
-  __HAL_RCC_GPIOA_CLK_ENABLE();
-  __HAL_RCC_GPIOC_CLK_ENABLE();
-  __HAL_RCC_GPIOG_CLK_ENABLE();
-
-/* Ethernet pins configuration ************************************************/
-  /*
-        RMII_REF_CLK ----------------------> PA1
-        RMII_MDIO -------------------------> PA2
-        RMII_MDC --------------------------> PC1
-        RMII_MII_CRS_DV -------------------> PA7
-        RMII_MII_RXD0 ---------------------> PC4
-        RMII_MII_RXD1 ---------------------> PC5
-        RMII_MII_RXER ---------------------> PG2
-        RMII_MII_TX_EN --------------------> PG11
-        RMII_MII_TXD0 ---------------------> PG13
-        RMII_MII_TXD1 ---------------------> PG14
-  */
-
-  /* Configure PA1, PA2 and PA7 */
-  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
-  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
-  GPIO_InitStructure.Pull = GPIO_NOPULL; 
-  GPIO_InitStructure.Alternate = GPIO_AF11_ETH;
-  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
-  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
-  
-  /* Configure PC1, PC4 and PC5 */
-  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;
-  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
-
-  /* Configure PG2, PG11, PG13 and PG14 */
-  GPIO_InitStructure.Pin =  GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14;
-  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
-  
-  // Install HAL Ethernet ISR
-  rtems_interrupt_handler_install(
-    ETH_IRQn,
-    NULL,
-    0,
-    stm32f_ethernet_isr,
-    heth);
-  
-  /* Enable ETHERNET clock  */
-  __HAL_RCC_ETH_CLK_ENABLE();
-}
-
-/**
-  * @brief  Ethernet Rx Transfer completed callback
-  * @param  heth: ETH handle
-  * @retval None
-  */
-void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
-{
-  osSemaphoreRelease(s_xSemaphore);
-}
-
-/**
-  * @brief  Ethernet IRQ Handler
-  * @param  None
-  * @retval None
-  */
-void ETHERNET_IRQHandler(void)
-{
-  HAL_ETH_IRQHandler(&EthHandle);
-}
-
-/*******************************************************************************
-                       LL Driver Interface ( LwIP stack --> ETH) 
-*******************************************************************************/
-/**
-  * @brief In this function, the hardware should be initialized.
-  * Called from ethernetif_init().
-  *
-  * @param netif the already initialized lwip network interface structure
-  *        for this ethernetif
-  */
-static void low_level_init(struct netif *netif)
-{
-  uint8_t macaddress[6]= { MAC_ADDR0, MAC_ADDR1, MAC_ADDR2, MAC_ADDR3, MAC_ADDR4, MAC_ADDR5 };
-  
-  EthHandle.Instance = ETH;  
-  EthHandle.Init.MACAddr = macaddress;
-  EthHandle.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
-  EthHandle.Init.Speed = ETH_SPEED_100M;
-  EthHandle.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
-  EthHandle.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
-  EthHandle.Init.RxMode = ETH_RXINTERRUPT_MODE;
-  EthHandle.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
-  EthHandle.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
-  
-  /* configure ethernet peripheral (GPIOs, clocks, MAC, DMA) */
-  if (HAL_ETH_Init(&EthHandle) == HAL_OK)
-  {
-    /* Set netif link flag */
-    netif->flags |= NETIF_FLAG_LINK_UP;
-  }
-  
-  /* Initialize Tx Descriptors list: Chain Mode */
-  HAL_ETH_DMATxDescListInit(&EthHandle, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
-     
-  /* Initialize Rx Descriptors list: Chain Mode  */
-  HAL_ETH_DMARxDescListInit(&EthHandle, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
-  
-  /* set netif MAC hardware address length */
-  netif->hwaddr_len = ETHARP_HWADDR_LEN;
-
-  /* set netif MAC hardware address */
-  netif->hwaddr[0] =  MAC_ADDR0;
-  netif->hwaddr[1] =  MAC_ADDR1;
-  netif->hwaddr[2] =  MAC_ADDR2;
-  netif->hwaddr[3] =  MAC_ADDR3;
-  netif->hwaddr[4] =  MAC_ADDR4;
-  netif->hwaddr[5] =  MAC_ADDR5;
-
-  /* set netif maximum transfer unit */
-  netif->mtu = 1500;
-
-  /* Accept broadcast address and ARP traffic */
-  netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
-
-  /* create a binary semaphore used for informing ethernetif of frame reception */
-  osSemaphoreDef(SEM);
-  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1 );
-
-  /* create the task that handles the ETH_MAC */
-  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
-  osThreadCreate (osThread(EthIf), netif);
-
-  /* Enable MAC and DMA transmission and reception */
-  HAL_ETH_Start(&EthHandle);
-}
-
-
-/**
-  * @brief This function should do the actual transmission of the packet. The packet is
-  * contained in the pbuf that is passed to the function. This pbuf
-  * might be chained.
-  *
-  * @param netif the lwip network interface structure for this ethernetif
-  * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
-  * @return ERR_OK if the packet could be sent
-  *         an err_t value if the packet couldn't be sent
-  *
-  * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
-  *       strange results. You might consider waiting for space in the DMA queue
-  *       to become available since the stack doesn't retry to send a packet
-  *       dropped because of memory failure (except for the TCP timers).
-  */
-static err_t low_level_output(struct netif *netif, struct pbuf *p)
-{
-  err_t errval;
-  struct pbuf *q;
-  uint8_t *buffer = (uint8_t *)(EthHandle.TxDesc->Buffer1Addr);
-  __IO ETH_DMADescTypeDef *DmaTxDesc;
-  uint32_t framelength = 0;
-  uint32_t bufferoffset = 0;
-  uint32_t byteslefttocopy = 0;
-  uint32_t payloadoffset = 0;
-
-  DmaTxDesc = EthHandle.TxDesc;
-  bufferoffset = 0;
-  
-  /* copy frame from pbufs to driver buffers */
-  for(q = p; q != NULL; q = q->next)
-  {
-    /* Is this buffer available? If not, goto error */
-    if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
-    {
-      errval = ERR_USE;
-      goto error;
-    }
-    
-    /* Get bytes in current lwIP buffer */
-    byteslefttocopy = q->len;
-    payloadoffset = 0;
-    
-    /* Check if the length of data to copy is bigger than Tx buffer size*/
-    while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
-    {
-      /* Copy data to Tx buffer*/
-      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
-      
-      /* Point to next descriptor */
-      DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
-      
-      /* Check if the buffer is available */
-      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
-      {
-        errval = ERR_USE;
-        goto error;
-      }
-      
-      buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
-      
-      byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
-      payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
-      framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
-      bufferoffset = 0;
-    }
-    
-    /* Copy the remaining bytes */
-    memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
-    bufferoffset = bufferoffset + byteslefttocopy;
-    framelength = framelength + byteslefttocopy;
-  }
-  
-  /* Prepare transmit descriptors to give to DMA */ 
-  HAL_ETH_TransmitFrame(&EthHandle, framelength);
-  
-  errval = ERR_OK;
-  
-error:
-  
-  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
-  if ((EthHandle.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
-  {
-    /* Clear TUS ETHERNET DMA flag */
-    EthHandle.Instance->DMASR = ETH_DMASR_TUS;
-    
-    /* Resume DMA transmission*/
-    EthHandle.Instance->DMATPDR = 0;
-  }
-  return errval;
-}
-
-/**
-  * @brief Should allocate a pbuf and transfer the bytes of the incoming
-  * packet from the interface into the pbuf.
-  *
-  * @param netif the lwip network interface structure for this ethernetif
-  * @return a pbuf filled with the received packet (including MAC header)
-  *         NULL on memory error
-  */
-static struct pbuf * low_level_input(struct netif *netif)
-{
-  struct pbuf *p = NULL, *q = NULL;
-  uint16_t len = 0;
-  uint8_t *buffer;
-  __IO ETH_DMADescTypeDef *dmarxdesc;
-  uint32_t bufferoffset = 0;
-  uint32_t payloadoffset = 0;
-  uint32_t byteslefttocopy = 0;
-  uint32_t i=0;
-  
-  /* get received frame */
-  if(HAL_ETH_GetReceivedFrame_IT(&EthHandle) != HAL_OK)
-    return NULL;
-  
-  /* Obtain the size of the packet and put it into the "len" variable. */
-  len = EthHandle.RxFrameInfos.length;
-  buffer = (uint8_t *)EthHandle.RxFrameInfos.buffer;
-  
-  if (len > 0)
-  {
-    /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
-    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
-  }
-  
-  if (p != NULL)
-  {
-    dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
-    bufferoffset = 0;
-    
-    for(q = p; q != NULL; q = q->next)
-    {
-      byteslefttocopy = q->len;
-      payloadoffset = 0;
-      
-      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size */
-      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
-      {
-        /* Copy data to pbuf */
-        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
-        
-        /* Point to next descriptor */
-        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
-        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
-        
-        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
-        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
-        bufferoffset = 0;
-      }
-      
-      /* Copy remaining data in pbuf */
-      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
-      bufferoffset = bufferoffset + byteslefttocopy;
-    }
-  }
-    
-  /* Release descriptors to DMA */
-  /* Point to first descriptor */
-  dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
-  /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
-  for (i=0; i< EthHandle.RxFrameInfos.SegCount; i++)
-  {  
-    dmarxdesc->Status |= ETH_DMARXDESC_OWN;
-    dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
-  }
-    
-  /* Clear Segment_Count */
-  EthHandle.RxFrameInfos.SegCount =0;
-  
-  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
-  if ((EthHandle.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
-  {
-    /* Clear RBUS ETHERNET DMA flag */
-    EthHandle.Instance->DMASR = ETH_DMASR_RBUS;
-    /* Resume DMA reception */
-    EthHandle.Instance->DMARPDR = 0;
-  }
-  return p;
-}
-
-/**
-  * @brief This function is the ethernetif_input task, it is processed when a packet 
-  * is ready to be read from the interface. It uses the function low_level_input() 
-  * that should handle the actual reception of bytes from the network
-  * interface. Then the type of the received packet is determined and
-  * the appropriate input function is called.
-  *
-  * @param netif the lwip network interface structure for this ethernetif
-  */
-void ethernetif_input( void const * argument )
-{
-  struct pbuf *p;
-  struct netif *netif = (struct netif *) argument;
-  
-  for( ;; )
-  {
-    if (osSemaphoreWait( s_xSemaphore, TIME_WAITING_FOR_INPUT)==osOK)
-    {
-      do
-      {
-        p = low_level_input( netif );
-        if (p != NULL)
-        {
-          if (netif->input( p, netif) != ERR_OK )
-          {
-            pbuf_free(p);
-          }
-        }
-      }while(p!=NULL);
-    }
-  }
-}
-
-/**
-  * @brief Should be called at the beginning of the program to set up the
-  * network interface. It calls the function low_level_init() to do the
-  * actual setup of the hardware.
-  *
-  * This function should be passed as a parameter to netif_add().
-  *
-  * @param netif the lwip network interface structure for this ethernetif
-  * @return ERR_OK if the loopif is initialized
-  *         ERR_MEM if private data couldn't be allocated
-  *         any other err_t on error
-  */
-err_t ethernetif_init(struct netif *netif)
-{
-  LWIP_ASSERT("netif != NULL", (netif != NULL));
-
-#if LWIP_NETIF_HOSTNAME
-  /* Initialize interface hostname */
-  netif->hostname = "lwip";
-#endif /* LWIP_NETIF_HOSTNAME */
-
-  netif->name[0] = IFNAME0;
-  netif->name[1] = IFNAME1;
-
-  netif->output = etharp_output;
-  netif->linkoutput = low_level_output;
-
-  /* initialize the hardware */
-  low_level_init(netif);
-
-  return ERR_OK;
-}
-
-/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
-- 
1.9.1


From 8f652ac0f1be0f2abc1493981763fc4c402bbfed Mon Sep 17 00:00:00 2001
From: Jay Doyle <jay.doyle@vecna.com>
Date: Wed, 16 Sep 2015 09:29:27 -0400
Subject: [PATCH 09/33] using options from sample project

---
 ports/include/lwipopts.h | 207 +++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 207 insertions(+)

diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
index 169ba46..68d799b 100644
--- a/ports/include/lwipopts.h
+++ b/ports/include/lwipopts.h
@@ -38,6 +38,9 @@
 #ifndef __LWIPOPTS_H__
 #define __LWIPOPTS_H__
 
+
+#if ORIGINAL_CONFIG_OPTIONS
+
 /*****************************************************************************
 **                           CONFIGURATIONS
 *****************************************************************************/
@@ -175,4 +178,208 @@
 
  #define LWIP_RAW                       0
 
+#else
+
+/**
+ * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
+ * critical regions during buffer allocation, deallocation and memory
+ * allocation and deallocation.
+ */
+#define SYS_LIGHTWEIGHT_PROT    0
+
+#define ETHARP_TRUST_IP_MAC     0
+#define IP_REASSEMBLY           0
+#define IP_FRAG                 0
+#define ARP_QUEUEING            0
+#define TCP_LISTEN_BACKLOG      1
+
+/**
+ * NO_SYS==1: Provides VERY minimal functionality. Otherwise,
+ * use lwIP facilities.
+ */
+#define NO_SYS                  0
+
+/* ---------- Memory options ---------- */
+/* MEM_ALIGNMENT: should be set to the alignment of the CPU for which
+   lwIP is compiled. 4 byte alignment -> define MEM_ALIGNMENT to 4, 2
+   byte alignment -> define MEM_ALIGNMENT to 2. */
+#define MEM_ALIGNMENT           4
+
+/* MEM_SIZE: the size of the heap memory. If the application will send
+a lot of data that needs to be copied, this should be set high. */
+#define MEM_SIZE                (10*1024)
+
+/* MEMP_NUM_PBUF: the number of memp struct pbufs. If the application
+   sends a lot of data out of ROM (or other static memory), this
+   should be set high. */
+#define MEMP_NUM_PBUF           50
+/* MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks. One
+   per active UDP "connection". */
+#define MEMP_NUM_UDP_PCB        6
+/* MEMP_NUM_TCP_PCB: the number of simulatenously active TCP
+   connections. */
+#define MEMP_NUM_TCP_PCB        10
+/* MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP
+   connections. */
+#define MEMP_NUM_TCP_PCB_LISTEN 5
+/* MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP
+   segments. */
+#define MEMP_NUM_TCP_SEG        12
+/* MEMP_NUM_SYS_TIMEOUT: the number of simulateously active
+   timeouts. */
+#define MEMP_NUM_SYS_TIMEOUT    10
+
+
+/* ---------- Pbuf options ---------- */
+/* PBUF_POOL_SIZE: the number of buffers in the pbuf pool. */
+#define PBUF_POOL_SIZE          10
+
+/* PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. */
+#define PBUF_POOL_BUFSIZE       1524
+
+
+/* ---------- TCP options ---------- */
+#define LWIP_TCP                1
+#define TCP_TTL                 255
+
+/* Controls if TCP should queue segments that arrive out of
+   order. Define to 0 if your device is low on memory. */
+#define TCP_QUEUE_OOSEQ         0
+
+/* TCP Maximum segment size. */
+#define TCP_MSS                 (1500 - 40)   /* TCP_MSS = (Ethernet MTU - IP header size - TCP header size) */
+
+/* TCP sender buffer space (bytes). */
+#define TCP_SND_BUF             (4*TCP_MSS)
+
+/*  TCP_SND_QUEUELEN: TCP sender buffer space (pbufs). This must be at least
+  as much as (2 * TCP_SND_BUF/TCP_MSS) for things to work. */
+
+#define TCP_SND_QUEUELEN        (2* TCP_SND_BUF/TCP_MSS)
+
+/* TCP receive window. */
+#define TCP_WND                 (2*TCP_MSS)
+
+
+/* ---------- ICMP options ---------- */
+#define LWIP_ICMP                       1
+
+
+/* ---------- DHCP options ---------- */
+/* Define LWIP_DHCP to 1 if you want DHCP configuration of
+   interfaces. DHCP is not implemented in lwIP 0.5.1, however, so
+   turning this on does currently not work. */
+#define LWIP_DHCP               1
+
+
+/* ---------- UDP options ---------- */
+#define LWIP_UDP                1
+#define UDP_TTL                 255
+
+
+/* ---------- Statistics options ---------- */
+#define LWIP_STATS 0
+#define LWIP_PROVIDE_ERRNO 1
+
+/* ---------- link callback options ---------- */
+/* LWIP_NETIF_LINK_CALLBACK==1: Support a callback function from an interface
+ * whenever the link changes (i.e., link down)
+ */
+#define LWIP_NETIF_LINK_CALLBACK        1
+
+/*
+   --------------------------------------
+   ---------- Checksum options ----------
+   --------------------------------------
+*/
+
+/*
+The STM32F4x7 allows computing and verifying the IP, UDP, TCP and ICMP checksums by hardware:
+ - To use this feature let the following define uncommented.
+ - To disable it and process by CPU comment the  the checksum.
+*/
+#define CHECKSUM_BY_HARDWARE
+
+
+#ifdef CHECKSUM_BY_HARDWARE
+  /* CHECKSUM_GEN_IP==0: Generate checksums by hardware for outgoing IP packets.*/
+  #define CHECKSUM_GEN_IP                 0
+  /* CHECKSUM_GEN_UDP==0: Generate checksums by hardware for outgoing UDP packets.*/
+  #define CHECKSUM_GEN_UDP                0
+  /* CHECKSUM_GEN_TCP==0: Generate checksums by hardware for outgoing TCP packets.*/
+  #define CHECKSUM_GEN_TCP                0
+  /* CHECKSUM_CHECK_IP==0: Check checksums by hardware for incoming IP packets.*/
+  #define CHECKSUM_CHECK_IP               0
+  /* CHECKSUM_CHECK_UDP==0: Check checksums by hardware for incoming UDP packets.*/
+  #define CHECKSUM_CHECK_UDP              0
+  /* CHECKSUM_CHECK_TCP==0: Check checksums by hardware for incoming TCP packets.*/
+  #define CHECKSUM_CHECK_TCP              0
+  /* CHECKSUM_CHECK_ICMP==0: Check checksums by hardware for incoming ICMP packets.*/
+  #define CHECKSUM_GEN_ICMP               0
+#else
+  /* CHECKSUM_GEN_IP==1: Generate checksums in software for outgoing IP packets.*/
+  #define CHECKSUM_GEN_IP                 1
+  /* CHECKSUM_GEN_UDP==1: Generate checksums in software for outgoing UDP packets.*/
+  #define CHECKSUM_GEN_UDP                1
+  /* CHECKSUM_GEN_TCP==1: Generate checksums in software for outgoing TCP packets.*/
+  #define CHECKSUM_GEN_TCP                1
+  /* CHECKSUM_CHECK_IP==1: Check checksums in software for incoming IP packets.*/
+  #define CHECKSUM_CHECK_IP               1
+  /* CHECKSUM_CHECK_UDP==1: Check checksums in software for incoming UDP packets.*/
+  #define CHECKSUM_CHECK_UDP              1
+  /* CHECKSUM_CHECK_TCP==1: Check checksums in software for incoming TCP packets.*/
+  #define CHECKSUM_CHECK_TCP              1
+  /* CHECKSUM_CHECK_ICMP==1: Check checksums by hardware for incoming ICMP packets.*/
+  #define CHECKSUM_GEN_ICMP               1
+#endif
+
+
+/*
+   ----------------------------------------------
+   ---------- Sequential layer options ----------
+   ----------------------------------------------
+*/
+/**
+ * LWIP_NETCONN==1: Enable Netconn API (require to use api_lib.c)
+ */
+#define LWIP_NETCONN                    1
+
+/*
+   ------------------------------------
+   ---------- Socket options ----------
+   ------------------------------------
+*/
+/**
+ * LWIP_SOCKET==1: Enable Socket API (require to use sockets.c)
+ */
+#define LWIP_SOCKET                     1
+
+/*
+   -----------------------------------
+   ---------- DEBUG options ----------
+   -----------------------------------
+*/
+
+#define LWIP_DEBUG                      0
+
+
+/*
+   ---------------------------------
+   ---------- OS options ----------
+   ---------------------------------
+*/
+
+#define TCPIP_THREAD_NAME              "TCP/IP"
+#define TCPIP_THREAD_STACKSIZE          1000
+#define TCPIP_MBOX_SIZE                 5
+#define DEFAULT_UDP_RECVMBOX_SIZE       2000
+#define DEFAULT_TCP_RECVMBOX_SIZE       2000
+#define DEFAULT_ACCEPTMBOX_SIZE         2000
+#define DEFAULT_THREAD_STACKSIZE        500
+#define TCPIP_THREAD_PRIO               (configMAX_PRIORITIES - 2)
+#define LWIP_COMPAT_MUTEX               1
+
+
+#endif
+
 #endif /* __LWIPOPTS_H__ */
-- 
1.9.1


From d2624890161b1ec246cd224de8079157367a6346 Mon Sep 17 00:00:00 2001
From: Jay Doyle <jay.doyle@vecna.com>
Date: Wed, 16 Sep 2015 10:01:58 -0400
Subject: [PATCH 10/33] added cache line configuration

---
 ports/include/lwipopts.h | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
index 68d799b..049d66d 100644
--- a/ports/include/lwipopts.h
+++ b/ports/include/lwipopts.h
@@ -180,6 +180,9 @@
 
 #else
 
+#define LWIP_CACHE_ENABLED
+#define SOC_CACHELINE_SIZE_BYTES 32
+
 /**
  * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
  * critical regions during buffer allocation, deallocation and memory
-- 
1.9.1


From 37e5b73c865357e530226ea2a2008aa355f58d55 Mon Sep 17 00:00:00 2001
From: Jay Doyle <jay.doyle@vecna.com>
Date: Wed, 16 Sep 2015 10:11:20 -0400
Subject: [PATCH 11/33] configured for local time structure definition

---
 ports/include/arch/cc.h  | 2 ++
 ports/include/lwipopts.h | 1 +
 2 files changed, 3 insertions(+)

diff --git a/ports/include/arch/cc.h b/ports/include/arch/cc.h
index 04ec89f..900e9b6 100644
--- a/ports/include/arch/cc.h
+++ b/ports/include/arch/cc.h
@@ -32,6 +32,8 @@
 #ifndef __CC_H__
 #define __CC_H__
 
+#include <sys/time.h>
+
 typedef unsigned    char    u8_t;
 typedef signed      char    s8_t;
 typedef unsigned    short   u16_t;
diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
index 049d66d..05f5b52 100644
--- a/ports/include/lwipopts.h
+++ b/ports/include/lwipopts.h
@@ -182,6 +182,7 @@
 
 #define LWIP_CACHE_ENABLED
 #define SOC_CACHELINE_SIZE_BYTES 32
+#define LWIP_TIMEVAL_PRIVATE 0
 
 /**
  * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
-- 
1.9.1


From 9a72a789d145f794b8a4c1084ed50597b71c6e2b Mon Sep 17 00:00:00 2001
From: Jay Doyle <jay.doyle@vecna.com>
Date: Wed, 16 Sep 2015 10:16:55 -0400
Subject: [PATCH 12/33] remove include from cc.h

---
 ports/include/arch/cc.h | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/ports/include/arch/cc.h b/ports/include/arch/cc.h
index 900e9b6..8eefd64 100644
--- a/ports/include/arch/cc.h
+++ b/ports/include/arch/cc.h
@@ -32,8 +32,6 @@
 #ifndef __CC_H__
 #define __CC_H__
 
-#include <sys/time.h>
-
 typedef unsigned    char    u8_t;
 typedef signed      char    s8_t;
 typedef unsigned    short   u16_t;
@@ -104,6 +102,8 @@ extern u8_t memp_memory_PBUF_POOL_base[] __attribute__ ((aligned (SOC_CACHELINE_
 #include <stdio.h>
 #include <stdlib.h>
 #include <bsp.h>
+//#include <sys/time.h>
+
 #define LWIP_PLATFORM_DIAG(x)   do { \
         printk("[%s - %s - %d] ", __PRETTY_FUNCTION__, __FILE__, __LINE__); \
         printk x; \
-- 
1.9.1


From a48846deb25945d360543ffe8d86766d323b9859 Mon Sep 17 00:00:00 2001
From: Jay Doyle <jay.doyle@vecna.com>
Date: Fri, 18 Sep 2015 13:22:21 -0400
Subject: [PATCH 13/33] turn off checksum checking by hardware

---
 ports/include/lwipopts.h | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
index 05f5b52..cf11793 100644
--- a/ports/include/lwipopts.h
+++ b/ports/include/lwipopts.h
@@ -243,8 +243,8 @@ a lot of data that needs to be copied, this should be set high. */
 
 
 /* ---------- TCP options ---------- */
-#define LWIP_TCP                1
-#define TCP_TTL                 255
+//#define LWIP_TCP                1
+//#define TCP_TTL                 255
 
 /* Controls if TCP should queue segments that arrive out of
    order. Define to 0 if your device is low on memory. */
@@ -302,7 +302,7 @@ The STM32F4x7 allows computing and verifying the IP, UDP, TCP and ICMP checksums
  - To use this feature let the following define uncommented.
  - To disable it and process by CPU comment the  the checksum.
 */
-#define CHECKSUM_BY_HARDWARE
+//#define CHECKSUM_BY_HARDWARE
 
 
 #ifdef CHECKSUM_BY_HARDWARE
-- 
1.9.1


From ab1a2feb46bbb67eb1639e08dd5ffd2ed1f1933d Mon Sep 17 00:00:00 2001
From: Jay Doyle <jay.doyle@vecna.com>
Date: Fri, 18 Sep 2015 13:24:24 -0400
Subject: [PATCH 14/33] defined configMAX_PRIORITIES

---
 ports/include/lwipopts.h |    3 +-
 rtems.patch              | 4105 ++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 4107 insertions(+), 1 deletion(-)
 create mode 100644 rtems.patch

diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
index cf11793..e7f344f 100644
--- a/ports/include/lwipopts.h
+++ b/ports/include/lwipopts.h
@@ -180,6 +180,7 @@
 
 #else
 
+#define configMAX_PRIORITIES 100
 #define LWIP_CACHE_ENABLED
 #define SOC_CACHELINE_SIZE_BYTES 32
 #define LWIP_TIMEVAL_PRIVATE 0
@@ -287,7 +288,7 @@ a lot of data that needs to be copied, this should be set high. */
 
 /* ---------- link callback options ---------- */
 /* LWIP_NETIF_LINK_CALLBACK==1: Support a callback function from an interface
- * whenever the link changes (i.e., link down)
+ * whenever the link a48846deb25945d360543ffe8d86766d323b9859changes (i.e., link down)
  */
 #define LWIP_NETIF_LINK_CALLBACK        1
 
diff --git a/rtems.patch b/rtems.patch
new file mode 100644
index 0000000..9ca8d63
--- /dev/null
+++ b/rtems.patch
@@ -0,0 +1,4105 @@
+From 2d83d4994e578ec339b2b1baef53090bf7a53570 Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Fri, 4 Sep 2015 17:28:55 -0400
+Subject: [PATCH 01/13] rtems changes necessary
+
+---
+ Makefile                      | 170 +++++++++++
+ ports/include/arch/cc.h       | 123 ++++++++
+ ports/include/arch/perf.h     |  38 +++
+ ports/include/arch/sys_arch.h |  59 ++++
+ ports/include/lwipopts.h      | 178 ++++++++++++
+ ports/sys_arch.c              | 663 ++++++++++++++++++++++++++++++++++++++++++
+ 6 files changed, 1231 insertions(+)
+ create mode 100644 Makefile
+ create mode 100644 ports/include/arch/cc.h
+ create mode 100644 ports/include/arch/perf.h
+ create mode 100644 ports/include/arch/sys_arch.h
+ create mode 100644 ports/include/lwipopts.h
+ create mode 100644 ports/sys_arch.c
+
+diff --git a/Makefile b/Makefile
+new file mode 100644
+index 0000000..0cbae64
+--- /dev/null
++++ b/Makefile
+@@ -0,0 +1,170 @@
++include $(RTEMS_MAKEFILE_PATH)/Makefile.inc
++include $(RTEMS_CUSTOM)
++include $(PROJECT_ROOT)/make/leaf.cfg
++
++#### CONFIG ####################################################################
++#For debugging symbols add -DLWIP_DEBUG
++# COMPILER/LINKER
++CFLAGS+=-g -O2   \
++ -Wall
++
++# OUTPUT
++LWIP_EXEC=lwip
++
++#### PATHS #####################################################################
++
++# LWIP
++LWIP_PATH=.
++LWIP_SRC_PATH=$(LWIP_PATH)/src
++LWIP_API_PATH=$(LWIP_SRC_PATH)/api
++LWIP_CORE_PATH=$(LWIP_SRC_PATH)/core
++LWIP_INCL_PATH=$(LWIP_SRC_PATH)/include
++LWIP_NETIF_PATH=$(LWIP_SRC_PATH)/netif
++
++# ARCH
++LWIPARCH_PATH=$(LWIP_PATH)/ports
++LWIPARCH_SRC_PATH=$(LWIPARCH_PATH)
++LWIPARCH_INCL_PATH=$(LWIPARCH_PATH)/include
++
++# DRIVER
++LWIPDRIVER_PATH=$(LWIP_PATH)/ports
++LWIPDRIVER_SRC_PATH=$(LWIPDRIVER_PATH)/netif
++LWIPDRIVER_INCL_PATH=$(LWIPDRIVER_PATH)/include/netif
++
++#### SOURCES ###################################################################
++
++## CORE
++CORE_SRC=$(wildcard $(LWIP_CORE_PATH)/*.c)
++
++## IPv4
++IPV4_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv4/*.c)
++
++## IPv6
++IPV6_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv6/*.c)
++
++## SNMP
++SNMP_SRC=$(wildcard $(LWIP_CORE_PATH)/snmp/*.c)
++
++## API
++API_SRC=$(wildcard $(LWIP_API_PATH)/*.c )
++
++## NETIF
++NETIF_SRC=$(wildcard $(LWIP_NETIF_PATH)/*.c) \
++          $(wildcard $(LWIP_NETIF_PATH)/ppp/*.c) \
++          $(wildcard $(LWIP_NETIF_PATH)/ppp/polarssl/*.c)
++
++
++ARCH_SRC=$(wildcard $(LWIPARCH_SRC_PATH)/*.c)
++
++# DRIVER
++DRIVER_SRC=$(wildcard $(LWIPDRIVER_SRC_PATH)/*.c ) \
++           $(wildcard $(LWIPDRIVER_SRC_PATH)/*.S )
++
++
++SOURCES =  $(DRIVER_SRC) $(SNMP_SRC)\
++           $(CORE_SRC) $(IPV4_SRC) $(API_SRC) $(NETIF_SRC) $(ARCH_SRC)
++
++
++#### HEADERS ###################################################################
++
++## CORE
++CORE_H=$(LWIP_INCL_PATH)
++
++## IPv4
++#IPV4_H=$(LWIP_INCL_PATH)/ipv4
++
++## IPv6
++#IPV6_H=$(LWIP_INCL_PATH)/ipv6
++
++## POSIX
++POSIX_H=$(LWIP_INCL_PATH)/posix
++
++##POSIX_SYS
++POSIX_SYS_H=$(LWIP_INCL_PATH)/posix/sys
++
++
++## NETIF
++NETIF_H=$(LWIP_INCL_PATH)/netif
++NETIF_H_PPP=$(LWIP_INCL_PATH)/netif/ppp
++NETIF_H_PPP_POLARSSL=$(LWIP_INCL_PATH)/netif/ppp/polarssl
++
++## ARCH
++ARCH_H=$(LWIPARCH_INCL_PATH)
++
++## DRIVER
++DRIVER_H=$(LWIPDRIVER_INCL_PATH)
++
++# HEADERS
++HEADERS=-I$(CORE_H) -I$(POSIX_H) -I$(POSIX_SYS_H) -I$(NETIF_H) \
++        -I$(NETIF_H_PPP) -I$(NETIF_H_PPP_POLARSSL) -I$(ARCH_H) \
++        -I$(DRIVER_H)
++
++
++################################################################################
++
++
++BIN=${ARCH}/$(LWIP_EXEC).bin
++LIB=${ARCH}/lib$(LWIP_EXEC).a
++
++# optional managers required
++MANAGERS=all
++
++# C source names
++CSRCS=$(filter %.c ,$(SOURCES))
++COBJS=$(patsubst %.c,${ARCH}/%.o,$(notdir $(CSRCS)))
++
++ASMSRCS=$(filter %.S , $(SOURCES))
++ASMOBJS=$(patsubst %.S,${ARCH}/%.o,$(notdir $(ASMSRCS)))
++
++OBJS=$(COBJS) $(ASMOBJS)
++
++all:${ARCH} $(LIB)
++
++$(LIB): $(OBJS)
++	$(AR)  rcs  $@ $^
++
++${ARCH}/%.o: $(LWIP_CORE_PATH)/%.c
++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
++
++${ARCH}/%.o: $(LWIP_CORE_PATH)/ipv4/%.c
++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
++
++${ARCH}/%.o: $(LWIP_CORE_PATH)/ipv6/%.c
++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
++
++${ARCH}/%.o: $(LWIP_CORE_PATH)/snmp/%.c
++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
++
++${ARCH}/%.o: $(LWIP_API_PATH)/%.c
++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
++
++${ARCH}/%.o: $(LWIP_NETIF_PATH)/%.c
++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
++
++${ARCH}/%.o: $(LWIP_NETIF_PATH)/ppp/%.c
++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
++
++${ARCH}/%.o: $(LWIP_NETIF_PATH)/ppp/polarssl/%.c
++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
++
++${ARCH}/%.o: $(LWIPARCH_SRC_PATH)/%.c
++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
++
++${ARCH}/%.o: $(LWIPDRIVER_SRC_PATH)/%.S
++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
++
++${ARCH}/%.o: $(LWIPDRIVER_SRC_PATH)/%.c
++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
++
++INSTALL_DIR=$(RTEMS_MAKEFILE_PATH)/lwip
++
++install:
++	rm -rf $(INSTALL_DIR)
++	mkdir -p $(INSTALL_DIR)/include
++	mkdir -p $(INSTALL_DIR)/lib
++	cp $(LIB) $(INSTALL_DIR)/lib
++	cp -r $(CORE_H) $(INSTALL_DIR)
++	cp $(LWIPARCH_INCL_PATH)/lwipopts.h $(INSTALL_DIR)/include
++	cp -r $(LWIPARCH_INCL_PATH)/arch $(INSTALL_DIR)/include
++
++CPPFLAGS+=$(HEADERS)
+diff --git a/ports/include/arch/cc.h b/ports/include/arch/cc.h
+new file mode 100644
+index 0000000..04ec89f
+--- /dev/null
++++ b/ports/include/arch/cc.h
+@@ -0,0 +1,123 @@
++/*
++ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
++ * All rights reserved.
++ *
++ * Redistribution and use in source and binary forms, with or without modification,
++ * are permitted provided that the following conditions are met:
++ *
++ * 1. Redistributions of source code must retain the above copyright notice,
++ *    this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright notice,
++ *    this list of conditions and the following disclaimer in the documentation
++ *    and/or other materials provided with the distribution.
++ * 3. The name of the author may not be used to endorse or promote products
++ *    derived from this software without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
++ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
++ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
++ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
++ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
++ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
++ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
++ * OF SUCH DAMAGE.
++ *
++ * This file is part of the lwIP TCP/IP stack.
++ *
++ * Author: Adam Dunkels <adam@sics.se>
++ *
++ */
++#ifndef __CC_H__
++#define __CC_H__
++
++typedef unsigned    char    u8_t;
++typedef signed      char    s8_t;
++typedef unsigned    short   u16_t;
++typedef signed      short   s16_t;
++typedef unsigned    int    u32_t;
++typedef signed      int    s32_t;
++typedef u32_t           mem_ptr_t;
++
++#ifndef BYTE_ORDER
++#define BYTE_ORDER LITTLE_ENDIAN
++#endif
++
++#if defined(__arm__) && defined(__ARMCC_VERSION)
++    //
++    // Setup PACKing macros for KEIL/RVMDK Tools
++    //
++    #define PACK_STRUCT_BEGIN __packed
++    #define PACK_STRUCT_STRUCT
++    #define PACK_STRUCT_END
++    #define PACK_STRUCT_FIELD(x) x
++#elif defined (__IAR_SYSTEMS_ICC__)
++    //
++    // Setup PACKing macros for IAR Tools
++    //
++    #define PACK_STRUCT_BEGIN
++    #define PACK_STRUCT_STRUCT
++    #define PACK_STRUCT_END
++    #define PACK_STRUCT_FIELD(x) x
++    #define PACK_STRUCT_USE_INCLUDES
++#elif defined (__TMS470__)
++    #define PACK_STRUCT_BEGIN
++    #define PACK_STRUCT_STRUCT
++    #define PACK_STRUCT_END
++    #define PACK_STRUCT_FIELD(x) x
++#else
++    //
++    // Setup PACKing macros for GCC Tools
++    //
++    #define PACK_STRUCT_BEGIN
++    #define PACK_STRUCT_STRUCT __attribute__ ((__packed__))
++    #define PACK_STRUCT_END
++    #define PACK_STRUCT_FIELD(x) x
++#endif
++
++#ifdef LWIP_CACHE_ENABLED
++/**
++ * Make the PBUF POOL cacheline aligned.
++ */
++#ifdef __IAR_SYSTEMS_ICC__
++#pragma data_alignment=SOC_CACHELINE_SIZE_BYTES
++extern u8_t memp_memory_PBUF_POOL_base[];
++#else /*By default, GCC */
++extern u8_t memp_memory_PBUF_POOL_base[] __attribute__ ((aligned (SOC_CACHELINE_SIZE_BYTES)));
++#endif
++#endif
++
++extern u8_t memp_memory_PBUF_POOL_base[] __attribute__ ((aligned (SOC_CACHELINE_SIZE_BYTES)));
++
++/* Define (sn)printf formatters for these lwIP types */
++#define X8_F  "02x"
++#define U16_F "u"
++#define S16_F "d"
++#define X16_F "x"
++#define U32_F "u"
++#define S32_F "d"
++#define X32_F "x"
++
++#include <stdio.h>
++#include <stdlib.h>
++#include <bsp.h>
++#define LWIP_PLATFORM_DIAG(x)   do { \
++        printk("[%s - %s - %d] ", __PRETTY_FUNCTION__, __FILE__, __LINE__); \
++        printk x; \
++    } while(0)
++
++#ifdef LWIP_DEBUG  //DEBUG
++extern void __error__(char *pcFilename, unsigned long ulLine);
++#define LWIP_PLATFORM_ASSERT(expr)   printk("[%s - %s - %d] ", expr , __FILE__, __LINE__);
++//{
++    //if(!(expr))
++    //{
++        //__error__(__FILE__, __LINE__);
++    //}
++//}
++#else
++#define LWIP_PLATFORM_ASSERT(expr)
++#endif
++
++#endif /* __CC_H__ */
+diff --git a/ports/include/arch/perf.h b/ports/include/arch/perf.h
+new file mode 100644
+index 0000000..d754157
+--- /dev/null
++++ b/ports/include/arch/perf.h
+@@ -0,0 +1,38 @@
++/*
++ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
++ * All rights reserved.
++ *
++ * Redistribution and use in source and binary forms, with or without modification,
++ * are permitted provided that the following conditions are met:
++ *
++ * 1. Redistributions of source code must retain the above copyright notice,
++ *    this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright notice,
++ *    this list of conditions and the following disclaimer in the documentation
++ *    and/or other materials provided with the distribution.
++ * 3. The name of the author may not be used to endorse or promote products
++ *    derived from this software without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
++ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
++ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
++ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
++ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
++ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
++ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
++ * OF SUCH DAMAGE.
++ *
++ * This file is part of the lwIP TCP/IP stack.
++ *
++ * Author: Adam Dunkels <adam@sics.se>
++ *
++ */
++#ifndef __PERF_H__
++#define __PERF_H__
++
++#define PERF_START    /* null definition */
++#define PERF_STOP(x)  /* null definition */
++
++#endif /* __PERF_H__ */
+diff --git a/ports/include/arch/sys_arch.h b/ports/include/arch/sys_arch.h
+new file mode 100644
+index 0000000..32f0d99
+--- /dev/null
++++ b/ports/include/arch/sys_arch.h
+@@ -0,0 +1,59 @@
++/*
++ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
++ * All rights reserved.
++ *
++ * Redistribution and use in source and binary forms, with or without modification,
++ * are permitted provided that the following conditions are met:
++ *
++ * 1. Redistributions of source code must retain the above copyright notice,
++ *    this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright notice,
++ *    this list of conditions and the following disclaimer in the documentation
++ *    and/or other materials provided with the distribution.
++ * 3. The name of the author may not be used to endorse or promote products
++ *    derived from this software without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
++ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
++ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
++ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
++ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
++ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
++ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
++ * OF SUCH DAMAGE.
++ *
++ * This file is part of the lwIP TCP/IP stack.
++ *
++ * Author: Adam Dunkels <adam@sics.se>
++ *
++ */
++#ifndef LWIP_ARCH_SYS_ARCH_H
++#define LWIP_ARCH_SYS_ARCH_H
++
++#include <errno.h>
++
++#define SYS_MBOX_NULL NULL
++#define SYS_SEM_NULL  NULL
++
++typedef u32_t sys_prot_t;
++
++struct sys_sem;
++typedef struct sys_sem * sys_sem_t;
++#define sys_sem_valid(sem) (((sem) != NULL) && (*(sem) != NULL))
++#define sys_sem_set_invalid(sem) do { if((sem) != NULL) { *(sem) = NULL; }}while(0)
++
++/* let sys.h use binary semaphores for mutexes */
++#define LWIP_COMPAT_MUTEX 1
++
++struct sys_mbox;
++typedef struct sys_mbox *sys_mbox_t;
++#define sys_mbox_valid(mbox) ((*(mbox) != NULL))
++#define sys_mbox_set_invalid(mbox) do { if((mbox) != NULL) { *(mbox) = NULL; }}while(0)
++
++struct sys_thread;
++typedef struct sys_thread * sys_thread_t;
++
++#endif /* LWIP_ARCH_SYS_ARCH_H */
++
+diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
+new file mode 100644
+index 0000000..169ba46
+--- /dev/null
++++ b/ports/include/lwipopts.h
+@@ -0,0 +1,178 @@
++/**
++ * \file lwipopts.h - Configuration options for lwIP
++ *
++ * Copyright (c) 2010 Texas Instruments Incorporated
++ */
++/*
++ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
++ * All rights reserved.
++ *
++ * Redistribution and use in source and binary forms, with or without modification,
++ * are permitted provided that the following conditions are met:
++ *
++ * 1. Redistributions of source code must retain the above copyright notice,
++ *    this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright notice,
++ *    this list of conditions and the following disclaimer in the documentation
++ *    and/or other materials provided with the distribution.
++ * 3. The name of the author may not be used to endorse or promote products
++ *    derived from this software without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
++ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
++ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
++ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
++ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
++ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
++ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
++ * OF SUCH DAMAGE.
++ *
++ * This file is part of the lwIP TCP/IP stack.
++ *
++ * Author: Adam Dunkels <adam@sics.se>
++ *
++ */
++
++#ifndef __LWIPOPTS_H__
++#define __LWIPOPTS_H__
++
++/*****************************************************************************
++**                           CONFIGURATIONS
++*****************************************************************************/
++
++/*
++** The below macro should be defined for using lwIP with cache. For cache
++** enabling, pbuf pool shall be cache line aligned. This is done by using
++** separate pool for each memory. The alignment of pbuf pool to cache line
++** size is done in /ports/cpsw/include/arch/cc.h.
++*/
++/*#define LWIP_CACHE_ENABLED*/
++
++#define SOC_CACHELINE_SIZE_BYTES        64            /* Number of bytes in
++                                                         a cache line */
++/*
++** The timeout for DHCP completion. lwIP library will wait for DHCP
++** completion for (LWIP_DHCP_TIMEOUT / 100) seconds.
++*/
++#define LWIP_DHCP_TIMEOUT               500
++
++/*
++** The number of times DHCP is attempted. Each time, the library will wait
++** for (LWIP_DHCP_TIMEOUT / 100) seconds for DHCP completion.
++*/
++#define NUM_DHCP_TRIES                  5
++
++#define LWIP_ETHERNET                   1
++#define LWIP_ARP                        1
++
++/*****************************************************************************
++**            lwIP SPECIFIC DEFINITIONS - To be used by lwIP stack
++*****************************************************************************/
++#define HOST_TMR_INTERVAL               0
++#define DYNAMIC_HTTP_HEADERS
++
++/*****************************************************************************
++**                    Platform specific locking
++*****************************************************************************/
++#define SYS_LIGHTWEIGHT_PROT            1
++#define NO_SYS                          0
++#define NO_SYS_NO_TIMERS                0
++
++/*****************************************************************************
++**                          Memory Options
++*****************************************************************************/
++#define MEM_ALIGNMENT                   4
++#define MEM_SIZE                        (256 * 1024) /* 128K */
++
++#define MEMP_NUM_PBUF                   96
++#define MEMP_NUM_TCP_PCB                32
++#define MEMP_NUM_TCP_SEG                32
++#define PBUF_POOL_SIZE                  512
++
++#ifdef LWIP_CACHE_ENABLED
++#define MEMP_SEPARATE_POOLS             1            /* We want the pbuf
++                                                        pool cache line
++                                                        aligned*/
++#endif
++
++#define MEMP_NUM_SYS_TIMEOUT (LWIP_TCP + IP_REASSEMBLY + LWIP_ARP + (2*LWIP_DHCP) + LWIP_AUTOIP + LWIP_IGMP + LWIP_DNS + PPP_SUPPORT)
++
++/*****************************************************************************
++**                           IP Options
++*****************************************************************************/
++#define IP_REASSEMBLY                   0
++#define IP_FRAG                         0
++
++/*****************************************************************************
++**                           DHCP Options
++*****************************************************************************/
++#define LWIP_DHCP                       1
++#define DHCP_DOES_ARP_CHECK             0
++
++/*****************************************************************************
++**                           Auto IP  Options
++*****************************************************************************/
++#define LWIP_AUTOIP                     1
++#define LWIP_DHCP_AUTOIP_COOP           ((LWIP_DHCP) && (LWIP_AUTOIP))
++
++/*****************************************************************************
++**                           TCP  Options
++*****************************************************************************/
++#define TCP_MSS                         1500
++#define TCP_WND                         (8 * TCP_MSS)
++#define TCP_SND_BUF                     (8 * TCP_MSS)
++#define TCP_OVERSIZE                    TCP_MSS
++
++/*****************************************************************************
++**                           PBUF  Options
++*****************************************************************************/
++#define PBUF_LINK_HLEN                  14
++#define PBUF_POOL_BUFSIZE               1520         /* + size of struct pbuf
++                                                        shall be cache line
++                                                        aligned be enabled */
++#define ETH_PAD_SIZE                    0
++#define LWIP_NETCONN                    1
++
++/*****************************************************************************
++**                           Socket  Options
++*****************************************************************************/
++#define LWIP_SOCKET                     1
++
++/*****************************************************************************
++**                          Debugging options
++*****************************************************************************/
++#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_OFF
++#define LWIP_DBG_TYPES_ON               (LWIP_DBG_ON | LWIP_DBG_TRACE \
++                                         |LWIP_DBG_STATE | LWIP_DBG_FRESH)
++#define DHCP_DEBUG                      LWIP_DBG_OFF
++#define NETIF_DEBUG                     LWIP_DBG_OFF
++#define IP_DEBUG			LWIP_DBG_OFF
++#define UDP_DEBUG			LWIP_DBG_OFF
++#define ETHARP_DEBUG                    LWIP_DBG_OFF
++#define SYS_DEBUG                       LWIP_DBG_OFF
++#define RAW_DEBUG                       LWIP_DBG_OFF
++#define MEM_DEBUG                       LWIP_DBG_OFF
++#define MEMP_DEBUG                      LWIP_DBG_OFF
++#define PBUF_DEBUG			LWIP_DBG_OFF
++#define TCPIP_DEBUG			LWIP_DBG_OFF
++#define APP_DEBUG			LWIP_DBG_OFF
++#define SOCKETS_DEBUG		        LWIP_DBG_OFF
++#define LWIP_STATS                      0
++#define LWIP_STATS_DISPLAY              0
++#define LWIP_STATS_POSIX                0
++
++
++
++/**
++ * LWIP_COMPAT_SOCKETS==1: Enable BSD-style sockets functions names.
++ * (only used if you use sockets.c)
++ */
++#define LWIP_COMPAT_SOCKETS             0
++
++#define LWIP_TIMEVAL_PRIVATE            0
++
++ #define LWIP_RAW                       0
++
++#endif /* __LWIPOPTS_H__ */
+diff --git a/ports/sys_arch.c b/ports/sys_arch.c
+new file mode 100644
+index 0000000..360a4e2
+--- /dev/null
++++ b/ports/sys_arch.c
+@@ -0,0 +1,663 @@
++/*
++ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
++ * All rights reserved.
++ *
++ * Redistribution and use in source and binary forms, with or without modification,
++ * are permitted provided that the following conditions are met:
++ *
++ * 1. Redistributions of source code must retain the above copyright notice,
++ *    this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright notice,
++ *    this list of conditions and the following disclaimer in the documentation
++ *    and/or other materials provided with the distribution.
++ * 3. The name of the author may not be used to endorse or promote products
++ *    derived from this software without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
++ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
++ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
++ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
++ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
++ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
++ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
++ * OF SUCH DAMAGE.
++ *
++ * This file is part of the lwIP TCP/IP stack.
++ *
++ * Author: Adam Dunkels <adam@sics.se>
++ *
++ */
++
++/*
++ * Wed Apr 17 16:05:29 EDT 2002 (James Roth)
++ *
++ *  - Fixed an unlikely sys_thread_new() race condition.
++ *
++ *  - Made current_thread() work with threads which where
++ *    not created with sys_thread_new().  This includes
++ *    the main thread and threads made with pthread_create().
++ *
++ *  - Catch overflows where more than SYS_MBOX_SIZE messages
++ *    are waiting to be read.  The sys_mbox_post() routine
++ *    will block until there is more room instead of just
++ *    leaking messages.
++ */
++
++#include <string.h>
++#include <sys/time.h>
++#include <sys/types.h>
++#include <stdlib.h>
++#include <unistd.h>
++#include <pthread.h>
++
++#include "lwip/opt.h"
++#include "lwip/sys.h"
++#include "lwip/stats.h"
++#include "lwip/debug.h"
++
++#define UMAX(a, b)      ((a) > (b) ? (a) : (b))
++
++static struct timeval starttime;
++
++#if !NO_SYS
++
++static struct sys_thread *threads = NULL;
++static pthread_mutex_t threads_mutex = PTHREAD_MUTEX_INITIALIZER;
++
++struct sys_mbox_msg {
++  struct sys_mbox_msg *next;
++  void *msg;
++};
++
++#define SYS_MBOX_SIZE 128
++
++struct sys_mbox {
++  int first, last;
++  void *msgs[SYS_MBOX_SIZE];
++  struct sys_sem *not_empty;
++  struct sys_sem *not_full;
++  struct sys_sem *mutex;
++  int wait_send;
++};
++
++struct sys_sem {
++  unsigned int c;
++  pthread_cond_t cond;
++  pthread_mutex_t mutex;
++};
++
++struct sys_thread {
++  struct sys_thread *next;
++  pthread_t pthread;
++};
++
++#if SYS_LIGHTWEIGHT_PROT
++static pthread_mutex_t lwprot_mutex = PTHREAD_MUTEX_INITIALIZER;
++static pthread_t lwprot_thread = (pthread_t)0xDEAD;
++static int lwprot_count = 0;
++#endif /* SYS_LIGHTWEIGHT_PROT */
++
++static struct sys_sem *sys_sem_new_internal(u8_t count);
++static void sys_sem_free_internal(struct sys_sem *sem);
++
++static u32_t cond_wait(pthread_cond_t * cond, pthread_mutex_t * mutex,
++                       u32_t timeout);
++
++/*-----------------------------------------------------------------------------------*/
++static struct sys_thread *
++introduce_thread(pthread_t id)
++{
++  struct sys_thread *thread = NULL;
++
++  thread = (struct sys_thread *)malloc(sizeof(struct sys_thread));
++
++  if (thread != NULL) {
++    pthread_mutex_lock(&threads_mutex);
++    thread->next = threads;
++    thread->pthread = id;
++    threads = thread;
++    pthread_mutex_unlock(&threads_mutex);
++  }
++
++  return thread;
++}
++/*-----------------------------------------------------------------------------------*/
++sys_thread_t
++sys_thread_new(const char *name, lwip_thread_fn function, void *arg, int stacksize, int prio)
++{
++  int code;
++  int rc;
++  pthread_t tmp;
++  pthread_attr_t attr;
++  struct sys_thread *st = NULL;
++  LWIP_UNUSED_ARG(name);
++  LWIP_UNUSED_ARG(stacksize);
++  LWIP_UNUSED_ARG(prio);
++
++  /* Alloc a new pthread with the specified stack size. */
++  if(stacksize > 0) {
++    rc = pthread_attr_init(&attr);
++    if (rc != 0) {
++      LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: pthread_attr_init error = %d\n", rc));
++      return NULL;
++    }
++    rc = pthread_attr_setstacksize(&attr, stacksize);
++    if (rc != 0) {
++      LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: pthread_attr_setstacksize error = %d\n", rc));
++      pthread_attr_destroy(&attr);
++      return NULL;
++    }
++    pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);
++    pthread_attr_setschedpolicy(&attr, SCHED_RR);
++    code = pthread_create(&tmp, &attr, (void *(*)(void *)) function, arg);
++    pthread_attr_destroy(&attr);
++  } else {
++    code = pthread_create(&tmp, NULL, (void *(*)(void *)) function, arg);
++  }
++  LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: thread created [name:%s|stacksize:%d|prio:%d|addr:0x%x]\n",
++                          name, stacksize, prio, (uint)tmp));
++
++  if (0 == code) {
++    st = introduce_thread(tmp);
++  }
++
++  if (NULL == st) {
++    LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: failed to introduce %d, st = %p\n",
++                            code, (void*)st));
++    abort();
++  } else {
++    LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: introduced %d, st = %p\n",
++                            code, (void*)st));
++  }
++
++  return st;
++}
++/*-----------------------------------------------------------------------------------*/
++void sys_thread_signal(sys_thread_t thread, int signal)
++{
++    /* Check received parameters. */
++    if(thread == NULL) {
++        LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_signal: could not send signal to thread. thread = NULL\n"));
++        return;
++    }
++
++    /* Send signal. */
++    pthread_kill(thread->pthread, signal);
++}
++/*-----------------------------------------------------------------------------------*/
++err_t
++sys_mbox_new(struct sys_mbox **mb, int size)
++{
++  struct sys_mbox *mbox = NULL;
++  LWIP_UNUSED_ARG(size);
++
++  mbox = (struct sys_mbox *)malloc(sizeof(struct sys_mbox));
++  if (mbox == NULL) {
++    SYS_STATS_INC(mbox.err);
++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_new: could not create mbox\n"));
++    return ERR_MEM;
++  }
++  mbox->first = mbox->last = 0;
++  mbox->not_empty = sys_sem_new_internal(0);
++  mbox->not_full = sys_sem_new_internal(0);
++  mbox->mutex = sys_sem_new_internal(1);
++  mbox->wait_send = 0;
++
++  SYS_STATS_INC_USED(mbox);
++
++  if((mbox->not_empty == NULL) || (mbox->not_full == NULL) || (mbox->mutex == NULL)) {
++    SYS_STATS_INC(mbox.err);
++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_new: could not create mbox internals\n"));
++    sys_mbox_free(&mbox);
++    return ERR_MEM;
++  }
++  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_new: mbox created [not_empty:%X|not_full:%X|mutex:%X] \n",
++                          mbox->not_empty, mbox->not_full, mbox->mutex));
++
++  *mb = mbox;
++  return ERR_OK;
++}
++/*-----------------------------------------------------------------------------------*/
++void
++sys_mbox_free(struct sys_mbox **mb)
++{
++  if ((mb != NULL) && (*mb != SYS_MBOX_NULL)) {
++    struct sys_mbox *mbox = *mb;
++    sys_arch_sem_wait(&mbox->mutex, 0);
++
++    sys_sem_free_internal(mbox->not_empty);
++    sys_sem_free_internal(mbox->not_full);
++    sys_sem_free_internal(mbox->mutex);
++    mbox->not_empty = mbox->not_full = mbox->mutex = NULL;
++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_free: mbox 0x%lx\n", mbox));
++    free(mbox);
++    SYS_STATS_DEC(mbox.used);
++  }
++}
++/*-----------------------------------------------------------------------------------*/
++err_t
++sys_mbox_trypost(struct sys_mbox **mb, void *msg)
++{
++  u8_t first;
++  struct sys_mbox *mbox;
++  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
++  mbox = *mb;
++  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_trypost: start"));
++  sys_arch_sem_wait(&mbox->mutex, 0);
++
++  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_trypost: mbox %p msg %p\n",
++                          (void *)mbox, (void *)msg));
++
++  if ((mbox->last + 1) >= (mbox->first + SYS_MBOX_SIZE)) {
++    sys_sem_signal(&mbox->mutex);
++    return ERR_MEM;
++  }
++
++  mbox->msgs[mbox->last % SYS_MBOX_SIZE] = msg;
++
++  if (mbox->last == mbox->first) {
++    first = 1;
++  } else {
++    first = 0;
++  }
++
++  mbox->last++;
++
++  if (first) {
++    sys_sem_signal(&mbox->not_empty);
++  }
++
++  sys_sem_signal(&mbox->mutex);
++
++  return ERR_OK;
++}
++/*-----------------------------------------------------------------------------------*/
++void
++sys_mbox_post(struct sys_mbox **mb, void *msg)
++{
++  u8_t first;
++  struct sys_mbox *mbox;
++  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
++  mbox = *mb;
++
++  sys_arch_sem_wait(&mbox->mutex, 0);
++
++  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_post: mbox %p msg %p\n", (void *)mbox, (void *)msg));
++
++  while ((mbox->last + 1) >= (mbox->first + SYS_MBOX_SIZE)) {
++    mbox->wait_send++;
++    sys_sem_signal(&mbox->mutex);
++    sys_arch_sem_wait(&mbox->not_full, 0);
++    sys_arch_sem_wait(&mbox->mutex, 0);
++    mbox->wait_send--;
++  }
++
++  mbox->msgs[mbox->last % SYS_MBOX_SIZE] = msg;
++
++  if (mbox->last == mbox->first) {
++    first = 1;
++  } else {
++    first = 0;
++  }
++
++  mbox->last++;
++
++  if (first) {
++    sys_sem_signal(&mbox->not_empty);
++  }
++
++  sys_sem_signal(&mbox->mutex);
++}
++/*-----------------------------------------------------------------------------------*/
++u32_t
++sys_arch_mbox_tryfetch(struct sys_mbox **mb, void **msg)
++{
++  struct sys_mbox *mbox;
++  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
++  mbox = *mb;
++
++  sys_arch_sem_wait(&mbox->mutex, 0);
++
++  if (mbox->first == mbox->last) {
++    sys_sem_signal(&mbox->mutex);
++    return SYS_MBOX_EMPTY;
++  }
++
++  if (msg != NULL) {
++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_tryfetch: mbox %p msg %p\n", (void *)mbox, *msg));
++    *msg = mbox->msgs[mbox->first % SYS_MBOX_SIZE];
++  }
++  else{
++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_tryfetch: mbox %p, null msg\n", (void *)mbox));
++  }
++
++  mbox->first++;
++
++  if (mbox->wait_send) {
++    sys_sem_signal(&mbox->not_full);
++  }
++
++  sys_sem_signal(&mbox->mutex);
++
++  return 0;
++}
++/*-----------------------------------------------------------------------------------*/
++u32_t
++sys_arch_mbox_fetch(struct sys_mbox **mb, void **msg, u32_t timeout)
++{
++  u32_t time_needed = 0;
++  struct sys_mbox *mbox;
++  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
++  mbox = *mb;
++
++  /* The mutex lock is quick so we don't bother with the timeout
++     stuff here. */
++  sys_arch_sem_wait(&mbox->mutex, 0);
++
++  while (mbox->first == mbox->last) {
++    sys_sem_signal(&mbox->mutex);
++
++    /* We block while waiting for a mail to arrive in the mailbox. We
++       must be prepared to timeout. */
++    if (timeout != 0) {
++      time_needed = sys_arch_sem_wait(&mbox->not_empty, timeout);
++
++      if (time_needed == SYS_ARCH_TIMEOUT) {
++        return SYS_ARCH_TIMEOUT;
++      }
++    } else {
++      sys_arch_sem_wait(&mbox->not_empty, 0);
++    }
++
++    sys_arch_sem_wait(&mbox->mutex, 0);
++  }
++
++  if (msg != NULL) {
++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_fetch: mbox %p msg %p\n", (void *)mbox, *msg));
++    *msg = mbox->msgs[mbox->first % SYS_MBOX_SIZE];
++  }
++  else{
++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_fetch: mbox %p, null msg\n", (void *)mbox));
++  }
++
++  mbox->first++;
++
++  if (mbox->wait_send) {
++    sys_sem_signal(&mbox->not_full);
++  }
++
++  sys_sem_signal(&mbox->mutex);
++
++  return time_needed;
++}
++/*-----------------------------------------------------------------------------------*/
++static struct sys_sem *
++sys_sem_new_internal(u8_t count)
++{
++  struct sys_sem *sem = NULL;
++  int rc;
++
++  sem = (struct sys_sem *)malloc(sizeof(struct sys_sem));
++  if (sem != NULL) {
++    sem->c = count;
++    rc = pthread_cond_init(&(sem->cond), NULL);
++    if(rc != 0) {
++      LWIP_DEBUGF(SYS_DEBUG, ("sys_sem_new_internal: pthread_cond_init error = %d\n", rc));
++      return NULL;
++    }
++    rc = pthread_mutex_init(&(sem->mutex), NULL);
++    if(rc != 0) {
++      LWIP_DEBUGF(SYS_DEBUG, ("sys_sem_new_internal: pthread_mutex_init error = %d\n", rc));
++      SYS_STATS_INC(mutex.err);
++      pthread_cond_destroy(&(sem->cond));
++      return NULL;
++    }
++    SYS_STATS_INC_USED(mutex);
++    SYS_STATS_INC_USED(sem);
++  } else {
++    LWIP_DEBUGF(SYS_DEBUG, ("sys_sem_new_internal: could not create semaphore\n"));
++    SYS_STATS_INC(sem.err);
++  }
++  return sem;
++}
++/*-----------------------------------------------------------------------------------*/
++err_t
++sys_sem_new(struct sys_sem **sem, u8_t count)
++{
++  *sem = sys_sem_new_internal(count);
++  if (*sem == NULL) {
++    return ERR_MEM;
++  }
++  return ERR_OK;
++}
++/*-----------------------------------------------------------------------------------*/
++static u32_t
++cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex, u32_t timeout)
++{
++  time_t tdiff;
++  time_t sec, usec;
++  struct timeval rtime1, rtime2;
++  struct timespec ts;
++  int retval;
++
++  if (timeout > 0) {
++    /* Get a timestamp and add the timeout value. */
++    gettimeofday(&rtime1, NULL);
++    sec = rtime1.tv_sec;
++    usec = rtime1.tv_usec;
++    usec += timeout % 1000 * 1000;
++    sec += (int)(timeout / 1000) + (int)(usec / 1000000);
++    usec = usec % 1000000;
++    ts.tv_nsec = usec * 1000;
++    ts.tv_sec = sec;
++
++    retval = pthread_cond_timedwait(cond, mutex, &ts);
++
++    if (retval == ETIMEDOUT) {
++      return SYS_ARCH_TIMEOUT;
++    } else {
++      /* Calculate for how long we waited for the cond. */
++      gettimeofday(&rtime2, NULL);
++      tdiff = (rtime2.tv_sec - rtime1.tv_sec) * 1000 +
++        (rtime2.tv_usec - rtime1.tv_usec) / 1000;
++
++      if (tdiff <= 0) {
++        return 0;
++      }
++      return (u32_t)tdiff;
++    }
++  } else {
++    pthread_cond_wait(cond, mutex);
++    return 0;
++  }
++}
++/*-----------------------------------------------------------------------------------*/
++u32_t
++sys_arch_sem_wait(struct sys_sem **s, u32_t timeout)
++{
++  u32_t time_needed = 0;
++  struct sys_sem *sem;
++  LWIP_ASSERT("invalid sem", (s != NULL) && (*s != NULL));
++  sem = *s;
++
++  pthread_mutex_lock(&(sem->mutex));
++  while (sem->c <= 0) {
++    if (timeout > 0) {
++      time_needed = cond_wait(&(sem->cond), &(sem->mutex), timeout);
++
++      if (time_needed == SYS_ARCH_TIMEOUT) {
++        pthread_mutex_unlock(&(sem->mutex));
++        return SYS_ARCH_TIMEOUT;
++      }
++    } else {
++      cond_wait(&(sem->cond), &(sem->mutex), 0);
++    }
++  }
++  sem->c--;
++  pthread_mutex_unlock(&(sem->mutex));
++  return (u32_t)time_needed;
++}
++/*-----------------------------------------------------------------------------------*/
++void
++sys_sem_signal(struct sys_sem **s)
++{
++  struct sys_sem *sem;
++  LWIP_ASSERT("invalid sem", (s != NULL) && (*s != NULL));
++  sem = *s;
++
++  pthread_mutex_lock(&(sem->mutex));
++  sem->c++;
++
++  if (sem->c > 1) {
++    sem->c = 1;
++  }
++
++  pthread_cond_broadcast(&(sem->cond));
++  pthread_mutex_unlock(&(sem->mutex));
++}
++/*-----------------------------------------------------------------------------------*/
++static void
++sys_sem_free_internal(struct sys_sem *sem)
++{
++  if(sem != NULL) {
++    pthread_cond_destroy(&(sem->cond));
++    pthread_mutex_destroy(&(sem->mutex));
++    SYS_STATS_DEC(mutex.used);
++    SYS_STATS_DEC(sem.used);
++    free(sem);
++  }
++}
++/*-----------------------------------------------------------------------------------*/
++void
++sys_sem_free(struct sys_sem **sem)
++{
++  if ((sem != NULL) && (*sem != SYS_SEM_NULL)) {
++    sys_sem_free_internal(*sem);
++  }
++}
++#endif /* !NO_SYS */
++/*-----------------------------------------------------------------------------------*/
++u32_t
++sys_now(void)
++{
++  struct timeval tv;
++  u32_t sec, usec, msec;
++  gettimeofday(&tv, NULL);
++
++  sec = (u32_t)(tv.tv_sec - starttime.tv_sec);
++  usec = (u32_t)(tv.tv_usec - starttime.tv_usec);
++  msec = sec * 1000 + usec / 1000;
++
++  return msec;
++}
++/*-----------------------------------------------------------------------------------*/
++void
++sys_init(void)
++{
++  SYS_STATS_INC_USED(mutex);
++  gettimeofday(&starttime, NULL);
++}
++/*-----------------------------------------------------------------------------------*/
++#if SYS_LIGHTWEIGHT_PROT
++/** sys_prot_t sys_arch_protect(void)
++
++This optional function does a "fast" critical region protection and returns
++the previous protection level. This function is only called during very short
++critical regions. An embedded system which supports ISR-based drivers might
++want to implement this function by disabling interrupts. Task-based systems
++might want to implement this by using a mutex or disabling tasking. This
++function should support recursive calls from the same task or interrupt. In
++other words, sys_arch_protect() could be called while already protected. In
++that case the return value indicates that it is already protected.
++
++sys_arch_protect() is only required if your port is supporting an operating
++system.
++*/
++sys_prot_t
++sys_arch_protect(void)
++{
++    /* Note that for the UNIX port, we are using a lightweight mutex, and our
++     * own counter (which is locked by the mutex). The return code is not actually
++     * used. */
++    if (lwprot_thread != pthread_self())
++    {
++        /* We are locking the mutex where it has not been locked before *
++        * or is being locked by another thread */
++        pthread_mutex_lock(&lwprot_mutex);
++        lwprot_thread = pthread_self();
++        lwprot_count = 1;
++    }
++    else
++    {
++        /* It is already locked by THIS thread */
++        lwprot_count++;
++    }
++    return 0;
++}
++/*-----------------------------------------------------------------------------------*/
++/** void sys_arch_unprotect(sys_prot_t pval)
++
++This optional function does a "fast" set of critical region protection to the
++value specified by pval. See the documentation for sys_arch_protect() for
++more information. This function is only required if your port is supporting
++an operating system.
++*/
++void
++sys_arch_unprotect(sys_prot_t pval)
++{
++    LWIP_UNUSED_ARG(pval);
++    if (lwprot_thread == pthread_self())
++    {
++        if (--lwprot_count == 0)
++        {
++            lwprot_thread = (pthread_t) 0xDEAD;
++            pthread_mutex_unlock(&lwprot_mutex);
++        }
++    }
++}
++#endif /* SYS_LIGHTWEIGHT_PROT */
++
++/*-----------------------------------------------------------------------------------*/
++
++#ifndef MAX_JIFFY_OFFSET
++#define MAX_JIFFY_OFFSET ((~0U >> 1)-1)
++#endif
++
++#ifndef HZ
++#define HZ 100
++#endif
++
++u32_t
++sys_jiffies(void)
++{
++    struct timeval tv;
++    unsigned long sec;
++    long usec;
++
++    gettimeofday(&tv,NULL);
++    sec = tv.tv_sec - starttime.tv_sec;
++    usec = tv.tv_usec;
++
++    if (sec >= (MAX_JIFFY_OFFSET / HZ))
++      return MAX_JIFFY_OFFSET;
++    usec += 1000000L / HZ - 1;
++    usec /= 1000000L / HZ;
++    return HZ * sec + usec;
++}
++
++#if PPP_DEBUG
++
++#include <stdarg.h>
++
++void ppp_trace(int level, const char *format, ...)
++{
++    va_list args;
++
++    (void)level;
++    va_start(args, format);
++    vprintf(format, args);
++    va_end(args);
++}
++#endif
+-- 
+1.9.1
+
+
+From d053fa836b445b6736bf82d33a33a59055150aa7 Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Fri, 4 Sep 2015 17:30:37 -0400
+Subject: [PATCH 02/13] changed the compiler options
+
+---
+ Makefile | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/Makefile b/Makefile
+index 0cbae64..94fcafc 100644
+--- a/Makefile
++++ b/Makefile
+@@ -5,7 +5,7 @@ include $(PROJECT_ROOT)/make/leaf.cfg
+ #### CONFIG ####################################################################
+ #For debugging symbols add -DLWIP_DEBUG
+ # COMPILER/LINKER
+-CFLAGS+=-g -O2   \
++CFLAGS+=-g -O0   \
+  -Wall
+ 
+ # OUTPUT
+-- 
+1.9.1
+
+
+From 841adb17430bdb9298dcb6d44ac5dad72e82af80 Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Mon, 7 Sep 2015 08:56:58 -0400
+Subject: [PATCH 03/13] disabled any mention of ipv6
+
+---
+ Makefile | 6 +++---
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+diff --git a/Makefile b/Makefile
+index 94fcafc..6efa141 100644
+--- a/Makefile
++++ b/Makefile
+@@ -40,7 +40,7 @@ CORE_SRC=$(wildcard $(LWIP_CORE_PATH)/*.c)
+ IPV4_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv4/*.c)
+ 
+ ## IPv6
+-IPV6_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv6/*.c)
++#IPV6_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv6/*.c)
+ 
+ ## SNMP
+ SNMP_SRC=$(wildcard $(LWIP_CORE_PATH)/snmp/*.c)
+@@ -71,7 +71,7 @@ SOURCES =  $(DRIVER_SRC) $(SNMP_SRC)\
+ CORE_H=$(LWIP_INCL_PATH)
+ 
+ ## IPv4
+-#IPV4_H=$(LWIP_INCL_PATH)/ipv4
++IPV4_H=$(LWIP_INCL_PATH)/ipv4
+ 
+ ## IPv6
+ #IPV6_H=$(LWIP_INCL_PATH)/ipv6
+@@ -97,7 +97,7 @@ DRIVER_H=$(LWIPDRIVER_INCL_PATH)
+ # HEADERS
+ HEADERS=-I$(CORE_H) -I$(POSIX_H) -I$(POSIX_SYS_H) -I$(NETIF_H) \
+         -I$(NETIF_H_PPP) -I$(NETIF_H_PPP_POLARSSL) -I$(ARCH_H) \
+-        -I$(DRIVER_H)
++        -I$(DRIVER_H) -I$(IPV4_H)
+ 
+ 
+ ################################################################################
+-- 
+1.9.1
+
+
+From a653d818348fef0130e6e497eecb0c3a35822df4 Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Mon, 7 Sep 2015 09:27:48 -0400
+Subject: [PATCH 04/13] added in stm32f low-level driver
+
+---
+ src/netif/ethernetif.c | 709 ++++++++++++++++++++++++++++++-------------------
+ 1 file changed, 435 insertions(+), 274 deletions(-)
+
+diff --git a/src/netif/ethernetif.c b/src/netif/ethernetif.c
+index 7982d11..82c85ae 100644
+--- a/src/netif/ethernetif.c
++++ b/src/netif/ethernetif.c
+@@ -1,335 +1,496 @@
+ /**
+- * @file
+- * Ethernet Interface Skeleton
+- *
+- */
+-
+-/*
+- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+- * All rights reserved. 
+- * 
+- * Redistribution and use in source and binary forms, with or without modification, 
+- * are permitted provided that the following conditions are met:
+- *
+- * 1. Redistributions of source code must retain the above copyright notice,
+- *    this list of conditions and the following disclaimer.
+- * 2. Redistributions in binary form must reproduce the above copyright notice,
+- *    this list of conditions and the following disclaimer in the documentation
+- *    and/or other materials provided with the distribution.
+- * 3. The name of the author may not be used to endorse or promote products
+- *    derived from this software without specific prior written permission. 
+- *
+- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+- * OF SUCH DAMAGE.
+- *
+- * This file is part of the lwIP TCP/IP stack.
+- * 
+- * Author: Adam Dunkels <adam@sics.se>
+- *
+- */
+-
+-/*
+- * This file is a skeleton for developing Ethernet network interface
+- * drivers for lwIP. Add code to the low_level functions and do a
+- * search-and-replace for the word "ethernetif" to replace it with
+- * something that better describes your network interface.
+- */
+-
++  ******************************************************************************
++  * @file    LwIP/LwIP_HTTP_Server_Netconn_RTOS/Src/ethernetif.c
++  * @author  MCD Application Team
++  * @version V1.0.0
++  * @date    25-June-2015
++  * @brief   This file implements Ethernet network interface drivers for lwIP
++  ******************************************************************************
++  * @attention
++  *
++  * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
++  *
++  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
++  * You may not use this file except in compliance with the License.
++  * You may obtain a copy of the License at:
++  *
++  *        http://www.st.com/software_license_agreement_liberty_v2
++  *
++  * Unless required by applicable law or agreed to in writing, software 
++  * distributed under the License is distributed on an "AS IS" BASIS, 
++  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++  * See the License for the specific language governing permissions and
++  * limitations under the License.
++  *
++  ******************************************************************************
++  */
++
++/* Includes ------------------------------------------------------------------*/
++#include "stm32f7xx_hal.h"
+ #include "lwip/opt.h"
+-
+-#if 0 /* don't build, this is only a skeleton, see previous comment */
+-
+-#include "lwip/def.h"
+-#include "lwip/mem.h"
+-#include "lwip/pbuf.h"
+-#include "lwip/stats.h"
+-#include "lwip/snmp.h"
+-#include "lwip/ethip6.h"
++#include "lwip/lwip_timers.h"
+ #include "netif/etharp.h"
+-#include "netif/ppp/pppoe.h"
++#include "hal-ethernetif.h"
++#include <string.h>
++
++/* Private typedef -----------------------------------------------------------*/
++/* Private define ------------------------------------------------------------*/
++/* The time to block waiting for input. */
++#define TIME_WAITING_FOR_INPUT                 ( 100 )
++/* Stack size of the interface thread */
++#define INTERFACE_THREAD_STACK_SIZE            ( 350 )
+ 
+ /* Define those to better describe your network interface. */
+ #define IFNAME0 'e'
+ #define IFNAME1 'n'
+ 
+-/**
+- * Helper struct to hold private data used to operate your ethernet interface.
+- * Keeping the ethernet address of the MAC in this struct is not necessary
+- * as it is already kept in the struct netif.
+- * But this is only an example, anyway...
+- */
+-struct ethernetif {
+-  struct eth_addr *ethaddr;
+-  /* Add whatever per-interface state that is needed here. */
+-};
+-
+-/* Forward declarations. */
+-static void  ethernetif_input(struct netif *netif);
++#define LAN8742A_PHY_ADDRESS            0x00
+ 
+-/**
+- * In this function, the hardware should be initialized.
+- * Called from ethernetif_init().
+- *
+- * @param netif the already initialized lwip network interface structure
+- *        for this ethernetif
+- */
+-static void
+-low_level_init(struct netif *netif)
+-{
+-  struct ethernetif *ethernetif = netif->state;
+-  
+-  /* set MAC hardware address length */
+-  netif->hwaddr_len = ETHARP_HWADDR_LEN;
++/* Private macro -------------------------------------------------------------*/
++/* Private variables ---------------------------------------------------------*/
+ 
+-  /* set MAC hardware address */
+-  netif->hwaddr[0] = ;
+-  ...
+-  netif->hwaddr[5] = ;
++#if defined ( __ICCARM__ ) /*!< IAR Compiler */
+ 
+-  /* maximum transfer unit */
+-  netif->mtu = 1500;
+-  
+-  /* device capabilities */
+-  /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
+-  netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
+- 
+-#if LWIP_IPV6 && LWIP_IPV6_MLD
+-  /*
+-   * For hardware/netifs that implement MAC filtering.
+-   * All-nodes link-local is handled by default, so we must let the hardware know
+-   * to allow multicast packets in.
+-   * Should set mld_mac_filter previously. */
+-  if (netif->mld_mac_filter != NULL) {
+-    ip6_addr_t ip6_allnodes_ll;
+-    ip6_addr_set_allnodes_linklocal(&ip6_allnodes_ll);
+-    netif->mld_mac_filter(netif, &ip6_allnodes_ll, MLD6_ADD_MAC_FILTER);
+-  }
+-#endif /* LWIP_IPV6 && LWIP_IPV6_MLD */
++#pragma location=0x2000E000
++__no_init ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
++#pragma location=0x2000E100
++__no_init ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
++#elif defined ( __CC_ARM   )
++ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((at(0x2000E000)));/* Ethernet Rx MA Descriptor */
++ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((at(0x2000E100)));/* Ethernet Tx DMA Descriptor */
++#elif defined ( __GNUC__   )
++//ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".RxDescripSection")));/* Ethernet Rx MA Descriptor */
++//ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".TxDescripSection")));/* Ethernet Tx DMA Descriptor */
++ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Rx MA Descriptor */
++ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Tx DMA Descriptor */
++
++
++#endif
++#if defined ( __ICCARM__ ) /*!< IAR Compiler */
++#pragma location=0x2000E200
++__no_init uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
++#pragma location=0x2000FFC4
++__no_init uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
++#elif defined ( __CC_ARM   )
++uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((at(0x2000E200)));  /* Ethernet Receive Buffer */
++uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]  __attribute__((at(0x2000FFC4))); /* Ethernet Transmit Buffer */
++#elif defined ( __GNUC__   )
++//uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".RxBUF")));/* Ethernet Receive Buffer */
++//uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".TxBUF")));/* Ethernet Transmit Buffer */
++uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Receive Buffer */
++uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Transmit Buffer */
++
++#endif
++/* Semaphore to signal incoming packets */
++osSemaphoreId s_xSemaphore = NULL;
+ 
+-  /* Do whatever else is needed to initialize interface. */  
++/* Global Ethernet handle*/
++ETH_HandleTypeDef EthHandle;
++
++/* Private function prototypes -----------------------------------------------*/
++static void ethernetif_input( void const * argument );
++
++static void stm32f_ethernet_isr(
++  void* argData
++)
++{
++  ETH_HandleTypeDef* pEth =
++    (ETH_HandleTypeDef*) argData;
++
++  HAL_ETH_IRQHandler(pEth);
+ }
+ 
++/* Private functions ---------------------------------------------------------*/
++/*******************************************************************************
++                       Ethernet MSP Routines
++*******************************************************************************/
+ /**
+- * This function should do the actual transmission of the packet. The packet is
+- * contained in the pbuf that is passed to the function. This pbuf
+- * might be chained.
+- *
+- * @param netif the lwip network interface structure for this ethernetif
+- * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
+- * @return ERR_OK if the packet could be sent
+- *         an err_t value if the packet couldn't be sent
+- *
+- * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
+- *       strange results. You might consider waiting for space in the DMA queue
+- *       to become available since the stack doesn't retry to send a packet
+- *       dropped because of memory failure (except for the TCP timers).
+- */
+-
+-static err_t
+-low_level_output(struct netif *netif, struct pbuf *p)
++  * @brief  Initializes the ETH MSP.
++  * @param  heth: ETH handle
++  * @retval None
++  */
++void HAL_ETH_MspInit(ETH_HandleTypeDef *heth)
+ {
+-  struct ethernetif *ethernetif = netif->state;
+-  struct pbuf *q;
+-
+-  initiate transfer();
++  GPIO_InitTypeDef GPIO_InitStructure;
+   
+-#if ETH_PAD_SIZE
+-  pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
+-#endif
+-
+-  for(q = p; q != NULL; q = q->next) {
+-    /* Send the data from the pbuf to the interface, one pbuf at a
+-       time. The size of the data in each pbuf is kept in the ->len
+-       variable. */
+-    send data from(q->payload, q->len);
+-  }
++  /* Enable GPIOs clocks */
++  __HAL_RCC_GPIOA_CLK_ENABLE();
++  __HAL_RCC_GPIOC_CLK_ENABLE();
++  __HAL_RCC_GPIOG_CLK_ENABLE();
+ 
+-  signal that packet should be sent();
++/* Ethernet pins configuration ************************************************/
++  /*
++        RMII_REF_CLK ----------------------> PA1
++        RMII_MDIO -------------------------> PA2
++        RMII_MDC --------------------------> PC1
++        RMII_MII_CRS_DV -------------------> PA7
++        RMII_MII_RXD0 ---------------------> PC4
++        RMII_MII_RXD1 ---------------------> PC5
++        RMII_MII_RXER ---------------------> PG2
++        RMII_MII_TX_EN --------------------> PG11
++        RMII_MII_TXD0 ---------------------> PG13
++        RMII_MII_TXD1 ---------------------> PG14
++  */
++
++  /* Configure PA1, PA2 and PA7 */
++  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
++  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
++  GPIO_InitStructure.Pull = GPIO_NOPULL; 
++  GPIO_InitStructure.Alternate = GPIO_AF11_ETH;
++  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
++  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
++  
++  /* Configure PC1, PC4 and PC5 */
++  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;
++  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
+ 
+-#if ETH_PAD_SIZE
+-  pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
+-#endif
++  /* Configure PG2, PG11, PG13 and PG14 */
++  GPIO_InitStructure.Pin =  GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14;
++  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
+   
+-  LINK_STATS_INC(link.xmit);
++  // Install HAL Ethernet ISR
++  rtems_interrupt_handler_install(
++    ETH_IRQn,
++    NULL,
++    0,
++    stm32f_ethernet_isr,
++    heth);
++  
++  /* Enable ETHERNET clock  */
++  __HAL_RCC_ETH_CLK_ENABLE();
++}
+ 
+-  return ERR_OK;
++/**
++  * @brief  Ethernet Rx Transfer completed callback
++  * @param  heth: ETH handle
++  * @retval None
++  */
++void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
++{
++  osSemaphoreRelease(s_xSemaphore);
+ }
+ 
+ /**
+- * Should allocate a pbuf and transfer the bytes of the incoming
+- * packet from the interface into the pbuf.
+- *
+- * @param netif the lwip network interface structure for this ethernetif
+- * @return a pbuf filled with the received packet (including MAC header)
+- *         NULL on memory error
+- */
+-static struct pbuf *
+-low_level_input(struct netif *netif)
++  * @brief  Ethernet IRQ Handler
++  * @param  None
++  * @retval None
++  */
++void ETHERNET_IRQHandler(void)
+ {
+-  struct ethernetif *ethernetif = netif->state;
+-  struct pbuf *p, *q;
+-  u16_t len;
++  HAL_ETH_IRQHandler(&EthHandle);
++}
+ 
+-  /* Obtain the size of the packet and put it into the "len"
+-     variable. */
+-  len = ;
++/*******************************************************************************
++                       LL Driver Interface ( LwIP stack --> ETH) 
++*******************************************************************************/
++/**
++  * @brief In this function, the hardware should be initialized.
++  * Called from ethernetif_init().
++  *
++  * @param netif the already initialized lwip network interface structure
++  *        for this ethernetif
++  */
++static void low_level_init(struct netif *netif)
++{
++  uint8_t macaddress[6]= { MAC_ADDR0, MAC_ADDR1, MAC_ADDR2, MAC_ADDR3, MAC_ADDR4, MAC_ADDR5 };
++  
++  EthHandle.Instance = ETH;  
++  EthHandle.Init.MACAddr = macaddress;
++  EthHandle.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
++  EthHandle.Init.Speed = ETH_SPEED_100M;
++  EthHandle.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
++  EthHandle.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
++  EthHandle.Init.RxMode = ETH_RXINTERRUPT_MODE;
++  EthHandle.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
++  EthHandle.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
++  
++  /* configure ethernet peripheral (GPIOs, clocks, MAC, DMA) */
++  if (HAL_ETH_Init(&EthHandle) == HAL_OK)
++  {
++    /* Set netif link flag */
++    netif->flags |= NETIF_FLAG_LINK_UP;
++  }
++  
++  /* Initialize Tx Descriptors list: Chain Mode */
++  HAL_ETH_DMATxDescListInit(&EthHandle, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
++     
++  /* Initialize Rx Descriptors list: Chain Mode  */
++  HAL_ETH_DMARxDescListInit(&EthHandle, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
++  
++  /* set netif MAC hardware address length */
++  netif->hwaddr_len = ETHARP_HWADDR_LEN;
+ 
+-#if ETH_PAD_SIZE
+-  len += ETH_PAD_SIZE; /* allow room for Ethernet padding */
+-#endif
++  /* set netif MAC hardware address */
++  netif->hwaddr[0] =  MAC_ADDR0;
++  netif->hwaddr[1] =  MAC_ADDR1;
++  netif->hwaddr[2] =  MAC_ADDR2;
++  netif->hwaddr[3] =  MAC_ADDR3;
++  netif->hwaddr[4] =  MAC_ADDR4;
++  netif->hwaddr[5] =  MAC_ADDR5;
+ 
+-  /* We allocate a pbuf chain of pbufs from the pool. */
+-  p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
+-  
+-  if (p != NULL) {
++  /* set netif maximum transfer unit */
++  netif->mtu = 1500;
+ 
+-#if ETH_PAD_SIZE
+-    pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
+-#endif
++  /* Accept broadcast address and ARP traffic */
++  netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
+ 
+-    /* We iterate over the pbuf chain until we have read the entire
+-     * packet into the pbuf. */
+-    for(q = p; q != NULL; q = q->next) {
+-      /* Read enough bytes to fill this pbuf in the chain. The
+-       * available data in the pbuf is given by the q->len
+-       * variable.
+-       * This does not necessarily have to be a memcpy, you can also preallocate
+-       * pbufs for a DMA-enabled MAC and after receiving truncate it to the
+-       * actually received size. In this case, ensure the tot_len member of the
+-       * pbuf is the sum of the chained pbuf len members.
+-       */
+-      read data into(q->payload, q->len);
+-    }
+-    acknowledge that packet has been read();
++  /* create a binary semaphore used for informing ethernetif of frame reception */
++  osSemaphoreDef(SEM);
++  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1 );
++
++  /* create the task that handles the ETH_MAC */
++  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
++  osThreadCreate (osThread(EthIf), netif);
++
++  /* Enable MAC and DMA transmission and reception */
++  HAL_ETH_Start(&EthHandle);
++}
+ 
+-#if ETH_PAD_SIZE
+-    pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
+-#endif
+ 
+-    LINK_STATS_INC(link.recv);
+-  } else {
+-    drop packet();
+-    LINK_STATS_INC(link.memerr);
+-    LINK_STATS_INC(link.drop);
++/**
++  * @brief This function should do the actual transmission of the packet. The packet is
++  * contained in the pbuf that is passed to the function. This pbuf
++  * might be chained.
++  *
++  * @param netif the lwip network interface structure for this ethernetif
++  * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
++  * @return ERR_OK if the packet could be sent
++  *         an err_t value if the packet couldn't be sent
++  *
++  * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
++  *       strange results. You might consider waiting for space in the DMA queue
++  *       to become available since the stack doesn't retry to send a packet
++  *       dropped because of memory failure (except for the TCP timers).
++  */
++static err_t low_level_output(struct netif *netif, struct pbuf *p)
++{
++  err_t errval;
++  struct pbuf *q;
++  uint8_t *buffer = (uint8_t *)(EthHandle.TxDesc->Buffer1Addr);
++  __IO ETH_DMADescTypeDef *DmaTxDesc;
++  uint32_t framelength = 0;
++  uint32_t bufferoffset = 0;
++  uint32_t byteslefttocopy = 0;
++  uint32_t payloadoffset = 0;
++
++  DmaTxDesc = EthHandle.TxDesc;
++  bufferoffset = 0;
++  
++  /* copy frame from pbufs to driver buffers */
++  for(q = p; q != NULL; q = q->next)
++  {
++    /* Is this buffer available? If not, goto error */
++    if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
++    {
++      errval = ERR_USE;
++      goto error;
++    }
++    
++    /* Get bytes in current lwIP buffer */
++    byteslefttocopy = q->len;
++    payloadoffset = 0;
++    
++    /* Check if the length of data to copy is bigger than Tx buffer size*/
++    while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
++    {
++      /* Copy data to Tx buffer*/
++      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
++      
++      /* Point to next descriptor */
++      DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
++      
++      /* Check if the buffer is available */
++      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
++      {
++        errval = ERR_USE;
++        goto error;
++      }
++      
++      buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
++      
++      byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
++      payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
++      framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
++      bufferoffset = 0;
++    }
++    
++    /* Copy the remaining bytes */
++    memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
++    bufferoffset = bufferoffset + byteslefttocopy;
++    framelength = framelength + byteslefttocopy;
++  }
++  
++  /* Prepare transmit descriptors to give to DMA */ 
++  HAL_ETH_TransmitFrame(&EthHandle, framelength);
++  
++  errval = ERR_OK;
++  
++error:
++  
++  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
++  if ((EthHandle.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
++  {
++    /* Clear TUS ETHERNET DMA flag */
++    EthHandle.Instance->DMASR = ETH_DMASR_TUS;
++    
++    /* Resume DMA transmission*/
++    EthHandle.Instance->DMATPDR = 0;
+   }
++  return errval;
++}
+ 
+-  return p;  
++/**
++  * @brief Should allocate a pbuf and transfer the bytes of the incoming
++  * packet from the interface into the pbuf.
++  *
++  * @param netif the lwip network interface structure for this ethernetif
++  * @return a pbuf filled with the received packet (including MAC header)
++  *         NULL on memory error
++  */
++static struct pbuf * low_level_input(struct netif *netif)
++{
++  struct pbuf *p = NULL, *q = NULL;
++  uint16_t len = 0;
++  uint8_t *buffer;
++  __IO ETH_DMADescTypeDef *dmarxdesc;
++  uint32_t bufferoffset = 0;
++  uint32_t payloadoffset = 0;
++  uint32_t byteslefttocopy = 0;
++  uint32_t i=0;
++  
++  /* get received frame */
++  if(HAL_ETH_GetReceivedFrame_IT(&EthHandle) != HAL_OK)
++    return NULL;
++  
++  /* Obtain the size of the packet and put it into the "len" variable. */
++  len = EthHandle.RxFrameInfos.length;
++  buffer = (uint8_t *)EthHandle.RxFrameInfos.buffer;
++  
++  if (len > 0)
++  {
++    /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
++    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
++  }
++  
++  if (p != NULL)
++  {
++    dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
++    bufferoffset = 0;
++    
++    for(q = p; q != NULL; q = q->next)
++    {
++      byteslefttocopy = q->len;
++      payloadoffset = 0;
++      
++      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size */
++      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
++      {
++        /* Copy data to pbuf */
++        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
++        
++        /* Point to next descriptor */
++        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
++        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
++        
++        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
++        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
++        bufferoffset = 0;
++      }
++      
++      /* Copy remaining data in pbuf */
++      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
++      bufferoffset = bufferoffset + byteslefttocopy;
++    }
++  }
++    
++  /* Release descriptors to DMA */
++  /* Point to first descriptor */
++  dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
++  /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
++  for (i=0; i< EthHandle.RxFrameInfos.SegCount; i++)
++  {  
++    dmarxdesc->Status |= ETH_DMARXDESC_OWN;
++    dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
++  }
++    
++  /* Clear Segment_Count */
++  EthHandle.RxFrameInfos.SegCount =0;
++  
++  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
++  if ((EthHandle.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
++  {
++    /* Clear RBUS ETHERNET DMA flag */
++    EthHandle.Instance->DMASR = ETH_DMASR_RBUS;
++    /* Resume DMA reception */
++    EthHandle.Instance->DMARPDR = 0;
++  }
++  return p;
+ }
+ 
+ /**
+- * This function should be called when a packet is ready to be read
+- * from the interface. It uses the function low_level_input() that
+- * should handle the actual reception of bytes from the network
+- * interface. Then the type of the received packet is determined and
+- * the appropriate input function is called.
+- *
+- * @param netif the lwip network interface structure for this ethernetif
+- */
+-static void
+-ethernetif_input(struct netif *netif)
++  * @brief This function is the ethernetif_input task, it is processed when a packet 
++  * is ready to be read from the interface. It uses the function low_level_input() 
++  * that should handle the actual reception of bytes from the network
++  * interface. Then the type of the received packet is determined and
++  * the appropriate input function is called.
++  *
++  * @param netif the lwip network interface structure for this ethernetif
++  */
++void ethernetif_input( void const * argument )
+ {
+-  struct ethernetif *ethernetif;
+-  struct eth_hdr *ethhdr;
+   struct pbuf *p;
+-
+-  ethernetif = netif->state;
+-
+-  /* move received packet into a new pbuf */
+-  p = low_level_input(netif);
+-  /* no packet could be read, silently ignore this */
+-  if (p == NULL) return;
+-  /* points to packet payload, which starts with an Ethernet header */
+-  ethhdr = p->payload;
+-
+-  switch (htons(ethhdr->type)) {
+-  /* IP or ARP packet? */
+-  case ETHTYPE_IP:
+-  case ETHTYPE_IPV6:
+-  case ETHTYPE_ARP:
+-#if PPPOE_SUPPORT
+-  /* PPPoE packet? */
+-  case ETHTYPE_PPPOEDISC:
+-  case ETHTYPE_PPPOE:
+-#endif /* PPPOE_SUPPORT */
+-    /* full packet send to tcpip_thread to process */
+-    if (netif->input(p, netif)!=ERR_OK)
+-     { LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
+-       pbuf_free(p);
+-       p = NULL;
+-     }
+-    break;
+-
+-  default:
+-    pbuf_free(p);
+-    p = NULL;
+-    break;
++  struct netif *netif = (struct netif *) argument;
++  
++  for( ;; )
++  {
++    if (osSemaphoreWait( s_xSemaphore, TIME_WAITING_FOR_INPUT)==osOK)
++    {
++      do
++      {
++        p = low_level_input( netif );
++        if (p != NULL)
++        {
++          if (netif->input( p, netif) != ERR_OK )
++          {
++            pbuf_free(p);
++          }
++        }
++      }while(p!=NULL);
++    }
+   }
+ }
+ 
+ /**
+- * Should be called at the beginning of the program to set up the
+- * network interface. It calls the function low_level_init() to do the
+- * actual setup of the hardware.
+- *
+- * This function should be passed as a parameter to netif_add().
+- *
+- * @param netif the lwip network interface structure for this ethernetif
+- * @return ERR_OK if the loopif is initialized
+- *         ERR_MEM if private data couldn't be allocated
+- *         any other err_t on error
+- */
+-err_t
+-ethernetif_init(struct netif *netif)
++  * @brief Should be called at the beginning of the program to set up the
++  * network interface. It calls the function low_level_init() to do the
++  * actual setup of the hardware.
++  *
++  * This function should be passed as a parameter to netif_add().
++  *
++  * @param netif the lwip network interface structure for this ethernetif
++  * @return ERR_OK if the loopif is initialized
++  *         ERR_MEM if private data couldn't be allocated
++  *         any other err_t on error
++  */
++err_t ethernetif_init(struct netif *netif)
+ {
+-  struct ethernetif *ethernetif;
+-
+   LWIP_ASSERT("netif != NULL", (netif != NULL));
+-    
+-  ethernetif = mem_malloc(sizeof(struct ethernetif));
+-  if (ethernetif == NULL) {
+-    LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_init: out of memory\n"));
+-    return ERR_MEM;
+-  }
+ 
+ #if LWIP_NETIF_HOSTNAME
+   /* Initialize interface hostname */
+   netif->hostname = "lwip";
+ #endif /* LWIP_NETIF_HOSTNAME */
+ 
+-  /*
+-   * Initialize the snmp variables and counters inside the struct netif.
+-   * The last argument should be replaced with your link speed, in units
+-   * of bits per second.
+-   */
+-  NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, LINK_SPEED_OF_YOUR_NETIF_IN_BPS);
+-
+-  netif->state = ethernetif;
+   netif->name[0] = IFNAME0;
+   netif->name[1] = IFNAME1;
+-  /* We directly use etharp_output() here to save a function call.
+-   * You can instead declare your own function an call etharp_output()
+-   * from it if you have to do some checks before sending (e.g. if link
+-   * is available...) */
++
+   netif->output = etharp_output;
+-#if LWIP_IPV6
+-  netif->output_ip6 = ethip6_output;
+-#endif /* LWIP_IPV6 */
+   netif->linkoutput = low_level_output;
+-  
+-  ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
+-  
++
+   /* initialize the hardware */
+   low_level_init(netif);
+ 
+   return ERR_OK;
+ }
+ 
+-#endif /* 0 */
++/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+-- 
+1.9.1
+
+
+From ab97b49d1d41e34fdfdfb457b397c768ee228c9f Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Mon, 7 Sep 2015 09:39:20 -0400
+Subject: [PATCH 05/13] removed ethernetif (it should be in BSP
+
+---
+ src/netif/ethernetif.c | 496 -------------------------------------------------
+ 1 file changed, 496 deletions(-)
+ delete mode 100644 src/netif/ethernetif.c
+
+diff --git a/src/netif/ethernetif.c b/src/netif/ethernetif.c
+deleted file mode 100644
+index 82c85ae..0000000
+--- a/src/netif/ethernetif.c
++++ /dev/null
+@@ -1,496 +0,0 @@
+-/**
+-  ******************************************************************************
+-  * @file    LwIP/LwIP_HTTP_Server_Netconn_RTOS/Src/ethernetif.c
+-  * @author  MCD Application Team
+-  * @version V1.0.0
+-  * @date    25-June-2015
+-  * @brief   This file implements Ethernet network interface drivers for lwIP
+-  ******************************************************************************
+-  * @attention
+-  *
+-  * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
+-  *
+-  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+-  * You may not use this file except in compliance with the License.
+-  * You may obtain a copy of the License at:
+-  *
+-  *        http://www.st.com/software_license_agreement_liberty_v2
+-  *
+-  * Unless required by applicable law or agreed to in writing, software 
+-  * distributed under the License is distributed on an "AS IS" BASIS, 
+-  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+-  * See the License for the specific language governing permissions and
+-  * limitations under the License.
+-  *
+-  ******************************************************************************
+-  */
+-
+-/* Includes ------------------------------------------------------------------*/
+-#include "stm32f7xx_hal.h"
+-#include "lwip/opt.h"
+-#include "lwip/lwip_timers.h"
+-#include "netif/etharp.h"
+-#include "hal-ethernetif.h"
+-#include <string.h>
+-
+-/* Private typedef -----------------------------------------------------------*/
+-/* Private define ------------------------------------------------------------*/
+-/* The time to block waiting for input. */
+-#define TIME_WAITING_FOR_INPUT                 ( 100 )
+-/* Stack size of the interface thread */
+-#define INTERFACE_THREAD_STACK_SIZE            ( 350 )
+-
+-/* Define those to better describe your network interface. */
+-#define IFNAME0 'e'
+-#define IFNAME1 'n'
+-
+-#define LAN8742A_PHY_ADDRESS            0x00
+-
+-/* Private macro -------------------------------------------------------------*/
+-/* Private variables ---------------------------------------------------------*/
+-
+-#if defined ( __ICCARM__ ) /*!< IAR Compiler */
+-
+-#pragma location=0x2000E000
+-__no_init ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
+-#pragma location=0x2000E100
+-__no_init ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
+-#elif defined ( __CC_ARM   )
+-ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((at(0x2000E000)));/* Ethernet Rx MA Descriptor */
+-ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((at(0x2000E100)));/* Ethernet Tx DMA Descriptor */
+-#elif defined ( __GNUC__   )
+-//ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".RxDescripSection")));/* Ethernet Rx MA Descriptor */
+-//ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".TxDescripSection")));/* Ethernet Tx DMA Descriptor */
+-ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Rx MA Descriptor */
+-ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Tx DMA Descriptor */
+-
+-
+-#endif
+-#if defined ( __ICCARM__ ) /*!< IAR Compiler */
+-#pragma location=0x2000E200
+-__no_init uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
+-#pragma location=0x2000FFC4
+-__no_init uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
+-#elif defined ( __CC_ARM   )
+-uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((at(0x2000E200)));  /* Ethernet Receive Buffer */
+-uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]  __attribute__((at(0x2000FFC4))); /* Ethernet Transmit Buffer */
+-#elif defined ( __GNUC__   )
+-//uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".RxBUF")));/* Ethernet Receive Buffer */
+-//uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".TxBUF")));/* Ethernet Transmit Buffer */
+-uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Receive Buffer */
+-uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Transmit Buffer */
+-
+-#endif
+-/* Semaphore to signal incoming packets */
+-osSemaphoreId s_xSemaphore = NULL;
+-
+-/* Global Ethernet handle*/
+-ETH_HandleTypeDef EthHandle;
+-
+-/* Private function prototypes -----------------------------------------------*/
+-static void ethernetif_input( void const * argument );
+-
+-static void stm32f_ethernet_isr(
+-  void* argData
+-)
+-{
+-  ETH_HandleTypeDef* pEth =
+-    (ETH_HandleTypeDef*) argData;
+-
+-  HAL_ETH_IRQHandler(pEth);
+-}
+-
+-/* Private functions ---------------------------------------------------------*/
+-/*******************************************************************************
+-                       Ethernet MSP Routines
+-*******************************************************************************/
+-/**
+-  * @brief  Initializes the ETH MSP.
+-  * @param  heth: ETH handle
+-  * @retval None
+-  */
+-void HAL_ETH_MspInit(ETH_HandleTypeDef *heth)
+-{
+-  GPIO_InitTypeDef GPIO_InitStructure;
+-  
+-  /* Enable GPIOs clocks */
+-  __HAL_RCC_GPIOA_CLK_ENABLE();
+-  __HAL_RCC_GPIOC_CLK_ENABLE();
+-  __HAL_RCC_GPIOG_CLK_ENABLE();
+-
+-/* Ethernet pins configuration ************************************************/
+-  /*
+-        RMII_REF_CLK ----------------------> PA1
+-        RMII_MDIO -------------------------> PA2
+-        RMII_MDC --------------------------> PC1
+-        RMII_MII_CRS_DV -------------------> PA7
+-        RMII_MII_RXD0 ---------------------> PC4
+-        RMII_MII_RXD1 ---------------------> PC5
+-        RMII_MII_RXER ---------------------> PG2
+-        RMII_MII_TX_EN --------------------> PG11
+-        RMII_MII_TXD0 ---------------------> PG13
+-        RMII_MII_TXD1 ---------------------> PG14
+-  */
+-
+-  /* Configure PA1, PA2 and PA7 */
+-  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
+-  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
+-  GPIO_InitStructure.Pull = GPIO_NOPULL; 
+-  GPIO_InitStructure.Alternate = GPIO_AF11_ETH;
+-  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
+-  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
+-  
+-  /* Configure PC1, PC4 and PC5 */
+-  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;
+-  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
+-
+-  /* Configure PG2, PG11, PG13 and PG14 */
+-  GPIO_InitStructure.Pin =  GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14;
+-  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
+-  
+-  // Install HAL Ethernet ISR
+-  rtems_interrupt_handler_install(
+-    ETH_IRQn,
+-    NULL,
+-    0,
+-    stm32f_ethernet_isr,
+-    heth);
+-  
+-  /* Enable ETHERNET clock  */
+-  __HAL_RCC_ETH_CLK_ENABLE();
+-}
+-
+-/**
+-  * @brief  Ethernet Rx Transfer completed callback
+-  * @param  heth: ETH handle
+-  * @retval None
+-  */
+-void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
+-{
+-  osSemaphoreRelease(s_xSemaphore);
+-}
+-
+-/**
+-  * @brief  Ethernet IRQ Handler
+-  * @param  None
+-  * @retval None
+-  */
+-void ETHERNET_IRQHandler(void)
+-{
+-  HAL_ETH_IRQHandler(&EthHandle);
+-}
+-
+-/*******************************************************************************
+-                       LL Driver Interface ( LwIP stack --> ETH) 
+-*******************************************************************************/
+-/**
+-  * @brief In this function, the hardware should be initialized.
+-  * Called from ethernetif_init().
+-  *
+-  * @param netif the already initialized lwip network interface structure
+-  *        for this ethernetif
+-  */
+-static void low_level_init(struct netif *netif)
+-{
+-  uint8_t macaddress[6]= { MAC_ADDR0, MAC_ADDR1, MAC_ADDR2, MAC_ADDR3, MAC_ADDR4, MAC_ADDR5 };
+-  
+-  EthHandle.Instance = ETH;  
+-  EthHandle.Init.MACAddr = macaddress;
+-  EthHandle.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
+-  EthHandle.Init.Speed = ETH_SPEED_100M;
+-  EthHandle.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
+-  EthHandle.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
+-  EthHandle.Init.RxMode = ETH_RXINTERRUPT_MODE;
+-  EthHandle.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
+-  EthHandle.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
+-  
+-  /* configure ethernet peripheral (GPIOs, clocks, MAC, DMA) */
+-  if (HAL_ETH_Init(&EthHandle) == HAL_OK)
+-  {
+-    /* Set netif link flag */
+-    netif->flags |= NETIF_FLAG_LINK_UP;
+-  }
+-  
+-  /* Initialize Tx Descriptors list: Chain Mode */
+-  HAL_ETH_DMATxDescListInit(&EthHandle, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
+-     
+-  /* Initialize Rx Descriptors list: Chain Mode  */
+-  HAL_ETH_DMARxDescListInit(&EthHandle, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
+-  
+-  /* set netif MAC hardware address length */
+-  netif->hwaddr_len = ETHARP_HWADDR_LEN;
+-
+-  /* set netif MAC hardware address */
+-  netif->hwaddr[0] =  MAC_ADDR0;
+-  netif->hwaddr[1] =  MAC_ADDR1;
+-  netif->hwaddr[2] =  MAC_ADDR2;
+-  netif->hwaddr[3] =  MAC_ADDR3;
+-  netif->hwaddr[4] =  MAC_ADDR4;
+-  netif->hwaddr[5] =  MAC_ADDR5;
+-
+-  /* set netif maximum transfer unit */
+-  netif->mtu = 1500;
+-
+-  /* Accept broadcast address and ARP traffic */
+-  netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
+-
+-  /* create a binary semaphore used for informing ethernetif of frame reception */
+-  osSemaphoreDef(SEM);
+-  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1 );
+-
+-  /* create the task that handles the ETH_MAC */
+-  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
+-  osThreadCreate (osThread(EthIf), netif);
+-
+-  /* Enable MAC and DMA transmission and reception */
+-  HAL_ETH_Start(&EthHandle);
+-}
+-
+-
+-/**
+-  * @brief This function should do the actual transmission of the packet. The packet is
+-  * contained in the pbuf that is passed to the function. This pbuf
+-  * might be chained.
+-  *
+-  * @param netif the lwip network interface structure for this ethernetif
+-  * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
+-  * @return ERR_OK if the packet could be sent
+-  *         an err_t value if the packet couldn't be sent
+-  *
+-  * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
+-  *       strange results. You might consider waiting for space in the DMA queue
+-  *       to become available since the stack doesn't retry to send a packet
+-  *       dropped because of memory failure (except for the TCP timers).
+-  */
+-static err_t low_level_output(struct netif *netif, struct pbuf *p)
+-{
+-  err_t errval;
+-  struct pbuf *q;
+-  uint8_t *buffer = (uint8_t *)(EthHandle.TxDesc->Buffer1Addr);
+-  __IO ETH_DMADescTypeDef *DmaTxDesc;
+-  uint32_t framelength = 0;
+-  uint32_t bufferoffset = 0;
+-  uint32_t byteslefttocopy = 0;
+-  uint32_t payloadoffset = 0;
+-
+-  DmaTxDesc = EthHandle.TxDesc;
+-  bufferoffset = 0;
+-  
+-  /* copy frame from pbufs to driver buffers */
+-  for(q = p; q != NULL; q = q->next)
+-  {
+-    /* Is this buffer available? If not, goto error */
+-    if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
+-    {
+-      errval = ERR_USE;
+-      goto error;
+-    }
+-    
+-    /* Get bytes in current lwIP buffer */
+-    byteslefttocopy = q->len;
+-    payloadoffset = 0;
+-    
+-    /* Check if the length of data to copy is bigger than Tx buffer size*/
+-    while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
+-    {
+-      /* Copy data to Tx buffer*/
+-      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
+-      
+-      /* Point to next descriptor */
+-      DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
+-      
+-      /* Check if the buffer is available */
+-      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
+-      {
+-        errval = ERR_USE;
+-        goto error;
+-      }
+-      
+-      buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
+-      
+-      byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
+-      payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
+-      framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
+-      bufferoffset = 0;
+-    }
+-    
+-    /* Copy the remaining bytes */
+-    memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
+-    bufferoffset = bufferoffset + byteslefttocopy;
+-    framelength = framelength + byteslefttocopy;
+-  }
+-  
+-  /* Prepare transmit descriptors to give to DMA */ 
+-  HAL_ETH_TransmitFrame(&EthHandle, framelength);
+-  
+-  errval = ERR_OK;
+-  
+-error:
+-  
+-  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
+-  if ((EthHandle.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
+-  {
+-    /* Clear TUS ETHERNET DMA flag */
+-    EthHandle.Instance->DMASR = ETH_DMASR_TUS;
+-    
+-    /* Resume DMA transmission*/
+-    EthHandle.Instance->DMATPDR = 0;
+-  }
+-  return errval;
+-}
+-
+-/**
+-  * @brief Should allocate a pbuf and transfer the bytes of the incoming
+-  * packet from the interface into the pbuf.
+-  *
+-  * @param netif the lwip network interface structure for this ethernetif
+-  * @return a pbuf filled with the received packet (including MAC header)
+-  *         NULL on memory error
+-  */
+-static struct pbuf * low_level_input(struct netif *netif)
+-{
+-  struct pbuf *p = NULL, *q = NULL;
+-  uint16_t len = 0;
+-  uint8_t *buffer;
+-  __IO ETH_DMADescTypeDef *dmarxdesc;
+-  uint32_t bufferoffset = 0;
+-  uint32_t payloadoffset = 0;
+-  uint32_t byteslefttocopy = 0;
+-  uint32_t i=0;
+-  
+-  /* get received frame */
+-  if(HAL_ETH_GetReceivedFrame_IT(&EthHandle) != HAL_OK)
+-    return NULL;
+-  
+-  /* Obtain the size of the packet and put it into the "len" variable. */
+-  len = EthHandle.RxFrameInfos.length;
+-  buffer = (uint8_t *)EthHandle.RxFrameInfos.buffer;
+-  
+-  if (len > 0)
+-  {
+-    /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
+-    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
+-  }
+-  
+-  if (p != NULL)
+-  {
+-    dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
+-    bufferoffset = 0;
+-    
+-    for(q = p; q != NULL; q = q->next)
+-    {
+-      byteslefttocopy = q->len;
+-      payloadoffset = 0;
+-      
+-      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size */
+-      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
+-      {
+-        /* Copy data to pbuf */
+-        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
+-        
+-        /* Point to next descriptor */
+-        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
+-        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
+-        
+-        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
+-        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
+-        bufferoffset = 0;
+-      }
+-      
+-      /* Copy remaining data in pbuf */
+-      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
+-      bufferoffset = bufferoffset + byteslefttocopy;
+-    }
+-  }
+-    
+-  /* Release descriptors to DMA */
+-  /* Point to first descriptor */
+-  dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
+-  /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
+-  for (i=0; i< EthHandle.RxFrameInfos.SegCount; i++)
+-  {  
+-    dmarxdesc->Status |= ETH_DMARXDESC_OWN;
+-    dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
+-  }
+-    
+-  /* Clear Segment_Count */
+-  EthHandle.RxFrameInfos.SegCount =0;
+-  
+-  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
+-  if ((EthHandle.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
+-  {
+-    /* Clear RBUS ETHERNET DMA flag */
+-    EthHandle.Instance->DMASR = ETH_DMASR_RBUS;
+-    /* Resume DMA reception */
+-    EthHandle.Instance->DMARPDR = 0;
+-  }
+-  return p;
+-}
+-
+-/**
+-  * @brief This function is the ethernetif_input task, it is processed when a packet 
+-  * is ready to be read from the interface. It uses the function low_level_input() 
+-  * that should handle the actual reception of bytes from the network
+-  * interface. Then the type of the received packet is determined and
+-  * the appropriate input function is called.
+-  *
+-  * @param netif the lwip network interface structure for this ethernetif
+-  */
+-void ethernetif_input( void const * argument )
+-{
+-  struct pbuf *p;
+-  struct netif *netif = (struct netif *) argument;
+-  
+-  for( ;; )
+-  {
+-    if (osSemaphoreWait( s_xSemaphore, TIME_WAITING_FOR_INPUT)==osOK)
+-    {
+-      do
+-      {
+-        p = low_level_input( netif );
+-        if (p != NULL)
+-        {
+-          if (netif->input( p, netif) != ERR_OK )
+-          {
+-            pbuf_free(p);
+-          }
+-        }
+-      }while(p!=NULL);
+-    }
+-  }
+-}
+-
+-/**
+-  * @brief Should be called at the beginning of the program to set up the
+-  * network interface. It calls the function low_level_init() to do the
+-  * actual setup of the hardware.
+-  *
+-  * This function should be passed as a parameter to netif_add().
+-  *
+-  * @param netif the lwip network interface structure for this ethernetif
+-  * @return ERR_OK if the loopif is initialized
+-  *         ERR_MEM if private data couldn't be allocated
+-  *         any other err_t on error
+-  */
+-err_t ethernetif_init(struct netif *netif)
+-{
+-  LWIP_ASSERT("netif != NULL", (netif != NULL));
+-
+-#if LWIP_NETIF_HOSTNAME
+-  /* Initialize interface hostname */
+-  netif->hostname = "lwip";
+-#endif /* LWIP_NETIF_HOSTNAME */
+-
+-  netif->name[0] = IFNAME0;
+-  netif->name[1] = IFNAME1;
+-
+-  netif->output = etharp_output;
+-  netif->linkoutput = low_level_output;
+-
+-  /* initialize the hardware */
+-  low_level_init(netif);
+-
+-  return ERR_OK;
+-}
+-
+-/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+-- 
+1.9.1
+
+
+From 31d34fab26b1e3fde99fe7288786725fe5e51b95 Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Mon, 7 Sep 2015 10:17:32 -0400
+Subject: [PATCH 06/13] add low level driver back
+
+---
+ src/netif/ethernetif.c | 496 +++++++++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 496 insertions(+)
+ create mode 100644 src/netif/ethernetif.c
+
+diff --git a/src/netif/ethernetif.c b/src/netif/ethernetif.c
+new file mode 100644
+index 0000000..bc429e9
+--- /dev/null
++++ b/src/netif/ethernetif.c
+@@ -0,0 +1,496 @@
++/**
++  ******************************************************************************
++  * @file    LwIP/LwIP_HTTP_Server_Netconn_RTOS/Src/ethernetif.c
++  * @author  MCD Application Team
++  * @version V1.0.0
++  * @date    25-June-2015
++  * @brief   This file implements Ethernet network interface drivers for lwIP
++  ******************************************************************************
++  * @attention
++  *
++  * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
++  *
++  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
++  * You may not use this file except in compliance with the License.
++  * You may obtain a copy of the License at:
++  *
++  *        http://www.st.com/software_license_agreement_liberty_v2
++  *
++  * Unless required by applicable law or agreed to in writing, software 
++  * distributed under the License is distributed on an "AS IS" BASIS, 
++  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++  * See the License for the specific language governing permissions and
++  * limitations under the License.
++  *
++  ******************************************************************************
++  */
++
++/* Includes ------------------------------------------------------------------*/
++#include <stm32f7xx_hal.h>
++#include <lwip/opt.h>
++#include <lwip/lwip_timers.h>
++#include <netif/etharp.h>
++#include <hal-ethernetif.h>
++#include <string.h>
++
++/* Private typedef -----------------------------------------------------------*/
++/* Private define ------------------------------------------------------------*/
++/* The time to block waiting for input. */
++#define TIME_WAITING_FOR_INPUT                 ( 100 )
++/* Stack size of the interface thread */
++#define INTERFACE_THREAD_STACK_SIZE            ( 350 )
++
++/* Define those to better describe your network interface. */
++#define IFNAME0 'e'
++#define IFNAME1 'n'
++
++#define LAN8742A_PHY_ADDRESS            0x00
++
++/* Private macro -------------------------------------------------------------*/
++/* Private variables ---------------------------------------------------------*/
++
++#if defined ( __ICCARM__ ) /*!< IAR Compiler */
++
++#pragma location=0x2000E000
++__no_init ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
++#pragma location=0x2000E100
++__no_init ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
++#elif defined ( __CC_ARM   )
++ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((at(0x2000E000)));/* Ethernet Rx MA Descriptor */
++ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((at(0x2000E100)));/* Ethernet Tx DMA Descriptor */
++#elif defined ( __GNUC__   )
++//ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".RxDescripSection")));/* Ethernet Rx MA Descriptor */
++//ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".TxDescripSection")));/* Ethernet Tx DMA Descriptor */
++ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Rx MA Descriptor */
++ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Tx DMA Descriptor */
++
++
++#endif
++#if defined ( __ICCARM__ ) /*!< IAR Compiler */
++#pragma location=0x2000E200
++__no_init uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
++#pragma location=0x2000FFC4
++__no_init uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
++#elif defined ( __CC_ARM   )
++uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((at(0x2000E200)));  /* Ethernet Receive Buffer */
++uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]  __attribute__((at(0x2000FFC4))); /* Ethernet Transmit Buffer */
++#elif defined ( __GNUC__   )
++//uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".RxBUF")));/* Ethernet Receive Buffer */
++//uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".TxBUF")));/* Ethernet Transmit Buffer */
++uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Receive Buffer */
++uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Transmit Buffer */
++
++#endif
++/* Semaphore to signal incoming packets */
++osSemaphoreId s_xSemaphore = NULL;
++
++/* Global Ethernet handle*/
++ETH_HandleTypeDef EthHandle;
++
++/* Private function prototypes -----------------------------------------------*/
++static void ethernetif_input( void const * argument );
++
++static void stm32f_ethernet_isr(
++  void* argData
++)
++{
++  ETH_HandleTypeDef* pEth =
++    (ETH_HandleTypeDef*) argData;
++
++  HAL_ETH_IRQHandler(pEth);
++}
++
++/* Private functions ---------------------------------------------------------*/
++/*******************************************************************************
++                       Ethernet MSP Routines
++*******************************************************************************/
++/**
++  * @brief  Initializes the ETH MSP.
++  * @param  heth: ETH handle
++  * @retval None
++  */
++void HAL_ETH_MspInit(ETH_HandleTypeDef *heth)
++{
++  GPIO_InitTypeDef GPIO_InitStructure;
++  
++  /* Enable GPIOs clocks */
++  __HAL_RCC_GPIOA_CLK_ENABLE();
++  __HAL_RCC_GPIOC_CLK_ENABLE();
++  __HAL_RCC_GPIOG_CLK_ENABLE();
++
++/* Ethernet pins configuration ************************************************/
++  /*
++        RMII_REF_CLK ----------------------> PA1
++        RMII_MDIO -------------------------> PA2
++        RMII_MDC --------------------------> PC1
++        RMII_MII_CRS_DV -------------------> PA7
++        RMII_MII_RXD0 ---------------------> PC4
++        RMII_MII_RXD1 ---------------------> PC5
++        RMII_MII_RXER ---------------------> PG2
++        RMII_MII_TX_EN --------------------> PG11
++        RMII_MII_TXD0 ---------------------> PG13
++        RMII_MII_TXD1 ---------------------> PG14
++  */
++
++  /* Configure PA1, PA2 and PA7 */
++  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
++  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
++  GPIO_InitStructure.Pull = GPIO_NOPULL; 
++  GPIO_InitStructure.Alternate = GPIO_AF11_ETH;
++  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
++  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
++  
++  /* Configure PC1, PC4 and PC5 */
++  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;
++  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
++
++  /* Configure PG2, PG11, PG13 and PG14 */
++  GPIO_InitStructure.Pin =  GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14;
++  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
++  
++  // Install HAL Ethernet ISR
++  rtems_interrupt_handler_install(
++    ETH_IRQn,
++    NULL,
++    0,
++    stm32f_ethernet_isr,
++    heth);
++  
++  /* Enable ETHERNET clock  */
++  __HAL_RCC_ETH_CLK_ENABLE();
++}
++
++/**
++  * @brief  Ethernet Rx Transfer completed callback
++  * @param  heth: ETH handle
++  * @retval None
++  */
++void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
++{
++  osSemaphoreRelease(s_xSemaphore);
++}
++
++/**
++  * @brief  Ethernet IRQ Handler
++  * @param  None
++  * @retval None
++  */
++void ETHERNET_IRQHandler(void)
++{
++  HAL_ETH_IRQHandler(&EthHandle);
++}
++
++/*******************************************************************************
++                       LL Driver Interface ( LwIP stack --> ETH) 
++*******************************************************************************/
++/**
++  * @brief In this function, the hardware should be initialized.
++  * Called from ethernetif_init().
++  *
++  * @param netif the already initialized lwip network interface structure
++  *        for this ethernetif
++  */
++static void low_level_init(struct netif *netif)
++{
++  uint8_t macaddress[6]= { MAC_ADDR0, MAC_ADDR1, MAC_ADDR2, MAC_ADDR3, MAC_ADDR4, MAC_ADDR5 };
++  
++  EthHandle.Instance = ETH;  
++  EthHandle.Init.MACAddr = macaddress;
++  EthHandle.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
++  EthHandle.Init.Speed = ETH_SPEED_100M;
++  EthHandle.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
++  EthHandle.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
++  EthHandle.Init.RxMode = ETH_RXINTERRUPT_MODE;
++  EthHandle.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
++  EthHandle.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
++  
++  /* configure ethernet peripheral (GPIOs, clocks, MAC, DMA) */
++  if (HAL_ETH_Init(&EthHandle) == HAL_OK)
++  {
++    /* Set netif link flag */
++    netif->flags |= NETIF_FLAG_LINK_UP;
++  }
++  
++  /* Initialize Tx Descriptors list: Chain Mode */
++  HAL_ETH_DMATxDescListInit(&EthHandle, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
++     
++  /* Initialize Rx Descriptors list: Chain Mode  */
++  HAL_ETH_DMARxDescListInit(&EthHandle, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
++  
++  /* set netif MAC hardware address length */
++  netif->hwaddr_len = ETHARP_HWADDR_LEN;
++
++  /* set netif MAC hardware address */
++  netif->hwaddr[0] =  MAC_ADDR0;
++  netif->hwaddr[1] =  MAC_ADDR1;
++  netif->hwaddr[2] =  MAC_ADDR2;
++  netif->hwaddr[3] =  MAC_ADDR3;
++  netif->hwaddr[4] =  MAC_ADDR4;
++  netif->hwaddr[5] =  MAC_ADDR5;
++
++  /* set netif maximum transfer unit */
++  netif->mtu = 1500;
++
++  /* Accept broadcast address and ARP traffic */
++  netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
++
++  /* create a binary semaphore used for informing ethernetif of frame reception */
++  osSemaphoreDef(SEM);
++  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1 );
++
++  /* create the task that handles the ETH_MAC */
++  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
++  osThreadCreate (osThread(EthIf), netif);
++
++  /* Enable MAC and DMA transmission and reception */
++  HAL_ETH_Start(&EthHandle);
++}
++
++
++/**
++  * @brief This function should do the actual transmission of the packet. The packet is
++  * contained in the pbuf that is passed to the function. This pbuf
++  * might be chained.
++  *
++  * @param netif the lwip network interface structure for this ethernetif
++  * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
++  * @return ERR_OK if the packet could be sent
++  *         an err_t value if the packet couldn't be sent
++  *
++  * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
++  *       strange results. You might consider waiting for space in the DMA queue
++  *       to become available since the stack doesn't retry to send a packet
++  *       dropped because of memory failure (except for the TCP timers).
++  */
++static err_t low_level_output(struct netif *netif, struct pbuf *p)
++{
++  err_t errval;
++  struct pbuf *q;
++  uint8_t *buffer = (uint8_t *)(EthHandle.TxDesc->Buffer1Addr);
++  __IO ETH_DMADescTypeDef *DmaTxDesc;
++  uint32_t framelength = 0;
++  uint32_t bufferoffset = 0;
++  uint32_t byteslefttocopy = 0;
++  uint32_t payloadoffset = 0;
++
++  DmaTxDesc = EthHandle.TxDesc;
++  bufferoffset = 0;
++  
++  /* copy frame from pbufs to driver buffers */
++  for(q = p; q != NULL; q = q->next)
++  {
++    /* Is this buffer available? If not, goto error */
++    if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
++    {
++      errval = ERR_USE;
++      goto error;
++    }
++    
++    /* Get bytes in current lwIP buffer */
++    byteslefttocopy = q->len;
++    payloadoffset = 0;
++    
++    /* Check if the length of data to copy is bigger than Tx buffer size*/
++    while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
++    {
++      /* Copy data to Tx buffer*/
++      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
++      
++      /* Point to next descriptor */
++      DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
++      
++      /* Check if the buffer is available */
++      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
++      {
++        errval = ERR_USE;
++        goto error;
++      }
++      
++      buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
++      
++      byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
++      payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
++      framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
++      bufferoffset = 0;
++    }
++    
++    /* Copy the remaining bytes */
++    memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
++    bufferoffset = bufferoffset + byteslefttocopy;
++    framelength = framelength + byteslefttocopy;
++  }
++  
++  /* Prepare transmit descriptors to give to DMA */ 
++  HAL_ETH_TransmitFrame(&EthHandle, framelength);
++  
++  errval = ERR_OK;
++  
++error:
++  
++  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
++  if ((EthHandle.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
++  {
++    /* Clear TUS ETHERNET DMA flag */
++    EthHandle.Instance->DMASR = ETH_DMASR_TUS;
++    
++    /* Resume DMA transmission*/
++    EthHandle.Instance->DMATPDR = 0;
++  }
++  return errval;
++}
++
++/**
++  * @brief Should allocate a pbuf and transfer the bytes of the incoming
++  * packet from the interface into the pbuf.
++  *
++  * @param netif the lwip network interface structure for this ethernetif
++  * @return a pbuf filled with the received packet (including MAC header)
++  *         NULL on memory error
++  */
++static struct pbuf * low_level_input(struct netif *netif)
++{
++  struct pbuf *p = NULL, *q = NULL;
++  uint16_t len = 0;
++  uint8_t *buffer;
++  __IO ETH_DMADescTypeDef *dmarxdesc;
++  uint32_t bufferoffset = 0;
++  uint32_t payloadoffset = 0;
++  uint32_t byteslefttocopy = 0;
++  uint32_t i=0;
++  
++  /* get received frame */
++  if(HAL_ETH_GetReceivedFrame_IT(&EthHandle) != HAL_OK)
++    return NULL;
++  
++  /* Obtain the size of the packet and put it into the "len" variable. */
++  len = EthHandle.RxFrameInfos.length;
++  buffer = (uint8_t *)EthHandle.RxFrameInfos.buffer;
++  
++  if (len > 0)
++  {
++    /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
++    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
++  }
++  
++  if (p != NULL)
++  {
++    dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
++    bufferoffset = 0;
++    
++    for(q = p; q != NULL; q = q->next)
++    {
++      byteslefttocopy = q->len;
++      payloadoffset = 0;
++      
++      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size */
++      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
++      {
++        /* Copy data to pbuf */
++        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
++        
++        /* Point to next descriptor */
++        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
++        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
++        
++        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
++        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
++        bufferoffset = 0;
++      }
++      
++      /* Copy remaining data in pbuf */
++      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
++      bufferoffset = bufferoffset + byteslefttocopy;
++    }
++  }
++    
++  /* Release descriptors to DMA */
++  /* Point to first descriptor */
++  dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
++  /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
++  for (i=0; i< EthHandle.RxFrameInfos.SegCount; i++)
++  {  
++    dmarxdesc->Status |= ETH_DMARXDESC_OWN;
++    dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
++  }
++    
++  /* Clear Segment_Count */
++  EthHandle.RxFrameInfos.SegCount =0;
++  
++  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
++  if ((EthHandle.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
++  {
++    /* Clear RBUS ETHERNET DMA flag */
++    EthHandle.Instance->DMASR = ETH_DMASR_RBUS;
++    /* Resume DMA reception */
++    EthHandle.Instance->DMARPDR = 0;
++  }
++  return p;
++}
++
++/**
++  * @brief This function is the ethernetif_input task, it is processed when a packet 
++  * is ready to be read from the interface. It uses the function low_level_input() 
++  * that should handle the actual reception of bytes from the network
++  * interface. Then the type of the received packet is determined and
++  * the appropriate input function is called.
++  *
++  * @param netif the lwip network interface structure for this ethernetif
++  */
++void ethernetif_input( void const * argument )
++{
++  struct pbuf *p;
++  struct netif *netif = (struct netif *) argument;
++  
++  for( ;; )
++  {
++    if (osSemaphoreWait( s_xSemaphore, TIME_WAITING_FOR_INPUT)==osOK)
++    {
++      do
++      {
++        p = low_level_input( netif );
++        if (p != NULL)
++        {
++          if (netif->input( p, netif) != ERR_OK )
++          {
++            pbuf_free(p);
++          }
++        }
++      }while(p!=NULL);
++    }
++  }
++}
++
++/**
++  * @brief Should be called at the beginning of the program to set up the
++  * network interface. It calls the function low_level_init() to do the
++  * actual setup of the hardware.
++  *
++  * This function should be passed as a parameter to netif_add().
++  *
++  * @param netif the lwip network interface structure for this ethernetif
++  * @return ERR_OK if the loopif is initialized
++  *         ERR_MEM if private data couldn't be allocated
++  *         any other err_t on error
++  */
++err_t ethernetif_init(struct netif *netif)
++{
++  LWIP_ASSERT("netif != NULL", (netif != NULL));
++
++#if LWIP_NETIF_HOSTNAME
++  /* Initialize interface hostname */
++  netif->hostname = "lwip";
++#endif /* LWIP_NETIF_HOSTNAME */
++
++  netif->name[0] = IFNAME0;
++  netif->name[1] = IFNAME1;
++
++  netif->output = etharp_output;
++  netif->linkoutput = low_level_output;
++
++  /* initialize the hardware */
++  low_level_init(netif);
++
++  return ERR_OK;
++}
++
++/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+-- 
+1.9.1
+
+
+From 81eded01bb2bc35a9b627e5cf35b2021efb5972c Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Mon, 7 Sep 2015 10:22:57 -0400
+Subject: [PATCH 07/13] Added bsp path
+
+---
+ Makefile | 4 +++-
+ 1 file changed, 3 insertions(+), 1 deletion(-)
+
+diff --git a/Makefile b/Makefile
+index 6efa141..a855d9f 100644
+--- a/Makefile
++++ b/Makefile
+@@ -13,6 +13,8 @@ LWIP_EXEC=lwip
+ 
+ #### PATHS #####################################################################
+ 
++BSP_PATH=/opt/rtems-4.11/arm-rtems4.11/stm32f7x/lib/include/bsp
++
+ # LWIP
+ LWIP_PATH=.
+ LWIP_SRC_PATH=$(LWIP_PATH)/src
+@@ -97,7 +99,7 @@ DRIVER_H=$(LWIPDRIVER_INCL_PATH)
+ # HEADERS
+ HEADERS=-I$(CORE_H) -I$(POSIX_H) -I$(POSIX_SYS_H) -I$(NETIF_H) \
+         -I$(NETIF_H_PPP) -I$(NETIF_H_PPP_POLARSSL) -I$(ARCH_H) \
+-        -I$(DRIVER_H) -I$(IPV4_H)
++        -I$(DRIVER_H) -I$(IPV4_H) -I$(BSP_PATH)
+ 
+ 
+ ################################################################################
+-- 
+1.9.1
+
+
+From f114529d5af1e2a83b49b67d631b10c02648e8d8 Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Mon, 7 Sep 2015 10:54:26 -0400
+Subject: [PATCH 08/13] removed ethernetif.c
+
+---
+ src/netif/ethernetif.c | 496 -------------------------------------------------
+ 1 file changed, 496 deletions(-)
+ delete mode 100644 src/netif/ethernetif.c
+
+diff --git a/src/netif/ethernetif.c b/src/netif/ethernetif.c
+deleted file mode 100644
+index bc429e9..0000000
+--- a/src/netif/ethernetif.c
++++ /dev/null
+@@ -1,496 +0,0 @@
+-/**
+-  ******************************************************************************
+-  * @file    LwIP/LwIP_HTTP_Server_Netconn_RTOS/Src/ethernetif.c
+-  * @author  MCD Application Team
+-  * @version V1.0.0
+-  * @date    25-June-2015
+-  * @brief   This file implements Ethernet network interface drivers for lwIP
+-  ******************************************************************************
+-  * @attention
+-  *
+-  * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
+-  *
+-  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+-  * You may not use this file except in compliance with the License.
+-  * You may obtain a copy of the License at:
+-  *
+-  *        http://www.st.com/software_license_agreement_liberty_v2
+-  *
+-  * Unless required by applicable law or agreed to in writing, software 
+-  * distributed under the License is distributed on an "AS IS" BASIS, 
+-  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+-  * See the License for the specific language governing permissions and
+-  * limitations under the License.
+-  *
+-  ******************************************************************************
+-  */
+-
+-/* Includes ------------------------------------------------------------------*/
+-#include <stm32f7xx_hal.h>
+-#include <lwip/opt.h>
+-#include <lwip/lwip_timers.h>
+-#include <netif/etharp.h>
+-#include <hal-ethernetif.h>
+-#include <string.h>
+-
+-/* Private typedef -----------------------------------------------------------*/
+-/* Private define ------------------------------------------------------------*/
+-/* The time to block waiting for input. */
+-#define TIME_WAITING_FOR_INPUT                 ( 100 )
+-/* Stack size of the interface thread */
+-#define INTERFACE_THREAD_STACK_SIZE            ( 350 )
+-
+-/* Define those to better describe your network interface. */
+-#define IFNAME0 'e'
+-#define IFNAME1 'n'
+-
+-#define LAN8742A_PHY_ADDRESS            0x00
+-
+-/* Private macro -------------------------------------------------------------*/
+-/* Private variables ---------------------------------------------------------*/
+-
+-#if defined ( __ICCARM__ ) /*!< IAR Compiler */
+-
+-#pragma location=0x2000E000
+-__no_init ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
+-#pragma location=0x2000E100
+-__no_init ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
+-#elif defined ( __CC_ARM   )
+-ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((at(0x2000E000)));/* Ethernet Rx MA Descriptor */
+-ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((at(0x2000E100)));/* Ethernet Tx DMA Descriptor */
+-#elif defined ( __GNUC__   )
+-//ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".RxDescripSection")));/* Ethernet Rx MA Descriptor */
+-//ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".TxDescripSection")));/* Ethernet Tx DMA Descriptor */
+-ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Rx MA Descriptor */
+-ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Tx DMA Descriptor */
+-
+-
+-#endif
+-#if defined ( __ICCARM__ ) /*!< IAR Compiler */
+-#pragma location=0x2000E200
+-__no_init uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
+-#pragma location=0x2000FFC4
+-__no_init uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
+-#elif defined ( __CC_ARM   )
+-uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((at(0x2000E200)));  /* Ethernet Receive Buffer */
+-uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]  __attribute__((at(0x2000FFC4))); /* Ethernet Transmit Buffer */
+-#elif defined ( __GNUC__   )
+-//uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".RxBUF")));/* Ethernet Receive Buffer */
+-//uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".TxBUF")));/* Ethernet Transmit Buffer */
+-uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Receive Buffer */
+-uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Transmit Buffer */
+-
+-#endif
+-/* Semaphore to signal incoming packets */
+-osSemaphoreId s_xSemaphore = NULL;
+-
+-/* Global Ethernet handle*/
+-ETH_HandleTypeDef EthHandle;
+-
+-/* Private function prototypes -----------------------------------------------*/
+-static void ethernetif_input( void const * argument );
+-
+-static void stm32f_ethernet_isr(
+-  void* argData
+-)
+-{
+-  ETH_HandleTypeDef* pEth =
+-    (ETH_HandleTypeDef*) argData;
+-
+-  HAL_ETH_IRQHandler(pEth);
+-}
+-
+-/* Private functions ---------------------------------------------------------*/
+-/*******************************************************************************
+-                       Ethernet MSP Routines
+-*******************************************************************************/
+-/**
+-  * @brief  Initializes the ETH MSP.
+-  * @param  heth: ETH handle
+-  * @retval None
+-  */
+-void HAL_ETH_MspInit(ETH_HandleTypeDef *heth)
+-{
+-  GPIO_InitTypeDef GPIO_InitStructure;
+-  
+-  /* Enable GPIOs clocks */
+-  __HAL_RCC_GPIOA_CLK_ENABLE();
+-  __HAL_RCC_GPIOC_CLK_ENABLE();
+-  __HAL_RCC_GPIOG_CLK_ENABLE();
+-
+-/* Ethernet pins configuration ************************************************/
+-  /*
+-        RMII_REF_CLK ----------------------> PA1
+-        RMII_MDIO -------------------------> PA2
+-        RMII_MDC --------------------------> PC1
+-        RMII_MII_CRS_DV -------------------> PA7
+-        RMII_MII_RXD0 ---------------------> PC4
+-        RMII_MII_RXD1 ---------------------> PC5
+-        RMII_MII_RXER ---------------------> PG2
+-        RMII_MII_TX_EN --------------------> PG11
+-        RMII_MII_TXD0 ---------------------> PG13
+-        RMII_MII_TXD1 ---------------------> PG14
+-  */
+-
+-  /* Configure PA1, PA2 and PA7 */
+-  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
+-  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
+-  GPIO_InitStructure.Pull = GPIO_NOPULL; 
+-  GPIO_InitStructure.Alternate = GPIO_AF11_ETH;
+-  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
+-  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
+-  
+-  /* Configure PC1, PC4 and PC5 */
+-  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;
+-  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
+-
+-  /* Configure PG2, PG11, PG13 and PG14 */
+-  GPIO_InitStructure.Pin =  GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14;
+-  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
+-  
+-  // Install HAL Ethernet ISR
+-  rtems_interrupt_handler_install(
+-    ETH_IRQn,
+-    NULL,
+-    0,
+-    stm32f_ethernet_isr,
+-    heth);
+-  
+-  /* Enable ETHERNET clock  */
+-  __HAL_RCC_ETH_CLK_ENABLE();
+-}
+-
+-/**
+-  * @brief  Ethernet Rx Transfer completed callback
+-  * @param  heth: ETH handle
+-  * @retval None
+-  */
+-void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
+-{
+-  osSemaphoreRelease(s_xSemaphore);
+-}
+-
+-/**
+-  * @brief  Ethernet IRQ Handler
+-  * @param  None
+-  * @retval None
+-  */
+-void ETHERNET_IRQHandler(void)
+-{
+-  HAL_ETH_IRQHandler(&EthHandle);
+-}
+-
+-/*******************************************************************************
+-                       LL Driver Interface ( LwIP stack --> ETH) 
+-*******************************************************************************/
+-/**
+-  * @brief In this function, the hardware should be initialized.
+-  * Called from ethernetif_init().
+-  *
+-  * @param netif the already initialized lwip network interface structure
+-  *        for this ethernetif
+-  */
+-static void low_level_init(struct netif *netif)
+-{
+-  uint8_t macaddress[6]= { MAC_ADDR0, MAC_ADDR1, MAC_ADDR2, MAC_ADDR3, MAC_ADDR4, MAC_ADDR5 };
+-  
+-  EthHandle.Instance = ETH;  
+-  EthHandle.Init.MACAddr = macaddress;
+-  EthHandle.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
+-  EthHandle.Init.Speed = ETH_SPEED_100M;
+-  EthHandle.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
+-  EthHandle.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
+-  EthHandle.Init.RxMode = ETH_RXINTERRUPT_MODE;
+-  EthHandle.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
+-  EthHandle.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
+-  
+-  /* configure ethernet peripheral (GPIOs, clocks, MAC, DMA) */
+-  if (HAL_ETH_Init(&EthHandle) == HAL_OK)
+-  {
+-    /* Set netif link flag */
+-    netif->flags |= NETIF_FLAG_LINK_UP;
+-  }
+-  
+-  /* Initialize Tx Descriptors list: Chain Mode */
+-  HAL_ETH_DMATxDescListInit(&EthHandle, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
+-     
+-  /* Initialize Rx Descriptors list: Chain Mode  */
+-  HAL_ETH_DMARxDescListInit(&EthHandle, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
+-  
+-  /* set netif MAC hardware address length */
+-  netif->hwaddr_len = ETHARP_HWADDR_LEN;
+-
+-  /* set netif MAC hardware address */
+-  netif->hwaddr[0] =  MAC_ADDR0;
+-  netif->hwaddr[1] =  MAC_ADDR1;
+-  netif->hwaddr[2] =  MAC_ADDR2;
+-  netif->hwaddr[3] =  MAC_ADDR3;
+-  netif->hwaddr[4] =  MAC_ADDR4;
+-  netif->hwaddr[5] =  MAC_ADDR5;
+-
+-  /* set netif maximum transfer unit */
+-  netif->mtu = 1500;
+-
+-  /* Accept broadcast address and ARP traffic */
+-  netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
+-
+-  /* create a binary semaphore used for informing ethernetif of frame reception */
+-  osSemaphoreDef(SEM);
+-  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1 );
+-
+-  /* create the task that handles the ETH_MAC */
+-  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
+-  osThreadCreate (osThread(EthIf), netif);
+-
+-  /* Enable MAC and DMA transmission and reception */
+-  HAL_ETH_Start(&EthHandle);
+-}
+-
+-
+-/**
+-  * @brief This function should do the actual transmission of the packet. The packet is
+-  * contained in the pbuf that is passed to the function. This pbuf
+-  * might be chained.
+-  *
+-  * @param netif the lwip network interface structure for this ethernetif
+-  * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
+-  * @return ERR_OK if the packet could be sent
+-  *         an err_t value if the packet couldn't be sent
+-  *
+-  * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
+-  *       strange results. You might consider waiting for space in the DMA queue
+-  *       to become available since the stack doesn't retry to send a packet
+-  *       dropped because of memory failure (except for the TCP timers).
+-  */
+-static err_t low_level_output(struct netif *netif, struct pbuf *p)
+-{
+-  err_t errval;
+-  struct pbuf *q;
+-  uint8_t *buffer = (uint8_t *)(EthHandle.TxDesc->Buffer1Addr);
+-  __IO ETH_DMADescTypeDef *DmaTxDesc;
+-  uint32_t framelength = 0;
+-  uint32_t bufferoffset = 0;
+-  uint32_t byteslefttocopy = 0;
+-  uint32_t payloadoffset = 0;
+-
+-  DmaTxDesc = EthHandle.TxDesc;
+-  bufferoffset = 0;
+-  
+-  /* copy frame from pbufs to driver buffers */
+-  for(q = p; q != NULL; q = q->next)
+-  {
+-    /* Is this buffer available? If not, goto error */
+-    if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
+-    {
+-      errval = ERR_USE;
+-      goto error;
+-    }
+-    
+-    /* Get bytes in current lwIP buffer */
+-    byteslefttocopy = q->len;
+-    payloadoffset = 0;
+-    
+-    /* Check if the length of data to copy is bigger than Tx buffer size*/
+-    while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
+-    {
+-      /* Copy data to Tx buffer*/
+-      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
+-      
+-      /* Point to next descriptor */
+-      DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
+-      
+-      /* Check if the buffer is available */
+-      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
+-      {
+-        errval = ERR_USE;
+-        goto error;
+-      }
+-      
+-      buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
+-      
+-      byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
+-      payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
+-      framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
+-      bufferoffset = 0;
+-    }
+-    
+-    /* Copy the remaining bytes */
+-    memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
+-    bufferoffset = bufferoffset + byteslefttocopy;
+-    framelength = framelength + byteslefttocopy;
+-  }
+-  
+-  /* Prepare transmit descriptors to give to DMA */ 
+-  HAL_ETH_TransmitFrame(&EthHandle, framelength);
+-  
+-  errval = ERR_OK;
+-  
+-error:
+-  
+-  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
+-  if ((EthHandle.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
+-  {
+-    /* Clear TUS ETHERNET DMA flag */
+-    EthHandle.Instance->DMASR = ETH_DMASR_TUS;
+-    
+-    /* Resume DMA transmission*/
+-    EthHandle.Instance->DMATPDR = 0;
+-  }
+-  return errval;
+-}
+-
+-/**
+-  * @brief Should allocate a pbuf and transfer the bytes of the incoming
+-  * packet from the interface into the pbuf.
+-  *
+-  * @param netif the lwip network interface structure for this ethernetif
+-  * @return a pbuf filled with the received packet (including MAC header)
+-  *         NULL on memory error
+-  */
+-static struct pbuf * low_level_input(struct netif *netif)
+-{
+-  struct pbuf *p = NULL, *q = NULL;
+-  uint16_t len = 0;
+-  uint8_t *buffer;
+-  __IO ETH_DMADescTypeDef *dmarxdesc;
+-  uint32_t bufferoffset = 0;
+-  uint32_t payloadoffset = 0;
+-  uint32_t byteslefttocopy = 0;
+-  uint32_t i=0;
+-  
+-  /* get received frame */
+-  if(HAL_ETH_GetReceivedFrame_IT(&EthHandle) != HAL_OK)
+-    return NULL;
+-  
+-  /* Obtain the size of the packet and put it into the "len" variable. */
+-  len = EthHandle.RxFrameInfos.length;
+-  buffer = (uint8_t *)EthHandle.RxFrameInfos.buffer;
+-  
+-  if (len > 0)
+-  {
+-    /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
+-    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
+-  }
+-  
+-  if (p != NULL)
+-  {
+-    dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
+-    bufferoffset = 0;
+-    
+-    for(q = p; q != NULL; q = q->next)
+-    {
+-      byteslefttocopy = q->len;
+-      payloadoffset = 0;
+-      
+-      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size */
+-      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
+-      {
+-        /* Copy data to pbuf */
+-        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
+-        
+-        /* Point to next descriptor */
+-        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
+-        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
+-        
+-        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
+-        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
+-        bufferoffset = 0;
+-      }
+-      
+-      /* Copy remaining data in pbuf */
+-      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
+-      bufferoffset = bufferoffset + byteslefttocopy;
+-    }
+-  }
+-    
+-  /* Release descriptors to DMA */
+-  /* Point to first descriptor */
+-  dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
+-  /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
+-  for (i=0; i< EthHandle.RxFrameInfos.SegCount; i++)
+-  {  
+-    dmarxdesc->Status |= ETH_DMARXDESC_OWN;
+-    dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
+-  }
+-    
+-  /* Clear Segment_Count */
+-  EthHandle.RxFrameInfos.SegCount =0;
+-  
+-  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
+-  if ((EthHandle.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
+-  {
+-    /* Clear RBUS ETHERNET DMA flag */
+-    EthHandle.Instance->DMASR = ETH_DMASR_RBUS;
+-    /* Resume DMA reception */
+-    EthHandle.Instance->DMARPDR = 0;
+-  }
+-  return p;
+-}
+-
+-/**
+-  * @brief This function is the ethernetif_input task, it is processed when a packet 
+-  * is ready to be read from the interface. It uses the function low_level_input() 
+-  * that should handle the actual reception of bytes from the network
+-  * interface. Then the type of the received packet is determined and
+-  * the appropriate input function is called.
+-  *
+-  * @param netif the lwip network interface structure for this ethernetif
+-  */
+-void ethernetif_input( void const * argument )
+-{
+-  struct pbuf *p;
+-  struct netif *netif = (struct netif *) argument;
+-  
+-  for( ;; )
+-  {
+-    if (osSemaphoreWait( s_xSemaphore, TIME_WAITING_FOR_INPUT)==osOK)
+-    {
+-      do
+-      {
+-        p = low_level_input( netif );
+-        if (p != NULL)
+-        {
+-          if (netif->input( p, netif) != ERR_OK )
+-          {
+-            pbuf_free(p);
+-          }
+-        }
+-      }while(p!=NULL);
+-    }
+-  }
+-}
+-
+-/**
+-  * @brief Should be called at the beginning of the program to set up the
+-  * network interface. It calls the function low_level_init() to do the
+-  * actual setup of the hardware.
+-  *
+-  * This function should be passed as a parameter to netif_add().
+-  *
+-  * @param netif the lwip network interface structure for this ethernetif
+-  * @return ERR_OK if the loopif is initialized
+-  *         ERR_MEM if private data couldn't be allocated
+-  *         any other err_t on error
+-  */
+-err_t ethernetif_init(struct netif *netif)
+-{
+-  LWIP_ASSERT("netif != NULL", (netif != NULL));
+-
+-#if LWIP_NETIF_HOSTNAME
+-  /* Initialize interface hostname */
+-  netif->hostname = "lwip";
+-#endif /* LWIP_NETIF_HOSTNAME */
+-
+-  netif->name[0] = IFNAME0;
+-  netif->name[1] = IFNAME1;
+-
+-  netif->output = etharp_output;
+-  netif->linkoutput = low_level_output;
+-
+-  /* initialize the hardware */
+-  low_level_init(netif);
+-
+-  return ERR_OK;
+-}
+-
+-/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+-- 
+1.9.1
+
+
+From 8f652ac0f1be0f2abc1493981763fc4c402bbfed Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Wed, 16 Sep 2015 09:29:27 -0400
+Subject: [PATCH 09/13] using options from sample project
+
+---
+ ports/include/lwipopts.h | 207 +++++++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 207 insertions(+)
+
+diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
+index 169ba46..68d799b 100644
+--- a/ports/include/lwipopts.h
++++ b/ports/include/lwipopts.h
+@@ -38,6 +38,9 @@
+ #ifndef __LWIPOPTS_H__
+ #define __LWIPOPTS_H__
+ 
++
++#if ORIGINAL_CONFIG_OPTIONS
++
+ /*****************************************************************************
+ **                           CONFIGURATIONS
+ *****************************************************************************/
+@@ -175,4 +178,208 @@
+ 
+  #define LWIP_RAW                       0
+ 
++#else
++
++/**
++ * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
++ * critical regions during buffer allocation, deallocation and memory
++ * allocation and deallocation.
++ */
++#define SYS_LIGHTWEIGHT_PROT    0
++
++#define ETHARP_TRUST_IP_MAC     0
++#define IP_REASSEMBLY           0
++#define IP_FRAG                 0
++#define ARP_QUEUEING            0
++#define TCP_LISTEN_BACKLOG      1
++
++/**
++ * NO_SYS==1: Provides VERY minimal functionality. Otherwise,
++ * use lwIP facilities.
++ */
++#define NO_SYS                  0
++
++/* ---------- Memory options ---------- */
++/* MEM_ALIGNMENT: should be set to the alignment of the CPU for which
++   lwIP is compiled. 4 byte alignment -> define MEM_ALIGNMENT to 4, 2
++   byte alignment -> define MEM_ALIGNMENT to 2. */
++#define MEM_ALIGNMENT           4
++
++/* MEM_SIZE: the size of the heap memory. If the application will send
++a lot of data that needs to be copied, this should be set high. */
++#define MEM_SIZE                (10*1024)
++
++/* MEMP_NUM_PBUF: the number of memp struct pbufs. If the application
++   sends a lot of data out of ROM (or other static memory), this
++   should be set high. */
++#define MEMP_NUM_PBUF           50
++/* MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks. One
++   per active UDP "connection". */
++#define MEMP_NUM_UDP_PCB        6
++/* MEMP_NUM_TCP_PCB: the number of simulatenously active TCP
++   connections. */
++#define MEMP_NUM_TCP_PCB        10
++/* MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP
++   connections. */
++#define MEMP_NUM_TCP_PCB_LISTEN 5
++/* MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP
++   segments. */
++#define MEMP_NUM_TCP_SEG        12
++/* MEMP_NUM_SYS_TIMEOUT: the number of simulateously active
++   timeouts. */
++#define MEMP_NUM_SYS_TIMEOUT    10
++
++
++/* ---------- Pbuf options ---------- */
++/* PBUF_POOL_SIZE: the number of buffers in the pbuf pool. */
++#define PBUF_POOL_SIZE          10
++
++/* PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. */
++#define PBUF_POOL_BUFSIZE       1524
++
++
++/* ---------- TCP options ---------- */
++#define LWIP_TCP                1
++#define TCP_TTL                 255
++
++/* Controls if TCP should queue segments that arrive out of
++   order. Define to 0 if your device is low on memory. */
++#define TCP_QUEUE_OOSEQ         0
++
++/* TCP Maximum segment size. */
++#define TCP_MSS                 (1500 - 40)   /* TCP_MSS = (Ethernet MTU - IP header size - TCP header size) */
++
++/* TCP sender buffer space (bytes). */
++#define TCP_SND_BUF             (4*TCP_MSS)
++
++/*  TCP_SND_QUEUELEN: TCP sender buffer space (pbufs). This must be at least
++  as much as (2 * TCP_SND_BUF/TCP_MSS) for things to work. */
++
++#define TCP_SND_QUEUELEN        (2* TCP_SND_BUF/TCP_MSS)
++
++/* TCP receive window. */
++#define TCP_WND                 (2*TCP_MSS)
++
++
++/* ---------- ICMP options ---------- */
++#define LWIP_ICMP                       1
++
++
++/* ---------- DHCP options ---------- */
++/* Define LWIP_DHCP to 1 if you want DHCP configuration of
++   interfaces. DHCP is not implemented in lwIP 0.5.1, however, so
++   turning this on does currently not work. */
++#define LWIP_DHCP               1
++
++
++/* ---------- UDP options ---------- */
++#define LWIP_UDP                1
++#define UDP_TTL                 255
++
++
++/* ---------- Statistics options ---------- */
++#define LWIP_STATS 0
++#define LWIP_PROVIDE_ERRNO 1
++
++/* ---------- link callback options ---------- */
++/* LWIP_NETIF_LINK_CALLBACK==1: Support a callback function from an interface
++ * whenever the link changes (i.e., link down)
++ */
++#define LWIP_NETIF_LINK_CALLBACK        1
++
++/*
++   --------------------------------------
++   ---------- Checksum options ----------
++   --------------------------------------
++*/
++
++/*
++The STM32F4x7 allows computing and verifying the IP, UDP, TCP and ICMP checksums by hardware:
++ - To use this feature let the following define uncommented.
++ - To disable it and process by CPU comment the  the checksum.
++*/
++#define CHECKSUM_BY_HARDWARE
++
++
++#ifdef CHECKSUM_BY_HARDWARE
++  /* CHECKSUM_GEN_IP==0: Generate checksums by hardware for outgoing IP packets.*/
++  #define CHECKSUM_GEN_IP                 0
++  /* CHECKSUM_GEN_UDP==0: Generate checksums by hardware for outgoing UDP packets.*/
++  #define CHECKSUM_GEN_UDP                0
++  /* CHECKSUM_GEN_TCP==0: Generate checksums by hardware for outgoing TCP packets.*/
++  #define CHECKSUM_GEN_TCP                0
++  /* CHECKSUM_CHECK_IP==0: Check checksums by hardware for incoming IP packets.*/
++  #define CHECKSUM_CHECK_IP               0
++  /* CHECKSUM_CHECK_UDP==0: Check checksums by hardware for incoming UDP packets.*/
++  #define CHECKSUM_CHECK_UDP              0
++  /* CHECKSUM_CHECK_TCP==0: Check checksums by hardware for incoming TCP packets.*/
++  #define CHECKSUM_CHECK_TCP              0
++  /* CHECKSUM_CHECK_ICMP==0: Check checksums by hardware for incoming ICMP packets.*/
++  #define CHECKSUM_GEN_ICMP               0
++#else
++  /* CHECKSUM_GEN_IP==1: Generate checksums in software for outgoing IP packets.*/
++  #define CHECKSUM_GEN_IP                 1
++  /* CHECKSUM_GEN_UDP==1: Generate checksums in software for outgoing UDP packets.*/
++  #define CHECKSUM_GEN_UDP                1
++  /* CHECKSUM_GEN_TCP==1: Generate checksums in software for outgoing TCP packets.*/
++  #define CHECKSUM_GEN_TCP                1
++  /* CHECKSUM_CHECK_IP==1: Check checksums in software for incoming IP packets.*/
++  #define CHECKSUM_CHECK_IP               1
++  /* CHECKSUM_CHECK_UDP==1: Check checksums in software for incoming UDP packets.*/
++  #define CHECKSUM_CHECK_UDP              1
++  /* CHECKSUM_CHECK_TCP==1: Check checksums in software for incoming TCP packets.*/
++  #define CHECKSUM_CHECK_TCP              1
++  /* CHECKSUM_CHECK_ICMP==1: Check checksums by hardware for incoming ICMP packets.*/
++  #define CHECKSUM_GEN_ICMP               1
++#endif
++
++
++/*
++   ----------------------------------------------
++   ---------- Sequential layer options ----------
++   ----------------------------------------------
++*/
++/**
++ * LWIP_NETCONN==1: Enable Netconn API (require to use api_lib.c)
++ */
++#define LWIP_NETCONN                    1
++
++/*
++   ------------------------------------
++   ---------- Socket options ----------
++   ------------------------------------
++*/
++/**
++ * LWIP_SOCKET==1: Enable Socket API (require to use sockets.c)
++ */
++#define LWIP_SOCKET                     1
++
++/*
++   -----------------------------------
++   ---------- DEBUG options ----------
++   -----------------------------------
++*/
++
++#define LWIP_DEBUG                      0
++
++
++/*
++   ---------------------------------
++   ---------- OS options ----------
++   ---------------------------------
++*/
++
++#define TCPIP_THREAD_NAME              "TCP/IP"
++#define TCPIP_THREAD_STACKSIZE          1000
++#define TCPIP_MBOX_SIZE                 5
++#define DEFAULT_UDP_RECVMBOX_SIZE       2000
++#define DEFAULT_TCP_RECVMBOX_SIZE       2000
++#define DEFAULT_ACCEPTMBOX_SIZE         2000
++#define DEFAULT_THREAD_STACKSIZE        500
++#define TCPIP_THREAD_PRIO               (configMAX_PRIORITIES - 2)
++#define LWIP_COMPAT_MUTEX               1
++
++
++#endif
++
+ #endif /* __LWIPOPTS_H__ */
+-- 
+1.9.1
+
+
+From d2624890161b1ec246cd224de8079157367a6346 Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Wed, 16 Sep 2015 10:01:58 -0400
+Subject: [PATCH 10/13] added cache line configuration
+
+---
+ ports/include/lwipopts.h | 3 +++
+ 1 file changed, 3 insertions(+)
+
+diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
+index 68d799b..049d66d 100644
+--- a/ports/include/lwipopts.h
++++ b/ports/include/lwipopts.h
+@@ -180,6 +180,9 @@
+ 
+ #else
+ 
++#define LWIP_CACHE_ENABLED
++#define SOC_CACHELINE_SIZE_BYTES 32
++
+ /**
+  * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
+  * critical regions during buffer allocation, deallocation and memory
+-- 
+1.9.1
+
+
+From 37e5b73c865357e530226ea2a2008aa355f58d55 Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Wed, 16 Sep 2015 10:11:20 -0400
+Subject: [PATCH 11/13] configured for local time structure definition
+
+---
+ ports/include/arch/cc.h  | 2 ++
+ ports/include/lwipopts.h | 1 +
+ 2 files changed, 3 insertions(+)
+
+diff --git a/ports/include/arch/cc.h b/ports/include/arch/cc.h
+index 04ec89f..900e9b6 100644
+--- a/ports/include/arch/cc.h
++++ b/ports/include/arch/cc.h
+@@ -32,6 +32,8 @@
+ #ifndef __CC_H__
+ #define __CC_H__
+ 
++#include <sys/time.h>
++
+ typedef unsigned    char    u8_t;
+ typedef signed      char    s8_t;
+ typedef unsigned    short   u16_t;
+diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
+index 049d66d..05f5b52 100644
+--- a/ports/include/lwipopts.h
++++ b/ports/include/lwipopts.h
+@@ -182,6 +182,7 @@
+ 
+ #define LWIP_CACHE_ENABLED
+ #define SOC_CACHELINE_SIZE_BYTES 32
++#define LWIP_TIMEVAL_PRIVATE 0
+ 
+ /**
+  * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
+-- 
+1.9.1
+
+
+From 9a72a789d145f794b8a4c1084ed50597b71c6e2b Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Wed, 16 Sep 2015 10:16:55 -0400
+Subject: [PATCH 12/13] remove include from cc.h
+
+---
+ ports/include/arch/cc.h | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/ports/include/arch/cc.h b/ports/include/arch/cc.h
+index 900e9b6..8eefd64 100644
+--- a/ports/include/arch/cc.h
++++ b/ports/include/arch/cc.h
+@@ -32,8 +32,6 @@
+ #ifndef __CC_H__
+ #define __CC_H__
+ 
+-#include <sys/time.h>
+-
+ typedef unsigned    char    u8_t;
+ typedef signed      char    s8_t;
+ typedef unsigned    short   u16_t;
+@@ -104,6 +102,8 @@ extern u8_t memp_memory_PBUF_POOL_base[] __attribute__ ((aligned (SOC_CACHELINE_
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <bsp.h>
++//#include <sys/time.h>
++
+ #define LWIP_PLATFORM_DIAG(x)   do { \
+         printk("[%s - %s - %d] ", __PRETTY_FUNCTION__, __FILE__, __LINE__); \
+         printk x; \
+-- 
+1.9.1
+
+
+From a48846deb25945d360543ffe8d86766d323b9859 Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Fri, 18 Sep 2015 13:22:21 -0400
+Subject: [PATCH 13/13] turn off checksum checking by hardware
+
+---
+ ports/include/lwipopts.h | 6 +++---
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
+index 05f5b52..cf11793 100644
+--- a/ports/include/lwipopts.h
++++ b/ports/include/lwipopts.h
+@@ -243,8 +243,8 @@ a lot of data that needs to be copied, this should be set high. */
+ 
+ 
+ /* ---------- TCP options ---------- */
+-#define LWIP_TCP                1
+-#define TCP_TTL                 255
++//#define LWIP_TCP                1
++//#define TCP_TTL                 255
+ 
+ /* Controls if TCP should queue segments that arrive out of
+    order. Define to 0 if your device is low on memory. */
+@@ -302,7 +302,7 @@ The STM32F4x7 allows computing and verifying the IP, UDP, TCP and ICMP checksums
+  - To use this feature let the following define uncommented.
+  - To disable it and process by CPU comment the  the checksum.
+ */
+-#define CHECKSUM_BY_HARDWARE
++//#define CHECKSUM_BY_HARDWARE
+ 
+ 
+ #ifdef CHECKSUM_BY_HARDWARE
+-- 
+1.9.1
+
-- 
1.9.1


From 6fef0eeaefffd939b7dfaed53b6aafaf9060ce55 Mon Sep 17 00:00:00 2001
From: Jay Doyle <jay.doyle@vecna.com>
Date: Fri, 18 Sep 2015 13:48:53 -0400
Subject: [PATCH 15/33] potential fix

---
 ports/include/lwipopts.h | 2 +-
 src/core/tcp_out.c       | 3 ++-
 2 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
index e7f344f..ea659b6 100644
--- a/ports/include/lwipopts.h
+++ b/ports/include/lwipopts.h
@@ -303,7 +303,7 @@ The STM32F4x7 allows computing and verifying the IP, UDP, TCP and ICMP checksums
  - To use this feature let the following define uncommented.
  - To disable it and process by CPU comment the  the checksum.
 */
-//#define CHECKSUM_BY_HARDWARE
+#define CHECKSUM_BY_HARDWARE
 
 
 #ifdef CHECKSUM_BY_HARDWARE
diff --git a/src/core/tcp_out.c b/src/core/tcp_out.c
index 567942e..a3ad274 100644
--- a/src/core/tcp_out.c
+++ b/src/core/tcp_out.c
@@ -1260,8 +1260,9 @@ tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
     seg->tcphdr->chksum = ip_chksum_pseudo(seg->p, IP_PROTO_TCP,
       seg->p->tot_len, &pcb->local_ip, &pcb->remote_ip);
 #endif /* TCP_CHECKSUM_ON_COPY */
-#endif /* CHECKSUM_GEN_TCP */
   }
+#endif /* CHECKSUM_GEN_TCP */
+
   TCP_STATS_INC(tcp.xmit);
 
   NETIF_SET_HWADDRHINT(netif, &(pcb->addr_hint));
-- 
1.9.1


From 18ce710395c4ccc708bdab59c97d3884dc7a054e Mon Sep 17 00:00:00 2001
From: Jay Doyle <jay.doyle@vecna.com>
Date: Mon, 28 Sep 2015 13:47:22 -0400
Subject: [PATCH 16/33] enable BSD sockets naming

---
 ports/include/lwipopts.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
index ea659b6..a085c41 100644
--- a/ports/include/lwipopts.h
+++ b/ports/include/lwipopts.h
@@ -172,7 +172,7 @@
  * LWIP_COMPAT_SOCKETS==1: Enable BSD-style sockets functions names.
  * (only used if you use sockets.c)
  */
-#define LWIP_COMPAT_SOCKETS             0
+#define LWIP_COMPAT_SOCKETS             1
 
 #define LWIP_TIMEVAL_PRIVATE            0
 
-- 
1.9.1


From 5ce5c5555d9e55504350fd4e4d97122b701a7259 Mon Sep 17 00:00:00 2001
From: Jay Doyle <jay.doyle@vecna.com>
Date: Mon, 28 Sep 2015 15:28:28 -0400
Subject: [PATCH 17/33] corrected cache line size

---
 ports/include/lwipopts.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
index a085c41..2b218ec 100644
--- a/ports/include/lwipopts.h
+++ b/ports/include/lwipopts.h
@@ -53,7 +53,7 @@
 */
 /*#define LWIP_CACHE_ENABLED*/
 
-#define SOC_CACHELINE_SIZE_BYTES        64            /* Number of bytes in
+#define SOC_CACHELINE_SIZE_BYTES        32            /* Number of bytes in
                                                          a cache line */
 /*
 ** The timeout for DHCP completion. lwIP library will wait for DHCP
-- 
1.9.1


From bf475c67310de79d262ca8ad90435d94aaee5e5e Mon Sep 17 00:00:00 2001
From: Jay Doyle <jay.doyle@vecna.com>
Date: Mon, 28 Sep 2015 16:21:35 -0400
Subject: [PATCH 18/33] patch file update

---
 rtems.patch | 390 ++++--------------------------------------------------------
 1 file changed, 21 insertions(+), 369 deletions(-)

diff --git a/rtems.patch b/rtems.patch
index 9ca8d63..c088510 100644
--- a/rtems.patch
+++ b/rtems.patch
@@ -1,7 +1,7 @@
 From 2d83d4994e578ec339b2b1baef53090bf7a53570 Mon Sep 17 00:00:00 2001
 From: Jay Doyle <jay.doyle@vecna.com>
 Date: Fri, 4 Sep 2015 17:28:55 -0400
-Subject: [PATCH 01/13] rtems changes necessary
+Subject: [PATCH 1/9] rtems changes necessary
 
 ---
  Makefile                      | 170 +++++++++++
@@ -1292,7 +1292,7 @@ index 0000000..360a4e2
 From d053fa836b445b6736bf82d33a33a59055150aa7 Mon Sep 17 00:00:00 2001
 From: Jay Doyle <jay.doyle@vecna.com>
 Date: Fri, 4 Sep 2015 17:30:37 -0400
-Subject: [PATCH 02/13] changed the compiler options
+Subject: [PATCH 2/9] changed the compiler options
 
 ---
  Makefile | 2 +-
@@ -1318,7 +1318,7 @@ index 0cbae64..94fcafc 100644
 From 841adb17430bdb9298dcb6d44ac5dad72e82af80 Mon Sep 17 00:00:00 2001
 From: Jay Doyle <jay.doyle@vecna.com>
 Date: Mon, 7 Sep 2015 08:56:58 -0400
-Subject: [PATCH 03/13] disabled any mention of ipv6
+Subject: [PATCH 3/9] disabled any mention of ipv6
 
 ---
  Makefile | 6 +++---
@@ -1362,7 +1362,7 @@ index 94fcafc..6efa141 100644
 From a653d818348fef0130e6e497eecb0c3a35822df4 Mon Sep 17 00:00:00 2001
 From: Jay Doyle <jay.doyle@vecna.com>
 Date: Mon, 7 Sep 2015 09:27:48 -0400
-Subject: [PATCH 04/13] added in stm32f low-level driver
+Subject: [PATCH 4/9] added in stm32f low-level driver
 
 ---
  src/netif/ethernetif.c | 709 ++++++++++++++++++++++++++++++-------------------
@@ -2150,7 +2150,7 @@ index 7982d11..82c85ae 100644
 From ab97b49d1d41e34fdfdfb457b397c768ee228c9f Mon Sep 17 00:00:00 2001
 From: Jay Doyle <jay.doyle@vecna.com>
 Date: Mon, 7 Sep 2015 09:39:20 -0400
-Subject: [PATCH 05/13] removed ethernetif (it should be in BSP
+Subject: [PATCH 5/9] removed ethernetif (it should be in BSP
 
 ---
  src/netif/ethernetif.c | 496 -------------------------------------------------
@@ -2666,7 +2666,7 @@ index 82c85ae..0000000
 From 31d34fab26b1e3fde99fe7288786725fe5e51b95 Mon Sep 17 00:00:00 2001
 From: Jay Doyle <jay.doyle@vecna.com>
 Date: Mon, 7 Sep 2015 10:17:32 -0400
-Subject: [PATCH 06/13] add low level driver back
+Subject: [PATCH 6/9] add low level driver back
 
 ---
  src/netif/ethernetif.c | 496 +++++++++++++++++++++++++++++++++++++++++++++++++
@@ -3182,7 +3182,7 @@ index 0000000..bc429e9
 From 81eded01bb2bc35a9b627e5cf35b2021efb5972c Mon Sep 17 00:00:00 2001
 From: Jay Doyle <jay.doyle@vecna.com>
 Date: Mon, 7 Sep 2015 10:22:57 -0400
-Subject: [PATCH 07/13] Added bsp path
+Subject: [PATCH 7/9] Added bsp path
 
 ---
  Makefile | 4 +++-
@@ -3217,7 +3217,7 @@ index 6efa141..a855d9f 100644
 From f114529d5af1e2a83b49b67d631b10c02648e8d8 Mon Sep 17 00:00:00 2001
 From: Jay Doyle <jay.doyle@vecna.com>
 Date: Mon, 7 Sep 2015 10:54:26 -0400
-Subject: [PATCH 08/13] removed ethernetif.c
+Subject: [PATCH 8/9] removed ethernetif.c
 
 ---
  src/netif/ethernetif.c | 496 -------------------------------------------------
@@ -3730,376 +3730,28 @@ index bc429e9..0000000
 1.9.1
 
 
-From 8f652ac0f1be0f2abc1493981763fc4c402bbfed Mon Sep 17 00:00:00 2001
+From badcd5771d8fa3046a2cd7aa07536c6dcb703891 Mon Sep 17 00:00:00 2001
 From: Jay Doyle <jay.doyle@vecna.com>
-Date: Wed, 16 Sep 2015 09:29:27 -0400
-Subject: [PATCH 09/13] using options from sample project
+Date: Mon, 28 Sep 2015 13:47:22 -0400
+Subject: [PATCH 9/9] enable BSD sockets naming
 
 ---
- ports/include/lwipopts.h | 207 +++++++++++++++++++++++++++++++++++++++++++++++
- 1 file changed, 207 insertions(+)
-
-diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
-index 169ba46..68d799b 100644
---- a/ports/include/lwipopts.h
-+++ b/ports/include/lwipopts.h
-@@ -38,6 +38,9 @@
- #ifndef __LWIPOPTS_H__
- #define __LWIPOPTS_H__
- 
-+
-+#if ORIGINAL_CONFIG_OPTIONS
-+
- /*****************************************************************************
- **                           CONFIGURATIONS
- *****************************************************************************/
-@@ -175,4 +178,208 @@
- 
-  #define LWIP_RAW                       0
- 
-+#else
-+
-+/**
-+ * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
-+ * critical regions during buffer allocation, deallocation and memory
-+ * allocation and deallocation.
-+ */
-+#define SYS_LIGHTWEIGHT_PROT    0
-+
-+#define ETHARP_TRUST_IP_MAC     0
-+#define IP_REASSEMBLY           0
-+#define IP_FRAG                 0
-+#define ARP_QUEUEING            0
-+#define TCP_LISTEN_BACKLOG      1
-+
-+/**
-+ * NO_SYS==1: Provides VERY minimal functionality. Otherwise,
-+ * use lwIP facilities.
-+ */
-+#define NO_SYS                  0
-+
-+/* ---------- Memory options ---------- */
-+/* MEM_ALIGNMENT: should be set to the alignment of the CPU for which
-+   lwIP is compiled. 4 byte alignment -> define MEM_ALIGNMENT to 4, 2
-+   byte alignment -> define MEM_ALIGNMENT to 2. */
-+#define MEM_ALIGNMENT           4
-+
-+/* MEM_SIZE: the size of the heap memory. If the application will send
-+a lot of data that needs to be copied, this should be set high. */
-+#define MEM_SIZE                (10*1024)
-+
-+/* MEMP_NUM_PBUF: the number of memp struct pbufs. If the application
-+   sends a lot of data out of ROM (or other static memory), this
-+   should be set high. */
-+#define MEMP_NUM_PBUF           50
-+/* MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks. One
-+   per active UDP "connection". */
-+#define MEMP_NUM_UDP_PCB        6
-+/* MEMP_NUM_TCP_PCB: the number of simulatenously active TCP
-+   connections. */
-+#define MEMP_NUM_TCP_PCB        10
-+/* MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP
-+   connections. */
-+#define MEMP_NUM_TCP_PCB_LISTEN 5
-+/* MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP
-+   segments. */
-+#define MEMP_NUM_TCP_SEG        12
-+/* MEMP_NUM_SYS_TIMEOUT: the number of simulateously active
-+   timeouts. */
-+#define MEMP_NUM_SYS_TIMEOUT    10
-+
-+
-+/* ---------- Pbuf options ---------- */
-+/* PBUF_POOL_SIZE: the number of buffers in the pbuf pool. */
-+#define PBUF_POOL_SIZE          10
-+
-+/* PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. */
-+#define PBUF_POOL_BUFSIZE       1524
-+
-+
-+/* ---------- TCP options ---------- */
-+#define LWIP_TCP                1
-+#define TCP_TTL                 255
-+
-+/* Controls if TCP should queue segments that arrive out of
-+   order. Define to 0 if your device is low on memory. */
-+#define TCP_QUEUE_OOSEQ         0
-+
-+/* TCP Maximum segment size. */
-+#define TCP_MSS                 (1500 - 40)   /* TCP_MSS = (Ethernet MTU - IP header size - TCP header size) */
-+
-+/* TCP sender buffer space (bytes). */
-+#define TCP_SND_BUF             (4*TCP_MSS)
-+
-+/*  TCP_SND_QUEUELEN: TCP sender buffer space (pbufs). This must be at least
-+  as much as (2 * TCP_SND_BUF/TCP_MSS) for things to work. */
-+
-+#define TCP_SND_QUEUELEN        (2* TCP_SND_BUF/TCP_MSS)
-+
-+/* TCP receive window. */
-+#define TCP_WND                 (2*TCP_MSS)
-+
-+
-+/* ---------- ICMP options ---------- */
-+#define LWIP_ICMP                       1
-+
-+
-+/* ---------- DHCP options ---------- */
-+/* Define LWIP_DHCP to 1 if you want DHCP configuration of
-+   interfaces. DHCP is not implemented in lwIP 0.5.1, however, so
-+   turning this on does currently not work. */
-+#define LWIP_DHCP               1
-+
-+
-+/* ---------- UDP options ---------- */
-+#define LWIP_UDP                1
-+#define UDP_TTL                 255
-+
-+
-+/* ---------- Statistics options ---------- */
-+#define LWIP_STATS 0
-+#define LWIP_PROVIDE_ERRNO 1
-+
-+/* ---------- link callback options ---------- */
-+/* LWIP_NETIF_LINK_CALLBACK==1: Support a callback function from an interface
-+ * whenever the link changes (i.e., link down)
-+ */
-+#define LWIP_NETIF_LINK_CALLBACK        1
-+
-+/*
-+   --------------------------------------
-+   ---------- Checksum options ----------
-+   --------------------------------------
-+*/
-+
-+/*
-+The STM32F4x7 allows computing and verifying the IP, UDP, TCP and ICMP checksums by hardware:
-+ - To use this feature let the following define uncommented.
-+ - To disable it and process by CPU comment the  the checksum.
-+*/
-+#define CHECKSUM_BY_HARDWARE
-+
-+
-+#ifdef CHECKSUM_BY_HARDWARE
-+  /* CHECKSUM_GEN_IP==0: Generate checksums by hardware for outgoing IP packets.*/
-+  #define CHECKSUM_GEN_IP                 0
-+  /* CHECKSUM_GEN_UDP==0: Generate checksums by hardware for outgoing UDP packets.*/
-+  #define CHECKSUM_GEN_UDP                0
-+  /* CHECKSUM_GEN_TCP==0: Generate checksums by hardware for outgoing TCP packets.*/
-+  #define CHECKSUM_GEN_TCP                0
-+  /* CHECKSUM_CHECK_IP==0: Check checksums by hardware for incoming IP packets.*/
-+  #define CHECKSUM_CHECK_IP               0
-+  /* CHECKSUM_CHECK_UDP==0: Check checksums by hardware for incoming UDP packets.*/
-+  #define CHECKSUM_CHECK_UDP              0
-+  /* CHECKSUM_CHECK_TCP==0: Check checksums by hardware for incoming TCP packets.*/
-+  #define CHECKSUM_CHECK_TCP              0
-+  /* CHECKSUM_CHECK_ICMP==0: Check checksums by hardware for incoming ICMP packets.*/
-+  #define CHECKSUM_GEN_ICMP               0
-+#else
-+  /* CHECKSUM_GEN_IP==1: Generate checksums in software for outgoing IP packets.*/
-+  #define CHECKSUM_GEN_IP                 1
-+  /* CHECKSUM_GEN_UDP==1: Generate checksums in software for outgoing UDP packets.*/
-+  #define CHECKSUM_GEN_UDP                1
-+  /* CHECKSUM_GEN_TCP==1: Generate checksums in software for outgoing TCP packets.*/
-+  #define CHECKSUM_GEN_TCP                1
-+  /* CHECKSUM_CHECK_IP==1: Check checksums in software for incoming IP packets.*/
-+  #define CHECKSUM_CHECK_IP               1
-+  /* CHECKSUM_CHECK_UDP==1: Check checksums in software for incoming UDP packets.*/
-+  #define CHECKSUM_CHECK_UDP              1
-+  /* CHECKSUM_CHECK_TCP==1: Check checksums in software for incoming TCP packets.*/
-+  #define CHECKSUM_CHECK_TCP              1
-+  /* CHECKSUM_CHECK_ICMP==1: Check checksums by hardware for incoming ICMP packets.*/
-+  #define CHECKSUM_GEN_ICMP               1
-+#endif
-+
-+
-+/*
-+   ----------------------------------------------
-+   ---------- Sequential layer options ----------
-+   ----------------------------------------------
-+*/
-+/**
-+ * LWIP_NETCONN==1: Enable Netconn API (require to use api_lib.c)
-+ */
-+#define LWIP_NETCONN                    1
-+
-+/*
-+   ------------------------------------
-+   ---------- Socket options ----------
-+   ------------------------------------
-+*/
-+/**
-+ * LWIP_SOCKET==1: Enable Socket API (require to use sockets.c)
-+ */
-+#define LWIP_SOCKET                     1
-+
-+/*
-+   -----------------------------------
-+   ---------- DEBUG options ----------
-+   -----------------------------------
-+*/
-+
-+#define LWIP_DEBUG                      0
-+
-+
-+/*
-+   ---------------------------------
-+   ---------- OS options ----------
-+   ---------------------------------
-+*/
-+
-+#define TCPIP_THREAD_NAME              "TCP/IP"
-+#define TCPIP_THREAD_STACKSIZE          1000
-+#define TCPIP_MBOX_SIZE                 5
-+#define DEFAULT_UDP_RECVMBOX_SIZE       2000
-+#define DEFAULT_TCP_RECVMBOX_SIZE       2000
-+#define DEFAULT_ACCEPTMBOX_SIZE         2000
-+#define DEFAULT_THREAD_STACKSIZE        500
-+#define TCPIP_THREAD_PRIO               (configMAX_PRIORITIES - 2)
-+#define LWIP_COMPAT_MUTEX               1
-+
-+
-+#endif
-+
- #endif /* __LWIPOPTS_H__ */
--- 
-1.9.1
-
-
-From d2624890161b1ec246cd224de8079157367a6346 Mon Sep 17 00:00:00 2001
-From: Jay Doyle <jay.doyle@vecna.com>
-Date: Wed, 16 Sep 2015 10:01:58 -0400
-Subject: [PATCH 10/13] added cache line configuration
-
----
- ports/include/lwipopts.h | 3 +++
- 1 file changed, 3 insertions(+)
-
-diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
-index 68d799b..049d66d 100644
---- a/ports/include/lwipopts.h
-+++ b/ports/include/lwipopts.h
-@@ -180,6 +180,9 @@
- 
- #else
- 
-+#define LWIP_CACHE_ENABLED
-+#define SOC_CACHELINE_SIZE_BYTES 32
-+
- /**
-  * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
-  * critical regions during buffer allocation, deallocation and memory
--- 
-1.9.1
-
-
-From 37e5b73c865357e530226ea2a2008aa355f58d55 Mon Sep 17 00:00:00 2001
-From: Jay Doyle <jay.doyle@vecna.com>
-Date: Wed, 16 Sep 2015 10:11:20 -0400
-Subject: [PATCH 11/13] configured for local time structure definition
-
----
- ports/include/arch/cc.h  | 2 ++
- ports/include/lwipopts.h | 1 +
- 2 files changed, 3 insertions(+)
-
-diff --git a/ports/include/arch/cc.h b/ports/include/arch/cc.h
-index 04ec89f..900e9b6 100644
---- a/ports/include/arch/cc.h
-+++ b/ports/include/arch/cc.h
-@@ -32,6 +32,8 @@
- #ifndef __CC_H__
- #define __CC_H__
- 
-+#include <sys/time.h>
-+
- typedef unsigned    char    u8_t;
- typedef signed      char    s8_t;
- typedef unsigned    short   u16_t;
-diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
-index 049d66d..05f5b52 100644
---- a/ports/include/lwipopts.h
-+++ b/ports/include/lwipopts.h
-@@ -182,6 +182,7 @@
- 
- #define LWIP_CACHE_ENABLED
- #define SOC_CACHELINE_SIZE_BYTES 32
-+#define LWIP_TIMEVAL_PRIVATE 0
- 
- /**
-  * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
--- 
-1.9.1
-
-
-From 9a72a789d145f794b8a4c1084ed50597b71c6e2b Mon Sep 17 00:00:00 2001
-From: Jay Doyle <jay.doyle@vecna.com>
-Date: Wed, 16 Sep 2015 10:16:55 -0400
-Subject: [PATCH 12/13] remove include from cc.h
-
----
- ports/include/arch/cc.h | 4 ++--
- 1 file changed, 2 insertions(+), 2 deletions(-)
-
-diff --git a/ports/include/arch/cc.h b/ports/include/arch/cc.h
-index 900e9b6..8eefd64 100644
---- a/ports/include/arch/cc.h
-+++ b/ports/include/arch/cc.h
-@@ -32,8 +32,6 @@
- #ifndef __CC_H__
- #define __CC_H__
- 
--#include <sys/time.h>
--
- typedef unsigned    char    u8_t;
- typedef signed      char    s8_t;
- typedef unsigned    short   u16_t;
-@@ -104,6 +102,8 @@ extern u8_t memp_memory_PBUF_POOL_base[] __attribute__ ((aligned (SOC_CACHELINE_
- #include <stdio.h>
- #include <stdlib.h>
- #include <bsp.h>
-+//#include <sys/time.h>
-+
- #define LWIP_PLATFORM_DIAG(x)   do { \
-         printk("[%s - %s - %d] ", __PRETTY_FUNCTION__, __FILE__, __LINE__); \
-         printk x; \
--- 
-1.9.1
-
-
-From a48846deb25945d360543ffe8d86766d323b9859 Mon Sep 17 00:00:00 2001
-From: Jay Doyle <jay.doyle@vecna.com>
-Date: Fri, 18 Sep 2015 13:22:21 -0400
-Subject: [PATCH 13/13] turn off checksum checking by hardware
-
----
- ports/include/lwipopts.h | 6 +++---
- 1 file changed, 3 insertions(+), 3 deletions(-)
+ ports/include/lwipopts.h | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
 diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
-index 05f5b52..cf11793 100644
+index 169ba46..9149c29 100644
 --- a/ports/include/lwipopts.h
 +++ b/ports/include/lwipopts.h
-@@ -243,8 +243,8 @@ a lot of data that needs to be copied, this should be set high. */
- 
- 
- /* ---------- TCP options ---------- */
--#define LWIP_TCP                1
--#define TCP_TTL                 255
-+//#define LWIP_TCP                1
-+//#define TCP_TTL                 255
- 
- /* Controls if TCP should queue segments that arrive out of
-    order. Define to 0 if your device is low on memory. */
-@@ -302,7 +302,7 @@ The STM32F4x7 allows computing and verifying the IP, UDP, TCP and ICMP checksums
-  - To use this feature let the following define uncommented.
-  - To disable it and process by CPU comment the  the checksum.
- */
--#define CHECKSUM_BY_HARDWARE
-+//#define CHECKSUM_BY_HARDWARE
+@@ -169,7 +169,7 @@
+  * LWIP_COMPAT_SOCKETS==1: Enable BSD-style sockets functions names.
+  * (only used if you use sockets.c)
+  */
+-#define LWIP_COMPAT_SOCKETS             0
++#define LWIP_COMPAT_SOCKETS             1
  
+ #define LWIP_TIMEVAL_PRIVATE            0
  
- #ifdef CHECKSUM_BY_HARDWARE
 -- 
 1.9.1
 
-- 
1.9.1


From fe6c775ab3ffb3ae4e2f8fa18bec1ad745e9dca2 Mon Sep 17 00:00:00 2001
From: Jay Doyle <jay.doyle@vecna.com>
Date: Mon, 28 Sep 2015 16:36:49 -0400
Subject: [PATCH 19/33] updated patch

---
 rtems.patch | 4184 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 4172 insertions(+), 12 deletions(-)

diff --git a/rtems.patch b/rtems.patch
index c088510..1d3b090 100644
--- a/rtems.patch
+++ b/rtems.patch
@@ -1,7 +1,7 @@
 From 2d83d4994e578ec339b2b1baef53090bf7a53570 Mon Sep 17 00:00:00 2001
 From: Jay Doyle <jay.doyle@vecna.com>
 Date: Fri, 4 Sep 2015 17:28:55 -0400
-Subject: [PATCH 1/9] rtems changes necessary
+Subject: [PATCH 01/10] rtems changes necessary
 
 ---
  Makefile                      | 170 +++++++++++
@@ -1292,7 +1292,7 @@ index 0000000..360a4e2
 From d053fa836b445b6736bf82d33a33a59055150aa7 Mon Sep 17 00:00:00 2001
 From: Jay Doyle <jay.doyle@vecna.com>
 Date: Fri, 4 Sep 2015 17:30:37 -0400
-Subject: [PATCH 2/9] changed the compiler options
+Subject: [PATCH 02/10] changed the compiler options
 
 ---
  Makefile | 2 +-
@@ -1318,7 +1318,7 @@ index 0cbae64..94fcafc 100644
 From 841adb17430bdb9298dcb6d44ac5dad72e82af80 Mon Sep 17 00:00:00 2001
 From: Jay Doyle <jay.doyle@vecna.com>
 Date: Mon, 7 Sep 2015 08:56:58 -0400
-Subject: [PATCH 3/9] disabled any mention of ipv6
+Subject: [PATCH 03/10] disabled any mention of ipv6
 
 ---
  Makefile | 6 +++---
@@ -1362,7 +1362,7 @@ index 94fcafc..6efa141 100644
 From a653d818348fef0130e6e497eecb0c3a35822df4 Mon Sep 17 00:00:00 2001
 From: Jay Doyle <jay.doyle@vecna.com>
 Date: Mon, 7 Sep 2015 09:27:48 -0400
-Subject: [PATCH 4/9] added in stm32f low-level driver
+Subject: [PATCH 04/10] added in stm32f low-level driver
 
 ---
  src/netif/ethernetif.c | 709 ++++++++++++++++++++++++++++++-------------------
@@ -2150,7 +2150,7 @@ index 7982d11..82c85ae 100644
 From ab97b49d1d41e34fdfdfb457b397c768ee228c9f Mon Sep 17 00:00:00 2001
 From: Jay Doyle <jay.doyle@vecna.com>
 Date: Mon, 7 Sep 2015 09:39:20 -0400
-Subject: [PATCH 5/9] removed ethernetif (it should be in BSP
+Subject: [PATCH 05/10] removed ethernetif (it should be in BSP
 
 ---
  src/netif/ethernetif.c | 496 -------------------------------------------------
@@ -2666,7 +2666,7 @@ index 82c85ae..0000000
 From 31d34fab26b1e3fde99fe7288786725fe5e51b95 Mon Sep 17 00:00:00 2001
 From: Jay Doyle <jay.doyle@vecna.com>
 Date: Mon, 7 Sep 2015 10:17:32 -0400
-Subject: [PATCH 6/9] add low level driver back
+Subject: [PATCH 06/10] add low level driver back
 
 ---
  src/netif/ethernetif.c | 496 +++++++++++++++++++++++++++++++++++++++++++++++++
@@ -3182,7 +3182,7 @@ index 0000000..bc429e9
 From 81eded01bb2bc35a9b627e5cf35b2021efb5972c Mon Sep 17 00:00:00 2001
 From: Jay Doyle <jay.doyle@vecna.com>
 Date: Mon, 7 Sep 2015 10:22:57 -0400
-Subject: [PATCH 7/9] Added bsp path
+Subject: [PATCH 07/10] Added bsp path
 
 ---
  Makefile | 4 +++-
@@ -3217,7 +3217,7 @@ index 6efa141..a855d9f 100644
 From f114529d5af1e2a83b49b67d631b10c02648e8d8 Mon Sep 17 00:00:00 2001
 From: Jay Doyle <jay.doyle@vecna.com>
 Date: Mon, 7 Sep 2015 10:54:26 -0400
-Subject: [PATCH 8/9] removed ethernetif.c
+Subject: [PATCH 08/10] removed ethernetif.c
 
 ---
  src/netif/ethernetif.c | 496 -------------------------------------------------
@@ -3730,20 +3730,256 @@ index bc429e9..0000000
 1.9.1
 
 
-From badcd5771d8fa3046a2cd7aa07536c6dcb703891 Mon Sep 17 00:00:00 2001
+From 8f652ac0f1be0f2abc1493981763fc4c402bbfed Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Wed, 16 Sep 2015 09:29:27 -0400
+Subject: [PATCH 09/13] using options from sample project
+
+---
+ ports/include/lwipopts.h | 207 +++++++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 207 insertions(+)
+
+diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
+index 169ba46..68d799b 100644
+--- a/ports/include/lwipopts.h
++++ b/ports/include/lwipopts.h
+@@ -38,6 +38,9 @@
+ #ifndef __LWIPOPTS_H__
+ #define __LWIPOPTS_H__
+ 
++
++#if ORIGINAL_CONFIG_OPTIONS
++
+ /*****************************************************************************
+ **                           CONFIGURATIONS
+ *****************************************************************************/
+@@ -175,4 +178,208 @@
+ 
+  #define LWIP_RAW                       0
+ 
++#else
++
++/**
++ * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
++ * critical regions during buffer allocation, deallocation and memory
++ * allocation and deallocation.
++ */
++#define SYS_LIGHTWEIGHT_PROT    0
++
++#define ETHARP_TRUST_IP_MAC     0
++#define IP_REASSEMBLY           0
++#define IP_FRAG                 0
++#define ARP_QUEUEING            0
++#define TCP_LISTEN_BACKLOG      1
++
++/**
++ * NO_SYS==1: Provides VERY minimal functionality. Otherwise,
++ * use lwIP facilities.
++ */
++#define NO_SYS                  0
++
++/* ---------- Memory options ---------- */
++/* MEM_ALIGNMENT: should be set to the alignment of the CPU for which
++   lwIP is compiled. 4 byte alignment -> define MEM_ALIGNMENT to 4, 2
++   byte alignment -> define MEM_ALIGNMENT to 2. */
++#define MEM_ALIGNMENT           4
++
++/* MEM_SIZE: the size of the heap memory. If the application will send
++a lot of data that needs to be copied, this should be set high. */
++#define MEM_SIZE                (10*1024)
++
++/* MEMP_NUM_PBUF: the number of memp struct pbufs. If the application
++   sends a lot of data out of ROM (or other static memory), this
++   should be set high. */
++#define MEMP_NUM_PBUF           50
++/* MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks. One
++   per active UDP "connection". */
++#define MEMP_NUM_UDP_PCB        6
++/* MEMP_NUM_TCP_PCB: the number of simulatenously active TCP
++   connections. */
++#define MEMP_NUM_TCP_PCB        10
++/* MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP
++   connections. */
++#define MEMP_NUM_TCP_PCB_LISTEN 5
++/* MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP
++   segments. */
++#define MEMP_NUM_TCP_SEG        12
++/* MEMP_NUM_SYS_TIMEOUT: the number of simulateously active
++   timeouts. */
++#define MEMP_NUM_SYS_TIMEOUT    10
++
++
++/* ---------- Pbuf options ---------- */
++/* PBUF_POOL_SIZE: the number of buffers in the pbuf pool. */
++#define PBUF_POOL_SIZE          10
++
++/* PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. */
++#define PBUF_POOL_BUFSIZE       1524
++
++
++/* ---------- TCP options ---------- */
++#define LWIP_TCP                1
++#define TCP_TTL                 255
++
++/* Controls if TCP should queue segments that arrive out of
++   order. Define to 0 if your device is low on memory. */
++#define TCP_QUEUE_OOSEQ         0
++
++/* TCP Maximum segment size. */
++#define TCP_MSS                 (1500 - 40)   /* TCP_MSS = (Ethernet MTU - IP header size - TCP header size) */
++
++/* TCP sender buffer space (bytes). */
++#define TCP_SND_BUF             (4*TCP_MSS)
++
++/*  TCP_SND_QUEUELEN: TCP sender buffer space (pbufs). This must be at least
++  as much as (2 * TCP_SND_BUF/TCP_MSS) for things to work. */
++
++#define TCP_SND_QUEUELEN        (2* TCP_SND_BUF/TCP_MSS)
++
++/* TCP receive window. */
++#define TCP_WND                 (2*TCP_MSS)
++
++
++/* ---------- ICMP options ---------- */
++#define LWIP_ICMP                       1
++
++
++/* ---------- DHCP options ---------- */
++/* Define LWIP_DHCP to 1 if you want DHCP configuration of
++   interfaces. DHCP is not implemented in lwIP 0.5.1, however, so
++   turning this on does currently not work. */
++#define LWIP_DHCP               1
++
++
++/* ---------- UDP options ---------- */
++#define LWIP_UDP                1
++#define UDP_TTL                 255
++
++
++/* ---------- Statistics options ---------- */
++#define LWIP_STATS 0
++#define LWIP_PROVIDE_ERRNO 1
++
++/* ---------- link callback options ---------- */
++/* LWIP_NETIF_LINK_CALLBACK==1: Support a callback function from an interface
++ * whenever the link changes (i.e., link down)
++ */
++#define LWIP_NETIF_LINK_CALLBACK        1
++
++/*
++   --------------------------------------
++   ---------- Checksum options ----------
++   --------------------------------------
++*/
++
++/*
++The STM32F4x7 allows computing and verifying the IP, UDP, TCP and ICMP checksums by hardware:
++ - To use this feature let the following define uncommented.
++ - To disable it and process by CPU comment the  the checksum.
++*/
++#define CHECKSUM_BY_HARDWARE
++
++
++#ifdef CHECKSUM_BY_HARDWARE
++  /* CHECKSUM_GEN_IP==0: Generate checksums by hardware for outgoing IP packets.*/
++  #define CHECKSUM_GEN_IP                 0
++  /* CHECKSUM_GEN_UDP==0: Generate checksums by hardware for outgoing UDP packets.*/
++  #define CHECKSUM_GEN_UDP                0
++  /* CHECKSUM_GEN_TCP==0: Generate checksums by hardware for outgoing TCP packets.*/
++  #define CHECKSUM_GEN_TCP                0
++  /* CHECKSUM_CHECK_IP==0: Check checksums by hardware for incoming IP packets.*/
++  #define CHECKSUM_CHECK_IP               0
++  /* CHECKSUM_CHECK_UDP==0: Check checksums by hardware for incoming UDP packets.*/
++  #define CHECKSUM_CHECK_UDP              0
++  /* CHECKSUM_CHECK_TCP==0: Check checksums by hardware for incoming TCP packets.*/
++  #define CHECKSUM_CHECK_TCP              0
++  /* CHECKSUM_CHECK_ICMP==0: Check checksums by hardware for incoming ICMP packets.*/
++  #define CHECKSUM_GEN_ICMP               0
++#else
++  /* CHECKSUM_GEN_IP==1: Generate checksums in software for outgoing IP packets.*/
++  #define CHECKSUM_GEN_IP                 1
++  /* CHECKSUM_GEN_UDP==1: Generate checksums in software for outgoing UDP packets.*/
++  #define CHECKSUM_GEN_UDP                1
++  /* CHECKSUM_GEN_TCP==1: Generate checksums in software for outgoing TCP packets.*/
++  #define CHECKSUM_GEN_TCP                1
++  /* CHECKSUM_CHECK_IP==1: Check checksums in software for incoming IP packets.*/
++  #define CHECKSUM_CHECK_IP               1
++  /* CHECKSUM_CHECK_UDP==1: Check checksums in software for incoming UDP packets.*/
++  #define CHECKSUM_CHECK_UDP              1
++  /* CHECKSUM_CHECK_TCP==1: Check checksums in software for incoming TCP packets.*/
++  #define CHECKSUM_CHECK_TCP              1
++  /* CHECKSUM_CHECK_ICMP==1: Check checksums by hardware for incoming ICMP packets.*/
++  #define CHECKSUM_GEN_ICMP               1
++#endif
++
++
++/*
++   ----------------------------------------------
++   ---------- Sequential layer options ----------
++   ----------------------------------------------
++*/
++/**
++ * LWIP_NETCONN==1: Enable Netconn API (require to use api_lib.c)
++ */
++#define LWIP_NETCONN                    1
++
++/*
++   ------------------------------------
++   ---------- Socket options ----------
++   ------------------------------------
++*/
++/**
++ * LWIP_SOCKET==1: Enable Socket API (require to use sockets.c)
++ */
++#define LWIP_SOCKET                     1
++
++/*
++   -----------------------------------
++   ---------- DEBUG options ----------
++   -----------------------------------
++*/
++
++#define LWIP_DEBUG                      0
++
++
++/*
++   ---------------------------------
++   ---------- OS options ----------
++   ---------------------------------
++*/
++
++#define TCPIP_THREAD_NAME              "TCP/IP"
++#define TCPIP_THREAD_STACKSIZE          1000
++#define TCPIP_MBOX_SIZE                 5
++#define DEFAULT_UDP_RECVMBOX_SIZE       2000
++#define DEFAULT_TCP_RECVMBOX_SIZE       2000
++#define DEFAULT_ACCEPTMBOX_SIZE         2000
++#define DEFAULT_THREAD_STACKSIZE        500
++#define TCPIP_THREAD_PRIO               (configMAX_PRIORITIES - 2)
++#define LWIP_COMPAT_MUTEX               1
++
++
++#endif
++
+ #endif /* __LWIPOPTS_H__ */
+-- 
+1.9.1
+
+
+From c5a4114e1f21fe408301a2e5a8ae3a3f22fdea0f Mon Sep 17 00:00:00 2001
 From: Jay Doyle <jay.doyle@vecna.com>
 Date: Mon, 28 Sep 2015 13:47:22 -0400
-Subject: [PATCH 9/9] enable BSD sockets naming
+Subject: [PATCH 09/10] enable BSD sockets naming
 
 ---
  ports/include/lwipopts.h | 2 +-
  1 file changed, 1 insertion(+), 1 deletion(-)
 
 diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
-index 169ba46..9149c29 100644
+index 68d799b..40170c3 100644
 --- a/ports/include/lwipopts.h
 +++ b/ports/include/lwipopts.h
-@@ -169,7 +169,7 @@
+@@ -172,7 +172,7 @@
   * LWIP_COMPAT_SOCKETS==1: Enable BSD-style sockets functions names.
   * (only used if you use sockets.c)
   */
@@ -3755,3 +3991,3927 @@ index 169ba46..9149c29 100644
 -- 
 1.9.1
 
+
+From db7b9a1f9d9d2cba75a14e49e393c88e199ead20 Mon Sep 17 00:00:00 2001
+Subject: [PATCH 10/10] corrected cache line size
+index 9149c29..7b44db3 100644
+@@ -50,7 +50,7 @@
+-- 
+1.9.1
+
+
+From 35d7bb6c5d762616e71c785143ac2fb3c7c3ae86 Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Mon, 28 Sep 2015 16:21:35 -0400
+Subject: [PATCH 12/13] patch file update
+
+---
+ rtems.patch | 3809 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-
+ 1 file changed, 3800 insertions(+), 9 deletions(-)
+
+diff --git a/rtems.patch b/rtems.patch
+index c088510..3ec5fb0 100644
+--- a/rtems.patch
++++ b/rtems.patch
+@@ -1,7 +1,7 @@
+ From 2d83d4994e578ec339b2b1baef53090bf7a53570 Mon Sep 17 00:00:00 2001
+ From: Jay Doyle <jay.doyle@vecna.com>
+ Date: Fri, 4 Sep 2015 17:28:55 -0400
+-Subject: [PATCH 1/9] rtems changes necessary
++Subject: [PATCH 01/10] rtems changes necessary
+ 
+ ---
+  Makefile                      | 170 +++++++++++
+@@ -1292,7 +1292,7 @@ index 0000000..360a4e2
+ From d053fa836b445b6736bf82d33a33a59055150aa7 Mon Sep 17 00:00:00 2001
+ From: Jay Doyle <jay.doyle@vecna.com>
+ Date: Fri, 4 Sep 2015 17:30:37 -0400
+-Subject: [PATCH 2/9] changed the compiler options
++Subject: [PATCH 02/10] changed the compiler options
+ 
+ ---
+  Makefile | 2 +-
+@@ -1318,7 +1318,7 @@ index 0cbae64..94fcafc 100644
+ From 841adb17430bdb9298dcb6d44ac5dad72e82af80 Mon Sep 17 00:00:00 2001
+ From: Jay Doyle <jay.doyle@vecna.com>
+ Date: Mon, 7 Sep 2015 08:56:58 -0400
+-Subject: [PATCH 3/9] disabled any mention of ipv6
++Subject: [PATCH 03/10] disabled any mention of ipv6
+ 
+ ---
+  Makefile | 6 +++---
+@@ -1362,7 +1362,7 @@ index 94fcafc..6efa141 100644
+ From a653d818348fef0130e6e497eecb0c3a35822df4 Mon Sep 17 00:00:00 2001
+ From: Jay Doyle <jay.doyle@vecna.com>
+ Date: Mon, 7 Sep 2015 09:27:48 -0400
+-Subject: [PATCH 4/9] added in stm32f low-level driver
++Subject: [PATCH 04/10] added in stm32f low-level driver
+ 
+ ---
+  src/netif/ethernetif.c | 709 ++++++++++++++++++++++++++++++-------------------
+@@ -2150,7 +2150,7 @@ index 7982d11..82c85ae 100644
+ From ab97b49d1d41e34fdfdfb457b397c768ee228c9f Mon Sep 17 00:00:00 2001
+ From: Jay Doyle <jay.doyle@vecna.com>
+ Date: Mon, 7 Sep 2015 09:39:20 -0400
+-Subject: [PATCH 5/9] removed ethernetif (it should be in BSP
++Subject: [PATCH 05/10] removed ethernetif (it should be in BSP
+ 
+ ---
+  src/netif/ethernetif.c | 496 -------------------------------------------------
+@@ -2666,7 +2666,7 @@ index 82c85ae..0000000
+ From 31d34fab26b1e3fde99fe7288786725fe5e51b95 Mon Sep 17 00:00:00 2001
+ From: Jay Doyle <jay.doyle@vecna.com>
+ Date: Mon, 7 Sep 2015 10:17:32 -0400
+-Subject: [PATCH 6/9] add low level driver back
++Subject: [PATCH 06/10] add low level driver back
+ 
+ ---
+  src/netif/ethernetif.c | 496 +++++++++++++++++++++++++++++++++++++++++++++++++
+@@ -3182,7 +3182,7 @@ index 0000000..bc429e9
+ From 81eded01bb2bc35a9b627e5cf35b2021efb5972c Mon Sep 17 00:00:00 2001
+ From: Jay Doyle <jay.doyle@vecna.com>
+ Date: Mon, 7 Sep 2015 10:22:57 -0400
+-Subject: [PATCH 7/9] Added bsp path
++Subject: [PATCH 07/10] Added bsp path
+ 
+ ---
+  Makefile | 4 +++-
+@@ -3217,7 +3217,7 @@ index 6efa141..a855d9f 100644
+ From f114529d5af1e2a83b49b67d631b10c02648e8d8 Mon Sep 17 00:00:00 2001
+ From: Jay Doyle <jay.doyle@vecna.com>
+ Date: Mon, 7 Sep 2015 10:54:26 -0400
+-Subject: [PATCH 8/9] removed ethernetif.c
++Subject: [PATCH 08/10] removed ethernetif.c
+ 
+ ---
+  src/netif/ethernetif.c | 496 -------------------------------------------------
+@@ -3733,7 +3733,7 @@ index bc429e9..0000000
+ From badcd5771d8fa3046a2cd7aa07536c6dcb703891 Mon Sep 17 00:00:00 2001
+ From: Jay Doyle <jay.doyle@vecna.com>
+ Date: Mon, 28 Sep 2015 13:47:22 -0400
+-Subject: [PATCH 9/9] enable BSD sockets naming
++Subject: [PATCH 09/10] enable BSD sockets naming
+ 
+ ---
+  ports/include/lwipopts.h | 2 +-
+@@ -3755,3 +3755,3794 @@ index 169ba46..9149c29 100644
+ -- 
+ 1.9.1
+ 
++
++From db7b9a1f9d9d2cba75a14e49e393c88e199ead20 Mon Sep 17 00:00:00 2001
++From: Jay Doyle <jay.doyle@vecna.com>
++Date: Mon, 28 Sep 2015 15:28:28 -0400
++Subject: [PATCH 10/10] corrected cache line size
++
++---
++ ports/include/lwipopts.h |    2 +-
++ rtems.patch              | 3757 ++++++++++++++++++++++++++++++++++++++++++++++
++ 2 files changed, 3758 insertions(+), 1 deletion(-)
++ create mode 100644 rtems.patch
++
++diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
++index 9149c29..7b44db3 100644
++--- a/ports/include/lwipopts.h
+++++ b/ports/include/lwipopts.h
++@@ -50,7 +50,7 @@
++ */
++ /*#define LWIP_CACHE_ENABLED*/
++ 
++-#define SOC_CACHELINE_SIZE_BYTES        64            /* Number of bytes in
+++#define SOC_CACHELINE_SIZE_BYTES        32            /* Number of bytes in
++                                                          a cache line */
++ /*
++ ** The timeout for DHCP completion. lwIP library will wait for DHCP
++diff --git a/rtems.patch b/rtems.patch
++new file mode 100644
++index 0000000..c088510
++--- /dev/null
+++++ b/rtems.patch
++@@ -0,0 +1,3757 @@
+++From 2d83d4994e578ec339b2b1baef53090bf7a53570 Mon Sep 17 00:00:00 2001
+++From: Jay Doyle <jay.doyle@vecna.com>
+++Date: Fri, 4 Sep 2015 17:28:55 -0400
+++Subject: [PATCH 1/9] rtems changes necessary
+++
+++---
+++ Makefile                      | 170 +++++++++++
+++ ports/include/arch/cc.h       | 123 ++++++++
+++ ports/include/arch/perf.h     |  38 +++
+++ ports/include/arch/sys_arch.h |  59 ++++
+++ ports/include/lwipopts.h      | 178 ++++++++++++
+++ ports/sys_arch.c              | 663 ++++++++++++++++++++++++++++++++++++++++++
+++ 6 files changed, 1231 insertions(+)
+++ create mode 100644 Makefile
+++ create mode 100644 ports/include/arch/cc.h
+++ create mode 100644 ports/include/arch/perf.h
+++ create mode 100644 ports/include/arch/sys_arch.h
+++ create mode 100644 ports/include/lwipopts.h
+++ create mode 100644 ports/sys_arch.c
+++
+++diff --git a/Makefile b/Makefile
+++new file mode 100644
+++index 0000000..0cbae64
+++--- /dev/null
++++++ b/Makefile
+++@@ -0,0 +1,170 @@
++++include $(RTEMS_MAKEFILE_PATH)/Makefile.inc
++++include $(RTEMS_CUSTOM)
++++include $(PROJECT_ROOT)/make/leaf.cfg
++++
++++#### CONFIG ####################################################################
++++#For debugging symbols add -DLWIP_DEBUG
++++# COMPILER/LINKER
++++CFLAGS+=-g -O2   \
++++ -Wall
++++
++++# OUTPUT
++++LWIP_EXEC=lwip
++++
++++#### PATHS #####################################################################
++++
++++# LWIP
++++LWIP_PATH=.
++++LWIP_SRC_PATH=$(LWIP_PATH)/src
++++LWIP_API_PATH=$(LWIP_SRC_PATH)/api
++++LWIP_CORE_PATH=$(LWIP_SRC_PATH)/core
++++LWIP_INCL_PATH=$(LWIP_SRC_PATH)/include
++++LWIP_NETIF_PATH=$(LWIP_SRC_PATH)/netif
++++
++++# ARCH
++++LWIPARCH_PATH=$(LWIP_PATH)/ports
++++LWIPARCH_SRC_PATH=$(LWIPARCH_PATH)
++++LWIPARCH_INCL_PATH=$(LWIPARCH_PATH)/include
++++
++++# DRIVER
++++LWIPDRIVER_PATH=$(LWIP_PATH)/ports
++++LWIPDRIVER_SRC_PATH=$(LWIPDRIVER_PATH)/netif
++++LWIPDRIVER_INCL_PATH=$(LWIPDRIVER_PATH)/include/netif
++++
++++#### SOURCES ###################################################################
++++
++++## CORE
++++CORE_SRC=$(wildcard $(LWIP_CORE_PATH)/*.c)
++++
++++## IPv4
++++IPV4_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv4/*.c)
++++
++++## IPv6
++++IPV6_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv6/*.c)
++++
++++## SNMP
++++SNMP_SRC=$(wildcard $(LWIP_CORE_PATH)/snmp/*.c)
++++
++++## API
++++API_SRC=$(wildcard $(LWIP_API_PATH)/*.c )
++++
++++## NETIF
++++NETIF_SRC=$(wildcard $(LWIP_NETIF_PATH)/*.c) \
++++          $(wildcard $(LWIP_NETIF_PATH)/ppp/*.c) \
++++          $(wildcard $(LWIP_NETIF_PATH)/ppp/polarssl/*.c)
++++
++++
++++ARCH_SRC=$(wildcard $(LWIPARCH_SRC_PATH)/*.c)
++++
++++# DRIVER
++++DRIVER_SRC=$(wildcard $(LWIPDRIVER_SRC_PATH)/*.c ) \
++++           $(wildcard $(LWIPDRIVER_SRC_PATH)/*.S )
++++
++++
++++SOURCES =  $(DRIVER_SRC) $(SNMP_SRC)\
++++           $(CORE_SRC) $(IPV4_SRC) $(API_SRC) $(NETIF_SRC) $(ARCH_SRC)
++++
++++
++++#### HEADERS ###################################################################
++++
++++## CORE
++++CORE_H=$(LWIP_INCL_PATH)
++++
++++## IPv4
++++#IPV4_H=$(LWIP_INCL_PATH)/ipv4
++++
++++## IPv6
++++#IPV6_H=$(LWIP_INCL_PATH)/ipv6
++++
++++## POSIX
++++POSIX_H=$(LWIP_INCL_PATH)/posix
++++
++++##POSIX_SYS
++++POSIX_SYS_H=$(LWIP_INCL_PATH)/posix/sys
++++
++++
++++## NETIF
++++NETIF_H=$(LWIP_INCL_PATH)/netif
++++NETIF_H_PPP=$(LWIP_INCL_PATH)/netif/ppp
++++NETIF_H_PPP_POLARSSL=$(LWIP_INCL_PATH)/netif/ppp/polarssl
++++
++++## ARCH
++++ARCH_H=$(LWIPARCH_INCL_PATH)
++++
++++## DRIVER
++++DRIVER_H=$(LWIPDRIVER_INCL_PATH)
++++
++++# HEADERS
++++HEADERS=-I$(CORE_H) -I$(POSIX_H) -I$(POSIX_SYS_H) -I$(NETIF_H) \
++++        -I$(NETIF_H_PPP) -I$(NETIF_H_PPP_POLARSSL) -I$(ARCH_H) \
++++        -I$(DRIVER_H)
++++
++++
++++################################################################################
++++
++++
++++BIN=${ARCH}/$(LWIP_EXEC).bin
++++LIB=${ARCH}/lib$(LWIP_EXEC).a
++++
++++# optional managers required
++++MANAGERS=all
++++
++++# C source names
++++CSRCS=$(filter %.c ,$(SOURCES))
++++COBJS=$(patsubst %.c,${ARCH}/%.o,$(notdir $(CSRCS)))
++++
++++ASMSRCS=$(filter %.S , $(SOURCES))
++++ASMOBJS=$(patsubst %.S,${ARCH}/%.o,$(notdir $(ASMSRCS)))
++++
++++OBJS=$(COBJS) $(ASMOBJS)
++++
++++all:${ARCH} $(LIB)
++++
++++$(LIB): $(OBJS)
++++	$(AR)  rcs  $@ $^
++++
++++${ARCH}/%.o: $(LWIP_CORE_PATH)/%.c
++++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
++++
++++${ARCH}/%.o: $(LWIP_CORE_PATH)/ipv4/%.c
++++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
++++
++++${ARCH}/%.o: $(LWIP_CORE_PATH)/ipv6/%.c
++++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
++++
++++${ARCH}/%.o: $(LWIP_CORE_PATH)/snmp/%.c
++++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
++++
++++${ARCH}/%.o: $(LWIP_API_PATH)/%.c
++++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
++++
++++${ARCH}/%.o: $(LWIP_NETIF_PATH)/%.c
++++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
++++
++++${ARCH}/%.o: $(LWIP_NETIF_PATH)/ppp/%.c
++++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
++++
++++${ARCH}/%.o: $(LWIP_NETIF_PATH)/ppp/polarssl/%.c
++++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
++++
++++${ARCH}/%.o: $(LWIPARCH_SRC_PATH)/%.c
++++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
++++
++++${ARCH}/%.o: $(LWIPDRIVER_SRC_PATH)/%.S
++++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
++++
++++${ARCH}/%.o: $(LWIPDRIVER_SRC_PATH)/%.c
++++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
++++
++++INSTALL_DIR=$(RTEMS_MAKEFILE_PATH)/lwip
++++
++++install:
++++	rm -rf $(INSTALL_DIR)
++++	mkdir -p $(INSTALL_DIR)/include
++++	mkdir -p $(INSTALL_DIR)/lib
++++	cp $(LIB) $(INSTALL_DIR)/lib
++++	cp -r $(CORE_H) $(INSTALL_DIR)
++++	cp $(LWIPARCH_INCL_PATH)/lwipopts.h $(INSTALL_DIR)/include
++++	cp -r $(LWIPARCH_INCL_PATH)/arch $(INSTALL_DIR)/include
++++
++++CPPFLAGS+=$(HEADERS)
+++diff --git a/ports/include/arch/cc.h b/ports/include/arch/cc.h
+++new file mode 100644
+++index 0000000..04ec89f
+++--- /dev/null
++++++ b/ports/include/arch/cc.h
+++@@ -0,0 +1,123 @@
++++/*
++++ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
++++ * All rights reserved.
++++ *
++++ * Redistribution and use in source and binary forms, with or without modification,
++++ * are permitted provided that the following conditions are met:
++++ *
++++ * 1. Redistributions of source code must retain the above copyright notice,
++++ *    this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright notice,
++++ *    this list of conditions and the following disclaimer in the documentation
++++ *    and/or other materials provided with the distribution.
++++ * 3. The name of the author may not be used to endorse or promote products
++++ *    derived from this software without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
++++ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
++++ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
++++ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
++++ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
++++ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
++++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
++++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
++++ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
++++ * OF SUCH DAMAGE.
++++ *
++++ * This file is part of the lwIP TCP/IP stack.
++++ *
++++ * Author: Adam Dunkels <adam@sics.se>
++++ *
++++ */
++++#ifndef __CC_H__
++++#define __CC_H__
++++
++++typedef unsigned    char    u8_t;
++++typedef signed      char    s8_t;
++++typedef unsigned    short   u16_t;
++++typedef signed      short   s16_t;
++++typedef unsigned    int    u32_t;
++++typedef signed      int    s32_t;
++++typedef u32_t           mem_ptr_t;
++++
++++#ifndef BYTE_ORDER
++++#define BYTE_ORDER LITTLE_ENDIAN
++++#endif
++++
++++#if defined(__arm__) && defined(__ARMCC_VERSION)
++++    //
++++    // Setup PACKing macros for KEIL/RVMDK Tools
++++    //
++++    #define PACK_STRUCT_BEGIN __packed
++++    #define PACK_STRUCT_STRUCT
++++    #define PACK_STRUCT_END
++++    #define PACK_STRUCT_FIELD(x) x
++++#elif defined (__IAR_SYSTEMS_ICC__)
++++    //
++++    // Setup PACKing macros for IAR Tools
++++    //
++++    #define PACK_STRUCT_BEGIN
++++    #define PACK_STRUCT_STRUCT
++++    #define PACK_STRUCT_END
++++    #define PACK_STRUCT_FIELD(x) x
++++    #define PACK_STRUCT_USE_INCLUDES
++++#elif defined (__TMS470__)
++++    #define PACK_STRUCT_BEGIN
++++    #define PACK_STRUCT_STRUCT
++++    #define PACK_STRUCT_END
++++    #define PACK_STRUCT_FIELD(x) x
++++#else
++++    //
++++    // Setup PACKing macros for GCC Tools
++++    //
++++    #define PACK_STRUCT_BEGIN
++++    #define PACK_STRUCT_STRUCT __attribute__ ((__packed__))
++++    #define PACK_STRUCT_END
++++    #define PACK_STRUCT_FIELD(x) x
++++#endif
++++
++++#ifdef LWIP_CACHE_ENABLED
++++/**
++++ * Make the PBUF POOL cacheline aligned.
++++ */
++++#ifdef __IAR_SYSTEMS_ICC__
++++#pragma data_alignment=SOC_CACHELINE_SIZE_BYTES
++++extern u8_t memp_memory_PBUF_POOL_base[];
++++#else /*By default, GCC */
++++extern u8_t memp_memory_PBUF_POOL_base[] __attribute__ ((aligned (SOC_CACHELINE_SIZE_BYTES)));
++++#endif
++++#endif
++++
++++extern u8_t memp_memory_PBUF_POOL_base[] __attribute__ ((aligned (SOC_CACHELINE_SIZE_BYTES)));
++++
++++/* Define (sn)printf formatters for these lwIP types */
++++#define X8_F  "02x"
++++#define U16_F "u"
++++#define S16_F "d"
++++#define X16_F "x"
++++#define U32_F "u"
++++#define S32_F "d"
++++#define X32_F "x"
++++
++++#include <stdio.h>
++++#include <stdlib.h>
++++#include <bsp.h>
++++#define LWIP_PLATFORM_DIAG(x)   do { \
++++        printk("[%s - %s - %d] ", __PRETTY_FUNCTION__, __FILE__, __LINE__); \
++++        printk x; \
++++    } while(0)
++++
++++#ifdef LWIP_DEBUG  //DEBUG
++++extern void __error__(char *pcFilename, unsigned long ulLine);
++++#define LWIP_PLATFORM_ASSERT(expr)   printk("[%s - %s - %d] ", expr , __FILE__, __LINE__);
++++//{
++++    //if(!(expr))
++++    //{
++++        //__error__(__FILE__, __LINE__);
++++    //}
++++//}
++++#else
++++#define LWIP_PLATFORM_ASSERT(expr)
++++#endif
++++
++++#endif /* __CC_H__ */
+++diff --git a/ports/include/arch/perf.h b/ports/include/arch/perf.h
+++new file mode 100644
+++index 0000000..d754157
+++--- /dev/null
++++++ b/ports/include/arch/perf.h
+++@@ -0,0 +1,38 @@
++++/*
++++ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
++++ * All rights reserved.
++++ *
++++ * Redistribution and use in source and binary forms, with or without modification,
++++ * are permitted provided that the following conditions are met:
++++ *
++++ * 1. Redistributions of source code must retain the above copyright notice,
++++ *    this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright notice,
++++ *    this list of conditions and the following disclaimer in the documentation
++++ *    and/or other materials provided with the distribution.
++++ * 3. The name of the author may not be used to endorse or promote products
++++ *    derived from this software without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
++++ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
++++ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
++++ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
++++ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
++++ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
++++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
++++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
++++ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
++++ * OF SUCH DAMAGE.
++++ *
++++ * This file is part of the lwIP TCP/IP stack.
++++ *
++++ * Author: Adam Dunkels <adam@sics.se>
++++ *
++++ */
++++#ifndef __PERF_H__
++++#define __PERF_H__
++++
++++#define PERF_START    /* null definition */
++++#define PERF_STOP(x)  /* null definition */
++++
++++#endif /* __PERF_H__ */
+++diff --git a/ports/include/arch/sys_arch.h b/ports/include/arch/sys_arch.h
+++new file mode 100644
+++index 0000000..32f0d99
+++--- /dev/null
++++++ b/ports/include/arch/sys_arch.h
+++@@ -0,0 +1,59 @@
++++/*
++++ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
++++ * All rights reserved.
++++ *
++++ * Redistribution and use in source and binary forms, with or without modification,
++++ * are permitted provided that the following conditions are met:
++++ *
++++ * 1. Redistributions of source code must retain the above copyright notice,
++++ *    this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright notice,
++++ *    this list of conditions and the following disclaimer in the documentation
++++ *    and/or other materials provided with the distribution.
++++ * 3. The name of the author may not be used to endorse or promote products
++++ *    derived from this software without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
++++ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
++++ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
++++ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
++++ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
++++ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
++++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
++++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
++++ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
++++ * OF SUCH DAMAGE.
++++ *
++++ * This file is part of the lwIP TCP/IP stack.
++++ *
++++ * Author: Adam Dunkels <adam@sics.se>
++++ *
++++ */
++++#ifndef LWIP_ARCH_SYS_ARCH_H
++++#define LWIP_ARCH_SYS_ARCH_H
++++
++++#include <errno.h>
++++
++++#define SYS_MBOX_NULL NULL
++++#define SYS_SEM_NULL  NULL
++++
++++typedef u32_t sys_prot_t;
++++
++++struct sys_sem;
++++typedef struct sys_sem * sys_sem_t;
++++#define sys_sem_valid(sem) (((sem) != NULL) && (*(sem) != NULL))
++++#define sys_sem_set_invalid(sem) do { if((sem) != NULL) { *(sem) = NULL; }}while(0)
++++
++++/* let sys.h use binary semaphores for mutexes */
++++#define LWIP_COMPAT_MUTEX 1
++++
++++struct sys_mbox;
++++typedef struct sys_mbox *sys_mbox_t;
++++#define sys_mbox_valid(mbox) ((*(mbox) != NULL))
++++#define sys_mbox_set_invalid(mbox) do { if((mbox) != NULL) { *(mbox) = NULL; }}while(0)
++++
++++struct sys_thread;
++++typedef struct sys_thread * sys_thread_t;
++++
++++#endif /* LWIP_ARCH_SYS_ARCH_H */
++++
+++diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
+++new file mode 100644
+++index 0000000..169ba46
+++--- /dev/null
++++++ b/ports/include/lwipopts.h
+++@@ -0,0 +1,178 @@
++++/**
++++ * \file lwipopts.h - Configuration options for lwIP
++++ *
++++ * Copyright (c) 2010 Texas Instruments Incorporated
++++ */
++++/*
++++ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
++++ * All rights reserved.
++++ *
++++ * Redistribution and use in source and binary forms, with or without modification,
++++ * are permitted provided that the following conditions are met:
++++ *
++++ * 1. Redistributions of source code must retain the above copyright notice,
++++ *    this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright notice,
++++ *    this list of conditions and the following disclaimer in the documentation
++++ *    and/or other materials provided with the distribution.
++++ * 3. The name of the author may not be used to endorse or promote products
++++ *    derived from this software without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
++++ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
++++ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
++++ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
++++ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
++++ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
++++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
++++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
++++ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
++++ * OF SUCH DAMAGE.
++++ *
++++ * This file is part of the lwIP TCP/IP stack.
++++ *
++++ * Author: Adam Dunkels <adam@sics.se>
++++ *
++++ */
++++
++++#ifndef __LWIPOPTS_H__
++++#define __LWIPOPTS_H__
++++
++++/*****************************************************************************
++++**                           CONFIGURATIONS
++++*****************************************************************************/
++++
++++/*
++++** The below macro should be defined for using lwIP with cache. For cache
++++** enabling, pbuf pool shall be cache line aligned. This is done by using
++++** separate pool for each memory. The alignment of pbuf pool to cache line
++++** size is done in /ports/cpsw/include/arch/cc.h.
++++*/
++++/*#define LWIP_CACHE_ENABLED*/
++++
++++#define SOC_CACHELINE_SIZE_BYTES        64            /* Number of bytes in
++++                                                         a cache line */
++++/*
++++** The timeout for DHCP completion. lwIP library will wait for DHCP
++++** completion for (LWIP_DHCP_TIMEOUT / 100) seconds.
++++*/
++++#define LWIP_DHCP_TIMEOUT               500
++++
++++/*
++++** The number of times DHCP is attempted. Each time, the library will wait
++++** for (LWIP_DHCP_TIMEOUT / 100) seconds for DHCP completion.
++++*/
++++#define NUM_DHCP_TRIES                  5
++++
++++#define LWIP_ETHERNET                   1
++++#define LWIP_ARP                        1
++++
++++/*****************************************************************************
++++**            lwIP SPECIFIC DEFINITIONS - To be used by lwIP stack
++++*****************************************************************************/
++++#define HOST_TMR_INTERVAL               0
++++#define DYNAMIC_HTTP_HEADERS
++++
++++/*****************************************************************************
++++**                    Platform specific locking
++++*****************************************************************************/
++++#define SYS_LIGHTWEIGHT_PROT            1
++++#define NO_SYS                          0
++++#define NO_SYS_NO_TIMERS                0
++++
++++/*****************************************************************************
++++**                          Memory Options
++++*****************************************************************************/
++++#define MEM_ALIGNMENT                   4
++++#define MEM_SIZE                        (256 * 1024) /* 128K */
++++
++++#define MEMP_NUM_PBUF                   96
++++#define MEMP_NUM_TCP_PCB                32
++++#define MEMP_NUM_TCP_SEG                32
++++#define PBUF_POOL_SIZE                  512
++++
++++#ifdef LWIP_CACHE_ENABLED
++++#define MEMP_SEPARATE_POOLS             1            /* We want the pbuf
++++                                                        pool cache line
++++                                                        aligned*/
++++#endif
++++
++++#define MEMP_NUM_SYS_TIMEOUT (LWIP_TCP + IP_REASSEMBLY + LWIP_ARP + (2*LWIP_DHCP) + LWIP_AUTOIP + LWIP_IGMP + LWIP_DNS + PPP_SUPPORT)
++++
++++/*****************************************************************************
++++**                           IP Options
++++*****************************************************************************/
++++#define IP_REASSEMBLY                   0
++++#define IP_FRAG                         0
++++
++++/*****************************************************************************
++++**                           DHCP Options
++++*****************************************************************************/
++++#define LWIP_DHCP                       1
++++#define DHCP_DOES_ARP_CHECK             0
++++
++++/*****************************************************************************
++++**                           Auto IP  Options
++++*****************************************************************************/
++++#define LWIP_AUTOIP                     1
++++#define LWIP_DHCP_AUTOIP_COOP           ((LWIP_DHCP) && (LWIP_AUTOIP))
++++
++++/*****************************************************************************
++++**                           TCP  Options
++++*****************************************************************************/
++++#define TCP_MSS                         1500
++++#define TCP_WND                         (8 * TCP_MSS)
++++#define TCP_SND_BUF                     (8 * TCP_MSS)
++++#define TCP_OVERSIZE                    TCP_MSS
++++
++++/*****************************************************************************
++++**                           PBUF  Options
++++*****************************************************************************/
++++#define PBUF_LINK_HLEN                  14
++++#define PBUF_POOL_BUFSIZE               1520         /* + size of struct pbuf
++++                                                        shall be cache line
++++                                                        aligned be enabled */
++++#define ETH_PAD_SIZE                    0
++++#define LWIP_NETCONN                    1
++++
++++/*****************************************************************************
++++**                           Socket  Options
++++*****************************************************************************/
++++#define LWIP_SOCKET                     1
++++
++++/*****************************************************************************
++++**                          Debugging options
++++*****************************************************************************/
++++#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_OFF
++++#define LWIP_DBG_TYPES_ON               (LWIP_DBG_ON | LWIP_DBG_TRACE \
++++                                         |LWIP_DBG_STATE | LWIP_DBG_FRESH)
++++#define DHCP_DEBUG                      LWIP_DBG_OFF
++++#define NETIF_DEBUG                     LWIP_DBG_OFF
++++#define IP_DEBUG			LWIP_DBG_OFF
++++#define UDP_DEBUG			LWIP_DBG_OFF
++++#define ETHARP_DEBUG                    LWIP_DBG_OFF
++++#define SYS_DEBUG                       LWIP_DBG_OFF
++++#define RAW_DEBUG                       LWIP_DBG_OFF
++++#define MEM_DEBUG                       LWIP_DBG_OFF
++++#define MEMP_DEBUG                      LWIP_DBG_OFF
++++#define PBUF_DEBUG			LWIP_DBG_OFF
++++#define TCPIP_DEBUG			LWIP_DBG_OFF
++++#define APP_DEBUG			LWIP_DBG_OFF
++++#define SOCKETS_DEBUG		        LWIP_DBG_OFF
++++#define LWIP_STATS                      0
++++#define LWIP_STATS_DISPLAY              0
++++#define LWIP_STATS_POSIX                0
++++
++++
++++
++++/**
++++ * LWIP_COMPAT_SOCKETS==1: Enable BSD-style sockets functions names.
++++ * (only used if you use sockets.c)
++++ */
++++#define LWIP_COMPAT_SOCKETS             0
++++
++++#define LWIP_TIMEVAL_PRIVATE            0
++++
++++ #define LWIP_RAW                       0
++++
++++#endif /* __LWIPOPTS_H__ */
+++diff --git a/ports/sys_arch.c b/ports/sys_arch.c
+++new file mode 100644
+++index 0000000..360a4e2
+++--- /dev/null
++++++ b/ports/sys_arch.c
+++@@ -0,0 +1,663 @@
++++/*
++++ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
++++ * All rights reserved.
++++ *
++++ * Redistribution and use in source and binary forms, with or without modification,
++++ * are permitted provided that the following conditions are met:
++++ *
++++ * 1. Redistributions of source code must retain the above copyright notice,
++++ *    this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright notice,
++++ *    this list of conditions and the following disclaimer in the documentation
++++ *    and/or other materials provided with the distribution.
++++ * 3. The name of the author may not be used to endorse or promote products
++++ *    derived from this software without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
++++ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
++++ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
++++ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
++++ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
++++ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
++++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
++++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
++++ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
++++ * OF SUCH DAMAGE.
++++ *
++++ * This file is part of the lwIP TCP/IP stack.
++++ *
++++ * Author: Adam Dunkels <adam@sics.se>
++++ *
++++ */
++++
++++/*
++++ * Wed Apr 17 16:05:29 EDT 2002 (James Roth)
++++ *
++++ *  - Fixed an unlikely sys_thread_new() race condition.
++++ *
++++ *  - Made current_thread() work with threads which where
++++ *    not created with sys_thread_new().  This includes
++++ *    the main thread and threads made with pthread_create().
++++ *
++++ *  - Catch overflows where more than SYS_MBOX_SIZE messages
++++ *    are waiting to be read.  The sys_mbox_post() routine
++++ *    will block until there is more room instead of just
++++ *    leaking messages.
++++ */
++++
++++#include <string.h>
++++#include <sys/time.h>
++++#include <sys/types.h>
++++#include <stdlib.h>
++++#include <unistd.h>
++++#include <pthread.h>
++++
++++#include "lwip/opt.h"
++++#include "lwip/sys.h"
++++#include "lwip/stats.h"
++++#include "lwip/debug.h"
++++
++++#define UMAX(a, b)      ((a) > (b) ? (a) : (b))
++++
++++static struct timeval starttime;
++++
++++#if !NO_SYS
++++
++++static struct sys_thread *threads = NULL;
++++static pthread_mutex_t threads_mutex = PTHREAD_MUTEX_INITIALIZER;
++++
++++struct sys_mbox_msg {
++++  struct sys_mbox_msg *next;
++++  void *msg;
++++};
++++
++++#define SYS_MBOX_SIZE 128
++++
++++struct sys_mbox {
++++  int first, last;
++++  void *msgs[SYS_MBOX_SIZE];
++++  struct sys_sem *not_empty;
++++  struct sys_sem *not_full;
++++  struct sys_sem *mutex;
++++  int wait_send;
++++};
++++
++++struct sys_sem {
++++  unsigned int c;
++++  pthread_cond_t cond;
++++  pthread_mutex_t mutex;
++++};
++++
++++struct sys_thread {
++++  struct sys_thread *next;
++++  pthread_t pthread;
++++};
++++
++++#if SYS_LIGHTWEIGHT_PROT
++++static pthread_mutex_t lwprot_mutex = PTHREAD_MUTEX_INITIALIZER;
++++static pthread_t lwprot_thread = (pthread_t)0xDEAD;
++++static int lwprot_count = 0;
++++#endif /* SYS_LIGHTWEIGHT_PROT */
++++
++++static struct sys_sem *sys_sem_new_internal(u8_t count);
++++static void sys_sem_free_internal(struct sys_sem *sem);
++++
++++static u32_t cond_wait(pthread_cond_t * cond, pthread_mutex_t * mutex,
++++                       u32_t timeout);
++++
++++/*-----------------------------------------------------------------------------------*/
++++static struct sys_thread *
++++introduce_thread(pthread_t id)
++++{
++++  struct sys_thread *thread = NULL;
++++
++++  thread = (struct sys_thread *)malloc(sizeof(struct sys_thread));
++++
++++  if (thread != NULL) {
++++    pthread_mutex_lock(&threads_mutex);
++++    thread->next = threads;
++++    thread->pthread = id;
++++    threads = thread;
++++    pthread_mutex_unlock(&threads_mutex);
++++  }
++++
++++  return thread;
++++}
++++/*-----------------------------------------------------------------------------------*/
++++sys_thread_t
++++sys_thread_new(const char *name, lwip_thread_fn function, void *arg, int stacksize, int prio)
++++{
++++  int code;
++++  int rc;
++++  pthread_t tmp;
++++  pthread_attr_t attr;
++++  struct sys_thread *st = NULL;
++++  LWIP_UNUSED_ARG(name);
++++  LWIP_UNUSED_ARG(stacksize);
++++  LWIP_UNUSED_ARG(prio);
++++
++++  /* Alloc a new pthread with the specified stack size. */
++++  if(stacksize > 0) {
++++    rc = pthread_attr_init(&attr);
++++    if (rc != 0) {
++++      LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: pthread_attr_init error = %d\n", rc));
++++      return NULL;
++++    }
++++    rc = pthread_attr_setstacksize(&attr, stacksize);
++++    if (rc != 0) {
++++      LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: pthread_attr_setstacksize error = %d\n", rc));
++++      pthread_attr_destroy(&attr);
++++      return NULL;
++++    }
++++    pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);
++++    pthread_attr_setschedpolicy(&attr, SCHED_RR);
++++    code = pthread_create(&tmp, &attr, (void *(*)(void *)) function, arg);
++++    pthread_attr_destroy(&attr);
++++  } else {
++++    code = pthread_create(&tmp, NULL, (void *(*)(void *)) function, arg);
++++  }
++++  LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: thread created [name:%s|stacksize:%d|prio:%d|addr:0x%x]\n",
++++                          name, stacksize, prio, (uint)tmp));
++++
++++  if (0 == code) {
++++    st = introduce_thread(tmp);
++++  }
++++
++++  if (NULL == st) {
++++    LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: failed to introduce %d, st = %p\n",
++++                            code, (void*)st));
++++    abort();
++++  } else {
++++    LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: introduced %d, st = %p\n",
++++                            code, (void*)st));
++++  }
++++
++++  return st;
++++}
++++/*-----------------------------------------------------------------------------------*/
++++void sys_thread_signal(sys_thread_t thread, int signal)
++++{
++++    /* Check received parameters. */
++++    if(thread == NULL) {
++++        LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_signal: could not send signal to thread. thread = NULL\n"));
++++        return;
++++    }
++++
++++    /* Send signal. */
++++    pthread_kill(thread->pthread, signal);
++++}
++++/*-----------------------------------------------------------------------------------*/
++++err_t
++++sys_mbox_new(struct sys_mbox **mb, int size)
++++{
++++  struct sys_mbox *mbox = NULL;
++++  LWIP_UNUSED_ARG(size);
++++
++++  mbox = (struct sys_mbox *)malloc(sizeof(struct sys_mbox));
++++  if (mbox == NULL) {
++++    SYS_STATS_INC(mbox.err);
++++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_new: could not create mbox\n"));
++++    return ERR_MEM;
++++  }
++++  mbox->first = mbox->last = 0;
++++  mbox->not_empty = sys_sem_new_internal(0);
++++  mbox->not_full = sys_sem_new_internal(0);
++++  mbox->mutex = sys_sem_new_internal(1);
++++  mbox->wait_send = 0;
++++
++++  SYS_STATS_INC_USED(mbox);
++++
++++  if((mbox->not_empty == NULL) || (mbox->not_full == NULL) || (mbox->mutex == NULL)) {
++++    SYS_STATS_INC(mbox.err);
++++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_new: could not create mbox internals\n"));
++++    sys_mbox_free(&mbox);
++++    return ERR_MEM;
++++  }
++++  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_new: mbox created [not_empty:%X|not_full:%X|mutex:%X] \n",
++++                          mbox->not_empty, mbox->not_full, mbox->mutex));
++++
++++  *mb = mbox;
++++  return ERR_OK;
++++}
++++/*-----------------------------------------------------------------------------------*/
++++void
++++sys_mbox_free(struct sys_mbox **mb)
++++{
++++  if ((mb != NULL) && (*mb != SYS_MBOX_NULL)) {
++++    struct sys_mbox *mbox = *mb;
++++    sys_arch_sem_wait(&mbox->mutex, 0);
++++
++++    sys_sem_free_internal(mbox->not_empty);
++++    sys_sem_free_internal(mbox->not_full);
++++    sys_sem_free_internal(mbox->mutex);
++++    mbox->not_empty = mbox->not_full = mbox->mutex = NULL;
++++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_free: mbox 0x%lx\n", mbox));
++++    free(mbox);
++++    SYS_STATS_DEC(mbox.used);
++++  }
++++}
++++/*-----------------------------------------------------------------------------------*/
++++err_t
++++sys_mbox_trypost(struct sys_mbox **mb, void *msg)
++++{
++++  u8_t first;
++++  struct sys_mbox *mbox;
++++  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
++++  mbox = *mb;
++++  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_trypost: start"));
++++  sys_arch_sem_wait(&mbox->mutex, 0);
++++
++++  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_trypost: mbox %p msg %p\n",
++++                          (void *)mbox, (void *)msg));
++++
++++  if ((mbox->last + 1) >= (mbox->first + SYS_MBOX_SIZE)) {
++++    sys_sem_signal(&mbox->mutex);
++++    return ERR_MEM;
++++  }
++++
++++  mbox->msgs[mbox->last % SYS_MBOX_SIZE] = msg;
++++
++++  if (mbox->last == mbox->first) {
++++    first = 1;
++++  } else {
++++    first = 0;
++++  }
++++
++++  mbox->last++;
++++
++++  if (first) {
++++    sys_sem_signal(&mbox->not_empty);
++++  }
++++
++++  sys_sem_signal(&mbox->mutex);
++++
++++  return ERR_OK;
++++}
++++/*-----------------------------------------------------------------------------------*/
++++void
++++sys_mbox_post(struct sys_mbox **mb, void *msg)
++++{
++++  u8_t first;
++++  struct sys_mbox *mbox;
++++  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
++++  mbox = *mb;
++++
++++  sys_arch_sem_wait(&mbox->mutex, 0);
++++
++++  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_post: mbox %p msg %p\n", (void *)mbox, (void *)msg));
++++
++++  while ((mbox->last + 1) >= (mbox->first + SYS_MBOX_SIZE)) {
++++    mbox->wait_send++;
++++    sys_sem_signal(&mbox->mutex);
++++    sys_arch_sem_wait(&mbox->not_full, 0);
++++    sys_arch_sem_wait(&mbox->mutex, 0);
++++    mbox->wait_send--;
++++  }
++++
++++  mbox->msgs[mbox->last % SYS_MBOX_SIZE] = msg;
++++
++++  if (mbox->last == mbox->first) {
++++    first = 1;
++++  } else {
++++    first = 0;
++++  }
++++
++++  mbox->last++;
++++
++++  if (first) {
++++    sys_sem_signal(&mbox->not_empty);
++++  }
++++
++++  sys_sem_signal(&mbox->mutex);
++++}
++++/*-----------------------------------------------------------------------------------*/
++++u32_t
++++sys_arch_mbox_tryfetch(struct sys_mbox **mb, void **msg)
++++{
++++  struct sys_mbox *mbox;
++++  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
++++  mbox = *mb;
++++
++++  sys_arch_sem_wait(&mbox->mutex, 0);
++++
++++  if (mbox->first == mbox->last) {
++++    sys_sem_signal(&mbox->mutex);
++++    return SYS_MBOX_EMPTY;
++++  }
++++
++++  if (msg != NULL) {
++++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_tryfetch: mbox %p msg %p\n", (void *)mbox, *msg));
++++    *msg = mbox->msgs[mbox->first % SYS_MBOX_SIZE];
++++  }
++++  else{
++++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_tryfetch: mbox %p, null msg\n", (void *)mbox));
++++  }
++++
++++  mbox->first++;
++++
++++  if (mbox->wait_send) {
++++    sys_sem_signal(&mbox->not_full);
++++  }
++++
++++  sys_sem_signal(&mbox->mutex);
++++
++++  return 0;
++++}
++++/*-----------------------------------------------------------------------------------*/
++++u32_t
++++sys_arch_mbox_fetch(struct sys_mbox **mb, void **msg, u32_t timeout)
++++{
++++  u32_t time_needed = 0;
++++  struct sys_mbox *mbox;
++++  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
++++  mbox = *mb;
++++
++++  /* The mutex lock is quick so we don't bother with the timeout
++++     stuff here. */
++++  sys_arch_sem_wait(&mbox->mutex, 0);
++++
++++  while (mbox->first == mbox->last) {
++++    sys_sem_signal(&mbox->mutex);
++++
++++    /* We block while waiting for a mail to arrive in the mailbox. We
++++       must be prepared to timeout. */
++++    if (timeout != 0) {
++++      time_needed = sys_arch_sem_wait(&mbox->not_empty, timeout);
++++
++++      if (time_needed == SYS_ARCH_TIMEOUT) {
++++        return SYS_ARCH_TIMEOUT;
++++      }
++++    } else {
++++      sys_arch_sem_wait(&mbox->not_empty, 0);
++++    }
++++
++++    sys_arch_sem_wait(&mbox->mutex, 0);
++++  }
++++
++++  if (msg != NULL) {
++++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_fetch: mbox %p msg %p\n", (void *)mbox, *msg));
++++    *msg = mbox->msgs[mbox->first % SYS_MBOX_SIZE];
++++  }
++++  else{
++++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_fetch: mbox %p, null msg\n", (void *)mbox));
++++  }
++++
++++  mbox->first++;
++++
++++  if (mbox->wait_send) {
++++    sys_sem_signal(&mbox->not_full);
++++  }
++++
++++  sys_sem_signal(&mbox->mutex);
++++
++++  return time_needed;
++++}
++++/*-----------------------------------------------------------------------------------*/
++++static struct sys_sem *
++++sys_sem_new_internal(u8_t count)
++++{
++++  struct sys_sem *sem = NULL;
++++  int rc;
++++
++++  sem = (struct sys_sem *)malloc(sizeof(struct sys_sem));
++++  if (sem != NULL) {
++++    sem->c = count;
++++    rc = pthread_cond_init(&(sem->cond), NULL);
++++    if(rc != 0) {
++++      LWIP_DEBUGF(SYS_DEBUG, ("sys_sem_new_internal: pthread_cond_init error = %d\n", rc));
++++      return NULL;
++++    }
++++    rc = pthread_mutex_init(&(sem->mutex), NULL);
++++    if(rc != 0) {
++++      LWIP_DEBUGF(SYS_DEBUG, ("sys_sem_new_internal: pthread_mutex_init error = %d\n", rc));
++++      SYS_STATS_INC(mutex.err);
++++      pthread_cond_destroy(&(sem->cond));
++++      return NULL;
++++    }
++++    SYS_STATS_INC_USED(mutex);
++++    SYS_STATS_INC_USED(sem);
++++  } else {
++++    LWIP_DEBUGF(SYS_DEBUG, ("sys_sem_new_internal: could not create semaphore\n"));
++++    SYS_STATS_INC(sem.err);
++++  }
++++  return sem;
++++}
++++/*-----------------------------------------------------------------------------------*/
++++err_t
++++sys_sem_new(struct sys_sem **sem, u8_t count)
++++{
++++  *sem = sys_sem_new_internal(count);
++++  if (*sem == NULL) {
++++    return ERR_MEM;
++++  }
++++  return ERR_OK;
++++}
++++/*-----------------------------------------------------------------------------------*/
++++static u32_t
++++cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex, u32_t timeout)
++++{
++++  time_t tdiff;
++++  time_t sec, usec;
++++  struct timeval rtime1, rtime2;
++++  struct timespec ts;
++++  int retval;
++++
++++  if (timeout > 0) {
++++    /* Get a timestamp and add the timeout value. */
++++    gettimeofday(&rtime1, NULL);
++++    sec = rtime1.tv_sec;
++++    usec = rtime1.tv_usec;
++++    usec += timeout % 1000 * 1000;
++++    sec += (int)(timeout / 1000) + (int)(usec / 1000000);
++++    usec = usec % 1000000;
++++    ts.tv_nsec = usec * 1000;
++++    ts.tv_sec = sec;
++++
++++    retval = pthread_cond_timedwait(cond, mutex, &ts);
++++
++++    if (retval == ETIMEDOUT) {
++++      return SYS_ARCH_TIMEOUT;
++++    } else {
++++      /* Calculate for how long we waited for the cond. */
++++      gettimeofday(&rtime2, NULL);
++++      tdiff = (rtime2.tv_sec - rtime1.tv_sec) * 1000 +
++++        (rtime2.tv_usec - rtime1.tv_usec) / 1000;
++++
++++      if (tdiff <= 0) {
++++        return 0;
++++      }
++++      return (u32_t)tdiff;
++++    }
++++  } else {
++++    pthread_cond_wait(cond, mutex);
++++    return 0;
++++  }
++++}
++++/*-----------------------------------------------------------------------------------*/
++++u32_t
++++sys_arch_sem_wait(struct sys_sem **s, u32_t timeout)
++++{
++++  u32_t time_needed = 0;
++++  struct sys_sem *sem;
++++  LWIP_ASSERT("invalid sem", (s != NULL) && (*s != NULL));
++++  sem = *s;
++++
++++  pthread_mutex_lock(&(sem->mutex));
++++  while (sem->c <= 0) {
++++    if (timeout > 0) {
++++      time_needed = cond_wait(&(sem->cond), &(sem->mutex), timeout);
++++
++++      if (time_needed == SYS_ARCH_TIMEOUT) {
++++        pthread_mutex_unlock(&(sem->mutex));
++++        return SYS_ARCH_TIMEOUT;
++++      }
++++    } else {
++++      cond_wait(&(sem->cond), &(sem->mutex), 0);
++++    }
++++  }
++++  sem->c--;
++++  pthread_mutex_unlock(&(sem->mutex));
++++  return (u32_t)time_needed;
++++}
++++/*-----------------------------------------------------------------------------------*/
++++void
++++sys_sem_signal(struct sys_sem **s)
++++{
++++  struct sys_sem *sem;
++++  LWIP_ASSERT("invalid sem", (s != NULL) && (*s != NULL));
++++  sem = *s;
++++
++++  pthread_mutex_lock(&(sem->mutex));
++++  sem->c++;
++++
++++  if (sem->c > 1) {
++++    sem->c = 1;
++++  }
++++
++++  pthread_cond_broadcast(&(sem->cond));
++++  pthread_mutex_unlock(&(sem->mutex));
++++}
++++/*-----------------------------------------------------------------------------------*/
++++static void
++++sys_sem_free_internal(struct sys_sem *sem)
++++{
++++  if(sem != NULL) {
++++    pthread_cond_destroy(&(sem->cond));
++++    pthread_mutex_destroy(&(sem->mutex));
++++    SYS_STATS_DEC(mutex.used);
++++    SYS_STATS_DEC(sem.used);
++++    free(sem);
++++  }
++++}
++++/*-----------------------------------------------------------------------------------*/
++++void
++++sys_sem_free(struct sys_sem **sem)
++++{
++++  if ((sem != NULL) && (*sem != SYS_SEM_NULL)) {
++++    sys_sem_free_internal(*sem);
++++  }
++++}
++++#endif /* !NO_SYS */
++++/*-----------------------------------------------------------------------------------*/
++++u32_t
++++sys_now(void)
++++{
++++  struct timeval tv;
++++  u32_t sec, usec, msec;
++++  gettimeofday(&tv, NULL);
++++
++++  sec = (u32_t)(tv.tv_sec - starttime.tv_sec);
++++  usec = (u32_t)(tv.tv_usec - starttime.tv_usec);
++++  msec = sec * 1000 + usec / 1000;
++++
++++  return msec;
++++}
++++/*-----------------------------------------------------------------------------------*/
++++void
++++sys_init(void)
++++{
++++  SYS_STATS_INC_USED(mutex);
++++  gettimeofday(&starttime, NULL);
++++}
++++/*-----------------------------------------------------------------------------------*/
++++#if SYS_LIGHTWEIGHT_PROT
++++/** sys_prot_t sys_arch_protect(void)
++++
++++This optional function does a "fast" critical region protection and returns
++++the previous protection level. This function is only called during very short
++++critical regions. An embedded system which supports ISR-based drivers might
++++want to implement this function by disabling interrupts. Task-based systems
++++might want to implement this by using a mutex or disabling tasking. This
++++function should support recursive calls from the same task or interrupt. In
++++other words, sys_arch_protect() could be called while already protected. In
++++that case the return value indicates that it is already protected.
++++
++++sys_arch_protect() is only required if your port is supporting an operating
++++system.
++++*/
++++sys_prot_t
++++sys_arch_protect(void)
++++{
++++    /* Note that for the UNIX port, we are using a lightweight mutex, and our
++++     * own counter (which is locked by the mutex). The return code is not actually
++++     * used. */
++++    if (lwprot_thread != pthread_self())
++++    {
++++        /* We are locking the mutex where it has not been locked before *
++++        * or is being locked by another thread */
++++        pthread_mutex_lock(&lwprot_mutex);
++++        lwprot_thread = pthread_self();
++++        lwprot_count = 1;
++++    }
++++    else
++++    {
++++        /* It is already locked by THIS thread */
++++        lwprot_count++;
++++    }
++++    return 0;
++++}
++++/*-----------------------------------------------------------------------------------*/
++++/** void sys_arch_unprotect(sys_prot_t pval)
++++
++++This optional function does a "fast" set of critical region protection to the
++++value specified by pval. See the documentation for sys_arch_protect() for
++++more information. This function is only required if your port is supporting
++++an operating system.
++++*/
++++void
++++sys_arch_unprotect(sys_prot_t pval)
++++{
++++    LWIP_UNUSED_ARG(pval);
++++    if (lwprot_thread == pthread_self())
++++    {
++++        if (--lwprot_count == 0)
++++        {
++++            lwprot_thread = (pthread_t) 0xDEAD;
++++            pthread_mutex_unlock(&lwprot_mutex);
++++        }
++++    }
++++}
++++#endif /* SYS_LIGHTWEIGHT_PROT */
++++
++++/*-----------------------------------------------------------------------------------*/
++++
++++#ifndef MAX_JIFFY_OFFSET
++++#define MAX_JIFFY_OFFSET ((~0U >> 1)-1)
++++#endif
++++
++++#ifndef HZ
++++#define HZ 100
++++#endif
++++
++++u32_t
++++sys_jiffies(void)
++++{
++++    struct timeval tv;
++++    unsigned long sec;
++++    long usec;
++++
++++    gettimeofday(&tv,NULL);
++++    sec = tv.tv_sec - starttime.tv_sec;
++++    usec = tv.tv_usec;
++++
++++    if (sec >= (MAX_JIFFY_OFFSET / HZ))
++++      return MAX_JIFFY_OFFSET;
++++    usec += 1000000L / HZ - 1;
++++    usec /= 1000000L / HZ;
++++    return HZ * sec + usec;
++++}
++++
++++#if PPP_DEBUG
++++
++++#include <stdarg.h>
++++
++++void ppp_trace(int level, const char *format, ...)
++++{
++++    va_list args;
++++
++++    (void)level;
++++    va_start(args, format);
++++    vprintf(format, args);
++++    va_end(args);
++++}
++++#endif
+++-- 
+++1.9.1
+++
+++
+++From d053fa836b445b6736bf82d33a33a59055150aa7 Mon Sep 17 00:00:00 2001
+++From: Jay Doyle <jay.doyle@vecna.com>
+++Date: Fri, 4 Sep 2015 17:30:37 -0400
+++Subject: [PATCH 2/9] changed the compiler options
+++
+++---
+++ Makefile | 2 +-
+++ 1 file changed, 1 insertion(+), 1 deletion(-)
+++
+++diff --git a/Makefile b/Makefile
+++index 0cbae64..94fcafc 100644
+++--- a/Makefile
++++++ b/Makefile
+++@@ -5,7 +5,7 @@ include $(PROJECT_ROOT)/make/leaf.cfg
+++ #### CONFIG ####################################################################
+++ #For debugging symbols add -DLWIP_DEBUG
+++ # COMPILER/LINKER
+++-CFLAGS+=-g -O2   \
++++CFLAGS+=-g -O0   \
+++  -Wall
+++ 
+++ # OUTPUT
+++-- 
+++1.9.1
+++
+++
+++From 841adb17430bdb9298dcb6d44ac5dad72e82af80 Mon Sep 17 00:00:00 2001
+++From: Jay Doyle <jay.doyle@vecna.com>
+++Date: Mon, 7 Sep 2015 08:56:58 -0400
+++Subject: [PATCH 3/9] disabled any mention of ipv6
+++
+++---
+++ Makefile | 6 +++---
+++ 1 file changed, 3 insertions(+), 3 deletions(-)
+++
+++diff --git a/Makefile b/Makefile
+++index 94fcafc..6efa141 100644
+++--- a/Makefile
++++++ b/Makefile
+++@@ -40,7 +40,7 @@ CORE_SRC=$(wildcard $(LWIP_CORE_PATH)/*.c)
+++ IPV4_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv4/*.c)
+++ 
+++ ## IPv6
+++-IPV6_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv6/*.c)
++++#IPV6_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv6/*.c)
+++ 
+++ ## SNMP
+++ SNMP_SRC=$(wildcard $(LWIP_CORE_PATH)/snmp/*.c)
+++@@ -71,7 +71,7 @@ SOURCES =  $(DRIVER_SRC) $(SNMP_SRC)\
+++ CORE_H=$(LWIP_INCL_PATH)
+++ 
+++ ## IPv4
+++-#IPV4_H=$(LWIP_INCL_PATH)/ipv4
++++IPV4_H=$(LWIP_INCL_PATH)/ipv4
+++ 
+++ ## IPv6
+++ #IPV6_H=$(LWIP_INCL_PATH)/ipv6
+++@@ -97,7 +97,7 @@ DRIVER_H=$(LWIPDRIVER_INCL_PATH)
+++ # HEADERS
+++ HEADERS=-I$(CORE_H) -I$(POSIX_H) -I$(POSIX_SYS_H) -I$(NETIF_H) \
+++         -I$(NETIF_H_PPP) -I$(NETIF_H_PPP_POLARSSL) -I$(ARCH_H) \
+++-        -I$(DRIVER_H)
++++        -I$(DRIVER_H) -I$(IPV4_H)
+++ 
+++ 
+++ ################################################################################
+++-- 
+++1.9.1
+++
+++
+++From a653d818348fef0130e6e497eecb0c3a35822df4 Mon Sep 17 00:00:00 2001
+++From: Jay Doyle <jay.doyle@vecna.com>
+++Date: Mon, 7 Sep 2015 09:27:48 -0400
+++Subject: [PATCH 4/9] added in stm32f low-level driver
+++
+++---
+++ src/netif/ethernetif.c | 709 ++++++++++++++++++++++++++++++-------------------
+++ 1 file changed, 435 insertions(+), 274 deletions(-)
+++
+++diff --git a/src/netif/ethernetif.c b/src/netif/ethernetif.c
+++index 7982d11..82c85ae 100644
+++--- a/src/netif/ethernetif.c
++++++ b/src/netif/ethernetif.c
+++@@ -1,335 +1,496 @@
+++ /**
+++- * @file
+++- * Ethernet Interface Skeleton
+++- *
+++- */
+++-
+++-/*
+++- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+++- * All rights reserved. 
+++- * 
+++- * Redistribution and use in source and binary forms, with or without modification, 
+++- * are permitted provided that the following conditions are met:
+++- *
+++- * 1. Redistributions of source code must retain the above copyright notice,
+++- *    this list of conditions and the following disclaimer.
+++- * 2. Redistributions in binary form must reproduce the above copyright notice,
+++- *    this list of conditions and the following disclaimer in the documentation
+++- *    and/or other materials provided with the distribution.
+++- * 3. The name of the author may not be used to endorse or promote products
+++- *    derived from this software without specific prior written permission. 
+++- *
+++- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+++- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+++- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+++- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+++- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+++- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+++- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+++- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+++- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+++- * OF SUCH DAMAGE.
+++- *
+++- * This file is part of the lwIP TCP/IP stack.
+++- * 
+++- * Author: Adam Dunkels <adam@sics.se>
+++- *
+++- */
+++-
+++-/*
+++- * This file is a skeleton for developing Ethernet network interface
+++- * drivers for lwIP. Add code to the low_level functions and do a
+++- * search-and-replace for the word "ethernetif" to replace it with
+++- * something that better describes your network interface.
+++- */
+++-
++++  ******************************************************************************
++++  * @file    LwIP/LwIP_HTTP_Server_Netconn_RTOS/Src/ethernetif.c
++++  * @author  MCD Application Team
++++  * @version V1.0.0
++++  * @date    25-June-2015
++++  * @brief   This file implements Ethernet network interface drivers for lwIP
++++  ******************************************************************************
++++  * @attention
++++  *
++++  * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
++++  *
++++  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
++++  * You may not use this file except in compliance with the License.
++++  * You may obtain a copy of the License at:
++++  *
++++  *        http://www.st.com/software_license_agreement_liberty_v2
++++  *
++++  * Unless required by applicable law or agreed to in writing, software 
++++  * distributed under the License is distributed on an "AS IS" BASIS, 
++++  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++++  * See the License for the specific language governing permissions and
++++  * limitations under the License.
++++  *
++++  ******************************************************************************
++++  */
++++
++++/* Includes ------------------------------------------------------------------*/
++++#include "stm32f7xx_hal.h"
+++ #include "lwip/opt.h"
+++-
+++-#if 0 /* don't build, this is only a skeleton, see previous comment */
+++-
+++-#include "lwip/def.h"
+++-#include "lwip/mem.h"
+++-#include "lwip/pbuf.h"
+++-#include "lwip/stats.h"
+++-#include "lwip/snmp.h"
+++-#include "lwip/ethip6.h"
++++#include "lwip/lwip_timers.h"
+++ #include "netif/etharp.h"
+++-#include "netif/ppp/pppoe.h"
++++#include "hal-ethernetif.h"
++++#include <string.h>
++++
++++/* Private typedef -----------------------------------------------------------*/
++++/* Private define ------------------------------------------------------------*/
++++/* The time to block waiting for input. */
++++#define TIME_WAITING_FOR_INPUT                 ( 100 )
++++/* Stack size of the interface thread */
++++#define INTERFACE_THREAD_STACK_SIZE            ( 350 )
+++ 
+++ /* Define those to better describe your network interface. */
+++ #define IFNAME0 'e'
+++ #define IFNAME1 'n'
+++ 
+++-/**
+++- * Helper struct to hold private data used to operate your ethernet interface.
+++- * Keeping the ethernet address of the MAC in this struct is not necessary
+++- * as it is already kept in the struct netif.
+++- * But this is only an example, anyway...
+++- */
+++-struct ethernetif {
+++-  struct eth_addr *ethaddr;
+++-  /* Add whatever per-interface state that is needed here. */
+++-};
+++-
+++-/* Forward declarations. */
+++-static void  ethernetif_input(struct netif *netif);
++++#define LAN8742A_PHY_ADDRESS            0x00
+++ 
+++-/**
+++- * In this function, the hardware should be initialized.
+++- * Called from ethernetif_init().
+++- *
+++- * @param netif the already initialized lwip network interface structure
+++- *        for this ethernetif
+++- */
+++-static void
+++-low_level_init(struct netif *netif)
+++-{
+++-  struct ethernetif *ethernetif = netif->state;
+++-  
+++-  /* set MAC hardware address length */
+++-  netif->hwaddr_len = ETHARP_HWADDR_LEN;
++++/* Private macro -------------------------------------------------------------*/
++++/* Private variables ---------------------------------------------------------*/
+++ 
+++-  /* set MAC hardware address */
+++-  netif->hwaddr[0] = ;
+++-  ...
+++-  netif->hwaddr[5] = ;
++++#if defined ( __ICCARM__ ) /*!< IAR Compiler */
+++ 
+++-  /* maximum transfer unit */
+++-  netif->mtu = 1500;
+++-  
+++-  /* device capabilities */
+++-  /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
+++-  netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
+++- 
+++-#if LWIP_IPV6 && LWIP_IPV6_MLD
+++-  /*
+++-   * For hardware/netifs that implement MAC filtering.
+++-   * All-nodes link-local is handled by default, so we must let the hardware know
+++-   * to allow multicast packets in.
+++-   * Should set mld_mac_filter previously. */
+++-  if (netif->mld_mac_filter != NULL) {
+++-    ip6_addr_t ip6_allnodes_ll;
+++-    ip6_addr_set_allnodes_linklocal(&ip6_allnodes_ll);
+++-    netif->mld_mac_filter(netif, &ip6_allnodes_ll, MLD6_ADD_MAC_FILTER);
+++-  }
+++-#endif /* LWIP_IPV6 && LWIP_IPV6_MLD */
++++#pragma location=0x2000E000
++++__no_init ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
++++#pragma location=0x2000E100
++++__no_init ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
++++#elif defined ( __CC_ARM   )
++++ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((at(0x2000E000)));/* Ethernet Rx MA Descriptor */
++++ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((at(0x2000E100)));/* Ethernet Tx DMA Descriptor */
++++#elif defined ( __GNUC__   )
++++//ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".RxDescripSection")));/* Ethernet Rx MA Descriptor */
++++//ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".TxDescripSection")));/* Ethernet Tx DMA Descriptor */
++++ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Rx MA Descriptor */
++++ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Tx DMA Descriptor */
++++
++++
++++#endif
++++#if defined ( __ICCARM__ ) /*!< IAR Compiler */
++++#pragma location=0x2000E200
++++__no_init uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
++++#pragma location=0x2000FFC4
++++__no_init uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
++++#elif defined ( __CC_ARM   )
++++uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((at(0x2000E200)));  /* Ethernet Receive Buffer */
++++uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]  __attribute__((at(0x2000FFC4))); /* Ethernet Transmit Buffer */
++++#elif defined ( __GNUC__   )
++++//uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".RxBUF")));/* Ethernet Receive Buffer */
++++//uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".TxBUF")));/* Ethernet Transmit Buffer */
++++uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Receive Buffer */
++++uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Transmit Buffer */
++++
++++#endif
++++/* Semaphore to signal incoming packets */
++++osSemaphoreId s_xSemaphore = NULL;
+++ 
+++-  /* Do whatever else is needed to initialize interface. */  
++++/* Global Ethernet handle*/
++++ETH_HandleTypeDef EthHandle;
++++
++++/* Private function prototypes -----------------------------------------------*/
++++static void ethernetif_input( void const * argument );
++++
++++static void stm32f_ethernet_isr(
++++  void* argData
++++)
++++{
++++  ETH_HandleTypeDef* pEth =
++++    (ETH_HandleTypeDef*) argData;
++++
++++  HAL_ETH_IRQHandler(pEth);
+++ }
+++ 
++++/* Private functions ---------------------------------------------------------*/
++++/*******************************************************************************
++++                       Ethernet MSP Routines
++++*******************************************************************************/
+++ /**
+++- * This function should do the actual transmission of the packet. The packet is
+++- * contained in the pbuf that is passed to the function. This pbuf
+++- * might be chained.
+++- *
+++- * @param netif the lwip network interface structure for this ethernetif
+++- * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
+++- * @return ERR_OK if the packet could be sent
+++- *         an err_t value if the packet couldn't be sent
+++- *
+++- * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
+++- *       strange results. You might consider waiting for space in the DMA queue
+++- *       to become available since the stack doesn't retry to send a packet
+++- *       dropped because of memory failure (except for the TCP timers).
+++- */
+++-
+++-static err_t
+++-low_level_output(struct netif *netif, struct pbuf *p)
++++  * @brief  Initializes the ETH MSP.
++++  * @param  heth: ETH handle
++++  * @retval None
++++  */
++++void HAL_ETH_MspInit(ETH_HandleTypeDef *heth)
+++ {
+++-  struct ethernetif *ethernetif = netif->state;
+++-  struct pbuf *q;
+++-
+++-  initiate transfer();
++++  GPIO_InitTypeDef GPIO_InitStructure;
+++   
+++-#if ETH_PAD_SIZE
+++-  pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
+++-#endif
+++-
+++-  for(q = p; q != NULL; q = q->next) {
+++-    /* Send the data from the pbuf to the interface, one pbuf at a
+++-       time. The size of the data in each pbuf is kept in the ->len
+++-       variable. */
+++-    send data from(q->payload, q->len);
+++-  }
++++  /* Enable GPIOs clocks */
++++  __HAL_RCC_GPIOA_CLK_ENABLE();
++++  __HAL_RCC_GPIOC_CLK_ENABLE();
++++  __HAL_RCC_GPIOG_CLK_ENABLE();
+++ 
+++-  signal that packet should be sent();
++++/* Ethernet pins configuration ************************************************/
++++  /*
++++        RMII_REF_CLK ----------------------> PA1
++++        RMII_MDIO -------------------------> PA2
++++        RMII_MDC --------------------------> PC1
++++        RMII_MII_CRS_DV -------------------> PA7
++++        RMII_MII_RXD0 ---------------------> PC4
++++        RMII_MII_RXD1 ---------------------> PC5
++++        RMII_MII_RXER ---------------------> PG2
++++        RMII_MII_TX_EN --------------------> PG11
++++        RMII_MII_TXD0 ---------------------> PG13
++++        RMII_MII_TXD1 ---------------------> PG14
++++  */
++++
++++  /* Configure PA1, PA2 and PA7 */
++++  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
++++  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
++++  GPIO_InitStructure.Pull = GPIO_NOPULL; 
++++  GPIO_InitStructure.Alternate = GPIO_AF11_ETH;
++++  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
++++  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
++++  
++++  /* Configure PC1, PC4 and PC5 */
++++  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;
++++  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
+++ 
+++-#if ETH_PAD_SIZE
+++-  pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
+++-#endif
++++  /* Configure PG2, PG11, PG13 and PG14 */
++++  GPIO_InitStructure.Pin =  GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14;
++++  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
+++   
+++-  LINK_STATS_INC(link.xmit);
++++  // Install HAL Ethernet ISR
++++  rtems_interrupt_handler_install(
++++    ETH_IRQn,
++++    NULL,
++++    0,
++++    stm32f_ethernet_isr,
++++    heth);
++++  
++++  /* Enable ETHERNET clock  */
++++  __HAL_RCC_ETH_CLK_ENABLE();
++++}
+++ 
+++-  return ERR_OK;
++++/**
++++  * @brief  Ethernet Rx Transfer completed callback
++++  * @param  heth: ETH handle
++++  * @retval None
++++  */
++++void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
++++{
++++  osSemaphoreRelease(s_xSemaphore);
+++ }
+++ 
+++ /**
+++- * Should allocate a pbuf and transfer the bytes of the incoming
+++- * packet from the interface into the pbuf.
+++- *
+++- * @param netif the lwip network interface structure for this ethernetif
+++- * @return a pbuf filled with the received packet (including MAC header)
+++- *         NULL on memory error
+++- */
+++-static struct pbuf *
+++-low_level_input(struct netif *netif)
++++  * @brief  Ethernet IRQ Handler
++++  * @param  None
++++  * @retval None
++++  */
++++void ETHERNET_IRQHandler(void)
+++ {
+++-  struct ethernetif *ethernetif = netif->state;
+++-  struct pbuf *p, *q;
+++-  u16_t len;
++++  HAL_ETH_IRQHandler(&EthHandle);
++++}
+++ 
+++-  /* Obtain the size of the packet and put it into the "len"
+++-     variable. */
+++-  len = ;
++++/*******************************************************************************
++++                       LL Driver Interface ( LwIP stack --> ETH) 
++++*******************************************************************************/
++++/**
++++  * @brief In this function, the hardware should be initialized.
++++  * Called from ethernetif_init().
++++  *
++++  * @param netif the already initialized lwip network interface structure
++++  *        for this ethernetif
++++  */
++++static void low_level_init(struct netif *netif)
++++{
++++  uint8_t macaddress[6]= { MAC_ADDR0, MAC_ADDR1, MAC_ADDR2, MAC_ADDR3, MAC_ADDR4, MAC_ADDR5 };
++++  
++++  EthHandle.Instance = ETH;  
++++  EthHandle.Init.MACAddr = macaddress;
++++  EthHandle.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
++++  EthHandle.Init.Speed = ETH_SPEED_100M;
++++  EthHandle.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
++++  EthHandle.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
++++  EthHandle.Init.RxMode = ETH_RXINTERRUPT_MODE;
++++  EthHandle.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
++++  EthHandle.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
++++  
++++  /* configure ethernet peripheral (GPIOs, clocks, MAC, DMA) */
++++  if (HAL_ETH_Init(&EthHandle) == HAL_OK)
++++  {
++++    /* Set netif link flag */
++++    netif->flags |= NETIF_FLAG_LINK_UP;
++++  }
++++  
++++  /* Initialize Tx Descriptors list: Chain Mode */
++++  HAL_ETH_DMATxDescListInit(&EthHandle, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
++++     
++++  /* Initialize Rx Descriptors list: Chain Mode  */
++++  HAL_ETH_DMARxDescListInit(&EthHandle, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
++++  
++++  /* set netif MAC hardware address length */
++++  netif->hwaddr_len = ETHARP_HWADDR_LEN;
+++ 
+++-#if ETH_PAD_SIZE
+++-  len += ETH_PAD_SIZE; /* allow room for Ethernet padding */
+++-#endif
++++  /* set netif MAC hardware address */
++++  netif->hwaddr[0] =  MAC_ADDR0;
++++  netif->hwaddr[1] =  MAC_ADDR1;
++++  netif->hwaddr[2] =  MAC_ADDR2;
++++  netif->hwaddr[3] =  MAC_ADDR3;
++++  netif->hwaddr[4] =  MAC_ADDR4;
++++  netif->hwaddr[5] =  MAC_ADDR5;
+++ 
+++-  /* We allocate a pbuf chain of pbufs from the pool. */
+++-  p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
+++-  
+++-  if (p != NULL) {
++++  /* set netif maximum transfer unit */
++++  netif->mtu = 1500;
+++ 
+++-#if ETH_PAD_SIZE
+++-    pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
+++-#endif
++++  /* Accept broadcast address and ARP traffic */
++++  netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
+++ 
+++-    /* We iterate over the pbuf chain until we have read the entire
+++-     * packet into the pbuf. */
+++-    for(q = p; q != NULL; q = q->next) {
+++-      /* Read enough bytes to fill this pbuf in the chain. The
+++-       * available data in the pbuf is given by the q->len
+++-       * variable.
+++-       * This does not necessarily have to be a memcpy, you can also preallocate
+++-       * pbufs for a DMA-enabled MAC and after receiving truncate it to the
+++-       * actually received size. In this case, ensure the tot_len member of the
+++-       * pbuf is the sum of the chained pbuf len members.
+++-       */
+++-      read data into(q->payload, q->len);
+++-    }
+++-    acknowledge that packet has been read();
++++  /* create a binary semaphore used for informing ethernetif of frame reception */
++++  osSemaphoreDef(SEM);
++++  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1 );
++++
++++  /* create the task that handles the ETH_MAC */
++++  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
++++  osThreadCreate (osThread(EthIf), netif);
++++
++++  /* Enable MAC and DMA transmission and reception */
++++  HAL_ETH_Start(&EthHandle);
++++}
+++ 
+++-#if ETH_PAD_SIZE
+++-    pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
+++-#endif
+++ 
+++-    LINK_STATS_INC(link.recv);
+++-  } else {
+++-    drop packet();
+++-    LINK_STATS_INC(link.memerr);
+++-    LINK_STATS_INC(link.drop);
++++/**
++++  * @brief This function should do the actual transmission of the packet. The packet is
++++  * contained in the pbuf that is passed to the function. This pbuf
++++  * might be chained.
++++  *
++++  * @param netif the lwip network interface structure for this ethernetif
++++  * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
++++  * @return ERR_OK if the packet could be sent
++++  *         an err_t value if the packet couldn't be sent
++++  *
++++  * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
++++  *       strange results. You might consider waiting for space in the DMA queue
++++  *       to become available since the stack doesn't retry to send a packet
++++  *       dropped because of memory failure (except for the TCP timers).
++++  */
++++static err_t low_level_output(struct netif *netif, struct pbuf *p)
++++{
++++  err_t errval;
++++  struct pbuf *q;
++++  uint8_t *buffer = (uint8_t *)(EthHandle.TxDesc->Buffer1Addr);
++++  __IO ETH_DMADescTypeDef *DmaTxDesc;
++++  uint32_t framelength = 0;
++++  uint32_t bufferoffset = 0;
++++  uint32_t byteslefttocopy = 0;
++++  uint32_t payloadoffset = 0;
++++
++++  DmaTxDesc = EthHandle.TxDesc;
++++  bufferoffset = 0;
++++  
++++  /* copy frame from pbufs to driver buffers */
++++  for(q = p; q != NULL; q = q->next)
++++  {
++++    /* Is this buffer available? If not, goto error */
++++    if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
++++    {
++++      errval = ERR_USE;
++++      goto error;
++++    }
++++    
++++    /* Get bytes in current lwIP buffer */
++++    byteslefttocopy = q->len;
++++    payloadoffset = 0;
++++    
++++    /* Check if the length of data to copy is bigger than Tx buffer size*/
++++    while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
++++    {
++++      /* Copy data to Tx buffer*/
++++      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
++++      
++++      /* Point to next descriptor */
++++      DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
++++      
++++      /* Check if the buffer is available */
++++      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
++++      {
++++        errval = ERR_USE;
++++        goto error;
++++      }
++++      
++++      buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
++++      
++++      byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
++++      payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
++++      framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
++++      bufferoffset = 0;
++++    }
++++    
++++    /* Copy the remaining bytes */
++++    memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
++++    bufferoffset = bufferoffset + byteslefttocopy;
++++    framelength = framelength + byteslefttocopy;
++++  }
++++  
++++  /* Prepare transmit descriptors to give to DMA */ 
++++  HAL_ETH_TransmitFrame(&EthHandle, framelength);
++++  
++++  errval = ERR_OK;
++++  
++++error:
++++  
++++  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
++++  if ((EthHandle.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
++++  {
++++    /* Clear TUS ETHERNET DMA flag */
++++    EthHandle.Instance->DMASR = ETH_DMASR_TUS;
++++    
++++    /* Resume DMA transmission*/
++++    EthHandle.Instance->DMATPDR = 0;
+++   }
++++  return errval;
++++}
+++ 
+++-  return p;  
++++/**
++++  * @brief Should allocate a pbuf and transfer the bytes of the incoming
++++  * packet from the interface into the pbuf.
++++  *
++++  * @param netif the lwip network interface structure for this ethernetif
++++  * @return a pbuf filled with the received packet (including MAC header)
++++  *         NULL on memory error
++++  */
++++static struct pbuf * low_level_input(struct netif *netif)
++++{
++++  struct pbuf *p = NULL, *q = NULL;
++++  uint16_t len = 0;
++++  uint8_t *buffer;
++++  __IO ETH_DMADescTypeDef *dmarxdesc;
++++  uint32_t bufferoffset = 0;
++++  uint32_t payloadoffset = 0;
++++  uint32_t byteslefttocopy = 0;
++++  uint32_t i=0;
++++  
++++  /* get received frame */
++++  if(HAL_ETH_GetReceivedFrame_IT(&EthHandle) != HAL_OK)
++++    return NULL;
++++  
++++  /* Obtain the size of the packet and put it into the "len" variable. */
++++  len = EthHandle.RxFrameInfos.length;
++++  buffer = (uint8_t *)EthHandle.RxFrameInfos.buffer;
++++  
++++  if (len > 0)
++++  {
++++    /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
++++    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
++++  }
++++  
++++  if (p != NULL)
++++  {
++++    dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
++++    bufferoffset = 0;
++++    
++++    for(q = p; q != NULL; q = q->next)
++++    {
++++      byteslefttocopy = q->len;
++++      payloadoffset = 0;
++++      
++++      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size */
++++      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
++++      {
++++        /* Copy data to pbuf */
++++        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
++++        
++++        /* Point to next descriptor */
++++        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
++++        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
++++        
++++        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
++++        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
++++        bufferoffset = 0;
++++      }
++++      
++++      /* Copy remaining data in pbuf */
++++      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
++++      bufferoffset = bufferoffset + byteslefttocopy;
++++    }
++++  }
++++    
++++  /* Release descriptors to DMA */
++++  /* Point to first descriptor */
++++  dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
++++  /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
++++  for (i=0; i< EthHandle.RxFrameInfos.SegCount; i++)
++++  {  
++++    dmarxdesc->Status |= ETH_DMARXDESC_OWN;
++++    dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
++++  }
++++    
++++  /* Clear Segment_Count */
++++  EthHandle.RxFrameInfos.SegCount =0;
++++  
++++  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
++++  if ((EthHandle.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
++++  {
++++    /* Clear RBUS ETHERNET DMA flag */
++++    EthHandle.Instance->DMASR = ETH_DMASR_RBUS;
++++    /* Resume DMA reception */
++++    EthHandle.Instance->DMARPDR = 0;
++++  }
++++  return p;
+++ }
+++ 
+++ /**
+++- * This function should be called when a packet is ready to be read
+++- * from the interface. It uses the function low_level_input() that
+++- * should handle the actual reception of bytes from the network
+++- * interface. Then the type of the received packet is determined and
+++- * the appropriate input function is called.
+++- *
+++- * @param netif the lwip network interface structure for this ethernetif
+++- */
+++-static void
+++-ethernetif_input(struct netif *netif)
++++  * @brief This function is the ethernetif_input task, it is processed when a packet 
++++  * is ready to be read from the interface. It uses the function low_level_input() 
++++  * that should handle the actual reception of bytes from the network
++++  * interface. Then the type of the received packet is determined and
++++  * the appropriate input function is called.
++++  *
++++  * @param netif the lwip network interface structure for this ethernetif
++++  */
++++void ethernetif_input( void const * argument )
+++ {
+++-  struct ethernetif *ethernetif;
+++-  struct eth_hdr *ethhdr;
+++   struct pbuf *p;
+++-
+++-  ethernetif = netif->state;
+++-
+++-  /* move received packet into a new pbuf */
+++-  p = low_level_input(netif);
+++-  /* no packet could be read, silently ignore this */
+++-  if (p == NULL) return;
+++-  /* points to packet payload, which starts with an Ethernet header */
+++-  ethhdr = p->payload;
+++-
+++-  switch (htons(ethhdr->type)) {
+++-  /* IP or ARP packet? */
+++-  case ETHTYPE_IP:
+++-  case ETHTYPE_IPV6:
+++-  case ETHTYPE_ARP:
+++-#if PPPOE_SUPPORT
+++-  /* PPPoE packet? */
+++-  case ETHTYPE_PPPOEDISC:
+++-  case ETHTYPE_PPPOE:
+++-#endif /* PPPOE_SUPPORT */
+++-    /* full packet send to tcpip_thread to process */
+++-    if (netif->input(p, netif)!=ERR_OK)
+++-     { LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
+++-       pbuf_free(p);
+++-       p = NULL;
+++-     }
+++-    break;
+++-
+++-  default:
+++-    pbuf_free(p);
+++-    p = NULL;
+++-    break;
++++  struct netif *netif = (struct netif *) argument;
++++  
++++  for( ;; )
++++  {
++++    if (osSemaphoreWait( s_xSemaphore, TIME_WAITING_FOR_INPUT)==osOK)
++++    {
++++      do
++++      {
++++        p = low_level_input( netif );
++++        if (p != NULL)
++++        {
++++          if (netif->input( p, netif) != ERR_OK )
++++          {
++++            pbuf_free(p);
++++          }
++++        }
++++      }while(p!=NULL);
++++    }
+++   }
+++ }
+++ 
+++ /**
+++- * Should be called at the beginning of the program to set up the
+++- * network interface. It calls the function low_level_init() to do the
+++- * actual setup of the hardware.
+++- *
+++- * This function should be passed as a parameter to netif_add().
+++- *
+++- * @param netif the lwip network interface structure for this ethernetif
+++- * @return ERR_OK if the loopif is initialized
+++- *         ERR_MEM if private data couldn't be allocated
+++- *         any other err_t on error
+++- */
+++-err_t
+++-ethernetif_init(struct netif *netif)
++++  * @brief Should be called at the beginning of the program to set up the
++++  * network interface. It calls the function low_level_init() to do the
++++  * actual setup of the hardware.
++++  *
++++  * This function should be passed as a parameter to netif_add().
++++  *
++++  * @param netif the lwip network interface structure for this ethernetif
++++  * @return ERR_OK if the loopif is initialized
++++  *         ERR_MEM if private data couldn't be allocated
++++  *         any other err_t on error
++++  */
++++err_t ethernetif_init(struct netif *netif)
+++ {
+++-  struct ethernetif *ethernetif;
+++-
+++   LWIP_ASSERT("netif != NULL", (netif != NULL));
+++-    
+++-  ethernetif = mem_malloc(sizeof(struct ethernetif));
+++-  if (ethernetif == NULL) {
+++-    LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_init: out of memory\n"));
+++-    return ERR_MEM;
+++-  }
+++ 
+++ #if LWIP_NETIF_HOSTNAME
+++   /* Initialize interface hostname */
+++   netif->hostname = "lwip";
+++ #endif /* LWIP_NETIF_HOSTNAME */
+++ 
+++-  /*
+++-   * Initialize the snmp variables and counters inside the struct netif.
+++-   * The last argument should be replaced with your link speed, in units
+++-   * of bits per second.
+++-   */
+++-  NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, LINK_SPEED_OF_YOUR_NETIF_IN_BPS);
+++-
+++-  netif->state = ethernetif;
+++   netif->name[0] = IFNAME0;
+++   netif->name[1] = IFNAME1;
+++-  /* We directly use etharp_output() here to save a function call.
+++-   * You can instead declare your own function an call etharp_output()
+++-   * from it if you have to do some checks before sending (e.g. if link
+++-   * is available...) */
++++
+++   netif->output = etharp_output;
+++-#if LWIP_IPV6
+++-  netif->output_ip6 = ethip6_output;
+++-#endif /* LWIP_IPV6 */
+++   netif->linkoutput = low_level_output;
+++-  
+++-  ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
+++-  
++++
+++   /* initialize the hardware */
+++   low_level_init(netif);
+++ 
+++   return ERR_OK;
+++ }
+++ 
+++-#endif /* 0 */
++++/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+++-- 
+++1.9.1
+++
+++
+++From ab97b49d1d41e34fdfdfb457b397c768ee228c9f Mon Sep 17 00:00:00 2001
+++From: Jay Doyle <jay.doyle@vecna.com>
+++Date: Mon, 7 Sep 2015 09:39:20 -0400
+++Subject: [PATCH 5/9] removed ethernetif (it should be in BSP
+++
+++---
+++ src/netif/ethernetif.c | 496 -------------------------------------------------
+++ 1 file changed, 496 deletions(-)
+++ delete mode 100644 src/netif/ethernetif.c
+++
+++diff --git a/src/netif/ethernetif.c b/src/netif/ethernetif.c
+++deleted file mode 100644
+++index 82c85ae..0000000
+++--- a/src/netif/ethernetif.c
++++++ /dev/null
+++@@ -1,496 +0,0 @@
+++-/**
+++-  ******************************************************************************
+++-  * @file    LwIP/LwIP_HTTP_Server_Netconn_RTOS/Src/ethernetif.c
+++-  * @author  MCD Application Team
+++-  * @version V1.0.0
+++-  * @date    25-June-2015
+++-  * @brief   This file implements Ethernet network interface drivers for lwIP
+++-  ******************************************************************************
+++-  * @attention
+++-  *
+++-  * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
+++-  *
+++-  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+++-  * You may not use this file except in compliance with the License.
+++-  * You may obtain a copy of the License at:
+++-  *
+++-  *        http://www.st.com/software_license_agreement_liberty_v2
+++-  *
+++-  * Unless required by applicable law or agreed to in writing, software 
+++-  * distributed under the License is distributed on an "AS IS" BASIS, 
+++-  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+++-  * See the License for the specific language governing permissions and
+++-  * limitations under the License.
+++-  *
+++-  ******************************************************************************
+++-  */
+++-
+++-/* Includes ------------------------------------------------------------------*/
+++-#include "stm32f7xx_hal.h"
+++-#include "lwip/opt.h"
+++-#include "lwip/lwip_timers.h"
+++-#include "netif/etharp.h"
+++-#include "hal-ethernetif.h"
+++-#include <string.h>
+++-
+++-/* Private typedef -----------------------------------------------------------*/
+++-/* Private define ------------------------------------------------------------*/
+++-/* The time to block waiting for input. */
+++-#define TIME_WAITING_FOR_INPUT                 ( 100 )
+++-/* Stack size of the interface thread */
+++-#define INTERFACE_THREAD_STACK_SIZE            ( 350 )
+++-
+++-/* Define those to better describe your network interface. */
+++-#define IFNAME0 'e'
+++-#define IFNAME1 'n'
+++-
+++-#define LAN8742A_PHY_ADDRESS            0x00
+++-
+++-/* Private macro -------------------------------------------------------------*/
+++-/* Private variables ---------------------------------------------------------*/
+++-
+++-#if defined ( __ICCARM__ ) /*!< IAR Compiler */
+++-
+++-#pragma location=0x2000E000
+++-__no_init ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
+++-#pragma location=0x2000E100
+++-__no_init ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
+++-#elif defined ( __CC_ARM   )
+++-ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((at(0x2000E000)));/* Ethernet Rx MA Descriptor */
+++-ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((at(0x2000E100)));/* Ethernet Tx DMA Descriptor */
+++-#elif defined ( __GNUC__   )
+++-//ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".RxDescripSection")));/* Ethernet Rx MA Descriptor */
+++-//ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".TxDescripSection")));/* Ethernet Tx DMA Descriptor */
+++-ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Rx MA Descriptor */
+++-ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Tx DMA Descriptor */
+++-
+++-
+++-#endif
+++-#if defined ( __ICCARM__ ) /*!< IAR Compiler */
+++-#pragma location=0x2000E200
+++-__no_init uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
+++-#pragma location=0x2000FFC4
+++-__no_init uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
+++-#elif defined ( __CC_ARM   )
+++-uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((at(0x2000E200)));  /* Ethernet Receive Buffer */
+++-uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]  __attribute__((at(0x2000FFC4))); /* Ethernet Transmit Buffer */
+++-#elif defined ( __GNUC__   )
+++-//uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".RxBUF")));/* Ethernet Receive Buffer */
+++-//uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".TxBUF")));/* Ethernet Transmit Buffer */
+++-uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Receive Buffer */
+++-uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Transmit Buffer */
+++-
+++-#endif
+++-/* Semaphore to signal incoming packets */
+++-osSemaphoreId s_xSemaphore = NULL;
+++-
+++-/* Global Ethernet handle*/
+++-ETH_HandleTypeDef EthHandle;
+++-
+++-/* Private function prototypes -----------------------------------------------*/
+++-static void ethernetif_input( void const * argument );
+++-
+++-static void stm32f_ethernet_isr(
+++-  void* argData
+++-)
+++-{
+++-  ETH_HandleTypeDef* pEth =
+++-    (ETH_HandleTypeDef*) argData;
+++-
+++-  HAL_ETH_IRQHandler(pEth);
+++-}
+++-
+++-/* Private functions ---------------------------------------------------------*/
+++-/*******************************************************************************
+++-                       Ethernet MSP Routines
+++-*******************************************************************************/
+++-/**
+++-  * @brief  Initializes the ETH MSP.
+++-  * @param  heth: ETH handle
+++-  * @retval None
+++-  */
+++-void HAL_ETH_MspInit(ETH_HandleTypeDef *heth)
+++-{
+++-  GPIO_InitTypeDef GPIO_InitStructure;
+++-  
+++-  /* Enable GPIOs clocks */
+++-  __HAL_RCC_GPIOA_CLK_ENABLE();
+++-  __HAL_RCC_GPIOC_CLK_ENABLE();
+++-  __HAL_RCC_GPIOG_CLK_ENABLE();
+++-
+++-/* Ethernet pins configuration ************************************************/
+++-  /*
+++-        RMII_REF_CLK ----------------------> PA1
+++-        RMII_MDIO -------------------------> PA2
+++-        RMII_MDC --------------------------> PC1
+++-        RMII_MII_CRS_DV -------------------> PA7
+++-        RMII_MII_RXD0 ---------------------> PC4
+++-        RMII_MII_RXD1 ---------------------> PC5
+++-        RMII_MII_RXER ---------------------> PG2
+++-        RMII_MII_TX_EN --------------------> PG11
+++-        RMII_MII_TXD0 ---------------------> PG13
+++-        RMII_MII_TXD1 ---------------------> PG14
+++-  */
+++-
+++-  /* Configure PA1, PA2 and PA7 */
+++-  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
+++-  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
+++-  GPIO_InitStructure.Pull = GPIO_NOPULL; 
+++-  GPIO_InitStructure.Alternate = GPIO_AF11_ETH;
+++-  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
+++-  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
+++-  
+++-  /* Configure PC1, PC4 and PC5 */
+++-  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;
+++-  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
+++-
+++-  /* Configure PG2, PG11, PG13 and PG14 */
+++-  GPIO_InitStructure.Pin =  GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14;
+++-  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
+++-  
+++-  // Install HAL Ethernet ISR
+++-  rtems_interrupt_handler_install(
+++-    ETH_IRQn,
+++-    NULL,
+++-    0,
+++-    stm32f_ethernet_isr,
+++-    heth);
+++-  
+++-  /* Enable ETHERNET clock  */
+++-  __HAL_RCC_ETH_CLK_ENABLE();
+++-}
+++-
+++-/**
+++-  * @brief  Ethernet Rx Transfer completed callback
+++-  * @param  heth: ETH handle
+++-  * @retval None
+++-  */
+++-void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
+++-{
+++-  osSemaphoreRelease(s_xSemaphore);
+++-}
+++-
+++-/**
+++-  * @brief  Ethernet IRQ Handler
+++-  * @param  None
+++-  * @retval None
+++-  */
+++-void ETHERNET_IRQHandler(void)
+++-{
+++-  HAL_ETH_IRQHandler(&EthHandle);
+++-}
+++-
+++-/*******************************************************************************
+++-                       LL Driver Interface ( LwIP stack --> ETH) 
+++-*******************************************************************************/
+++-/**
+++-  * @brief In this function, the hardware should be initialized.
+++-  * Called from ethernetif_init().
+++-  *
+++-  * @param netif the already initialized lwip network interface structure
+++-  *        for this ethernetif
+++-  */
+++-static void low_level_init(struct netif *netif)
+++-{
+++-  uint8_t macaddress[6]= { MAC_ADDR0, MAC_ADDR1, MAC_ADDR2, MAC_ADDR3, MAC_ADDR4, MAC_ADDR5 };
+++-  
+++-  EthHandle.Instance = ETH;  
+++-  EthHandle.Init.MACAddr = macaddress;
+++-  EthHandle.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
+++-  EthHandle.Init.Speed = ETH_SPEED_100M;
+++-  EthHandle.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
+++-  EthHandle.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
+++-  EthHandle.Init.RxMode = ETH_RXINTERRUPT_MODE;
+++-  EthHandle.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
+++-  EthHandle.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
+++-  
+++-  /* configure ethernet peripheral (GPIOs, clocks, MAC, DMA) */
+++-  if (HAL_ETH_Init(&EthHandle) == HAL_OK)
+++-  {
+++-    /* Set netif link flag */
+++-    netif->flags |= NETIF_FLAG_LINK_UP;
+++-  }
+++-  
+++-  /* Initialize Tx Descriptors list: Chain Mode */
+++-  HAL_ETH_DMATxDescListInit(&EthHandle, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
+++-     
+++-  /* Initialize Rx Descriptors list: Chain Mode  */
+++-  HAL_ETH_DMARxDescListInit(&EthHandle, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
+++-  
+++-  /* set netif MAC hardware address length */
+++-  netif->hwaddr_len = ETHARP_HWADDR_LEN;
+++-
+++-  /* set netif MAC hardware address */
+++-  netif->hwaddr[0] =  MAC_ADDR0;
+++-  netif->hwaddr[1] =  MAC_ADDR1;
+++-  netif->hwaddr[2] =  MAC_ADDR2;
+++-  netif->hwaddr[3] =  MAC_ADDR3;
+++-  netif->hwaddr[4] =  MAC_ADDR4;
+++-  netif->hwaddr[5] =  MAC_ADDR5;
+++-
+++-  /* set netif maximum transfer unit */
+++-  netif->mtu = 1500;
+++-
+++-  /* Accept broadcast address and ARP traffic */
+++-  netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
+++-
+++-  /* create a binary semaphore used for informing ethernetif of frame reception */
+++-  osSemaphoreDef(SEM);
+++-  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1 );
+++-
+++-  /* create the task that handles the ETH_MAC */
+++-  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
+++-  osThreadCreate (osThread(EthIf), netif);
+++-
+++-  /* Enable MAC and DMA transmission and reception */
+++-  HAL_ETH_Start(&EthHandle);
+++-}
+++-
+++-
+++-/**
+++-  * @brief This function should do the actual transmission of the packet. The packet is
+++-  * contained in the pbuf that is passed to the function. This pbuf
+++-  * might be chained.
+++-  *
+++-  * @param netif the lwip network interface structure for this ethernetif
+++-  * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
+++-  * @return ERR_OK if the packet could be sent
+++-  *         an err_t value if the packet couldn't be sent
+++-  *
+++-  * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
+++-  *       strange results. You might consider waiting for space in the DMA queue
+++-  *       to become available since the stack doesn't retry to send a packet
+++-  *       dropped because of memory failure (except for the TCP timers).
+++-  */
+++-static err_t low_level_output(struct netif *netif, struct pbuf *p)
+++-{
+++-  err_t errval;
+++-  struct pbuf *q;
+++-  uint8_t *buffer = (uint8_t *)(EthHandle.TxDesc->Buffer1Addr);
+++-  __IO ETH_DMADescTypeDef *DmaTxDesc;
+++-  uint32_t framelength = 0;
+++-  uint32_t bufferoffset = 0;
+++-  uint32_t byteslefttocopy = 0;
+++-  uint32_t payloadoffset = 0;
+++-
+++-  DmaTxDesc = EthHandle.TxDesc;
+++-  bufferoffset = 0;
+++-  
+++-  /* copy frame from pbufs to driver buffers */
+++-  for(q = p; q != NULL; q = q->next)
+++-  {
+++-    /* Is this buffer available? If not, goto error */
+++-    if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
+++-    {
+++-      errval = ERR_USE;
+++-      goto error;
+++-    }
+++-    
+++-    /* Get bytes in current lwIP buffer */
+++-    byteslefttocopy = q->len;
+++-    payloadoffset = 0;
+++-    
+++-    /* Check if the length of data to copy is bigger than Tx buffer size*/
+++-    while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
+++-    {
+++-      /* Copy data to Tx buffer*/
+++-      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
+++-      
+++-      /* Point to next descriptor */
+++-      DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
+++-      
+++-      /* Check if the buffer is available */
+++-      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
+++-      {
+++-        errval = ERR_USE;
+++-        goto error;
+++-      }
+++-      
+++-      buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
+++-      
+++-      byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
+++-      payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
+++-      framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
+++-      bufferoffset = 0;
+++-    }
+++-    
+++-    /* Copy the remaining bytes */
+++-    memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
+++-    bufferoffset = bufferoffset + byteslefttocopy;
+++-    framelength = framelength + byteslefttocopy;
+++-  }
+++-  
+++-  /* Prepare transmit descriptors to give to DMA */ 
+++-  HAL_ETH_TransmitFrame(&EthHandle, framelength);
+++-  
+++-  errval = ERR_OK;
+++-  
+++-error:
+++-  
+++-  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
+++-  if ((EthHandle.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
+++-  {
+++-    /* Clear TUS ETHERNET DMA flag */
+++-    EthHandle.Instance->DMASR = ETH_DMASR_TUS;
+++-    
+++-    /* Resume DMA transmission*/
+++-    EthHandle.Instance->DMATPDR = 0;
+++-  }
+++-  return errval;
+++-}
+++-
+++-/**
+++-  * @brief Should allocate a pbuf and transfer the bytes of the incoming
+++-  * packet from the interface into the pbuf.
+++-  *
+++-  * @param netif the lwip network interface structure for this ethernetif
+++-  * @return a pbuf filled with the received packet (including MAC header)
+++-  *         NULL on memory error
+++-  */
+++-static struct pbuf * low_level_input(struct netif *netif)
+++-{
+++-  struct pbuf *p = NULL, *q = NULL;
+++-  uint16_t len = 0;
+++-  uint8_t *buffer;
+++-  __IO ETH_DMADescTypeDef *dmarxdesc;
+++-  uint32_t bufferoffset = 0;
+++-  uint32_t payloadoffset = 0;
+++-  uint32_t byteslefttocopy = 0;
+++-  uint32_t i=0;
+++-  
+++-  /* get received frame */
+++-  if(HAL_ETH_GetReceivedFrame_IT(&EthHandle) != HAL_OK)
+++-    return NULL;
+++-  
+++-  /* Obtain the size of the packet and put it into the "len" variable. */
+++-  len = EthHandle.RxFrameInfos.length;
+++-  buffer = (uint8_t *)EthHandle.RxFrameInfos.buffer;
+++-  
+++-  if (len > 0)
+++-  {
+++-    /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
+++-    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
+++-  }
+++-  
+++-  if (p != NULL)
+++-  {
+++-    dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
+++-    bufferoffset = 0;
+++-    
+++-    for(q = p; q != NULL; q = q->next)
+++-    {
+++-      byteslefttocopy = q->len;
+++-      payloadoffset = 0;
+++-      
+++-      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size */
+++-      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
+++-      {
+++-        /* Copy data to pbuf */
+++-        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
+++-        
+++-        /* Point to next descriptor */
+++-        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
+++-        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
+++-        
+++-        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
+++-        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
+++-        bufferoffset = 0;
+++-      }
+++-      
+++-      /* Copy remaining data in pbuf */
+++-      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
+++-      bufferoffset = bufferoffset + byteslefttocopy;
+++-    }
+++-  }
+++-    
+++-  /* Release descriptors to DMA */
+++-  /* Point to first descriptor */
+++-  dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
+++-  /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
+++-  for (i=0; i< EthHandle.RxFrameInfos.SegCount; i++)
+++-  {  
+++-    dmarxdesc->Status |= ETH_DMARXDESC_OWN;
+++-    dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
+++-  }
+++-    
+++-  /* Clear Segment_Count */
+++-  EthHandle.RxFrameInfos.SegCount =0;
+++-  
+++-  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
+++-  if ((EthHandle.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
+++-  {
+++-    /* Clear RBUS ETHERNET DMA flag */
+++-    EthHandle.Instance->DMASR = ETH_DMASR_RBUS;
+++-    /* Resume DMA reception */
+++-    EthHandle.Instance->DMARPDR = 0;
+++-  }
+++-  return p;
+++-}
+++-
+++-/**
+++-  * @brief This function is the ethernetif_input task, it is processed when a packet 
+++-  * is ready to be read from the interface. It uses the function low_level_input() 
+++-  * that should handle the actual reception of bytes from the network
+++-  * interface. Then the type of the received packet is determined and
+++-  * the appropriate input function is called.
+++-  *
+++-  * @param netif the lwip network interface structure for this ethernetif
+++-  */
+++-void ethernetif_input( void const * argument )
+++-{
+++-  struct pbuf *p;
+++-  struct netif *netif = (struct netif *) argument;
+++-  
+++-  for( ;; )
+++-  {
+++-    if (osSemaphoreWait( s_xSemaphore, TIME_WAITING_FOR_INPUT)==osOK)
+++-    {
+++-      do
+++-      {
+++-        p = low_level_input( netif );
+++-        if (p != NULL)
+++-        {
+++-          if (netif->input( p, netif) != ERR_OK )
+++-          {
+++-            pbuf_free(p);
+++-          }
+++-        }
+++-      }while(p!=NULL);
+++-    }
+++-  }
+++-}
+++-
+++-/**
+++-  * @brief Should be called at the beginning of the program to set up the
+++-  * network interface. It calls the function low_level_init() to do the
+++-  * actual setup of the hardware.
+++-  *
+++-  * This function should be passed as a parameter to netif_add().
+++-  *
+++-  * @param netif the lwip network interface structure for this ethernetif
+++-  * @return ERR_OK if the loopif is initialized
+++-  *         ERR_MEM if private data couldn't be allocated
+++-  *         any other err_t on error
+++-  */
+++-err_t ethernetif_init(struct netif *netif)
+++-{
+++-  LWIP_ASSERT("netif != NULL", (netif != NULL));
+++-
+++-#if LWIP_NETIF_HOSTNAME
+++-  /* Initialize interface hostname */
+++-  netif->hostname = "lwip";
+++-#endif /* LWIP_NETIF_HOSTNAME */
+++-
+++-  netif->name[0] = IFNAME0;
+++-  netif->name[1] = IFNAME1;
+++-
+++-  netif->output = etharp_output;
+++-  netif->linkoutput = low_level_output;
+++-
+++-  /* initialize the hardware */
+++-  low_level_init(netif);
+++-
+++-  return ERR_OK;
+++-}
+++-
+++-/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+++-- 
+++1.9.1
+++
+++
+++From 31d34fab26b1e3fde99fe7288786725fe5e51b95 Mon Sep 17 00:00:00 2001
+++From: Jay Doyle <jay.doyle@vecna.com>
+++Date: Mon, 7 Sep 2015 10:17:32 -0400
+++Subject: [PATCH 6/9] add low level driver back
+++
+++---
+++ src/netif/ethernetif.c | 496 +++++++++++++++++++++++++++++++++++++++++++++++++
+++ 1 file changed, 496 insertions(+)
+++ create mode 100644 src/netif/ethernetif.c
+++
+++diff --git a/src/netif/ethernetif.c b/src/netif/ethernetif.c
+++new file mode 100644
+++index 0000000..bc429e9
+++--- /dev/null
++++++ b/src/netif/ethernetif.c
+++@@ -0,0 +1,496 @@
++++/**
++++  ******************************************************************************
++++  * @file    LwIP/LwIP_HTTP_Server_Netconn_RTOS/Src/ethernetif.c
++++  * @author  MCD Application Team
++++  * @version V1.0.0
++++  * @date    25-June-2015
++++  * @brief   This file implements Ethernet network interface drivers for lwIP
++++  ******************************************************************************
++++  * @attention
++++  *
++++  * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
++++  *
++++  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
++++  * You may not use this file except in compliance with the License.
++++  * You may obtain a copy of the License at:
++++  *
++++  *        http://www.st.com/software_license_agreement_liberty_v2
++++  *
++++  * Unless required by applicable law or agreed to in writing, software 
++++  * distributed under the License is distributed on an "AS IS" BASIS, 
++++  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++++  * See the License for the specific language governing permissions and
++++  * limitations under the License.
++++  *
++++  ******************************************************************************
++++  */
++++
++++/* Includes ------------------------------------------------------------------*/
++++#include <stm32f7xx_hal.h>
++++#include <lwip/opt.h>
++++#include <lwip/lwip_timers.h>
++++#include <netif/etharp.h>
++++#include <hal-ethernetif.h>
++++#include <string.h>
++++
++++/* Private typedef -----------------------------------------------------------*/
++++/* Private define ------------------------------------------------------------*/
++++/* The time to block waiting for input. */
++++#define TIME_WAITING_FOR_INPUT                 ( 100 )
++++/* Stack size of the interface thread */
++++#define INTERFACE_THREAD_STACK_SIZE            ( 350 )
++++
++++/* Define those to better describe your network interface. */
++++#define IFNAME0 'e'
++++#define IFNAME1 'n'
++++
++++#define LAN8742A_PHY_ADDRESS            0x00
++++
++++/* Private macro -------------------------------------------------------------*/
++++/* Private variables ---------------------------------------------------------*/
++++
++++#if defined ( __ICCARM__ ) /*!< IAR Compiler */
++++
++++#pragma location=0x2000E000
++++__no_init ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
++++#pragma location=0x2000E100
++++__no_init ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
++++#elif defined ( __CC_ARM   )
++++ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((at(0x2000E000)));/* Ethernet Rx MA Descriptor */
++++ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((at(0x2000E100)));/* Ethernet Tx DMA Descriptor */
++++#elif defined ( __GNUC__   )
++++//ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".RxDescripSection")));/* Ethernet Rx MA Descriptor */
++++//ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".TxDescripSection")));/* Ethernet Tx DMA Descriptor */
++++ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Rx MA Descriptor */
++++ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Tx DMA Descriptor */
++++
++++
++++#endif
++++#if defined ( __ICCARM__ ) /*!< IAR Compiler */
++++#pragma location=0x2000E200
++++__no_init uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
++++#pragma location=0x2000FFC4
++++__no_init uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
++++#elif defined ( __CC_ARM   )
++++uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((at(0x2000E200)));  /* Ethernet Receive Buffer */
++++uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]  __attribute__((at(0x2000FFC4))); /* Ethernet Transmit Buffer */
++++#elif defined ( __GNUC__   )
++++//uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".RxBUF")));/* Ethernet Receive Buffer */
++++//uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".TxBUF")));/* Ethernet Transmit Buffer */
++++uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Receive Buffer */
++++uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Transmit Buffer */
++++
++++#endif
++++/* Semaphore to signal incoming packets */
++++osSemaphoreId s_xSemaphore = NULL;
++++
++++/* Global Ethernet handle*/
++++ETH_HandleTypeDef EthHandle;
++++
++++/* Private function prototypes -----------------------------------------------*/
++++static void ethernetif_input( void const * argument );
++++
++++static void stm32f_ethernet_isr(
++++  void* argData
++++)
++++{
++++  ETH_HandleTypeDef* pEth =
++++    (ETH_HandleTypeDef*) argData;
++++
++++  HAL_ETH_IRQHandler(pEth);
++++}
++++
++++/* Private functions ---------------------------------------------------------*/
++++/*******************************************************************************
++++                       Ethernet MSP Routines
++++*******************************************************************************/
++++/**
++++  * @brief  Initializes the ETH MSP.
++++  * @param  heth: ETH handle
++++  * @retval None
++++  */
++++void HAL_ETH_MspInit(ETH_HandleTypeDef *heth)
++++{
++++  GPIO_InitTypeDef GPIO_InitStructure;
++++  
++++  /* Enable GPIOs clocks */
++++  __HAL_RCC_GPIOA_CLK_ENABLE();
++++  __HAL_RCC_GPIOC_CLK_ENABLE();
++++  __HAL_RCC_GPIOG_CLK_ENABLE();
++++
++++/* Ethernet pins configuration ************************************************/
++++  /*
++++        RMII_REF_CLK ----------------------> PA1
++++        RMII_MDIO -------------------------> PA2
++++        RMII_MDC --------------------------> PC1
++++        RMII_MII_CRS_DV -------------------> PA7
++++        RMII_MII_RXD0 ---------------------> PC4
++++        RMII_MII_RXD1 ---------------------> PC5
++++        RMII_MII_RXER ---------------------> PG2
++++        RMII_MII_TX_EN --------------------> PG11
++++        RMII_MII_TXD0 ---------------------> PG13
++++        RMII_MII_TXD1 ---------------------> PG14
++++  */
++++
++++  /* Configure PA1, PA2 and PA7 */
++++  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
++++  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
++++  GPIO_InitStructure.Pull = GPIO_NOPULL; 
++++  GPIO_InitStructure.Alternate = GPIO_AF11_ETH;
++++  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
++++  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
++++  
++++  /* Configure PC1, PC4 and PC5 */
++++  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;
++++  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
++++
++++  /* Configure PG2, PG11, PG13 and PG14 */
++++  GPIO_InitStructure.Pin =  GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14;
++++  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
++++  
++++  // Install HAL Ethernet ISR
++++  rtems_interrupt_handler_install(
++++    ETH_IRQn,
++++    NULL,
++++    0,
++++    stm32f_ethernet_isr,
++++    heth);
++++  
++++  /* Enable ETHERNET clock  */
++++  __HAL_RCC_ETH_CLK_ENABLE();
++++}
++++
++++/**
++++  * @brief  Ethernet Rx Transfer completed callback
++++  * @param  heth: ETH handle
++++  * @retval None
++++  */
++++void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
++++{
++++  osSemaphoreRelease(s_xSemaphore);
++++}
++++
++++/**
++++  * @brief  Ethernet IRQ Handler
++++  * @param  None
++++  * @retval None
++++  */
++++void ETHERNET_IRQHandler(void)
++++{
++++  HAL_ETH_IRQHandler(&EthHandle);
++++}
++++
++++/*******************************************************************************
++++                       LL Driver Interface ( LwIP stack --> ETH) 
++++*******************************************************************************/
++++/**
++++  * @brief In this function, the hardware should be initialized.
++++  * Called from ethernetif_init().
++++  *
++++  * @param netif the already initialized lwip network interface structure
++++  *        for this ethernetif
++++  */
++++static void low_level_init(struct netif *netif)
++++{
++++  uint8_t macaddress[6]= { MAC_ADDR0, MAC_ADDR1, MAC_ADDR2, MAC_ADDR3, MAC_ADDR4, MAC_ADDR5 };
++++  
++++  EthHandle.Instance = ETH;  
++++  EthHandle.Init.MACAddr = macaddress;
++++  EthHandle.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
++++  EthHandle.Init.Speed = ETH_SPEED_100M;
++++  EthHandle.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
++++  EthHandle.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
++++  EthHandle.Init.RxMode = ETH_RXINTERRUPT_MODE;
++++  EthHandle.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
++++  EthHandle.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
++++  
++++  /* configure ethernet peripheral (GPIOs, clocks, MAC, DMA) */
++++  if (HAL_ETH_Init(&EthHandle) == HAL_OK)
++++  {
++++    /* Set netif link flag */
++++    netif->flags |= NETIF_FLAG_LINK_UP;
++++  }
++++  
++++  /* Initialize Tx Descriptors list: Chain Mode */
++++  HAL_ETH_DMATxDescListInit(&EthHandle, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
++++     
++++  /* Initialize Rx Descriptors list: Chain Mode  */
++++  HAL_ETH_DMARxDescListInit(&EthHandle, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
++++  
++++  /* set netif MAC hardware address length */
++++  netif->hwaddr_len = ETHARP_HWADDR_LEN;
++++
++++  /* set netif MAC hardware address */
++++  netif->hwaddr[0] =  MAC_ADDR0;
++++  netif->hwaddr[1] =  MAC_ADDR1;
++++  netif->hwaddr[2] =  MAC_ADDR2;
++++  netif->hwaddr[3] =  MAC_ADDR3;
++++  netif->hwaddr[4] =  MAC_ADDR4;
++++  netif->hwaddr[5] =  MAC_ADDR5;
++++
++++  /* set netif maximum transfer unit */
++++  netif->mtu = 1500;
++++
++++  /* Accept broadcast address and ARP traffic */
++++  netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
++++
++++  /* create a binary semaphore used for informing ethernetif of frame reception */
++++  osSemaphoreDef(SEM);
++++  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1 );
++++
++++  /* create the task that handles the ETH_MAC */
++++  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
++++  osThreadCreate (osThread(EthIf), netif);
++++
++++  /* Enable MAC and DMA transmission and reception */
++++  HAL_ETH_Start(&EthHandle);
++++}
++++
++++
++++/**
++++  * @brief This function should do the actual transmission of the packet. The packet is
++++  * contained in the pbuf that is passed to the function. This pbuf
++++  * might be chained.
++++  *
++++  * @param netif the lwip network interface structure for this ethernetif
++++  * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
++++  * @return ERR_OK if the packet could be sent
++++  *         an err_t value if the packet couldn't be sent
++++  *
++++  * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
++++  *       strange results. You might consider waiting for space in the DMA queue
++++  *       to become available since the stack doesn't retry to send a packet
++++  *       dropped because of memory failure (except for the TCP timers).
++++  */
++++static err_t low_level_output(struct netif *netif, struct pbuf *p)
++++{
++++  err_t errval;
++++  struct pbuf *q;
++++  uint8_t *buffer = (uint8_t *)(EthHandle.TxDesc->Buffer1Addr);
++++  __IO ETH_DMADescTypeDef *DmaTxDesc;
++++  uint32_t framelength = 0;
++++  uint32_t bufferoffset = 0;
++++  uint32_t byteslefttocopy = 0;
++++  uint32_t payloadoffset = 0;
++++
++++  DmaTxDesc = EthHandle.TxDesc;
++++  bufferoffset = 0;
++++  
++++  /* copy frame from pbufs to driver buffers */
++++  for(q = p; q != NULL; q = q->next)
++++  {
++++    /* Is this buffer available? If not, goto error */
++++    if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
++++    {
++++      errval = ERR_USE;
++++      goto error;
++++    }
++++    
++++    /* Get bytes in current lwIP buffer */
++++    byteslefttocopy = q->len;
++++    payloadoffset = 0;
++++    
++++    /* Check if the length of data to copy is bigger than Tx buffer size*/
++++    while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
++++    {
++++      /* Copy data to Tx buffer*/
++++      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
++++      
++++      /* Point to next descriptor */
++++      DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
++++      
++++      /* Check if the buffer is available */
++++      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
++++      {
++++        errval = ERR_USE;
++++        goto error;
++++      }
++++      
++++      buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
++++      
++++      byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
++++      payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
++++      framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
++++      bufferoffset = 0;
++++    }
++++    
++++    /* Copy the remaining bytes */
++++    memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
++++    bufferoffset = bufferoffset + byteslefttocopy;
++++    framelength = framelength + byteslefttocopy;
++++  }
++++  
++++  /* Prepare transmit descriptors to give to DMA */ 
++++  HAL_ETH_TransmitFrame(&EthHandle, framelength);
++++  
++++  errval = ERR_OK;
++++  
++++error:
++++  
++++  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
++++  if ((EthHandle.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
++++  {
++++    /* Clear TUS ETHERNET DMA flag */
++++    EthHandle.Instance->DMASR = ETH_DMASR_TUS;
++++    
++++    /* Resume DMA transmission*/
++++    EthHandle.Instance->DMATPDR = 0;
++++  }
++++  return errval;
++++}
++++
++++/**
++++  * @brief Should allocate a pbuf and transfer the bytes of the incoming
++++  * packet from the interface into the pbuf.
++++  *
++++  * @param netif the lwip network interface structure for this ethernetif
++++  * @return a pbuf filled with the received packet (including MAC header)
++++  *         NULL on memory error
++++  */
++++static struct pbuf * low_level_input(struct netif *netif)
++++{
++++  struct pbuf *p = NULL, *q = NULL;
++++  uint16_t len = 0;
++++  uint8_t *buffer;
++++  __IO ETH_DMADescTypeDef *dmarxdesc;
++++  uint32_t bufferoffset = 0;
++++  uint32_t payloadoffset = 0;
++++  uint32_t byteslefttocopy = 0;
++++  uint32_t i=0;
++++  
++++  /* get received frame */
++++  if(HAL_ETH_GetReceivedFrame_IT(&EthHandle) != HAL_OK)
++++    return NULL;
++++  
++++  /* Obtain the size of the packet and put it into the "len" variable. */
++++  len = EthHandle.RxFrameInfos.length;
++++  buffer = (uint8_t *)EthHandle.RxFrameInfos.buffer;
++++  
++++  if (len > 0)
++++  {
++++    /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
++++    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
++++  }
++++  
++++  if (p != NULL)
++++  {
++++    dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
++++    bufferoffset = 0;
++++    
++++    for(q = p; q != NULL; q = q->next)
++++    {
++++      byteslefttocopy = q->len;
++++      payloadoffset = 0;
++++      
++++      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size */
++++      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
++++      {
++++        /* Copy data to pbuf */
++++        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
++++        
++++        /* Point to next descriptor */
++++        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
++++        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
++++        
++++        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
++++        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
++++        bufferoffset = 0;
++++      }
++++      
++++      /* Copy remaining data in pbuf */
++++      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
++++      bufferoffset = bufferoffset + byteslefttocopy;
++++    }
++++  }
++++    
++++  /* Release descriptors to DMA */
++++  /* Point to first descriptor */
++++  dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
++++  /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
++++  for (i=0; i< EthHandle.RxFrameInfos.SegCount; i++)
++++  {  
++++    dmarxdesc->Status |= ETH_DMARXDESC_OWN;
++++    dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
++++  }
++++    
++++  /* Clear Segment_Count */
++++  EthHandle.RxFrameInfos.SegCount =0;
++++  
++++  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
++++  if ((EthHandle.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
++++  {
++++    /* Clear RBUS ETHERNET DMA flag */
++++    EthHandle.Instance->DMASR = ETH_DMASR_RBUS;
++++    /* Resume DMA reception */
++++    EthHandle.Instance->DMARPDR = 0;
++++  }
++++  return p;
++++}
++++
++++/**
++++  * @brief This function is the ethernetif_input task, it is processed when a packet 
++++  * is ready to be read from the interface. It uses the function low_level_input() 
++++  * that should handle the actual reception of bytes from the network
++++  * interface. Then the type of the received packet is determined and
++++  * the appropriate input function is called.
++++  *
++++  * @param netif the lwip network interface structure for this ethernetif
++++  */
++++void ethernetif_input( void const * argument )
++++{
++++  struct pbuf *p;
++++  struct netif *netif = (struct netif *) argument;
++++  
++++  for( ;; )
++++  {
++++    if (osSemaphoreWait( s_xSemaphore, TIME_WAITING_FOR_INPUT)==osOK)
++++    {
++++      do
++++      {
++++        p = low_level_input( netif );
++++        if (p != NULL)
++++        {
++++          if (netif->input( p, netif) != ERR_OK )
++++          {
++++            pbuf_free(p);
++++          }
++++        }
++++      }while(p!=NULL);
++++    }
++++  }
++++}
++++
++++/**
++++  * @brief Should be called at the beginning of the program to set up the
++++  * network interface. It calls the function low_level_init() to do the
++++  * actual setup of the hardware.
++++  *
++++  * This function should be passed as a parameter to netif_add().
++++  *
++++  * @param netif the lwip network interface structure for this ethernetif
++++  * @return ERR_OK if the loopif is initialized
++++  *         ERR_MEM if private data couldn't be allocated
++++  *         any other err_t on error
++++  */
++++err_t ethernetif_init(struct netif *netif)
++++{
++++  LWIP_ASSERT("netif != NULL", (netif != NULL));
++++
++++#if LWIP_NETIF_HOSTNAME
++++  /* Initialize interface hostname */
++++  netif->hostname = "lwip";
++++#endif /* LWIP_NETIF_HOSTNAME */
++++
++++  netif->name[0] = IFNAME0;
++++  netif->name[1] = IFNAME1;
++++
++++  netif->output = etharp_output;
++++  netif->linkoutput = low_level_output;
++++
++++  /* initialize the hardware */
++++  low_level_init(netif);
++++
++++  return ERR_OK;
++++}
++++
++++/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+++-- 
+++1.9.1
+++
+++
+++From 81eded01bb2bc35a9b627e5cf35b2021efb5972c Mon Sep 17 00:00:00 2001
+++From: Jay Doyle <jay.doyle@vecna.com>
+++Date: Mon, 7 Sep 2015 10:22:57 -0400
+++Subject: [PATCH 7/9] Added bsp path
+++
+++---
+++ Makefile | 4 +++-
+++ 1 file changed, 3 insertions(+), 1 deletion(-)
+++
+++diff --git a/Makefile b/Makefile
+++index 6efa141..a855d9f 100644
+++--- a/Makefile
++++++ b/Makefile
+++@@ -13,6 +13,8 @@ LWIP_EXEC=lwip
+++ 
+++ #### PATHS #####################################################################
+++ 
++++BSP_PATH=/opt/rtems-4.11/arm-rtems4.11/stm32f7x/lib/include/bsp
++++
+++ # LWIP
+++ LWIP_PATH=.
+++ LWIP_SRC_PATH=$(LWIP_PATH)/src
+++@@ -97,7 +99,7 @@ DRIVER_H=$(LWIPDRIVER_INCL_PATH)
+++ # HEADERS
+++ HEADERS=-I$(CORE_H) -I$(POSIX_H) -I$(POSIX_SYS_H) -I$(NETIF_H) \
+++         -I$(NETIF_H_PPP) -I$(NETIF_H_PPP_POLARSSL) -I$(ARCH_H) \
+++-        -I$(DRIVER_H) -I$(IPV4_H)
++++        -I$(DRIVER_H) -I$(IPV4_H) -I$(BSP_PATH)
+++ 
+++ 
+++ ################################################################################
+++-- 
+++1.9.1
+++
+++
+++From f114529d5af1e2a83b49b67d631b10c02648e8d8 Mon Sep 17 00:00:00 2001
+++From: Jay Doyle <jay.doyle@vecna.com>
+++Date: Mon, 7 Sep 2015 10:54:26 -0400
+++Subject: [PATCH 8/9] removed ethernetif.c
+++
+++---
+++ src/netif/ethernetif.c | 496 -------------------------------------------------
+++ 1 file changed, 496 deletions(-)
+++ delete mode 100644 src/netif/ethernetif.c
+++
+++diff --git a/src/netif/ethernetif.c b/src/netif/ethernetif.c
+++deleted file mode 100644
+++index bc429e9..0000000
+++--- a/src/netif/ethernetif.c
++++++ /dev/null
+++@@ -1,496 +0,0 @@
+++-/**
+++-  ******************************************************************************
+++-  * @file    LwIP/LwIP_HTTP_Server_Netconn_RTOS/Src/ethernetif.c
+++-  * @author  MCD Application Team
+++-  * @version V1.0.0
+++-  * @date    25-June-2015
+++-  * @brief   This file implements Ethernet network interface drivers for lwIP
+++-  ******************************************************************************
+++-  * @attention
+++-  *
+++-  * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
+++-  *
+++-  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+++-  * You may not use this file except in compliance with the License.
+++-  * You may obtain a copy of the License at:
+++-  *
+++-  *        http://www.st.com/software_license_agreement_liberty_v2
+++-  *
+++-  * Unless required by applicable law or agreed to in writing, software 
+++-  * distributed under the License is distributed on an "AS IS" BASIS, 
+++-  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+++-  * See the License for the specific language governing permissions and
+++-  * limitations under the License.
+++-  *
+++-  ******************************************************************************
+++-  */
+++-
+++-/* Includes ------------------------------------------------------------------*/
+++-#include <stm32f7xx_hal.h>
+++-#include <lwip/opt.h>
+++-#include <lwip/lwip_timers.h>
+++-#include <netif/etharp.h>
+++-#include <hal-ethernetif.h>
+++-#include <string.h>
+++-
+++-/* Private typedef -----------------------------------------------------------*/
+++-/* Private define ------------------------------------------------------------*/
+++-/* The time to block waiting for input. */
+++-#define TIME_WAITING_FOR_INPUT                 ( 100 )
+++-/* Stack size of the interface thread */
+++-#define INTERFACE_THREAD_STACK_SIZE            ( 350 )
+++-
+++-/* Define those to better describe your network interface. */
+++-#define IFNAME0 'e'
+++-#define IFNAME1 'n'
+++-
+++-#define LAN8742A_PHY_ADDRESS            0x00
+++-
+++-/* Private macro -------------------------------------------------------------*/
+++-/* Private variables ---------------------------------------------------------*/
+++-
+++-#if defined ( __ICCARM__ ) /*!< IAR Compiler */
+++-
+++-#pragma location=0x2000E000
+++-__no_init ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
+++-#pragma location=0x2000E100
+++-__no_init ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
+++-#elif defined ( __CC_ARM   )
+++-ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((at(0x2000E000)));/* Ethernet Rx MA Descriptor */
+++-ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((at(0x2000E100)));/* Ethernet Tx DMA Descriptor */
+++-#elif defined ( __GNUC__   )
+++-//ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".RxDescripSection")));/* Ethernet Rx MA Descriptor */
+++-//ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".TxDescripSection")));/* Ethernet Tx DMA Descriptor */
+++-ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Rx MA Descriptor */
+++-ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Tx DMA Descriptor */
+++-
+++-
+++-#endif
+++-#if defined ( __ICCARM__ ) /*!< IAR Compiler */
+++-#pragma location=0x2000E200
+++-__no_init uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
+++-#pragma location=0x2000FFC4
+++-__no_init uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
+++-#elif defined ( __CC_ARM   )
+++-uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((at(0x2000E200)));  /* Ethernet Receive Buffer */
+++-uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]  __attribute__((at(0x2000FFC4))); /* Ethernet Transmit Buffer */
+++-#elif defined ( __GNUC__   )
+++-//uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".RxBUF")));/* Ethernet Receive Buffer */
+++-//uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".TxBUF")));/* Ethernet Transmit Buffer */
+++-uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Receive Buffer */
+++-uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Transmit Buffer */
+++-
+++-#endif
+++-/* Semaphore to signal incoming packets */
+++-osSemaphoreId s_xSemaphore = NULL;
+++-
+++-/* Global Ethernet handle*/
+++-ETH_HandleTypeDef EthHandle;
+++-
+++-/* Private function prototypes -----------------------------------------------*/
+++-static void ethernetif_input( void const * argument );
+++-
+++-static void stm32f_ethernet_isr(
+++-  void* argData
+++-)
+++-{
+++-  ETH_HandleTypeDef* pEth =
+++-    (ETH_HandleTypeDef*) argData;
+++-
+++-  HAL_ETH_IRQHandler(pEth);
+++-}
+++-
+++-/* Private functions ---------------------------------------------------------*/
+++-/*******************************************************************************
+++-                       Ethernet MSP Routines
+++-*******************************************************************************/
+++-/**
+++-  * @brief  Initializes the ETH MSP.
+++-  * @param  heth: ETH handle
+++-  * @retval None
+++-  */
+++-void HAL_ETH_MspInit(ETH_HandleTypeDef *heth)
+++-{
+++-  GPIO_InitTypeDef GPIO_InitStructure;
+++-  
+++-  /* Enable GPIOs clocks */
+++-  __HAL_RCC_GPIOA_CLK_ENABLE();
+++-  __HAL_RCC_GPIOC_CLK_ENABLE();
+++-  __HAL_RCC_GPIOG_CLK_ENABLE();
+++-
+++-/* Ethernet pins configuration ************************************************/
+++-  /*
+++-        RMII_REF_CLK ----------------------> PA1
+++-        RMII_MDIO -------------------------> PA2
+++-        RMII_MDC --------------------------> PC1
+++-        RMII_MII_CRS_DV -------------------> PA7
+++-        RMII_MII_RXD0 ---------------------> PC4
+++-        RMII_MII_RXD1 ---------------------> PC5
+++-        RMII_MII_RXER ---------------------> PG2
+++-        RMII_MII_TX_EN --------------------> PG11
+++-        RMII_MII_TXD0 ---------------------> PG13
+++-        RMII_MII_TXD1 ---------------------> PG14
+++-  */
+++-
+++-  /* Configure PA1, PA2 and PA7 */
+++-  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
+++-  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
+++-  GPIO_InitStructure.Pull = GPIO_NOPULL; 
+++-  GPIO_InitStructure.Alternate = GPIO_AF11_ETH;
+++-  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
+++-  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
+++-  
+++-  /* Configure PC1, PC4 and PC5 */
+++-  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;
+++-  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
+++-
+++-  /* Configure PG2, PG11, PG13 and PG14 */
+++-  GPIO_InitStructure.Pin =  GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14;
+++-  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
+++-  
+++-  // Install HAL Ethernet ISR
+++-  rtems_interrupt_handler_install(
+++-    ETH_IRQn,
+++-    NULL,
+++-    0,
+++-    stm32f_ethernet_isr,
+++-    heth);
+++-  
+++-  /* Enable ETHERNET clock  */
+++-  __HAL_RCC_ETH_CLK_ENABLE();
+++-}
+++-
+++-/**
+++-  * @brief  Ethernet Rx Transfer completed callback
+++-  * @param  heth: ETH handle
+++-  * @retval None
+++-  */
+++-void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
+++-{
+++-  osSemaphoreRelease(s_xSemaphore);
+++-}
+++-
+++-/**
+++-  * @brief  Ethernet IRQ Handler
+++-  * @param  None
+++-  * @retval None
+++-  */
+++-void ETHERNET_IRQHandler(void)
+++-{
+++-  HAL_ETH_IRQHandler(&EthHandle);
+++-}
+++-
+++-/*******************************************************************************
+++-                       LL Driver Interface ( LwIP stack --> ETH) 
+++-*******************************************************************************/
+++-/**
+++-  * @brief In this function, the hardware should be initialized.
+++-  * Called from ethernetif_init().
+++-  *
+++-  * @param netif the already initialized lwip network interface structure
+++-  *        for this ethernetif
+++-  */
+++-static void low_level_init(struct netif *netif)
+++-{
+++-  uint8_t macaddress[6]= { MAC_ADDR0, MAC_ADDR1, MAC_ADDR2, MAC_ADDR3, MAC_ADDR4, MAC_ADDR5 };
+++-  
+++-  EthHandle.Instance = ETH;  
+++-  EthHandle.Init.MACAddr = macaddress;
+++-  EthHandle.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
+++-  EthHandle.Init.Speed = ETH_SPEED_100M;
+++-  EthHandle.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
+++-  EthHandle.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
+++-  EthHandle.Init.RxMode = ETH_RXINTERRUPT_MODE;
+++-  EthHandle.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
+++-  EthHandle.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
+++-  
+++-  /* configure ethernet peripheral (GPIOs, clocks, MAC, DMA) */
+++-  if (HAL_ETH_Init(&EthHandle) == HAL_OK)
+++-  {
+++-    /* Set netif link flag */
+++-    netif->flags |= NETIF_FLAG_LINK_UP;
+++-  }
+++-  
+++-  /* Initialize Tx Descriptors list: Chain Mode */
+++-  HAL_ETH_DMATxDescListInit(&EthHandle, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
+++-     
+++-  /* Initialize Rx Descriptors list: Chain Mode  */
+++-  HAL_ETH_DMARxDescListInit(&EthHandle, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
+++-  
+++-  /* set netif MAC hardware address length */
+++-  netif->hwaddr_len = ETHARP_HWADDR_LEN;
+++-
+++-  /* set netif MAC hardware address */
+++-  netif->hwaddr[0] =  MAC_ADDR0;
+++-  netif->hwaddr[1] =  MAC_ADDR1;
+++-  netif->hwaddr[2] =  MAC_ADDR2;
+++-  netif->hwaddr[3] =  MAC_ADDR3;
+++-  netif->hwaddr[4] =  MAC_ADDR4;
+++-  netif->hwaddr[5] =  MAC_ADDR5;
+++-
+++-  /* set netif maximum transfer unit */
+++-  netif->mtu = 1500;
+++-
+++-  /* Accept broadcast address and ARP traffic */
+++-  netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
+++-
+++-  /* create a binary semaphore used for informing ethernetif of frame reception */
+++-  osSemaphoreDef(SEM);
+++-  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1 );
+++-
+++-  /* create the task that handles the ETH_MAC */
+++-  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
+++-  osThreadCreate (osThread(EthIf), netif);
+++-
+++-  /* Enable MAC and DMA transmission and reception */
+++-  HAL_ETH_Start(&EthHandle);
+++-}
+++-
+++-
+++-/**
+++-  * @brief This function should do the actual transmission of the packet. The packet is
+++-  * contained in the pbuf that is passed to the function. This pbuf
+++-  * might be chained.
+++-  *
+++-  * @param netif the lwip network interface structure for this ethernetif
+++-  * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
+++-  * @return ERR_OK if the packet could be sent
+++-  *         an err_t value if the packet couldn't be sent
+++-  *
+++-  * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
+++-  *       strange results. You might consider waiting for space in the DMA queue
+++-  *       to become available since the stack doesn't retry to send a packet
+++-  *       dropped because of memory failure (except for the TCP timers).
+++-  */
+++-static err_t low_level_output(struct netif *netif, struct pbuf *p)
+++-{
+++-  err_t errval;
+++-  struct pbuf *q;
+++-  uint8_t *buffer = (uint8_t *)(EthHandle.TxDesc->Buffer1Addr);
+++-  __IO ETH_DMADescTypeDef *DmaTxDesc;
+++-  uint32_t framelength = 0;
+++-  uint32_t bufferoffset = 0;
+++-  uint32_t byteslefttocopy = 0;
+++-  uint32_t payloadoffset = 0;
+++-
+++-  DmaTxDesc = EthHandle.TxDesc;
+++-  bufferoffset = 0;
+++-  
+++-  /* copy frame from pbufs to driver buffers */
+++-  for(q = p; q != NULL; q = q->next)
+++-  {
+++-    /* Is this buffer available? If not, goto error */
+++-    if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
+++-    {
+++-      errval = ERR_USE;
+++-      goto error;
+++-    }
+++-    
+++-    /* Get bytes in current lwIP buffer */
+++-    byteslefttocopy = q->len;
+++-    payloadoffset = 0;
+++-    
+++-    /* Check if the length of data to copy is bigger than Tx buffer size*/
+++-    while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
+++-    {
+++-      /* Copy data to Tx buffer*/
+++-      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
+++-      
+++-      /* Point to next descriptor */
+++-      DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
+++-      
+++-      /* Check if the buffer is available */
+++-      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
+++-      {
+++-        errval = ERR_USE;
+++-        goto error;
+++-      }
+++-      
+++-      buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
+++-      
+++-      byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
+++-      payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
+++-      framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
+++-      bufferoffset = 0;
+++-    }
+++-    
+++-    /* Copy the remaining bytes */
+++-    memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
+++-    bufferoffset = bufferoffset + byteslefttocopy;
+++-    framelength = framelength + byteslefttocopy;
+++-  }
+++-  
+++-  /* Prepare transmit descriptors to give to DMA */ 
+++-  HAL_ETH_TransmitFrame(&EthHandle, framelength);
+++-  
+++-  errval = ERR_OK;
+++-  
+++-error:
+++-  
+++-  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
+++-  if ((EthHandle.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
+++-  {
+++-    /* Clear TUS ETHERNET DMA flag */
+++-    EthHandle.Instance->DMASR = ETH_DMASR_TUS;
+++-    
+++-    /* Resume DMA transmission*/
+++-    EthHandle.Instance->DMATPDR = 0;
+++-  }
+++-  return errval;
+++-}
+++-
+++-/**
+++-  * @brief Should allocate a pbuf and transfer the bytes of the incoming
+++-  * packet from the interface into the pbuf.
+++-  *
+++-  * @param netif the lwip network interface structure for this ethernetif
+++-  * @return a pbuf filled with the received packet (including MAC header)
+++-  *         NULL on memory error
+++-  */
+++-static struct pbuf * low_level_input(struct netif *netif)
+++-{
+++-  struct pbuf *p = NULL, *q = NULL;
+++-  uint16_t len = 0;
+++-  uint8_t *buffer;
+++-  __IO ETH_DMADescTypeDef *dmarxdesc;
+++-  uint32_t bufferoffset = 0;
+++-  uint32_t payloadoffset = 0;
+++-  uint32_t byteslefttocopy = 0;
+++-  uint32_t i=0;
+++-  
+++-  /* get received frame */
+++-  if(HAL_ETH_GetReceivedFrame_IT(&EthHandle) != HAL_OK)
+++-    return NULL;
+++-  
+++-  /* Obtain the size of the packet and put it into the "len" variable. */
+++-  len = EthHandle.RxFrameInfos.length;
+++-  buffer = (uint8_t *)EthHandle.RxFrameInfos.buffer;
+++-  
+++-  if (len > 0)
+++-  {
+++-    /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
+++-    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
+++-  }
+++-  
+++-  if (p != NULL)
+++-  {
+++-    dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
+++-    bufferoffset = 0;
+++-    
+++-    for(q = p; q != NULL; q = q->next)
+++-    {
+++-      byteslefttocopy = q->len;
+++-      payloadoffset = 0;
+++-      
+++-      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size */
+++-      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
+++-      {
+++-        /* Copy data to pbuf */
+++-        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
+++-        
+++-        /* Point to next descriptor */
+++-        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
+++-        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
+++-        
+++-        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
+++-        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
+++-        bufferoffset = 0;
+++-      }
+++-      
+++-      /* Copy remaining data in pbuf */
+++-      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
+++-      bufferoffset = bufferoffset + byteslefttocopy;
+++-    }
+++-  }
+++-    
+++-  /* Release descriptors to DMA */
+++-  /* Point to first descriptor */
+++-  dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
+++-  /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
+++-  for (i=0; i< EthHandle.RxFrameInfos.SegCount; i++)
+++-  {  
+++-    dmarxdesc->Status |= ETH_DMARXDESC_OWN;
+++-    dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
+++-  }
+++-    
+++-  /* Clear Segment_Count */
+++-  EthHandle.RxFrameInfos.SegCount =0;
+++-  
+++-  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
+++-  if ((EthHandle.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
+++-  {
+++-    /* Clear RBUS ETHERNET DMA flag */
+++-    EthHandle.Instance->DMASR = ETH_DMASR_RBUS;
+++-    /* Resume DMA reception */
+++-    EthHandle.Instance->DMARPDR = 0;
+++-  }
+++-  return p;
+++-}
+++-
+++-/**
+++-  * @brief This function is the ethernetif_input task, it is processed when a packet 
+++-  * is ready to be read from the interface. It uses the function low_level_input() 
+++-  * that should handle the actual reception of bytes from the network
+++-  * interface. Then the type of the received packet is determined and
+++-  * the appropriate input function is called.
+++-  *
+++-  * @param netif the lwip network interface structure for this ethernetif
+++-  */
+++-void ethernetif_input( void const * argument )
+++-{
+++-  struct pbuf *p;
+++-  struct netif *netif = (struct netif *) argument;
+++-  
+++-  for( ;; )
+++-  {
+++-    if (osSemaphoreWait( s_xSemaphore, TIME_WAITING_FOR_INPUT)==osOK)
+++-    {
+++-      do
+++-      {
+++-        p = low_level_input( netif );
+++-        if (p != NULL)
+++-        {
+++-          if (netif->input( p, netif) != ERR_OK )
+++-          {
+++-            pbuf_free(p);
+++-          }
+++-        }
+++-      }while(p!=NULL);
+++-    }
+++-  }
+++-}
+++-
+++-/**
+++-  * @brief Should be called at the beginning of the program to set up the
+++-  * network interface. It calls the function low_level_init() to do the
+++-  * actual setup of the hardware.
+++-  *
+++-  * This function should be passed as a parameter to netif_add().
+++-  *
+++-  * @param netif the lwip network interface structure for this ethernetif
+++-  * @return ERR_OK if the loopif is initialized
+++-  *         ERR_MEM if private data couldn't be allocated
+++-  *         any other err_t on error
+++-  */
+++-err_t ethernetif_init(struct netif *netif)
+++-{
+++-  LWIP_ASSERT("netif != NULL", (netif != NULL));
+++-
+++-#if LWIP_NETIF_HOSTNAME
+++-  /* Initialize interface hostname */
+++-  netif->hostname = "lwip";
+++-#endif /* LWIP_NETIF_HOSTNAME */
+++-
+++-  netif->name[0] = IFNAME0;
+++-  netif->name[1] = IFNAME1;
+++-
+++-  netif->output = etharp_output;
+++-  netif->linkoutput = low_level_output;
+++-
+++-  /* initialize the hardware */
+++-  low_level_init(netif);
+++-
+++-  return ERR_OK;
+++-}
+++-
+++-/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+++-- 
+++1.9.1
+++
+++
+++From badcd5771d8fa3046a2cd7aa07536c6dcb703891 Mon Sep 17 00:00:00 2001
+++From: Jay Doyle <jay.doyle@vecna.com>
+++Date: Mon, 28 Sep 2015 13:47:22 -0400
+++Subject: [PATCH 9/9] enable BSD sockets naming
+++
+++---
+++ ports/include/lwipopts.h | 2 +-
+++ 1 file changed, 1 insertion(+), 1 deletion(-)
+++
+++diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
+++index 169ba46..9149c29 100644
+++--- a/ports/include/lwipopts.h
++++++ b/ports/include/lwipopts.h
+++@@ -169,7 +169,7 @@
+++  * LWIP_COMPAT_SOCKETS==1: Enable BSD-style sockets functions names.
+++  * (only used if you use sockets.c)
+++  */
+++-#define LWIP_COMPAT_SOCKETS             0
++++#define LWIP_COMPAT_SOCKETS             1
+++ 
+++ #define LWIP_TIMEVAL_PRIVATE            0
+++ 
+++-- 
+++1.9.1
+++
++-- 
++1.9.1
++
+-- 
+1.9.1
+
+
+From 6e898ad87870ca775a3c9a38a05437d02b6f6ba5 Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Mon, 28 Sep 2015 16:33:04 -0400
+Subject: [PATCH 13/13] defined cache line size
+
+---
+ ports/include/lwipopts.h | 2 ++
+ 1 file changed, 2 insertions(+)
+
+diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
+index 4c23d97..41b67a1 100644
+--- a/ports/include/lwipopts.h
++++ b/ports/include/lwipopts.h
+@@ -180,6 +180,8 @@
+ 
+ #else
+ 
++#define SOC_CACHELINE_SIZE_BYTES        32            /* Number of bytes in
++                                                         a cache line */
+ /**
+  * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
+  * critical regions during buffer allocation, deallocation and memory
\ No newline at end of file
-- 
1.9.1


From 5ebf0076b70c1c78c5761d3689972b397558824f Mon Sep 17 00:00:00 2001
From: Jay Doyle <jay.doyle@vecna.com>
Date: Mon, 28 Sep 2015 16:44:20 -0400
Subject: [PATCH 20/33] revert to original settings

---
 ports/include/lwipopts.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
index 2b218ec..ea8e09c 100644
--- a/ports/include/lwipopts.h
+++ b/ports/include/lwipopts.h
@@ -38,7 +38,7 @@
 #ifndef __LWIPOPTS_H__
 #define __LWIPOPTS_H__
 
-
+#define ORIGINAL_CONFIG_OPTIONS 1
 #if ORIGINAL_CONFIG_OPTIONS
 
 /*****************************************************************************
-- 
1.9.1


From 8bc5b4e5120e3190ef2405dd9ae476477ec768b1 Mon Sep 17 00:00:00 2001
From: Jay Doyle <jay.doyle@vecna.com>
Date: Mon, 28 Sep 2015 16:53:05 -0400
Subject: [PATCH 21/33] increased memory

---
 ports/include/lwipopts.h | 19 +++++++++++--------
 1 file changed, 11 insertions(+), 8 deletions(-)

diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
index ea8e09c..ec45f74 100644
--- a/ports/include/lwipopts.h
+++ b/ports/include/lwipopts.h
@@ -51,8 +51,7 @@
 ** separate pool for each memory. The alignment of pbuf pool to cache line
 ** size is done in /ports/cpsw/include/arch/cc.h.
 */
-/*#define LWIP_CACHE_ENABLED*/
-
+#define LWIP_CACHE_ENABLED
 #define SOC_CACHELINE_SIZE_BYTES        32            /* Number of bytes in
                                                          a cache line */
 /*
@@ -87,16 +86,21 @@
 **                          Memory Options
 *****************************************************************************/
 #define MEM_ALIGNMENT                   4
-#define MEM_SIZE                        (256 * 1024) /* 128K */
+#define MEM_SIZE                        (512 * 1024) /* 256K */
 
 #define MEMP_NUM_PBUF                   96
 #define MEMP_NUM_TCP_PCB                32
 #define MEMP_NUM_TCP_SEG                32
+
+/* ---------- Pbuf options ---------- */
+/* PBUF_POOL_SIZE: the number of buffers in the pbuf pool. */
 #define PBUF_POOL_SIZE                  512
 
+/* PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. */
+#define PBUF_POOL_BUFSIZE               1524
+
 #ifdef LWIP_CACHE_ENABLED
-#define MEMP_SEPARATE_POOLS             1            /* We want the pbuf
-                                                        pool cache line
+#define MEMP_SEPARATE_POOLS             1            /* We want the pbuf                                                        pool cache line
                                                         aligned*/
 #endif
 
@@ -166,8 +170,6 @@
 #define LWIP_STATS_DISPLAY              0
 #define LWIP_STATS_POSIX                0
 
-
-
 /**
  * LWIP_COMPAT_SOCKETS==1: Enable BSD-style sockets functions names.
  * (only used if you use sockets.c)
@@ -175,8 +177,9 @@
 #define LWIP_COMPAT_SOCKETS             1
 
 #define LWIP_TIMEVAL_PRIVATE            0
+#define LWIP_RAW                        0
 
- #define LWIP_RAW                       0
+#define configMAX_PRIORITIES            100
 
 #else
 
-- 
1.9.1


From b93de9cb181989cc08db04536ce8e784b5a38de2 Mon Sep 17 00:00:00 2001
From: Jay Doyle <jay.doyle@vecna.com>
Date: Fri, 2 Oct 2015 11:16:09 -0400
Subject: [PATCH 22/33] turn on memp buffer overflow check

---
 ports/include/lwipopts.h | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
index ec45f74..d2612e8 100644
--- a/ports/include/lwipopts.h
+++ b/ports/include/lwipopts.h
@@ -181,6 +181,8 @@
 
 #define configMAX_PRIORITIES            100
 
+#define MEMP_OVERFLOW_CHECK             2
+
 #else
 
 #define configMAX_PRIORITIES 100
-- 
1.9.1


From e1dc0d9fdf7a784a317a92a2524f4201822dea00 Mon Sep 17 00:00:00 2001
From: Jay Doyle <jay.doyle@vecna.com>
Date: Fri, 2 Oct 2015 11:29:05 -0400
Subject: [PATCH 23/33] enabled debug mode

---
 ports/include/lwipopts.h | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
index d2612e8..c35bb0e 100644
--- a/ports/include/lwipopts.h
+++ b/ports/include/lwipopts.h
@@ -182,6 +182,14 @@
 #define configMAX_PRIORITIES            100
 
 #define MEMP_OVERFLOW_CHECK             2
+/*
+   -----------------------------------
+   ---------- DEBUG options ----------
+   -----------------------------------
+*/
+
+#define LWIP_DEBUG                      1
+
 
 #else
 
-- 
1.9.1


From 71b73cbbd89bff8deb521e605a7e9af1150dbdd8 Mon Sep 17 00:00:00 2001
From: Jay Doyle <jay.doyle@vecna.com>
Date: Fri, 2 Oct 2015 11:41:53 -0400
Subject: [PATCH 24/33] more magic

---
 ports/include/lwipopts.h | 9 ++-------
 1 file changed, 2 insertions(+), 7 deletions(-)

diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
index c35bb0e..1feb8b3 100644
--- a/ports/include/lwipopts.h
+++ b/ports/include/lwipopts.h
@@ -181,15 +181,10 @@
 
 #define configMAX_PRIORITIES            100
 
+// The following should be removed -- there just debugging tests
 #define MEMP_OVERFLOW_CHECK             2
-/*
-   -----------------------------------
-   ---------- DEBUG options ----------
-   -----------------------------------
-*/
-
 #define LWIP_DEBUG                      1
-
+#define MEMP_MEM_MALLOC                 1
 
 #else
 
-- 
1.9.1


From f1828cc5d26de48e1e5d2bb5358aa53a06e5cef8 Mon Sep 17 00:00:00 2001
From: Jay Doyle <jay.doyle@vecna.com>
Date: Fri, 2 Oct 2015 13:39:45 -0400
Subject: [PATCH 25/33] return to old settings

---
 ports/include/lwipopts.h | 5 -----
 1 file changed, 5 deletions(-)

diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
index 1feb8b3..ec45f74 100644
--- a/ports/include/lwipopts.h
+++ b/ports/include/lwipopts.h
@@ -181,11 +181,6 @@
 
 #define configMAX_PRIORITIES            100
 
-// The following should be removed -- there just debugging tests
-#define MEMP_OVERFLOW_CHECK             2
-#define LWIP_DEBUG                      1
-#define MEMP_MEM_MALLOC                 1
-
 #else
 
 #define configMAX_PRIORITIES 100
-- 
1.9.1


From 38530494195183314291c300a316f51a13fad368 Mon Sep 17 00:00:00 2001
From: Jay Doyle <jay.doyle@vecna.com>
Date: Mon, 5 Oct 2015 09:31:48 -0400
Subject: [PATCH 26/33] fixed redefinition of PBUF_POOL_SIZE

---
 ports/include/lwipopts.h | 13 ++++++-------
 1 file changed, 6 insertions(+), 7 deletions(-)

diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
index ec45f74..ffdfcdd 100644
--- a/ports/include/lwipopts.h
+++ b/ports/include/lwipopts.h
@@ -93,11 +93,7 @@
 #define MEMP_NUM_TCP_SEG                32
 
 /* ---------- Pbuf options ---------- */
-/* PBUF_POOL_SIZE: the number of buffers in the pbuf pool. */
-#define PBUF_POOL_SIZE                  512
 
-/* PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. */
-#define PBUF_POOL_BUFSIZE               1524
 
 #ifdef LWIP_CACHE_ENABLED
 #define MEMP_SEPARATE_POOLS             1            /* We want the pbuf                                                        pool cache line
@@ -136,9 +132,12 @@
 **                           PBUF  Options
 *****************************************************************************/
 #define PBUF_LINK_HLEN                  14
-#define PBUF_POOL_BUFSIZE               1520         /* + size of struct pbuf
-                                                        shall be cache line
-                                                        aligned be enabled */
+/* PBUF_POOL_SIZE: the number of buffers in the pbuf pool. */
+#define PBUF_POOL_SIZE                  512
+
+/* PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. */
+#define PBUF_POOL_BUFSIZE               1524
+
 #define ETH_PAD_SIZE                    0
 #define LWIP_NETCONN                    1
 
-- 
1.9.1


From 2ed13c967105608944026aee3ecb3bd9e0f523c5 Mon Sep 17 00:00:00 2001
From: Jay Doyle <jay.doyle@vecna.com>
Date: Mon, 5 Oct 2015 09:32:31 -0400
Subject: [PATCH 27/33] iets

---
 ports/include/arch/cc.h       |   144 +-
 ports/include/arch/perf.h     |    46 +-
 ports/include/arch/sys_arch.h |   100 +-
 ports/include/lwipopts.h      |   212 +-
 ports/rtems.patch             | 14902 ++++++++++++++++++++++++++++++++++++++++
 ports/sys_arch.c              |   800 +--
 rtems.patch                   |  7917 ---------------------
 7 files changed, 15324 insertions(+), 8797 deletions(-)
 create mode 100644 ports/rtems.patch
 delete mode 100644 rtems.patch

diff --git a/ports/include/arch/cc.h b/ports/include/arch/cc.h
index 8eefd64..5964091 100644
--- a/ports/include/arch/cc.h
+++ b/ports/include/arch/cc.h
@@ -24,38 +24,62 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
  * OF SUCH DAMAGE.
  *
- * This file is part of the lwIP TCP/IP stack.
+ * This file is system adaptation of the lwIP TCP/IP stack
+ * by Adam Dunkels <adam@sics.se> for RTEMS system.
  *
- * Author: Adam Dunkels <adam@sics.se>
+ * Author: Premysl Houdek <houdepre@fel.cvut.cz>
+ * Mentor: Pavel Pisa <pisa@cmp.felk.cvut.cz>
+ * Industrial Informatics Group, FEE, Czech Technical University in Prague
  *
  */
+/*
+ * settings to adapt lwIP for compiler and machine architecture for RTEMS/GCC
+ * DETAILS: ./lwip/doc/sys_arch.txt
+ */
 #ifndef __CC_H__
 #define __CC_H__
 
-typedef unsigned    char    u8_t;
-typedef signed      char    s8_t;
-typedef unsigned    short   u16_t;
-typedef signed      short   s16_t;
-typedef unsigned    int    u32_t;
-typedef signed      int    s32_t;
-typedef u32_t           mem_ptr_t;
+#include <stdio.h>
+#include <rtems/malloc.h>  /*printk*/
+#include <inttypes.h>
+#include <malloc.h>
 
-#ifndef BYTE_ORDER
-#define BYTE_ORDER LITTLE_ENDIAN
-#endif
+/* This file must either include a system-local <errno.h> which defines
+   the standard *nix error codes, or it should #define LWIP_PROVIDE_ERRNO
+   to make lwip/arch.h define the codes which are used throughout. */
+#undef LWIP_PROVIDE_ERRNO
+
+/* type definitions */
+typedef uint8_t             u8_t;
+typedef int8_t              s8_t;
+typedef uint16_t            u16_t;
+typedef int16_t             s16_t;
+typedef uint32_t            u32_t;
+typedef int32_t             s32_t;
+typedef u32_t               mem_ptr_t;
+
+#define BYTE_ORDER BIG_ENDIAN
+
+/* Define (sn)printf formatters for these lwIP types */
+#define U16_F PRIu16
+#define S16_F PRId16
+#define X16_F PRIx16
+#define U32_F PRIu32
+#define S32_F PRId32
+#define X32_F PRIx32
 
 #if defined(__arm__) && defined(__ARMCC_VERSION)
-    //
-    // Setup PACKing macros for KEIL/RVMDK Tools
-    //
+//
+// Setup PACKing macros for KEIL/RVMDK Tools
+//
     #define PACK_STRUCT_BEGIN __packed
     #define PACK_STRUCT_STRUCT
     #define PACK_STRUCT_END
     #define PACK_STRUCT_FIELD(x) x
 #elif defined (__IAR_SYSTEMS_ICC__)
-    //
-    // Setup PACKing macros for IAR Tools
-    //
+//
+// Setup PACKing macros for IAR Tools
+//
     #define PACK_STRUCT_BEGIN
     #define PACK_STRUCT_STRUCT
     #define PACK_STRUCT_END
@@ -67,59 +91,61 @@ typedef u32_t           mem_ptr_t;
     #define PACK_STRUCT_END
     #define PACK_STRUCT_FIELD(x) x
 #else
-    //
-    // Setup PACKing macros for GCC Tools
-    //
+//
+// Setup PACKing macros for GCC Tools
+//
     #define PACK_STRUCT_BEGIN
     #define PACK_STRUCT_STRUCT __attribute__ ((__packed__))
     #define PACK_STRUCT_END
     #define PACK_STRUCT_FIELD(x) x
 #endif
 
-#ifdef LWIP_CACHE_ENABLED
-/**
- * Make the PBUF POOL cacheline aligned.
+/*
+ *     1 - load byte by byte, construct 16 bits word and add: not efficient for most platforms
+ *     2 - load first byte if odd address, loop processing 16 bits words, add last byte.
+ *     3 - load first byte and word if not 4 byte aligned, loop processing 32 bits words, add last word/byte.
+ *
+ *     see inet_chksum.c
  */
-#ifdef __IAR_SYSTEMS_ICC__
-#pragma data_alignment=SOC_CACHELINE_SIZE_BYTES
-extern u8_t memp_memory_PBUF_POOL_base[];
-#else /*By default, GCC */
-extern u8_t memp_memory_PBUF_POOL_base[] __attribute__ ((aligned (SOC_CACHELINE_SIZE_BYTES)));
-#endif
+#ifndef LWIP_CHKSUM_ALGORITHM
+#define LWIP_CHKSUM_ALGORITHM 2
 #endif
 
-extern u8_t memp_memory_PBUF_POOL_base[] __attribute__ ((aligned (SOC_CACHELINE_SIZE_BYTES)));
+/* this is used for 1) displaying statistics and 2) lwip debugging (set appropriate debugging level in lwipopts.h) */
+//#ifdef LWIP_DEBUG
 
-/* Define (sn)printf formatters for these lwIP types */
-#define X8_F  "02x"
-#define U16_F "u"
-#define S16_F "d"
-#define X16_F "x"
-#define U32_F "u"
-#define S32_F "d"
-#define X32_F "x"
 
-#include <stdio.h>
-#include <stdlib.h>
-#include <bsp.h>
-//#include <sys/time.h>
-
-#define LWIP_PLATFORM_DIAG(x)   do { \
-        printk("[%s - %s - %d] ", __PRETTY_FUNCTION__, __FILE__, __LINE__); \
-        printk x; \
-    } while(0)
-
-#ifdef LWIP_DEBUG  //DEBUG
-extern void __error__(char *pcFilename, unsigned long ulLine);
-#define LWIP_PLATFORM_ASSERT(expr)   printk("[%s - %s - %d] ", expr , __FILE__, __LINE__);
-//{
-    //if(!(expr))
-    //{
-        //__error__(__FILE__, __LINE__);
-    //}
-//}
+#define LWIP_PLATFORM_DIAG(expr)        printk expr
+
+//#else
+//#define LWIP_PLATFORM_DIAG(expr)
+//#endif
+
+//#define DEBUG
+#ifdef DEBUG
+
+/* for passing arguments to print function */
+#define CC_ASSERT(message, assertion) do { if (!(assertion)) \
+					     LWIP_PLATFORM_DIAG(message); } while (0)
+
+//extern void __error__(char *pcFilename, unsigned long ulLine);
+#define LWIP_PLATFORM_ASSERT(expr)      printk((const char *)expr)
+/*
+{                                       \
+    if(!(expr))                         \
+    {                                   \
+        __error__(__FILE__, __LINE__);  \
+    }                                   \
+}
+*/
 #else
 #define LWIP_PLATFORM_ASSERT(expr)
-#endif
+#define CC_ASSERT(message, assertion)
+#endif /* DEBUG */
+
+/* "lightweight" synchronization mechanisms */
+/* #define SYS_ARCH_DECL_PROTECT(x) */ /* declare a protection state variable */
+/* #define SYS_ARCH_PROTECT(x) */ /* enter protection mode */
+/* #define SYS_ARCH_UNPROTECT(x) */ /* leave protection mode */
 
 #endif /* __CC_H__ */
diff --git a/ports/include/arch/perf.h b/ports/include/arch/perf.h
index d754157..1f799b3 100644
--- a/ports/include/arch/perf.h
+++ b/ports/include/arch/perf.h
@@ -1,38 +1,12 @@
-/*
- * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef __PERF_H__
-#define __PERF_H__
+#ifndef _LWIP_ARCH_PERF_H_
+#define _LWIP_ARCH_PERF_H_
 
-#define PERF_START    /* null definition */
-#define PERF_STOP(x)  /* null definition */
+//perf.h     - Architecture specific performance measurement.
+//Measurement calls made throughout lwip, these can be defined to nothing.
 
-#endif /* __PERF_H__ */
+#define PERF_START
+
+#define PERF_STOP(x)
+
+
+#endif /* _LWIP_ARCH_PERF_H_ */
diff --git a/ports/include/arch/sys_arch.h b/ports/include/arch/sys_arch.h
index 32f0d99..087892b 100644
--- a/ports/include/arch/sys_arch.h
+++ b/ports/include/arch/sys_arch.h
@@ -24,36 +24,94 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
  * OF SUCH DAMAGE.
  *
- * This file is part of the lwIP TCP/IP stack.
+ * This file is system adaptation of the lwIP TCP/IP stack
+ * by Adam Dunkels <adam@sics.se> for RTEMS system.
  *
- * Author: Adam Dunkels <adam@sics.se>
+ * Author: Premysl Houdek <houdepre@fel.cvut.cz>
+ * Mentor: Pavel Pisa <pisa@cmp.felk.cvut.cz>
+ * Industrial Informatics Group, FEE, Czech Technical University in Prague
  *
  */
-#ifndef LWIP_ARCH_SYS_ARCH_H
-#define LWIP_ARCH_SYS_ARCH_H
+/*
+ * mapping of lwIP system dependencies to RTEMS system services and types.
+ * DETAILS: ./lwip/doc/sys_arch.txt
+ */
+#ifndef __ARCH_SYS_ARCH_H__
+#define __ARCH_SYS_ARCH_H__
+
+#include <rtems/rtems/sem.h>
+#include <rtems/rtems/intr.h>
+#include <bsp/irq-generic.h>
+
+/* Typedefs for the various port-specific types. */
+#if defined(NO_SYS) && NO_SYS
+  #error "RTEMS SYS_ARCH cannot be compiled in NO_SYS variant"
+#endif
+
+#define sys_arch_printk printk
+
+typedef struct {
+  rtems_id mailbox;
+  rtems_id sem;
+} port_mailbox_t;
+
+typedef struct {
+  rtems_id semaphore;
+} port_sem_t;
+
+typedef struct {
+  rtems_id mutex;
+} port_mutex_t;
+
+typedef port_mailbox_t sys_mbox_t;
+typedef port_sem_t sys_sem_t;
+typedef rtems_id sys_thread_t;
+typedef port_mutex_t sys_mutex_t;
+typedef rtems_interrupt_level sys_prot_t;
 
-#include <errno.h>
+void
+sys_arch_delay(unsigned int x);
+void
+sys_sem_signal_from_ISR(sys_sem_t *sem);
 
-#define SYS_MBOX_NULL NULL
-#define SYS_SEM_NULL  NULL
+typedef void sys_irqreturn_t;
+#define SYS_IRQ_NONE       ((void)0)
+#define SYS_IRQ_HANDLED    ((void)1)
+#define SYS_IRQ_RETVAL(x)  (IRQ_HANDLED)
+typedef rtems_interrupt_handler sys_irq_handler_t;
+#define SYS_IRQ_HANDLER_FNC(M_fnc_name)	\
+  sys_irqreturn_t M_fnc_name(void *__irq_handler_context)
+#define sys_irq_handler_get_context() (__irq_handler_context)
 
-typedef u32_t sys_prot_t;
+int
+sys_request_irq(unsigned int irqnum, sys_irq_handler_t handler,
+		unsigned long flags, const char *name, void *context);
 
-struct sys_sem;
-typedef struct sys_sem * sys_sem_t;
-#define sys_sem_valid(sem) (((sem) != NULL) && (*(sem) != NULL))
-#define sys_sem_set_invalid(sem) do { if((sem) != NULL) { *(sem) = NULL; }}while(0)
+static inline void
+sys_arch_mask_interrupt_source(unsigned int x)
+{
+  bsp_interrupt_vector_disable(x);
+}
 
-/* let sys.h use binary semaphores for mutexes */
-#define LWIP_COMPAT_MUTEX 1
+static inline void
+sys_arch_unmask_interrupt_source(unsigned int x)
+{
+  bsp_interrupt_vector_enable(x);
+}
 
-struct sys_mbox;
-typedef struct sys_mbox *sys_mbox_t;
-#define sys_mbox_valid(mbox) ((*(mbox) != NULL))
-#define sys_mbox_set_invalid(mbox) do { if((mbox) != NULL) { *(mbox) = NULL; }}while(0)
+static inline sys_prot_t
+sys_arch_protect(void)
+{
+  sys_prot_t pval;
 
-struct sys_thread;
-typedef struct sys_thread * sys_thread_t;
+  rtems_interrupt_disable(pval);
+  return pval;
+}
 
-#endif /* LWIP_ARCH_SYS_ARCH_H */
+static inline void
+sys_arch_unprotect(sys_prot_t pval)
+{
+  rtems_interrupt_enable(pval);
+}
 
+#endif /* __ARCH_SYS_ARCH_H__ */
diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
index ffdfcdd..5922306 100644
--- a/ports/include/lwipopts.h
+++ b/ports/include/lwipopts.h
@@ -38,8 +38,6 @@
 #ifndef __LWIPOPTS_H__
 #define __LWIPOPTS_H__
 
-#define ORIGINAL_CONFIG_OPTIONS 1
-#if ORIGINAL_CONFIG_OPTIONS
 
 /*****************************************************************************
 **                           CONFIGURATIONS
@@ -179,214 +177,6 @@
 #define LWIP_RAW                        0
 
 #define configMAX_PRIORITIES            100
-
-#else
-
-#define configMAX_PRIORITIES 100
-#define LWIP_CACHE_ENABLED
-#define SOC_CACHELINE_SIZE_BYTES 32
-#define LWIP_TIMEVAL_PRIVATE 0
-
-/**
- * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
- * critical regions during buffer allocation, deallocation and memory
- * allocation and deallocation.
- */
-#define SYS_LIGHTWEIGHT_PROT    0
-
-#define ETHARP_TRUST_IP_MAC     0
-#define IP_REASSEMBLY           0
-#define IP_FRAG                 0
-#define ARP_QUEUEING            0
-#define TCP_LISTEN_BACKLOG      1
-
-/**
- * NO_SYS==1: Provides VERY minimal functionality. Otherwise,
- * use lwIP facilities.
- */
-#define NO_SYS                  0
-
-/* ---------- Memory options ---------- */
-/* MEM_ALIGNMENT: should be set to the alignment of the CPU for which
-   lwIP is compiled. 4 byte alignment -> define MEM_ALIGNMENT to 4, 2
-   byte alignment -> define MEM_ALIGNMENT to 2. */
-#define MEM_ALIGNMENT           4
-
-/* MEM_SIZE: the size of the heap memory. If the application will send
-a lot of data that needs to be copied, this should be set high. */
-#define MEM_SIZE                (10*1024)
-
-/* MEMP_NUM_PBUF: the number of memp struct pbufs. If the application
-   sends a lot of data out of ROM (or other static memory), this
-   should be set high. */
-#define MEMP_NUM_PBUF           50
-/* MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks. One
-   per active UDP "connection". */
-#define MEMP_NUM_UDP_PCB        6
-/* MEMP_NUM_TCP_PCB: the number of simulatenously active TCP
-   connections. */
-#define MEMP_NUM_TCP_PCB        10
-/* MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP
-   connections. */
-#define MEMP_NUM_TCP_PCB_LISTEN 5
-/* MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP
-   segments. */
-#define MEMP_NUM_TCP_SEG        12
-/* MEMP_NUM_SYS_TIMEOUT: the number of simulateously active
-   timeouts. */
-#define MEMP_NUM_SYS_TIMEOUT    10
-
-
-/* ---------- Pbuf options ---------- */
-/* PBUF_POOL_SIZE: the number of buffers in the pbuf pool. */
-#define PBUF_POOL_SIZE          10
-
-/* PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. */
-#define PBUF_POOL_BUFSIZE       1524
-
-
-/* ---------- TCP options ---------- */
-//#define LWIP_TCP                1
-//#define TCP_TTL                 255
-
-/* Controls if TCP should queue segments that arrive out of
-   order. Define to 0 if your device is low on memory. */
-#define TCP_QUEUE_OOSEQ         0
-
-/* TCP Maximum segment size. */
-#define TCP_MSS                 (1500 - 40)   /* TCP_MSS = (Ethernet MTU - IP header size - TCP header size) */
-
-/* TCP sender buffer space (bytes). */
-#define TCP_SND_BUF             (4*TCP_MSS)
-
-/*  TCP_SND_QUEUELEN: TCP sender buffer space (pbufs). This must be at least
-  as much as (2 * TCP_SND_BUF/TCP_MSS) for things to work. */
-
-#define TCP_SND_QUEUELEN        (2* TCP_SND_BUF/TCP_MSS)
-
-/* TCP receive window. */
-#define TCP_WND                 (2*TCP_MSS)
-
-
-/* ---------- ICMP options ---------- */
-#define LWIP_ICMP                       1
-
-
-/* ---------- DHCP options ---------- */
-/* Define LWIP_DHCP to 1 if you want DHCP configuration of
-   interfaces. DHCP is not implemented in lwIP 0.5.1, however, so
-   turning this on does currently not work. */
-#define LWIP_DHCP               1
-
-
-/* ---------- UDP options ---------- */
-#define LWIP_UDP                1
-#define UDP_TTL                 255
-
-
-/* ---------- Statistics options ---------- */
-#define LWIP_STATS 0
-#define LWIP_PROVIDE_ERRNO 1
-
-/* ---------- link callback options ---------- */
-/* LWIP_NETIF_LINK_CALLBACK==1: Support a callback function from an interface
- * whenever the link a48846deb25945d360543ffe8d86766d323b9859changes (i.e., link down)
- */
-#define LWIP_NETIF_LINK_CALLBACK        1
-
-/*
-   --------------------------------------
-   ---------- Checksum options ----------
-   --------------------------------------
-*/
-
-/*
-The STM32F4x7 allows computing and verifying the IP, UDP, TCP and ICMP checksums by hardware:
- - To use this feature let the following define uncommented.
- - To disable it and process by CPU comment the  the checksum.
-*/
-#define CHECKSUM_BY_HARDWARE
-
-
-#ifdef CHECKSUM_BY_HARDWARE
-  /* CHECKSUM_GEN_IP==0: Generate checksums by hardware for outgoing IP packets.*/
-  #define CHECKSUM_GEN_IP                 0
-  /* CHECKSUM_GEN_UDP==0: Generate checksums by hardware for outgoing UDP packets.*/
-  #define CHECKSUM_GEN_UDP                0
-  /* CHECKSUM_GEN_TCP==0: Generate checksums by hardware for outgoing TCP packets.*/
-  #define CHECKSUM_GEN_TCP                0
-  /* CHECKSUM_CHECK_IP==0: Check checksums by hardware for incoming IP packets.*/
-  #define CHECKSUM_CHECK_IP               0
-  /* CHECKSUM_CHECK_UDP==0: Check checksums by hardware for incoming UDP packets.*/
-  #define CHECKSUM_CHECK_UDP              0
-  /* CHECKSUM_CHECK_TCP==0: Check checksums by hardware for incoming TCP packets.*/
-  #define CHECKSUM_CHECK_TCP              0
-  /* CHECKSUM_CHECK_ICMP==0: Check checksums by hardware for incoming ICMP packets.*/
-  #define CHECKSUM_GEN_ICMP               0
-#else
-  /* CHECKSUM_GEN_IP==1: Generate checksums in software for outgoing IP packets.*/
-  #define CHECKSUM_GEN_IP                 1
-  /* CHECKSUM_GEN_UDP==1: Generate checksums in software for outgoing UDP packets.*/
-  #define CHECKSUM_GEN_UDP                1
-  /* CHECKSUM_GEN_TCP==1: Generate checksums in software for outgoing TCP packets.*/
-  #define CHECKSUM_GEN_TCP                1
-  /* CHECKSUM_CHECK_IP==1: Check checksums in software for incoming IP packets.*/
-  #define CHECKSUM_CHECK_IP               1
-  /* CHECKSUM_CHECK_UDP==1: Check checksums in software for incoming UDP packets.*/
-  #define CHECKSUM_CHECK_UDP              1
-  /* CHECKSUM_CHECK_TCP==1: Check checksums in software for incoming TCP packets.*/
-  #define CHECKSUM_CHECK_TCP              1
-  /* CHECKSUM_CHECK_ICMP==1: Check checksums by hardware for incoming ICMP packets.*/
-  #define CHECKSUM_GEN_ICMP               1
-#endif
-
-
-/*
-   ----------------------------------------------
-   ---------- Sequential layer options ----------
-   ----------------------------------------------
-*/
-/**
- * LWIP_NETCONN==1: Enable Netconn API (require to use api_lib.c)
- */
-#define LWIP_NETCONN                    1
-
-/*
-   ------------------------------------
-   ---------- Socket options ----------
-   ------------------------------------
-*/
-/**
- * LWIP_SOCKET==1: Enable Socket API (require to use sockets.c)
- */
-#define LWIP_SOCKET                     1
-
-/*
-   -----------------------------------
-   ---------- DEBUG options ----------
-   -----------------------------------
-*/
-
-#define LWIP_DEBUG                      0
-
-
-/*
-   ---------------------------------
-   ---------- OS options ----------
-   ---------------------------------
-*/
-
-#define TCPIP_THREAD_NAME              "TCP/IP"
-#define TCPIP_THREAD_STACKSIZE          1000
-#define TCPIP_MBOX_SIZE                 5
-#define DEFAULT_UDP_RECVMBOX_SIZE       2000
-#define DEFAULT_TCP_RECVMBOX_SIZE       2000
-#define DEFAULT_ACCEPTMBOX_SIZE         2000
-#define DEFAULT_THREAD_STACKSIZE        500
-#define TCPIP_THREAD_PRIO               (configMAX_PRIORITIES - 2)
-#define LWIP_COMPAT_MUTEX               1
-
-
-#endif
+#define TCPIP_THREAD_PRIO               200
 
 #endif /* __LWIPOPTS_H__ */
diff --git a/ports/rtems.patch b/ports/rtems.patch
new file mode 100644
index 0000000..722f7e8
--- /dev/null
+++ b/ports/rtems.patch
@@ -0,0 +1,14902 @@
+From 2d83d4994e578ec339b2b1baef53090bf7a53570 Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Fri, 4 Sep 2015 17:28:55 -0400
+Subject: [PATCH 01/29] rtems changes necessary
+
+---
+ Makefile                      | 170 +++++++++++
+ ports/include/arch/cc.h       | 123 ++++++++
+ ports/include/arch/perf.h     |  38 +++
+ ports/include/arch/sys_arch.h |  59 ++++
+ ports/include/lwipopts.h      | 178 ++++++++++++
+ ports/sys_arch.c              | 663 ++++++++++++++++++++++++++++++++++++++++++
+ 6 files changed, 1231 insertions(+)
+ create mode 100644 Makefile
+ create mode 100644 ports/include/arch/cc.h
+ create mode 100644 ports/include/arch/perf.h
+ create mode 100644 ports/include/arch/sys_arch.h
+ create mode 100644 ports/include/lwipopts.h
+ create mode 100644 ports/sys_arch.c
+
+diff --git a/Makefile b/Makefile
+new file mode 100644
+index 0000000..0cbae64
+--- /dev/null
++++ b/Makefile
+@@ -0,0 +1,170 @@
++include $(RTEMS_MAKEFILE_PATH)/Makefile.inc
++include $(RTEMS_CUSTOM)
++include $(PROJECT_ROOT)/make/leaf.cfg
++
++#### CONFIG ####################################################################
++#For debugging symbols add -DLWIP_DEBUG
++# COMPILER/LINKER
++CFLAGS+=-g -O2   \
++ -Wall
++
++# OUTPUT
++LWIP_EXEC=lwip
++
++#### PATHS #####################################################################
++
++# LWIP
++LWIP_PATH=.
++LWIP_SRC_PATH=$(LWIP_PATH)/src
++LWIP_API_PATH=$(LWIP_SRC_PATH)/api
++LWIP_CORE_PATH=$(LWIP_SRC_PATH)/core
++LWIP_INCL_PATH=$(LWIP_SRC_PATH)/include
++LWIP_NETIF_PATH=$(LWIP_SRC_PATH)/netif
++
++# ARCH
++LWIPARCH_PATH=$(LWIP_PATH)/ports
++LWIPARCH_SRC_PATH=$(LWIPARCH_PATH)
++LWIPARCH_INCL_PATH=$(LWIPARCH_PATH)/include
++
++# DRIVER
++LWIPDRIVER_PATH=$(LWIP_PATH)/ports
++LWIPDRIVER_SRC_PATH=$(LWIPDRIVER_PATH)/netif
++LWIPDRIVER_INCL_PATH=$(LWIPDRIVER_PATH)/include/netif
++
++#### SOURCES ###################################################################
++
++## CORE
++CORE_SRC=$(wildcard $(LWIP_CORE_PATH)/*.c)
++
++## IPv4
++IPV4_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv4/*.c)
++
++## IPv6
++IPV6_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv6/*.c)
++
++## SNMP
++SNMP_SRC=$(wildcard $(LWIP_CORE_PATH)/snmp/*.c)
++
++## API
++API_SRC=$(wildcard $(LWIP_API_PATH)/*.c )
++
++## NETIF
++NETIF_SRC=$(wildcard $(LWIP_NETIF_PATH)/*.c) \
++          $(wildcard $(LWIP_NETIF_PATH)/ppp/*.c) \
++          $(wildcard $(LWIP_NETIF_PATH)/ppp/polarssl/*.c)
++
++
++ARCH_SRC=$(wildcard $(LWIPARCH_SRC_PATH)/*.c)
++
++# DRIVER
++DRIVER_SRC=$(wildcard $(LWIPDRIVER_SRC_PATH)/*.c ) \
++           $(wildcard $(LWIPDRIVER_SRC_PATH)/*.S )
++
++
++SOURCES =  $(DRIVER_SRC) $(SNMP_SRC)\
++           $(CORE_SRC) $(IPV4_SRC) $(API_SRC) $(NETIF_SRC) $(ARCH_SRC)
++
++
++#### HEADERS ###################################################################
++
++## CORE
++CORE_H=$(LWIP_INCL_PATH)
++
++## IPv4
++#IPV4_H=$(LWIP_INCL_PATH)/ipv4
++
++## IPv6
++#IPV6_H=$(LWIP_INCL_PATH)/ipv6
++
++## POSIX
++POSIX_H=$(LWIP_INCL_PATH)/posix
++
++##POSIX_SYS
++POSIX_SYS_H=$(LWIP_INCL_PATH)/posix/sys
++
++
++## NETIF
++NETIF_H=$(LWIP_INCL_PATH)/netif
++NETIF_H_PPP=$(LWIP_INCL_PATH)/netif/ppp
++NETIF_H_PPP_POLARSSL=$(LWIP_INCL_PATH)/netif/ppp/polarssl
++
++## ARCH
++ARCH_H=$(LWIPARCH_INCL_PATH)
++
++## DRIVER
++DRIVER_H=$(LWIPDRIVER_INCL_PATH)
++
++# HEADERS
++HEADERS=-I$(CORE_H) -I$(POSIX_H) -I$(POSIX_SYS_H) -I$(NETIF_H) \
++        -I$(NETIF_H_PPP) -I$(NETIF_H_PPP_POLARSSL) -I$(ARCH_H) \
++        -I$(DRIVER_H)
++
++
++################################################################################
++
++
++BIN=${ARCH}/$(LWIP_EXEC).bin
++LIB=${ARCH}/lib$(LWIP_EXEC).a
++
++# optional managers required
++MANAGERS=all
++
++# C source names
++CSRCS=$(filter %.c ,$(SOURCES))
++COBJS=$(patsubst %.c,${ARCH}/%.o,$(notdir $(CSRCS)))
++
++ASMSRCS=$(filter %.S , $(SOURCES))
++ASMOBJS=$(patsubst %.S,${ARCH}/%.o,$(notdir $(ASMSRCS)))
++
++OBJS=$(COBJS) $(ASMOBJS)
++
++all:${ARCH} $(LIB)
++
++$(LIB): $(OBJS)
++	$(AR)  rcs  $@ $^
++
++${ARCH}/%.o: $(LWIP_CORE_PATH)/%.c
++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
++
++${ARCH}/%.o: $(LWIP_CORE_PATH)/ipv4/%.c
++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
++
++${ARCH}/%.o: $(LWIP_CORE_PATH)/ipv6/%.c
++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
++
++${ARCH}/%.o: $(LWIP_CORE_PATH)/snmp/%.c
++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
++
++${ARCH}/%.o: $(LWIP_API_PATH)/%.c
++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
++
++${ARCH}/%.o: $(LWIP_NETIF_PATH)/%.c
++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
++
++${ARCH}/%.o: $(LWIP_NETIF_PATH)/ppp/%.c
++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
++
++${ARCH}/%.o: $(LWIP_NETIF_PATH)/ppp/polarssl/%.c
++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
++
++${ARCH}/%.o: $(LWIPARCH_SRC_PATH)/%.c
++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
++
++${ARCH}/%.o: $(LWIPDRIVER_SRC_PATH)/%.S
++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
++
++${ARCH}/%.o: $(LWIPDRIVER_SRC_PATH)/%.c
++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
++
++INSTALL_DIR=$(RTEMS_MAKEFILE_PATH)/lwip
++
++install:
++	rm -rf $(INSTALL_DIR)
++	mkdir -p $(INSTALL_DIR)/include
++	mkdir -p $(INSTALL_DIR)/lib
++	cp $(LIB) $(INSTALL_DIR)/lib
++	cp -r $(CORE_H) $(INSTALL_DIR)
++	cp $(LWIPARCH_INCL_PATH)/lwipopts.h $(INSTALL_DIR)/include
++	cp -r $(LWIPARCH_INCL_PATH)/arch $(INSTALL_DIR)/include
++
++CPPFLAGS+=$(HEADERS)
+diff --git a/ports/include/arch/cc.h b/ports/include/arch/cc.h
+new file mode 100644
+index 0000000..04ec89f
+--- /dev/null
++++ b/ports/include/arch/cc.h
+@@ -0,0 +1,123 @@
++/*
++ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
++ * All rights reserved.
++ *
++ * Redistribution and use in source and binary forms, with or without modification,
++ * are permitted provided that the following conditions are met:
++ *
++ * 1. Redistributions of source code must retain the above copyright notice,
++ *    this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright notice,
++ *    this list of conditions and the following disclaimer in the documentation
++ *    and/or other materials provided with the distribution.
++ * 3. The name of the author may not be used to endorse or promote products
++ *    derived from this software without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
++ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
++ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
++ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
++ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
++ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
++ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
++ * OF SUCH DAMAGE.
++ *
++ * This file is part of the lwIP TCP/IP stack.
++ *
++ * Author: Adam Dunkels <adam@sics.se>
++ *
++ */
++#ifndef __CC_H__
++#define __CC_H__
++
++typedef unsigned    char    u8_t;
++typedef signed      char    s8_t;
++typedef unsigned    short   u16_t;
++typedef signed      short   s16_t;
++typedef unsigned    int    u32_t;
++typedef signed      int    s32_t;
++typedef u32_t           mem_ptr_t;
++
++#ifndef BYTE_ORDER
++#define BYTE_ORDER LITTLE_ENDIAN
++#endif
++
++#if defined(__arm__) && defined(__ARMCC_VERSION)
++    //
++    // Setup PACKing macros for KEIL/RVMDK Tools
++    //
++    #define PACK_STRUCT_BEGIN __packed
++    #define PACK_STRUCT_STRUCT
++    #define PACK_STRUCT_END
++    #define PACK_STRUCT_FIELD(x) x
++#elif defined (__IAR_SYSTEMS_ICC__)
++    //
++    // Setup PACKing macros for IAR Tools
++    //
++    #define PACK_STRUCT_BEGIN
++    #define PACK_STRUCT_STRUCT
++    #define PACK_STRUCT_END
++    #define PACK_STRUCT_FIELD(x) x
++    #define PACK_STRUCT_USE_INCLUDES
++#elif defined (__TMS470__)
++    #define PACK_STRUCT_BEGIN
++    #define PACK_STRUCT_STRUCT
++    #define PACK_STRUCT_END
++    #define PACK_STRUCT_FIELD(x) x
++#else
++    //
++    // Setup PACKing macros for GCC Tools
++    //
++    #define PACK_STRUCT_BEGIN
++    #define PACK_STRUCT_STRUCT __attribute__ ((__packed__))
++    #define PACK_STRUCT_END
++    #define PACK_STRUCT_FIELD(x) x
++#endif
++
++#ifdef LWIP_CACHE_ENABLED
++/**
++ * Make the PBUF POOL cacheline aligned.
++ */
++#ifdef __IAR_SYSTEMS_ICC__
++#pragma data_alignment=SOC_CACHELINE_SIZE_BYTES
++extern u8_t memp_memory_PBUF_POOL_base[];
++#else /*By default, GCC */
++extern u8_t memp_memory_PBUF_POOL_base[] __attribute__ ((aligned (SOC_CACHELINE_SIZE_BYTES)));
++#endif
++#endif
++
++extern u8_t memp_memory_PBUF_POOL_base[] __attribute__ ((aligned (SOC_CACHELINE_SIZE_BYTES)));
++
++/* Define (sn)printf formatters for these lwIP types */
++#define X8_F  "02x"
++#define U16_F "u"
++#define S16_F "d"
++#define X16_F "x"
++#define U32_F "u"
++#define S32_F "d"
++#define X32_F "x"
++
++#include <stdio.h>
++#include <stdlib.h>
++#include <bsp.h>
++#define LWIP_PLATFORM_DIAG(x)   do { \
++        printk("[%s - %s - %d] ", __PRETTY_FUNCTION__, __FILE__, __LINE__); \
++        printk x; \
++    } while(0)
++
++#ifdef LWIP_DEBUG  //DEBUG
++extern void __error__(char *pcFilename, unsigned long ulLine);
++#define LWIP_PLATFORM_ASSERT(expr)   printk("[%s - %s - %d] ", expr , __FILE__, __LINE__);
++//{
++    //if(!(expr))
++    //{
++        //__error__(__FILE__, __LINE__);
++    //}
++//}
++#else
++#define LWIP_PLATFORM_ASSERT(expr)
++#endif
++
++#endif /* __CC_H__ */
+diff --git a/ports/include/arch/perf.h b/ports/include/arch/perf.h
+new file mode 100644
+index 0000000..d754157
+--- /dev/null
++++ b/ports/include/arch/perf.h
+@@ -0,0 +1,38 @@
++/*
++ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
++ * All rights reserved.
++ *
++ * Redistribution and use in source and binary forms, with or without modification,
++ * are permitted provided that the following conditions are met:
++ *
++ * 1. Redistributions of source code must retain the above copyright notice,
++ *    this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright notice,
++ *    this list of conditions and the following disclaimer in the documentation
++ *    and/or other materials provided with the distribution.
++ * 3. The name of the author may not be used to endorse or promote products
++ *    derived from this software without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
++ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
++ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
++ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
++ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
++ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
++ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
++ * OF SUCH DAMAGE.
++ *
++ * This file is part of the lwIP TCP/IP stack.
++ *
++ * Author: Adam Dunkels <adam@sics.se>
++ *
++ */
++#ifndef __PERF_H__
++#define __PERF_H__
++
++#define PERF_START    /* null definition */
++#define PERF_STOP(x)  /* null definition */
++
++#endif /* __PERF_H__ */
+diff --git a/ports/include/arch/sys_arch.h b/ports/include/arch/sys_arch.h
+new file mode 100644
+index 0000000..32f0d99
+--- /dev/null
++++ b/ports/include/arch/sys_arch.h
+@@ -0,0 +1,59 @@
++/*
++ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
++ * All rights reserved.
++ *
++ * Redistribution and use in source and binary forms, with or without modification,
++ * are permitted provided that the following conditions are met:
++ *
++ * 1. Redistributions of source code must retain the above copyright notice,
++ *    this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright notice,
++ *    this list of conditions and the following disclaimer in the documentation
++ *    and/or other materials provided with the distribution.
++ * 3. The name of the author may not be used to endorse or promote products
++ *    derived from this software without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
++ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
++ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
++ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
++ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
++ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
++ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
++ * OF SUCH DAMAGE.
++ *
++ * This file is part of the lwIP TCP/IP stack.
++ *
++ * Author: Adam Dunkels <adam@sics.se>
++ *
++ */
++#ifndef LWIP_ARCH_SYS_ARCH_H
++#define LWIP_ARCH_SYS_ARCH_H
++
++#include <errno.h>
++
++#define SYS_MBOX_NULL NULL
++#define SYS_SEM_NULL  NULL
++
++typedef u32_t sys_prot_t;
++
++struct sys_sem;
++typedef struct sys_sem * sys_sem_t;
++#define sys_sem_valid(sem) (((sem) != NULL) && (*(sem) != NULL))
++#define sys_sem_set_invalid(sem) do { if((sem) != NULL) { *(sem) = NULL; }}while(0)
++
++/* let sys.h use binary semaphores for mutexes */
++#define LWIP_COMPAT_MUTEX 1
++
++struct sys_mbox;
++typedef struct sys_mbox *sys_mbox_t;
++#define sys_mbox_valid(mbox) ((*(mbox) != NULL))
++#define sys_mbox_set_invalid(mbox) do { if((mbox) != NULL) { *(mbox) = NULL; }}while(0)
++
++struct sys_thread;
++typedef struct sys_thread * sys_thread_t;
++
++#endif /* LWIP_ARCH_SYS_ARCH_H */
++
+diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
+new file mode 100644
+index 0000000..169ba46
+--- /dev/null
++++ b/ports/include/lwipopts.h
+@@ -0,0 +1,178 @@
++/**
++ * \file lwipopts.h - Configuration options for lwIP
++ *
++ * Copyright (c) 2010 Texas Instruments Incorporated
++ */
++/*
++ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
++ * All rights reserved.
++ *
++ * Redistribution and use in source and binary forms, with or without modification,
++ * are permitted provided that the following conditions are met:
++ *
++ * 1. Redistributions of source code must retain the above copyright notice,
++ *    this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright notice,
++ *    this list of conditions and the following disclaimer in the documentation
++ *    and/or other materials provided with the distribution.
++ * 3. The name of the author may not be used to endorse or promote products
++ *    derived from this software without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
++ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
++ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
++ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
++ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
++ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
++ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
++ * OF SUCH DAMAGE.
++ *
++ * This file is part of the lwIP TCP/IP stack.
++ *
++ * Author: Adam Dunkels <adam@sics.se>
++ *
++ */
++
++#ifndef __LWIPOPTS_H__
++#define __LWIPOPTS_H__
++
++/*****************************************************************************
++**                           CONFIGURATIONS
++*****************************************************************************/
++
++/*
++** The below macro should be defined for using lwIP with cache. For cache
++** enabling, pbuf pool shall be cache line aligned. This is done by using
++** separate pool for each memory. The alignment of pbuf pool to cache line
++** size is done in /ports/cpsw/include/arch/cc.h.
++*/
++/*#define LWIP_CACHE_ENABLED*/
++
++#define SOC_CACHELINE_SIZE_BYTES        64            /* Number of bytes in
++                                                         a cache line */
++/*
++** The timeout for DHCP completion. lwIP library will wait for DHCP
++** completion for (LWIP_DHCP_TIMEOUT / 100) seconds.
++*/
++#define LWIP_DHCP_TIMEOUT               500
++
++/*
++** The number of times DHCP is attempted. Each time, the library will wait
++** for (LWIP_DHCP_TIMEOUT / 100) seconds for DHCP completion.
++*/
++#define NUM_DHCP_TRIES                  5
++
++#define LWIP_ETHERNET                   1
++#define LWIP_ARP                        1
++
++/*****************************************************************************
++**            lwIP SPECIFIC DEFINITIONS - To be used by lwIP stack
++*****************************************************************************/
++#define HOST_TMR_INTERVAL               0
++#define DYNAMIC_HTTP_HEADERS
++
++/*****************************************************************************
++**                    Platform specific locking
++*****************************************************************************/
++#define SYS_LIGHTWEIGHT_PROT            1
++#define NO_SYS                          0
++#define NO_SYS_NO_TIMERS                0
++
++/*****************************************************************************
++**                          Memory Options
++*****************************************************************************/
++#define MEM_ALIGNMENT                   4
++#define MEM_SIZE                        (256 * 1024) /* 128K */
++
++#define MEMP_NUM_PBUF                   96
++#define MEMP_NUM_TCP_PCB                32
++#define MEMP_NUM_TCP_SEG                32
++#define PBUF_POOL_SIZE                  512
++
++#ifdef LWIP_CACHE_ENABLED
++#define MEMP_SEPARATE_POOLS             1            /* We want the pbuf
++                                                        pool cache line
++                                                        aligned*/
++#endif
++
++#define MEMP_NUM_SYS_TIMEOUT (LWIP_TCP + IP_REASSEMBLY + LWIP_ARP + (2*LWIP_DHCP) + LWIP_AUTOIP + LWIP_IGMP + LWIP_DNS + PPP_SUPPORT)
++
++/*****************************************************************************
++**                           IP Options
++*****************************************************************************/
++#define IP_REASSEMBLY                   0
++#define IP_FRAG                         0
++
++/*****************************************************************************
++**                           DHCP Options
++*****************************************************************************/
++#define LWIP_DHCP                       1
++#define DHCP_DOES_ARP_CHECK             0
++
++/*****************************************************************************
++**                           Auto IP  Options
++*****************************************************************************/
++#define LWIP_AUTOIP                     1
++#define LWIP_DHCP_AUTOIP_COOP           ((LWIP_DHCP) && (LWIP_AUTOIP))
++
++/*****************************************************************************
++**                           TCP  Options
++*****************************************************************************/
++#define TCP_MSS                         1500
++#define TCP_WND                         (8 * TCP_MSS)
++#define TCP_SND_BUF                     (8 * TCP_MSS)
++#define TCP_OVERSIZE                    TCP_MSS
++
++/*****************************************************************************
++**                           PBUF  Options
++*****************************************************************************/
++#define PBUF_LINK_HLEN                  14
++#define PBUF_POOL_BUFSIZE               1520         /* + size of struct pbuf
++                                                        shall be cache line
++                                                        aligned be enabled */
++#define ETH_PAD_SIZE                    0
++#define LWIP_NETCONN                    1
++
++/*****************************************************************************
++**                           Socket  Options
++*****************************************************************************/
++#define LWIP_SOCKET                     1
++
++/*****************************************************************************
++**                          Debugging options
++*****************************************************************************/
++#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_OFF
++#define LWIP_DBG_TYPES_ON               (LWIP_DBG_ON | LWIP_DBG_TRACE \
++                                         |LWIP_DBG_STATE | LWIP_DBG_FRESH)
++#define DHCP_DEBUG                      LWIP_DBG_OFF
++#define NETIF_DEBUG                     LWIP_DBG_OFF
++#define IP_DEBUG			LWIP_DBG_OFF
++#define UDP_DEBUG			LWIP_DBG_OFF
++#define ETHARP_DEBUG                    LWIP_DBG_OFF
++#define SYS_DEBUG                       LWIP_DBG_OFF
++#define RAW_DEBUG                       LWIP_DBG_OFF
++#define MEM_DEBUG                       LWIP_DBG_OFF
++#define MEMP_DEBUG                      LWIP_DBG_OFF
++#define PBUF_DEBUG			LWIP_DBG_OFF
++#define TCPIP_DEBUG			LWIP_DBG_OFF
++#define APP_DEBUG			LWIP_DBG_OFF
++#define SOCKETS_DEBUG		        LWIP_DBG_OFF
++#define LWIP_STATS                      0
++#define LWIP_STATS_DISPLAY              0
++#define LWIP_STATS_POSIX                0
++
++
++
++/**
++ * LWIP_COMPAT_SOCKETS==1: Enable BSD-style sockets functions names.
++ * (only used if you use sockets.c)
++ */
++#define LWIP_COMPAT_SOCKETS             0
++
++#define LWIP_TIMEVAL_PRIVATE            0
++
++ #define LWIP_RAW                       0
++
++#endif /* __LWIPOPTS_H__ */
+diff --git a/ports/sys_arch.c b/ports/sys_arch.c
+new file mode 100644
+index 0000000..360a4e2
+--- /dev/null
++++ b/ports/sys_arch.c
+@@ -0,0 +1,663 @@
++/*
++ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
++ * All rights reserved.
++ *
++ * Redistribution and use in source and binary forms, with or without modification,
++ * are permitted provided that the following conditions are met:
++ *
++ * 1. Redistributions of source code must retain the above copyright notice,
++ *    this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright notice,
++ *    this list of conditions and the following disclaimer in the documentation
++ *    and/or other materials provided with the distribution.
++ * 3. The name of the author may not be used to endorse or promote products
++ *    derived from this software without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
++ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
++ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
++ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
++ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
++ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
++ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
++ * OF SUCH DAMAGE.
++ *
++ * This file is part of the lwIP TCP/IP stack.
++ *
++ * Author: Adam Dunkels <adam@sics.se>
++ *
++ */
++
++/*
++ * Wed Apr 17 16:05:29 EDT 2002 (James Roth)
++ *
++ *  - Fixed an unlikely sys_thread_new() race condition.
++ *
++ *  - Made current_thread() work with threads which where
++ *    not created with sys_thread_new().  This includes
++ *    the main thread and threads made with pthread_create().
++ *
++ *  - Catch overflows where more than SYS_MBOX_SIZE messages
++ *    are waiting to be read.  The sys_mbox_post() routine
++ *    will block until there is more room instead of just
++ *    leaking messages.
++ */
++
++#include <string.h>
++#include <sys/time.h>
++#include <sys/types.h>
++#include <stdlib.h>
++#include <unistd.h>
++#include <pthread.h>
++
++#include "lwip/opt.h"
++#include "lwip/sys.h"
++#include "lwip/stats.h"
++#include "lwip/debug.h"
++
++#define UMAX(a, b)      ((a) > (b) ? (a) : (b))
++
++static struct timeval starttime;
++
++#if !NO_SYS
++
++static struct sys_thread *threads = NULL;
++static pthread_mutex_t threads_mutex = PTHREAD_MUTEX_INITIALIZER;
++
++struct sys_mbox_msg {
++  struct sys_mbox_msg *next;
++  void *msg;
++};
++
++#define SYS_MBOX_SIZE 128
++
++struct sys_mbox {
++  int first, last;
++  void *msgs[SYS_MBOX_SIZE];
++  struct sys_sem *not_empty;
++  struct sys_sem *not_full;
++  struct sys_sem *mutex;
++  int wait_send;
++};
++
++struct sys_sem {
++  unsigned int c;
++  pthread_cond_t cond;
++  pthread_mutex_t mutex;
++};
++
++struct sys_thread {
++  struct sys_thread *next;
++  pthread_t pthread;
++};
++
++#if SYS_LIGHTWEIGHT_PROT
++static pthread_mutex_t lwprot_mutex = PTHREAD_MUTEX_INITIALIZER;
++static pthread_t lwprot_thread = (pthread_t)0xDEAD;
++static int lwprot_count = 0;
++#endif /* SYS_LIGHTWEIGHT_PROT */
++
++static struct sys_sem *sys_sem_new_internal(u8_t count);
++static void sys_sem_free_internal(struct sys_sem *sem);
++
++static u32_t cond_wait(pthread_cond_t * cond, pthread_mutex_t * mutex,
++                       u32_t timeout);
++
++/*-----------------------------------------------------------------------------------*/
++static struct sys_thread *
++introduce_thread(pthread_t id)
++{
++  struct sys_thread *thread = NULL;
++
++  thread = (struct sys_thread *)malloc(sizeof(struct sys_thread));
++
++  if (thread != NULL) {
++    pthread_mutex_lock(&threads_mutex);
++    thread->next = threads;
++    thread->pthread = id;
++    threads = thread;
++    pthread_mutex_unlock(&threads_mutex);
++  }
++
++  return thread;
++}
++/*-----------------------------------------------------------------------------------*/
++sys_thread_t
++sys_thread_new(const char *name, lwip_thread_fn function, void *arg, int stacksize, int prio)
++{
++  int code;
++  int rc;
++  pthread_t tmp;
++  pthread_attr_t attr;
++  struct sys_thread *st = NULL;
++  LWIP_UNUSED_ARG(name);
++  LWIP_UNUSED_ARG(stacksize);
++  LWIP_UNUSED_ARG(prio);
++
++  /* Alloc a new pthread with the specified stack size. */
++  if(stacksize > 0) {
++    rc = pthread_attr_init(&attr);
++    if (rc != 0) {
++      LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: pthread_attr_init error = %d\n", rc));
++      return NULL;
++    }
++    rc = pthread_attr_setstacksize(&attr, stacksize);
++    if (rc != 0) {
++      LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: pthread_attr_setstacksize error = %d\n", rc));
++      pthread_attr_destroy(&attr);
++      return NULL;
++    }
++    pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);
++    pthread_attr_setschedpolicy(&attr, SCHED_RR);
++    code = pthread_create(&tmp, &attr, (void *(*)(void *)) function, arg);
++    pthread_attr_destroy(&attr);
++  } else {
++    code = pthread_create(&tmp, NULL, (void *(*)(void *)) function, arg);
++  }
++  LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: thread created [name:%s|stacksize:%d|prio:%d|addr:0x%x]\n",
++                          name, stacksize, prio, (uint)tmp));
++
++  if (0 == code) {
++    st = introduce_thread(tmp);
++  }
++
++  if (NULL == st) {
++    LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: failed to introduce %d, st = %p\n",
++                            code, (void*)st));
++    abort();
++  } else {
++    LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: introduced %d, st = %p\n",
++                            code, (void*)st));
++  }
++
++  return st;
++}
++/*-----------------------------------------------------------------------------------*/
++void sys_thread_signal(sys_thread_t thread, int signal)
++{
++    /* Check received parameters. */
++    if(thread == NULL) {
++        LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_signal: could not send signal to thread. thread = NULL\n"));
++        return;
++    }
++
++    /* Send signal. */
++    pthread_kill(thread->pthread, signal);
++}
++/*-----------------------------------------------------------------------------------*/
++err_t
++sys_mbox_new(struct sys_mbox **mb, int size)
++{
++  struct sys_mbox *mbox = NULL;
++  LWIP_UNUSED_ARG(size);
++
++  mbox = (struct sys_mbox *)malloc(sizeof(struct sys_mbox));
++  if (mbox == NULL) {
++    SYS_STATS_INC(mbox.err);
++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_new: could not create mbox\n"));
++    return ERR_MEM;
++  }
++  mbox->first = mbox->last = 0;
++  mbox->not_empty = sys_sem_new_internal(0);
++  mbox->not_full = sys_sem_new_internal(0);
++  mbox->mutex = sys_sem_new_internal(1);
++  mbox->wait_send = 0;
++
++  SYS_STATS_INC_USED(mbox);
++
++  if((mbox->not_empty == NULL) || (mbox->not_full == NULL) || (mbox->mutex == NULL)) {
++    SYS_STATS_INC(mbox.err);
++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_new: could not create mbox internals\n"));
++    sys_mbox_free(&mbox);
++    return ERR_MEM;
++  }
++  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_new: mbox created [not_empty:%X|not_full:%X|mutex:%X] \n",
++                          mbox->not_empty, mbox->not_full, mbox->mutex));
++
++  *mb = mbox;
++  return ERR_OK;
++}
++/*-----------------------------------------------------------------------------------*/
++void
++sys_mbox_free(struct sys_mbox **mb)
++{
++  if ((mb != NULL) && (*mb != SYS_MBOX_NULL)) {
++    struct sys_mbox *mbox = *mb;
++    sys_arch_sem_wait(&mbox->mutex, 0);
++
++    sys_sem_free_internal(mbox->not_empty);
++    sys_sem_free_internal(mbox->not_full);
++    sys_sem_free_internal(mbox->mutex);
++    mbox->not_empty = mbox->not_full = mbox->mutex = NULL;
++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_free: mbox 0x%lx\n", mbox));
++    free(mbox);
++    SYS_STATS_DEC(mbox.used);
++  }
++}
++/*-----------------------------------------------------------------------------------*/
++err_t
++sys_mbox_trypost(struct sys_mbox **mb, void *msg)
++{
++  u8_t first;
++  struct sys_mbox *mbox;
++  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
++  mbox = *mb;
++  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_trypost: start"));
++  sys_arch_sem_wait(&mbox->mutex, 0);
++
++  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_trypost: mbox %p msg %p\n",
++                          (void *)mbox, (void *)msg));
++
++  if ((mbox->last + 1) >= (mbox->first + SYS_MBOX_SIZE)) {
++    sys_sem_signal(&mbox->mutex);
++    return ERR_MEM;
++  }
++
++  mbox->msgs[mbox->last % SYS_MBOX_SIZE] = msg;
++
++  if (mbox->last == mbox->first) {
++    first = 1;
++  } else {
++    first = 0;
++  }
++
++  mbox->last++;
++
++  if (first) {
++    sys_sem_signal(&mbox->not_empty);
++  }
++
++  sys_sem_signal(&mbox->mutex);
++
++  return ERR_OK;
++}
++/*-----------------------------------------------------------------------------------*/
++void
++sys_mbox_post(struct sys_mbox **mb, void *msg)
++{
++  u8_t first;
++  struct sys_mbox *mbox;
++  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
++  mbox = *mb;
++
++  sys_arch_sem_wait(&mbox->mutex, 0);
++
++  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_post: mbox %p msg %p\n", (void *)mbox, (void *)msg));
++
++  while ((mbox->last + 1) >= (mbox->first + SYS_MBOX_SIZE)) {
++    mbox->wait_send++;
++    sys_sem_signal(&mbox->mutex);
++    sys_arch_sem_wait(&mbox->not_full, 0);
++    sys_arch_sem_wait(&mbox->mutex, 0);
++    mbox->wait_send--;
++  }
++
++  mbox->msgs[mbox->last % SYS_MBOX_SIZE] = msg;
++
++  if (mbox->last == mbox->first) {
++    first = 1;
++  } else {
++    first = 0;
++  }
++
++  mbox->last++;
++
++  if (first) {
++    sys_sem_signal(&mbox->not_empty);
++  }
++
++  sys_sem_signal(&mbox->mutex);
++}
++/*-----------------------------------------------------------------------------------*/
++u32_t
++sys_arch_mbox_tryfetch(struct sys_mbox **mb, void **msg)
++{
++  struct sys_mbox *mbox;
++  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
++  mbox = *mb;
++
++  sys_arch_sem_wait(&mbox->mutex, 0);
++
++  if (mbox->first == mbox->last) {
++    sys_sem_signal(&mbox->mutex);
++    return SYS_MBOX_EMPTY;
++  }
++
++  if (msg != NULL) {
++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_tryfetch: mbox %p msg %p\n", (void *)mbox, *msg));
++    *msg = mbox->msgs[mbox->first % SYS_MBOX_SIZE];
++  }
++  else{
++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_tryfetch: mbox %p, null msg\n", (void *)mbox));
++  }
++
++  mbox->first++;
++
++  if (mbox->wait_send) {
++    sys_sem_signal(&mbox->not_full);
++  }
++
++  sys_sem_signal(&mbox->mutex);
++
++  return 0;
++}
++/*-----------------------------------------------------------------------------------*/
++u32_t
++sys_arch_mbox_fetch(struct sys_mbox **mb, void **msg, u32_t timeout)
++{
++  u32_t time_needed = 0;
++  struct sys_mbox *mbox;
++  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
++  mbox = *mb;
++
++  /* The mutex lock is quick so we don't bother with the timeout
++     stuff here. */
++  sys_arch_sem_wait(&mbox->mutex, 0);
++
++  while (mbox->first == mbox->last) {
++    sys_sem_signal(&mbox->mutex);
++
++    /* We block while waiting for a mail to arrive in the mailbox. We
++       must be prepared to timeout. */
++    if (timeout != 0) {
++      time_needed = sys_arch_sem_wait(&mbox->not_empty, timeout);
++
++      if (time_needed == SYS_ARCH_TIMEOUT) {
++        return SYS_ARCH_TIMEOUT;
++      }
++    } else {
++      sys_arch_sem_wait(&mbox->not_empty, 0);
++    }
++
++    sys_arch_sem_wait(&mbox->mutex, 0);
++  }
++
++  if (msg != NULL) {
++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_fetch: mbox %p msg %p\n", (void *)mbox, *msg));
++    *msg = mbox->msgs[mbox->first % SYS_MBOX_SIZE];
++  }
++  else{
++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_fetch: mbox %p, null msg\n", (void *)mbox));
++  }
++
++  mbox->first++;
++
++  if (mbox->wait_send) {
++    sys_sem_signal(&mbox->not_full);
++  }
++
++  sys_sem_signal(&mbox->mutex);
++
++  return time_needed;
++}
++/*-----------------------------------------------------------------------------------*/
++static struct sys_sem *
++sys_sem_new_internal(u8_t count)
++{
++  struct sys_sem *sem = NULL;
++  int rc;
++
++  sem = (struct sys_sem *)malloc(sizeof(struct sys_sem));
++  if (sem != NULL) {
++    sem->c = count;
++    rc = pthread_cond_init(&(sem->cond), NULL);
++    if(rc != 0) {
++      LWIP_DEBUGF(SYS_DEBUG, ("sys_sem_new_internal: pthread_cond_init error = %d\n", rc));
++      return NULL;
++    }
++    rc = pthread_mutex_init(&(sem->mutex), NULL);
++    if(rc != 0) {
++      LWIP_DEBUGF(SYS_DEBUG, ("sys_sem_new_internal: pthread_mutex_init error = %d\n", rc));
++      SYS_STATS_INC(mutex.err);
++      pthread_cond_destroy(&(sem->cond));
++      return NULL;
++    }
++    SYS_STATS_INC_USED(mutex);
++    SYS_STATS_INC_USED(sem);
++  } else {
++    LWIP_DEBUGF(SYS_DEBUG, ("sys_sem_new_internal: could not create semaphore\n"));
++    SYS_STATS_INC(sem.err);
++  }
++  return sem;
++}
++/*-----------------------------------------------------------------------------------*/
++err_t
++sys_sem_new(struct sys_sem **sem, u8_t count)
++{
++  *sem = sys_sem_new_internal(count);
++  if (*sem == NULL) {
++    return ERR_MEM;
++  }
++  return ERR_OK;
++}
++/*-----------------------------------------------------------------------------------*/
++static u32_t
++cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex, u32_t timeout)
++{
++  time_t tdiff;
++  time_t sec, usec;
++  struct timeval rtime1, rtime2;
++  struct timespec ts;
++  int retval;
++
++  if (timeout > 0) {
++    /* Get a timestamp and add the timeout value. */
++    gettimeofday(&rtime1, NULL);
++    sec = rtime1.tv_sec;
++    usec = rtime1.tv_usec;
++    usec += timeout % 1000 * 1000;
++    sec += (int)(timeout / 1000) + (int)(usec / 1000000);
++    usec = usec % 1000000;
++    ts.tv_nsec = usec * 1000;
++    ts.tv_sec = sec;
++
++    retval = pthread_cond_timedwait(cond, mutex, &ts);
++
++    if (retval == ETIMEDOUT) {
++      return SYS_ARCH_TIMEOUT;
++    } else {
++      /* Calculate for how long we waited for the cond. */
++      gettimeofday(&rtime2, NULL);
++      tdiff = (rtime2.tv_sec - rtime1.tv_sec) * 1000 +
++        (rtime2.tv_usec - rtime1.tv_usec) / 1000;
++
++      if (tdiff <= 0) {
++        return 0;
++      }
++      return (u32_t)tdiff;
++    }
++  } else {
++    pthread_cond_wait(cond, mutex);
++    return 0;
++  }
++}
++/*-----------------------------------------------------------------------------------*/
++u32_t
++sys_arch_sem_wait(struct sys_sem **s, u32_t timeout)
++{
++  u32_t time_needed = 0;
++  struct sys_sem *sem;
++  LWIP_ASSERT("invalid sem", (s != NULL) && (*s != NULL));
++  sem = *s;
++
++  pthread_mutex_lock(&(sem->mutex));
++  while (sem->c <= 0) {
++    if (timeout > 0) {
++      time_needed = cond_wait(&(sem->cond), &(sem->mutex), timeout);
++
++      if (time_needed == SYS_ARCH_TIMEOUT) {
++        pthread_mutex_unlock(&(sem->mutex));
++        return SYS_ARCH_TIMEOUT;
++      }
++    } else {
++      cond_wait(&(sem->cond), &(sem->mutex), 0);
++    }
++  }
++  sem->c--;
++  pthread_mutex_unlock(&(sem->mutex));
++  return (u32_t)time_needed;
++}
++/*-----------------------------------------------------------------------------------*/
++void
++sys_sem_signal(struct sys_sem **s)
++{
++  struct sys_sem *sem;
++  LWIP_ASSERT("invalid sem", (s != NULL) && (*s != NULL));
++  sem = *s;
++
++  pthread_mutex_lock(&(sem->mutex));
++  sem->c++;
++
++  if (sem->c > 1) {
++    sem->c = 1;
++  }
++
++  pthread_cond_broadcast(&(sem->cond));
++  pthread_mutex_unlock(&(sem->mutex));
++}
++/*-----------------------------------------------------------------------------------*/
++static void
++sys_sem_free_internal(struct sys_sem *sem)
++{
++  if(sem != NULL) {
++    pthread_cond_destroy(&(sem->cond));
++    pthread_mutex_destroy(&(sem->mutex));
++    SYS_STATS_DEC(mutex.used);
++    SYS_STATS_DEC(sem.used);
++    free(sem);
++  }
++}
++/*-----------------------------------------------------------------------------------*/
++void
++sys_sem_free(struct sys_sem **sem)
++{
++  if ((sem != NULL) && (*sem != SYS_SEM_NULL)) {
++    sys_sem_free_internal(*sem);
++  }
++}
++#endif /* !NO_SYS */
++/*-----------------------------------------------------------------------------------*/
++u32_t
++sys_now(void)
++{
++  struct timeval tv;
++  u32_t sec, usec, msec;
++  gettimeofday(&tv, NULL);
++
++  sec = (u32_t)(tv.tv_sec - starttime.tv_sec);
++  usec = (u32_t)(tv.tv_usec - starttime.tv_usec);
++  msec = sec * 1000 + usec / 1000;
++
++  return msec;
++}
++/*-----------------------------------------------------------------------------------*/
++void
++sys_init(void)
++{
++  SYS_STATS_INC_USED(mutex);
++  gettimeofday(&starttime, NULL);
++}
++/*-----------------------------------------------------------------------------------*/
++#if SYS_LIGHTWEIGHT_PROT
++/** sys_prot_t sys_arch_protect(void)
++
++This optional function does a "fast" critical region protection and returns
++the previous protection level. This function is only called during very short
++critical regions. An embedded system which supports ISR-based drivers might
++want to implement this function by disabling interrupts. Task-based systems
++might want to implement this by using a mutex or disabling tasking. This
++function should support recursive calls from the same task or interrupt. In
++other words, sys_arch_protect() could be called while already protected. In
++that case the return value indicates that it is already protected.
++
++sys_arch_protect() is only required if your port is supporting an operating
++system.
++*/
++sys_prot_t
++sys_arch_protect(void)
++{
++    /* Note that for the UNIX port, we are using a lightweight mutex, and our
++     * own counter (which is locked by the mutex). The return code is not actually
++     * used. */
++    if (lwprot_thread != pthread_self())
++    {
++        /* We are locking the mutex where it has not been locked before *
++        * or is being locked by another thread */
++        pthread_mutex_lock(&lwprot_mutex);
++        lwprot_thread = pthread_self();
++        lwprot_count = 1;
++    }
++    else
++    {
++        /* It is already locked by THIS thread */
++        lwprot_count++;
++    }
++    return 0;
++}
++/*-----------------------------------------------------------------------------------*/
++/** void sys_arch_unprotect(sys_prot_t pval)
++
++This optional function does a "fast" set of critical region protection to the
++value specified by pval. See the documentation for sys_arch_protect() for
++more information. This function is only required if your port is supporting
++an operating system.
++*/
++void
++sys_arch_unprotect(sys_prot_t pval)
++{
++    LWIP_UNUSED_ARG(pval);
++    if (lwprot_thread == pthread_self())
++    {
++        if (--lwprot_count == 0)
++        {
++            lwprot_thread = (pthread_t) 0xDEAD;
++            pthread_mutex_unlock(&lwprot_mutex);
++        }
++    }
++}
++#endif /* SYS_LIGHTWEIGHT_PROT */
++
++/*-----------------------------------------------------------------------------------*/
++
++#ifndef MAX_JIFFY_OFFSET
++#define MAX_JIFFY_OFFSET ((~0U >> 1)-1)
++#endif
++
++#ifndef HZ
++#define HZ 100
++#endif
++
++u32_t
++sys_jiffies(void)
++{
++    struct timeval tv;
++    unsigned long sec;
++    long usec;
++
++    gettimeofday(&tv,NULL);
++    sec = tv.tv_sec - starttime.tv_sec;
++    usec = tv.tv_usec;
++
++    if (sec >= (MAX_JIFFY_OFFSET / HZ))
++      return MAX_JIFFY_OFFSET;
++    usec += 1000000L / HZ - 1;
++    usec /= 1000000L / HZ;
++    return HZ * sec + usec;
++}
++
++#if PPP_DEBUG
++
++#include <stdarg.h>
++
++void ppp_trace(int level, const char *format, ...)
++{
++    va_list args;
++
++    (void)level;
++    va_start(args, format);
++    vprintf(format, args);
++    va_end(args);
++}
++#endif
+-- 
+1.9.1
+
+
+From d053fa836b445b6736bf82d33a33a59055150aa7 Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Fri, 4 Sep 2015 17:30:37 -0400
+Subject: [PATCH 02/29] changed the compiler options
+
+---
+ Makefile | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/Makefile b/Makefile
+index 0cbae64..94fcafc 100644
+--- a/Makefile
++++ b/Makefile
+@@ -5,7 +5,7 @@ include $(PROJECT_ROOT)/make/leaf.cfg
+ #### CONFIG ####################################################################
+ #For debugging symbols add -DLWIP_DEBUG
+ # COMPILER/LINKER
+-CFLAGS+=-g -O2   \
++CFLAGS+=-g -O0   \
+  -Wall
+ 
+ # OUTPUT
+-- 
+1.9.1
+
+
+From 841adb17430bdb9298dcb6d44ac5dad72e82af80 Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Mon, 7 Sep 2015 08:56:58 -0400
+Subject: [PATCH 03/29] disabled any mention of ipv6
+
+---
+ Makefile | 6 +++---
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+diff --git a/Makefile b/Makefile
+index 94fcafc..6efa141 100644
+--- a/Makefile
++++ b/Makefile
+@@ -40,7 +40,7 @@ CORE_SRC=$(wildcard $(LWIP_CORE_PATH)/*.c)
+ IPV4_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv4/*.c)
+ 
+ ## IPv6
+-IPV6_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv6/*.c)
++#IPV6_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv6/*.c)
+ 
+ ## SNMP
+ SNMP_SRC=$(wildcard $(LWIP_CORE_PATH)/snmp/*.c)
+@@ -71,7 +71,7 @@ SOURCES =  $(DRIVER_SRC) $(SNMP_SRC)\
+ CORE_H=$(LWIP_INCL_PATH)
+ 
+ ## IPv4
+-#IPV4_H=$(LWIP_INCL_PATH)/ipv4
++IPV4_H=$(LWIP_INCL_PATH)/ipv4
+ 
+ ## IPv6
+ #IPV6_H=$(LWIP_INCL_PATH)/ipv6
+@@ -97,7 +97,7 @@ DRIVER_H=$(LWIPDRIVER_INCL_PATH)
+ # HEADERS
+ HEADERS=-I$(CORE_H) -I$(POSIX_H) -I$(POSIX_SYS_H) -I$(NETIF_H) \
+         -I$(NETIF_H_PPP) -I$(NETIF_H_PPP_POLARSSL) -I$(ARCH_H) \
+-        -I$(DRIVER_H)
++        -I$(DRIVER_H) -I$(IPV4_H)
+ 
+ 
+ ################################################################################
+-- 
+1.9.1
+
+
+From a653d818348fef0130e6e497eecb0c3a35822df4 Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Mon, 7 Sep 2015 09:27:48 -0400
+Subject: [PATCH 04/29] added in stm32f low-level driver
+
+---
+ src/netif/ethernetif.c | 709 ++++++++++++++++++++++++++++++-------------------
+ 1 file changed, 435 insertions(+), 274 deletions(-)
+
+diff --git a/src/netif/ethernetif.c b/src/netif/ethernetif.c
+index 7982d11..82c85ae 100644
+--- a/src/netif/ethernetif.c
++++ b/src/netif/ethernetif.c
+@@ -1,335 +1,496 @@
+ /**
+- * @file
+- * Ethernet Interface Skeleton
+- *
+- */
+-
+-/*
+- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+- * All rights reserved. 
+- * 
+- * Redistribution and use in source and binary forms, with or without modification, 
+- * are permitted provided that the following conditions are met:
+- *
+- * 1. Redistributions of source code must retain the above copyright notice,
+- *    this list of conditions and the following disclaimer.
+- * 2. Redistributions in binary form must reproduce the above copyright notice,
+- *    this list of conditions and the following disclaimer in the documentation
+- *    and/or other materials provided with the distribution.
+- * 3. The name of the author may not be used to endorse or promote products
+- *    derived from this software without specific prior written permission. 
+- *
+- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+- * OF SUCH DAMAGE.
+- *
+- * This file is part of the lwIP TCP/IP stack.
+- * 
+- * Author: Adam Dunkels <adam@sics.se>
+- *
+- */
+-
+-/*
+- * This file is a skeleton for developing Ethernet network interface
+- * drivers for lwIP. Add code to the low_level functions and do a
+- * search-and-replace for the word "ethernetif" to replace it with
+- * something that better describes your network interface.
+- */
+-
++  ******************************************************************************
++  * @file    LwIP/LwIP_HTTP_Server_Netconn_RTOS/Src/ethernetif.c
++  * @author  MCD Application Team
++  * @version V1.0.0
++  * @date    25-June-2015
++  * @brief   This file implements Ethernet network interface drivers for lwIP
++  ******************************************************************************
++  * @attention
++  *
++  * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
++  *
++  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
++  * You may not use this file except in compliance with the License.
++  * You may obtain a copy of the License at:
++  *
++  *        http://www.st.com/software_license_agreement_liberty_v2
++  *
++  * Unless required by applicable law or agreed to in writing, software 
++  * distributed under the License is distributed on an "AS IS" BASIS, 
++  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++  * See the License for the specific language governing permissions and
++  * limitations under the License.
++  *
++  ******************************************************************************
++  */
++
++/* Includes ------------------------------------------------------------------*/
++#include "stm32f7xx_hal.h"
+ #include "lwip/opt.h"
+-
+-#if 0 /* don't build, this is only a skeleton, see previous comment */
+-
+-#include "lwip/def.h"
+-#include "lwip/mem.h"
+-#include "lwip/pbuf.h"
+-#include "lwip/stats.h"
+-#include "lwip/snmp.h"
+-#include "lwip/ethip6.h"
++#include "lwip/lwip_timers.h"
+ #include "netif/etharp.h"
+-#include "netif/ppp/pppoe.h"
++#include "hal-ethernetif.h"
++#include <string.h>
++
++/* Private typedef -----------------------------------------------------------*/
++/* Private define ------------------------------------------------------------*/
++/* The time to block waiting for input. */
++#define TIME_WAITING_FOR_INPUT                 ( 100 )
++/* Stack size of the interface thread */
++#define INTERFACE_THREAD_STACK_SIZE            ( 350 )
+ 
+ /* Define those to better describe your network interface. */
+ #define IFNAME0 'e'
+ #define IFNAME1 'n'
+ 
+-/**
+- * Helper struct to hold private data used to operate your ethernet interface.
+- * Keeping the ethernet address of the MAC in this struct is not necessary
+- * as it is already kept in the struct netif.
+- * But this is only an example, anyway...
+- */
+-struct ethernetif {
+-  struct eth_addr *ethaddr;
+-  /* Add whatever per-interface state that is needed here. */
+-};
+-
+-/* Forward declarations. */
+-static void  ethernetif_input(struct netif *netif);
++#define LAN8742A_PHY_ADDRESS            0x00
+ 
+-/**
+- * In this function, the hardware should be initialized.
+- * Called from ethernetif_init().
+- *
+- * @param netif the already initialized lwip network interface structure
+- *        for this ethernetif
+- */
+-static void
+-low_level_init(struct netif *netif)
+-{
+-  struct ethernetif *ethernetif = netif->state;
+-  
+-  /* set MAC hardware address length */
+-  netif->hwaddr_len = ETHARP_HWADDR_LEN;
++/* Private macro -------------------------------------------------------------*/
++/* Private variables ---------------------------------------------------------*/
+ 
+-  /* set MAC hardware address */
+-  netif->hwaddr[0] = ;
+-  ...
+-  netif->hwaddr[5] = ;
++#if defined ( __ICCARM__ ) /*!< IAR Compiler */
+ 
+-  /* maximum transfer unit */
+-  netif->mtu = 1500;
+-  
+-  /* device capabilities */
+-  /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
+-  netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
+- 
+-#if LWIP_IPV6 && LWIP_IPV6_MLD
+-  /*
+-   * For hardware/netifs that implement MAC filtering.
+-   * All-nodes link-local is handled by default, so we must let the hardware know
+-   * to allow multicast packets in.
+-   * Should set mld_mac_filter previously. */
+-  if (netif->mld_mac_filter != NULL) {
+-    ip6_addr_t ip6_allnodes_ll;
+-    ip6_addr_set_allnodes_linklocal(&ip6_allnodes_ll);
+-    netif->mld_mac_filter(netif, &ip6_allnodes_ll, MLD6_ADD_MAC_FILTER);
+-  }
+-#endif /* LWIP_IPV6 && LWIP_IPV6_MLD */
++#pragma location=0x2000E000
++__no_init ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
++#pragma location=0x2000E100
++__no_init ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
++#elif defined ( __CC_ARM   )
++ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((at(0x2000E000)));/* Ethernet Rx MA Descriptor */
++ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((at(0x2000E100)));/* Ethernet Tx DMA Descriptor */
++#elif defined ( __GNUC__   )
++//ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".RxDescripSection")));/* Ethernet Rx MA Descriptor */
++//ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".TxDescripSection")));/* Ethernet Tx DMA Descriptor */
++ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Rx MA Descriptor */
++ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Tx DMA Descriptor */
++
++
++#endif
++#if defined ( __ICCARM__ ) /*!< IAR Compiler */
++#pragma location=0x2000E200
++__no_init uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
++#pragma location=0x2000FFC4
++__no_init uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
++#elif defined ( __CC_ARM   )
++uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((at(0x2000E200)));  /* Ethernet Receive Buffer */
++uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]  __attribute__((at(0x2000FFC4))); /* Ethernet Transmit Buffer */
++#elif defined ( __GNUC__   )
++//uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".RxBUF")));/* Ethernet Receive Buffer */
++//uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".TxBUF")));/* Ethernet Transmit Buffer */
++uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Receive Buffer */
++uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Transmit Buffer */
++
++#endif
++/* Semaphore to signal incoming packets */
++osSemaphoreId s_xSemaphore = NULL;
+ 
+-  /* Do whatever else is needed to initialize interface. */  
++/* Global Ethernet handle*/
++ETH_HandleTypeDef EthHandle;
++
++/* Private function prototypes -----------------------------------------------*/
++static void ethernetif_input( void const * argument );
++
++static void stm32f_ethernet_isr(
++  void* argData
++)
++{
++  ETH_HandleTypeDef* pEth =
++    (ETH_HandleTypeDef*) argData;
++
++  HAL_ETH_IRQHandler(pEth);
+ }
+ 
++/* Private functions ---------------------------------------------------------*/
++/*******************************************************************************
++                       Ethernet MSP Routines
++*******************************************************************************/
+ /**
+- * This function should do the actual transmission of the packet. The packet is
+- * contained in the pbuf that is passed to the function. This pbuf
+- * might be chained.
+- *
+- * @param netif the lwip network interface structure for this ethernetif
+- * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
+- * @return ERR_OK if the packet could be sent
+- *         an err_t value if the packet couldn't be sent
+- *
+- * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
+- *       strange results. You might consider waiting for space in the DMA queue
+- *       to become available since the stack doesn't retry to send a packet
+- *       dropped because of memory failure (except for the TCP timers).
+- */
+-
+-static err_t
+-low_level_output(struct netif *netif, struct pbuf *p)
++  * @brief  Initializes the ETH MSP.
++  * @param  heth: ETH handle
++  * @retval None
++  */
++void HAL_ETH_MspInit(ETH_HandleTypeDef *heth)
+ {
+-  struct ethernetif *ethernetif = netif->state;
+-  struct pbuf *q;
+-
+-  initiate transfer();
++  GPIO_InitTypeDef GPIO_InitStructure;
+   
+-#if ETH_PAD_SIZE
+-  pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
+-#endif
+-
+-  for(q = p; q != NULL; q = q->next) {
+-    /* Send the data from the pbuf to the interface, one pbuf at a
+-       time. The size of the data in each pbuf is kept in the ->len
+-       variable. */
+-    send data from(q->payload, q->len);
+-  }
++  /* Enable GPIOs clocks */
++  __HAL_RCC_GPIOA_CLK_ENABLE();
++  __HAL_RCC_GPIOC_CLK_ENABLE();
++  __HAL_RCC_GPIOG_CLK_ENABLE();
+ 
+-  signal that packet should be sent();
++/* Ethernet pins configuration ************************************************/
++  /*
++        RMII_REF_CLK ----------------------> PA1
++        RMII_MDIO -------------------------> PA2
++        RMII_MDC --------------------------> PC1
++        RMII_MII_CRS_DV -------------------> PA7
++        RMII_MII_RXD0 ---------------------> PC4
++        RMII_MII_RXD1 ---------------------> PC5
++        RMII_MII_RXER ---------------------> PG2
++        RMII_MII_TX_EN --------------------> PG11
++        RMII_MII_TXD0 ---------------------> PG13
++        RMII_MII_TXD1 ---------------------> PG14
++  */
++
++  /* Configure PA1, PA2 and PA7 */
++  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
++  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
++  GPIO_InitStructure.Pull = GPIO_NOPULL; 
++  GPIO_InitStructure.Alternate = GPIO_AF11_ETH;
++  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
++  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
++  
++  /* Configure PC1, PC4 and PC5 */
++  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;
++  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
+ 
+-#if ETH_PAD_SIZE
+-  pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
+-#endif
++  /* Configure PG2, PG11, PG13 and PG14 */
++  GPIO_InitStructure.Pin =  GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14;
++  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
+   
+-  LINK_STATS_INC(link.xmit);
++  // Install HAL Ethernet ISR
++  rtems_interrupt_handler_install(
++    ETH_IRQn,
++    NULL,
++    0,
++    stm32f_ethernet_isr,
++    heth);
++  
++  /* Enable ETHERNET clock  */
++  __HAL_RCC_ETH_CLK_ENABLE();
++}
+ 
+-  return ERR_OK;
++/**
++  * @brief  Ethernet Rx Transfer completed callback
++  * @param  heth: ETH handle
++  * @retval None
++  */
++void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
++{
++  osSemaphoreRelease(s_xSemaphore);
+ }
+ 
+ /**
+- * Should allocate a pbuf and transfer the bytes of the incoming
+- * packet from the interface into the pbuf.
+- *
+- * @param netif the lwip network interface structure for this ethernetif
+- * @return a pbuf filled with the received packet (including MAC header)
+- *         NULL on memory error
+- */
+-static struct pbuf *
+-low_level_input(struct netif *netif)
++  * @brief  Ethernet IRQ Handler
++  * @param  None
++  * @retval None
++  */
++void ETHERNET_IRQHandler(void)
+ {
+-  struct ethernetif *ethernetif = netif->state;
+-  struct pbuf *p, *q;
+-  u16_t len;
++  HAL_ETH_IRQHandler(&EthHandle);
++}
+ 
+-  /* Obtain the size of the packet and put it into the "len"
+-     variable. */
+-  len = ;
++/*******************************************************************************
++                       LL Driver Interface ( LwIP stack --> ETH) 
++*******************************************************************************/
++/**
++  * @brief In this function, the hardware should be initialized.
++  * Called from ethernetif_init().
++  *
++  * @param netif the already initialized lwip network interface structure
++  *        for this ethernetif
++  */
++static void low_level_init(struct netif *netif)
++{
++  uint8_t macaddress[6]= { MAC_ADDR0, MAC_ADDR1, MAC_ADDR2, MAC_ADDR3, MAC_ADDR4, MAC_ADDR5 };
++  
++  EthHandle.Instance = ETH;  
++  EthHandle.Init.MACAddr = macaddress;
++  EthHandle.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
++  EthHandle.Init.Speed = ETH_SPEED_100M;
++  EthHandle.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
++  EthHandle.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
++  EthHandle.Init.RxMode = ETH_RXINTERRUPT_MODE;
++  EthHandle.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
++  EthHandle.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
++  
++  /* configure ethernet peripheral (GPIOs, clocks, MAC, DMA) */
++  if (HAL_ETH_Init(&EthHandle) == HAL_OK)
++  {
++    /* Set netif link flag */
++    netif->flags |= NETIF_FLAG_LINK_UP;
++  }
++  
++  /* Initialize Tx Descriptors list: Chain Mode */
++  HAL_ETH_DMATxDescListInit(&EthHandle, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
++     
++  /* Initialize Rx Descriptors list: Chain Mode  */
++  HAL_ETH_DMARxDescListInit(&EthHandle, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
++  
++  /* set netif MAC hardware address length */
++  netif->hwaddr_len = ETHARP_HWADDR_LEN;
+ 
+-#if ETH_PAD_SIZE
+-  len += ETH_PAD_SIZE; /* allow room for Ethernet padding */
+-#endif
++  /* set netif MAC hardware address */
++  netif->hwaddr[0] =  MAC_ADDR0;
++  netif->hwaddr[1] =  MAC_ADDR1;
++  netif->hwaddr[2] =  MAC_ADDR2;
++  netif->hwaddr[3] =  MAC_ADDR3;
++  netif->hwaddr[4] =  MAC_ADDR4;
++  netif->hwaddr[5] =  MAC_ADDR5;
+ 
+-  /* We allocate a pbuf chain of pbufs from the pool. */
+-  p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
+-  
+-  if (p != NULL) {
++  /* set netif maximum transfer unit */
++  netif->mtu = 1500;
+ 
+-#if ETH_PAD_SIZE
+-    pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
+-#endif
++  /* Accept broadcast address and ARP traffic */
++  netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
+ 
+-    /* We iterate over the pbuf chain until we have read the entire
+-     * packet into the pbuf. */
+-    for(q = p; q != NULL; q = q->next) {
+-      /* Read enough bytes to fill this pbuf in the chain. The
+-       * available data in the pbuf is given by the q->len
+-       * variable.
+-       * This does not necessarily have to be a memcpy, you can also preallocate
+-       * pbufs for a DMA-enabled MAC and after receiving truncate it to the
+-       * actually received size. In this case, ensure the tot_len member of the
+-       * pbuf is the sum of the chained pbuf len members.
+-       */
+-      read data into(q->payload, q->len);
+-    }
+-    acknowledge that packet has been read();
++  /* create a binary semaphore used for informing ethernetif of frame reception */
++  osSemaphoreDef(SEM);
++  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1 );
++
++  /* create the task that handles the ETH_MAC */
++  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
++  osThreadCreate (osThread(EthIf), netif);
++
++  /* Enable MAC and DMA transmission and reception */
++  HAL_ETH_Start(&EthHandle);
++}
+ 
+-#if ETH_PAD_SIZE
+-    pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
+-#endif
+ 
+-    LINK_STATS_INC(link.recv);
+-  } else {
+-    drop packet();
+-    LINK_STATS_INC(link.memerr);
+-    LINK_STATS_INC(link.drop);
++/**
++  * @brief This function should do the actual transmission of the packet. The packet is
++  * contained in the pbuf that is passed to the function. This pbuf
++  * might be chained.
++  *
++  * @param netif the lwip network interface structure for this ethernetif
++  * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
++  * @return ERR_OK if the packet could be sent
++  *         an err_t value if the packet couldn't be sent
++  *
++  * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
++  *       strange results. You might consider waiting for space in the DMA queue
++  *       to become available since the stack doesn't retry to send a packet
++  *       dropped because of memory failure (except for the TCP timers).
++  */
++static err_t low_level_output(struct netif *netif, struct pbuf *p)
++{
++  err_t errval;
++  struct pbuf *q;
++  uint8_t *buffer = (uint8_t *)(EthHandle.TxDesc->Buffer1Addr);
++  __IO ETH_DMADescTypeDef *DmaTxDesc;
++  uint32_t framelength = 0;
++  uint32_t bufferoffset = 0;
++  uint32_t byteslefttocopy = 0;
++  uint32_t payloadoffset = 0;
++
++  DmaTxDesc = EthHandle.TxDesc;
++  bufferoffset = 0;
++  
++  /* copy frame from pbufs to driver buffers */
++  for(q = p; q != NULL; q = q->next)
++  {
++    /* Is this buffer available? If not, goto error */
++    if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
++    {
++      errval = ERR_USE;
++      goto error;
++    }
++    
++    /* Get bytes in current lwIP buffer */
++    byteslefttocopy = q->len;
++    payloadoffset = 0;
++    
++    /* Check if the length of data to copy is bigger than Tx buffer size*/
++    while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
++    {
++      /* Copy data to Tx buffer*/
++      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
++      
++      /* Point to next descriptor */
++      DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
++      
++      /* Check if the buffer is available */
++      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
++      {
++        errval = ERR_USE;
++        goto error;
++      }
++      
++      buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
++      
++      byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
++      payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
++      framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
++      bufferoffset = 0;
++    }
++    
++    /* Copy the remaining bytes */
++    memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
++    bufferoffset = bufferoffset + byteslefttocopy;
++    framelength = framelength + byteslefttocopy;
++  }
++  
++  /* Prepare transmit descriptors to give to DMA */ 
++  HAL_ETH_TransmitFrame(&EthHandle, framelength);
++  
++  errval = ERR_OK;
++  
++error:
++  
++  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
++  if ((EthHandle.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
++  {
++    /* Clear TUS ETHERNET DMA flag */
++    EthHandle.Instance->DMASR = ETH_DMASR_TUS;
++    
++    /* Resume DMA transmission*/
++    EthHandle.Instance->DMATPDR = 0;
+   }
++  return errval;
++}
+ 
+-  return p;  
++/**
++  * @brief Should allocate a pbuf and transfer the bytes of the incoming
++  * packet from the interface into the pbuf.
++  *
++  * @param netif the lwip network interface structure for this ethernetif
++  * @return a pbuf filled with the received packet (including MAC header)
++  *         NULL on memory error
++  */
++static struct pbuf * low_level_input(struct netif *netif)
++{
++  struct pbuf *p = NULL, *q = NULL;
++  uint16_t len = 0;
++  uint8_t *buffer;
++  __IO ETH_DMADescTypeDef *dmarxdesc;
++  uint32_t bufferoffset = 0;
++  uint32_t payloadoffset = 0;
++  uint32_t byteslefttocopy = 0;
++  uint32_t i=0;
++  
++  /* get received frame */
++  if(HAL_ETH_GetReceivedFrame_IT(&EthHandle) != HAL_OK)
++    return NULL;
++  
++  /* Obtain the size of the packet and put it into the "len" variable. */
++  len = EthHandle.RxFrameInfos.length;
++  buffer = (uint8_t *)EthHandle.RxFrameInfos.buffer;
++  
++  if (len > 0)
++  {
++    /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
++    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
++  }
++  
++  if (p != NULL)
++  {
++    dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
++    bufferoffset = 0;
++    
++    for(q = p; q != NULL; q = q->next)
++    {
++      byteslefttocopy = q->len;
++      payloadoffset = 0;
++      
++      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size */
++      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
++      {
++        /* Copy data to pbuf */
++        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
++        
++        /* Point to next descriptor */
++        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
++        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
++        
++        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
++        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
++        bufferoffset = 0;
++      }
++      
++      /* Copy remaining data in pbuf */
++      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
++      bufferoffset = bufferoffset + byteslefttocopy;
++    }
++  }
++    
++  /* Release descriptors to DMA */
++  /* Point to first descriptor */
++  dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
++  /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
++  for (i=0; i< EthHandle.RxFrameInfos.SegCount; i++)
++  {  
++    dmarxdesc->Status |= ETH_DMARXDESC_OWN;
++    dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
++  }
++    
++  /* Clear Segment_Count */
++  EthHandle.RxFrameInfos.SegCount =0;
++  
++  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
++  if ((EthHandle.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
++  {
++    /* Clear RBUS ETHERNET DMA flag */
++    EthHandle.Instance->DMASR = ETH_DMASR_RBUS;
++    /* Resume DMA reception */
++    EthHandle.Instance->DMARPDR = 0;
++  }
++  return p;
+ }
+ 
+ /**
+- * This function should be called when a packet is ready to be read
+- * from the interface. It uses the function low_level_input() that
+- * should handle the actual reception of bytes from the network
+- * interface. Then the type of the received packet is determined and
+- * the appropriate input function is called.
+- *
+- * @param netif the lwip network interface structure for this ethernetif
+- */
+-static void
+-ethernetif_input(struct netif *netif)
++  * @brief This function is the ethernetif_input task, it is processed when a packet 
++  * is ready to be read from the interface. It uses the function low_level_input() 
++  * that should handle the actual reception of bytes from the network
++  * interface. Then the type of the received packet is determined and
++  * the appropriate input function is called.
++  *
++  * @param netif the lwip network interface structure for this ethernetif
++  */
++void ethernetif_input( void const * argument )
+ {
+-  struct ethernetif *ethernetif;
+-  struct eth_hdr *ethhdr;
+   struct pbuf *p;
+-
+-  ethernetif = netif->state;
+-
+-  /* move received packet into a new pbuf */
+-  p = low_level_input(netif);
+-  /* no packet could be read, silently ignore this */
+-  if (p == NULL) return;
+-  /* points to packet payload, which starts with an Ethernet header */
+-  ethhdr = p->payload;
+-
+-  switch (htons(ethhdr->type)) {
+-  /* IP or ARP packet? */
+-  case ETHTYPE_IP:
+-  case ETHTYPE_IPV6:
+-  case ETHTYPE_ARP:
+-#if PPPOE_SUPPORT
+-  /* PPPoE packet? */
+-  case ETHTYPE_PPPOEDISC:
+-  case ETHTYPE_PPPOE:
+-#endif /* PPPOE_SUPPORT */
+-    /* full packet send to tcpip_thread to process */
+-    if (netif->input(p, netif)!=ERR_OK)
+-     { LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
+-       pbuf_free(p);
+-       p = NULL;
+-     }
+-    break;
+-
+-  default:
+-    pbuf_free(p);
+-    p = NULL;
+-    break;
++  struct netif *netif = (struct netif *) argument;
++  
++  for( ;; )
++  {
++    if (osSemaphoreWait( s_xSemaphore, TIME_WAITING_FOR_INPUT)==osOK)
++    {
++      do
++      {
++        p = low_level_input( netif );
++        if (p != NULL)
++        {
++          if (netif->input( p, netif) != ERR_OK )
++          {
++            pbuf_free(p);
++          }
++        }
++      }while(p!=NULL);
++    }
+   }
+ }
+ 
+ /**
+- * Should be called at the beginning of the program to set up the
+- * network interface. It calls the function low_level_init() to do the
+- * actual setup of the hardware.
+- *
+- * This function should be passed as a parameter to netif_add().
+- *
+- * @param netif the lwip network interface structure for this ethernetif
+- * @return ERR_OK if the loopif is initialized
+- *         ERR_MEM if private data couldn't be allocated
+- *         any other err_t on error
+- */
+-err_t
+-ethernetif_init(struct netif *netif)
++  * @brief Should be called at the beginning of the program to set up the
++  * network interface. It calls the function low_level_init() to do the
++  * actual setup of the hardware.
++  *
++  * This function should be passed as a parameter to netif_add().
++  *
++  * @param netif the lwip network interface structure for this ethernetif
++  * @return ERR_OK if the loopif is initialized
++  *         ERR_MEM if private data couldn't be allocated
++  *         any other err_t on error
++  */
++err_t ethernetif_init(struct netif *netif)
+ {
+-  struct ethernetif *ethernetif;
+-
+   LWIP_ASSERT("netif != NULL", (netif != NULL));
+-    
+-  ethernetif = mem_malloc(sizeof(struct ethernetif));
+-  if (ethernetif == NULL) {
+-    LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_init: out of memory\n"));
+-    return ERR_MEM;
+-  }
+ 
+ #if LWIP_NETIF_HOSTNAME
+   /* Initialize interface hostname */
+   netif->hostname = "lwip";
+ #endif /* LWIP_NETIF_HOSTNAME */
+ 
+-  /*
+-   * Initialize the snmp variables and counters inside the struct netif.
+-   * The last argument should be replaced with your link speed, in units
+-   * of bits per second.
+-   */
+-  NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, LINK_SPEED_OF_YOUR_NETIF_IN_BPS);
+-
+-  netif->state = ethernetif;
+   netif->name[0] = IFNAME0;
+   netif->name[1] = IFNAME1;
+-  /* We directly use etharp_output() here to save a function call.
+-   * You can instead declare your own function an call etharp_output()
+-   * from it if you have to do some checks before sending (e.g. if link
+-   * is available...) */
++
+   netif->output = etharp_output;
+-#if LWIP_IPV6
+-  netif->output_ip6 = ethip6_output;
+-#endif /* LWIP_IPV6 */
+   netif->linkoutput = low_level_output;
+-  
+-  ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
+-  
++
+   /* initialize the hardware */
+   low_level_init(netif);
+ 
+   return ERR_OK;
+ }
+ 
+-#endif /* 0 */
++/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+-- 
+1.9.1
+
+
+From ab97b49d1d41e34fdfdfb457b397c768ee228c9f Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Mon, 7 Sep 2015 09:39:20 -0400
+Subject: [PATCH 05/29] removed ethernetif (it should be in BSP
+
+---
+ src/netif/ethernetif.c | 496 -------------------------------------------------
+ 1 file changed, 496 deletions(-)
+ delete mode 100644 src/netif/ethernetif.c
+
+diff --git a/src/netif/ethernetif.c b/src/netif/ethernetif.c
+deleted file mode 100644
+index 82c85ae..0000000
+--- a/src/netif/ethernetif.c
++++ /dev/null
+@@ -1,496 +0,0 @@
+-/**
+-  ******************************************************************************
+-  * @file    LwIP/LwIP_HTTP_Server_Netconn_RTOS/Src/ethernetif.c
+-  * @author  MCD Application Team
+-  * @version V1.0.0
+-  * @date    25-June-2015
+-  * @brief   This file implements Ethernet network interface drivers for lwIP
+-  ******************************************************************************
+-  * @attention
+-  *
+-  * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
+-  *
+-  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+-  * You may not use this file except in compliance with the License.
+-  * You may obtain a copy of the License at:
+-  *
+-  *        http://www.st.com/software_license_agreement_liberty_v2
+-  *
+-  * Unless required by applicable law or agreed to in writing, software 
+-  * distributed under the License is distributed on an "AS IS" BASIS, 
+-  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+-  * See the License for the specific language governing permissions and
+-  * limitations under the License.
+-  *
+-  ******************************************************************************
+-  */
+-
+-/* Includes ------------------------------------------------------------------*/
+-#include "stm32f7xx_hal.h"
+-#include "lwip/opt.h"
+-#include "lwip/lwip_timers.h"
+-#include "netif/etharp.h"
+-#include "hal-ethernetif.h"
+-#include <string.h>
+-
+-/* Private typedef -----------------------------------------------------------*/
+-/* Private define ------------------------------------------------------------*/
+-/* The time to block waiting for input. */
+-#define TIME_WAITING_FOR_INPUT                 ( 100 )
+-/* Stack size of the interface thread */
+-#define INTERFACE_THREAD_STACK_SIZE            ( 350 )
+-
+-/* Define those to better describe your network interface. */
+-#define IFNAME0 'e'
+-#define IFNAME1 'n'
+-
+-#define LAN8742A_PHY_ADDRESS            0x00
+-
+-/* Private macro -------------------------------------------------------------*/
+-/* Private variables ---------------------------------------------------------*/
+-
+-#if defined ( __ICCARM__ ) /*!< IAR Compiler */
+-
+-#pragma location=0x2000E000
+-__no_init ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
+-#pragma location=0x2000E100
+-__no_init ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
+-#elif defined ( __CC_ARM   )
+-ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((at(0x2000E000)));/* Ethernet Rx MA Descriptor */
+-ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((at(0x2000E100)));/* Ethernet Tx DMA Descriptor */
+-#elif defined ( __GNUC__   )
+-//ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".RxDescripSection")));/* Ethernet Rx MA Descriptor */
+-//ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".TxDescripSection")));/* Ethernet Tx DMA Descriptor */
+-ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Rx MA Descriptor */
+-ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Tx DMA Descriptor */
+-
+-
+-#endif
+-#if defined ( __ICCARM__ ) /*!< IAR Compiler */
+-#pragma location=0x2000E200
+-__no_init uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
+-#pragma location=0x2000FFC4
+-__no_init uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
+-#elif defined ( __CC_ARM   )
+-uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((at(0x2000E200)));  /* Ethernet Receive Buffer */
+-uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]  __attribute__((at(0x2000FFC4))); /* Ethernet Transmit Buffer */
+-#elif defined ( __GNUC__   )
+-//uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".RxBUF")));/* Ethernet Receive Buffer */
+-//uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".TxBUF")));/* Ethernet Transmit Buffer */
+-uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Receive Buffer */
+-uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Transmit Buffer */
+-
+-#endif
+-/* Semaphore to signal incoming packets */
+-osSemaphoreId s_xSemaphore = NULL;
+-
+-/* Global Ethernet handle*/
+-ETH_HandleTypeDef EthHandle;
+-
+-/* Private function prototypes -----------------------------------------------*/
+-static void ethernetif_input( void const * argument );
+-
+-static void stm32f_ethernet_isr(
+-  void* argData
+-)
+-{
+-  ETH_HandleTypeDef* pEth =
+-    (ETH_HandleTypeDef*) argData;
+-
+-  HAL_ETH_IRQHandler(pEth);
+-}
+-
+-/* Private functions ---------------------------------------------------------*/
+-/*******************************************************************************
+-                       Ethernet MSP Routines
+-*******************************************************************************/
+-/**
+-  * @brief  Initializes the ETH MSP.
+-  * @param  heth: ETH handle
+-  * @retval None
+-  */
+-void HAL_ETH_MspInit(ETH_HandleTypeDef *heth)
+-{
+-  GPIO_InitTypeDef GPIO_InitStructure;
+-  
+-  /* Enable GPIOs clocks */
+-  __HAL_RCC_GPIOA_CLK_ENABLE();
+-  __HAL_RCC_GPIOC_CLK_ENABLE();
+-  __HAL_RCC_GPIOG_CLK_ENABLE();
+-
+-/* Ethernet pins configuration ************************************************/
+-  /*
+-        RMII_REF_CLK ----------------------> PA1
+-        RMII_MDIO -------------------------> PA2
+-        RMII_MDC --------------------------> PC1
+-        RMII_MII_CRS_DV -------------------> PA7
+-        RMII_MII_RXD0 ---------------------> PC4
+-        RMII_MII_RXD1 ---------------------> PC5
+-        RMII_MII_RXER ---------------------> PG2
+-        RMII_MII_TX_EN --------------------> PG11
+-        RMII_MII_TXD0 ---------------------> PG13
+-        RMII_MII_TXD1 ---------------------> PG14
+-  */
+-
+-  /* Configure PA1, PA2 and PA7 */
+-  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
+-  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
+-  GPIO_InitStructure.Pull = GPIO_NOPULL; 
+-  GPIO_InitStructure.Alternate = GPIO_AF11_ETH;
+-  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
+-  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
+-  
+-  /* Configure PC1, PC4 and PC5 */
+-  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;
+-  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
+-
+-  /* Configure PG2, PG11, PG13 and PG14 */
+-  GPIO_InitStructure.Pin =  GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14;
+-  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
+-  
+-  // Install HAL Ethernet ISR
+-  rtems_interrupt_handler_install(
+-    ETH_IRQn,
+-    NULL,
+-    0,
+-    stm32f_ethernet_isr,
+-    heth);
+-  
+-  /* Enable ETHERNET clock  */
+-  __HAL_RCC_ETH_CLK_ENABLE();
+-}
+-
+-/**
+-  * @brief  Ethernet Rx Transfer completed callback
+-  * @param  heth: ETH handle
+-  * @retval None
+-  */
+-void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
+-{
+-  osSemaphoreRelease(s_xSemaphore);
+-}
+-
+-/**
+-  * @brief  Ethernet IRQ Handler
+-  * @param  None
+-  * @retval None
+-  */
+-void ETHERNET_IRQHandler(void)
+-{
+-  HAL_ETH_IRQHandler(&EthHandle);
+-}
+-
+-/*******************************************************************************
+-                       LL Driver Interface ( LwIP stack --> ETH) 
+-*******************************************************************************/
+-/**
+-  * @brief In this function, the hardware should be initialized.
+-  * Called from ethernetif_init().
+-  *
+-  * @param netif the already initialized lwip network interface structure
+-  *        for this ethernetif
+-  */
+-static void low_level_init(struct netif *netif)
+-{
+-  uint8_t macaddress[6]= { MAC_ADDR0, MAC_ADDR1, MAC_ADDR2, MAC_ADDR3, MAC_ADDR4, MAC_ADDR5 };
+-  
+-  EthHandle.Instance = ETH;  
+-  EthHandle.Init.MACAddr = macaddress;
+-  EthHandle.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
+-  EthHandle.Init.Speed = ETH_SPEED_100M;
+-  EthHandle.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
+-  EthHandle.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
+-  EthHandle.Init.RxMode = ETH_RXINTERRUPT_MODE;
+-  EthHandle.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
+-  EthHandle.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
+-  
+-  /* configure ethernet peripheral (GPIOs, clocks, MAC, DMA) */
+-  if (HAL_ETH_Init(&EthHandle) == HAL_OK)
+-  {
+-    /* Set netif link flag */
+-    netif->flags |= NETIF_FLAG_LINK_UP;
+-  }
+-  
+-  /* Initialize Tx Descriptors list: Chain Mode */
+-  HAL_ETH_DMATxDescListInit(&EthHandle, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
+-     
+-  /* Initialize Rx Descriptors list: Chain Mode  */
+-  HAL_ETH_DMARxDescListInit(&EthHandle, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
+-  
+-  /* set netif MAC hardware address length */
+-  netif->hwaddr_len = ETHARP_HWADDR_LEN;
+-
+-  /* set netif MAC hardware address */
+-  netif->hwaddr[0] =  MAC_ADDR0;
+-  netif->hwaddr[1] =  MAC_ADDR1;
+-  netif->hwaddr[2] =  MAC_ADDR2;
+-  netif->hwaddr[3] =  MAC_ADDR3;
+-  netif->hwaddr[4] =  MAC_ADDR4;
+-  netif->hwaddr[5] =  MAC_ADDR5;
+-
+-  /* set netif maximum transfer unit */
+-  netif->mtu = 1500;
+-
+-  /* Accept broadcast address and ARP traffic */
+-  netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
+-
+-  /* create a binary semaphore used for informing ethernetif of frame reception */
+-  osSemaphoreDef(SEM);
+-  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1 );
+-
+-  /* create the task that handles the ETH_MAC */
+-  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
+-  osThreadCreate (osThread(EthIf), netif);
+-
+-  /* Enable MAC and DMA transmission and reception */
+-  HAL_ETH_Start(&EthHandle);
+-}
+-
+-
+-/**
+-  * @brief This function should do the actual transmission of the packet. The packet is
+-  * contained in the pbuf that is passed to the function. This pbuf
+-  * might be chained.
+-  *
+-  * @param netif the lwip network interface structure for this ethernetif
+-  * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
+-  * @return ERR_OK if the packet could be sent
+-  *         an err_t value if the packet couldn't be sent
+-  *
+-  * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
+-  *       strange results. You might consider waiting for space in the DMA queue
+-  *       to become available since the stack doesn't retry to send a packet
+-  *       dropped because of memory failure (except for the TCP timers).
+-  */
+-static err_t low_level_output(struct netif *netif, struct pbuf *p)
+-{
+-  err_t errval;
+-  struct pbuf *q;
+-  uint8_t *buffer = (uint8_t *)(EthHandle.TxDesc->Buffer1Addr);
+-  __IO ETH_DMADescTypeDef *DmaTxDesc;
+-  uint32_t framelength = 0;
+-  uint32_t bufferoffset = 0;
+-  uint32_t byteslefttocopy = 0;
+-  uint32_t payloadoffset = 0;
+-
+-  DmaTxDesc = EthHandle.TxDesc;
+-  bufferoffset = 0;
+-  
+-  /* copy frame from pbufs to driver buffers */
+-  for(q = p; q != NULL; q = q->next)
+-  {
+-    /* Is this buffer available? If not, goto error */
+-    if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
+-    {
+-      errval = ERR_USE;
+-      goto error;
+-    }
+-    
+-    /* Get bytes in current lwIP buffer */
+-    byteslefttocopy = q->len;
+-    payloadoffset = 0;
+-    
+-    /* Check if the length of data to copy is bigger than Tx buffer size*/
+-    while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
+-    {
+-      /* Copy data to Tx buffer*/
+-      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
+-      
+-      /* Point to next descriptor */
+-      DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
+-      
+-      /* Check if the buffer is available */
+-      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
+-      {
+-        errval = ERR_USE;
+-        goto error;
+-      }
+-      
+-      buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
+-      
+-      byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
+-      payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
+-      framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
+-      bufferoffset = 0;
+-    }
+-    
+-    /* Copy the remaining bytes */
+-    memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
+-    bufferoffset = bufferoffset + byteslefttocopy;
+-    framelength = framelength + byteslefttocopy;
+-  }
+-  
+-  /* Prepare transmit descriptors to give to DMA */ 
+-  HAL_ETH_TransmitFrame(&EthHandle, framelength);
+-  
+-  errval = ERR_OK;
+-  
+-error:
+-  
+-  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
+-  if ((EthHandle.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
+-  {
+-    /* Clear TUS ETHERNET DMA flag */
+-    EthHandle.Instance->DMASR = ETH_DMASR_TUS;
+-    
+-    /* Resume DMA transmission*/
+-    EthHandle.Instance->DMATPDR = 0;
+-  }
+-  return errval;
+-}
+-
+-/**
+-  * @brief Should allocate a pbuf and transfer the bytes of the incoming
+-  * packet from the interface into the pbuf.
+-  *
+-  * @param netif the lwip network interface structure for this ethernetif
+-  * @return a pbuf filled with the received packet (including MAC header)
+-  *         NULL on memory error
+-  */
+-static struct pbuf * low_level_input(struct netif *netif)
+-{
+-  struct pbuf *p = NULL, *q = NULL;
+-  uint16_t len = 0;
+-  uint8_t *buffer;
+-  __IO ETH_DMADescTypeDef *dmarxdesc;
+-  uint32_t bufferoffset = 0;
+-  uint32_t payloadoffset = 0;
+-  uint32_t byteslefttocopy = 0;
+-  uint32_t i=0;
+-  
+-  /* get received frame */
+-  if(HAL_ETH_GetReceivedFrame_IT(&EthHandle) != HAL_OK)
+-    return NULL;
+-  
+-  /* Obtain the size of the packet and put it into the "len" variable. */
+-  len = EthHandle.RxFrameInfos.length;
+-  buffer = (uint8_t *)EthHandle.RxFrameInfos.buffer;
+-  
+-  if (len > 0)
+-  {
+-    /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
+-    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
+-  }
+-  
+-  if (p != NULL)
+-  {
+-    dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
+-    bufferoffset = 0;
+-    
+-    for(q = p; q != NULL; q = q->next)
+-    {
+-      byteslefttocopy = q->len;
+-      payloadoffset = 0;
+-      
+-      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size */
+-      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
+-      {
+-        /* Copy data to pbuf */
+-        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
+-        
+-        /* Point to next descriptor */
+-        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
+-        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
+-        
+-        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
+-        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
+-        bufferoffset = 0;
+-      }
+-      
+-      /* Copy remaining data in pbuf */
+-      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
+-      bufferoffset = bufferoffset + byteslefttocopy;
+-    }
+-  }
+-    
+-  /* Release descriptors to DMA */
+-  /* Point to first descriptor */
+-  dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
+-  /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
+-  for (i=0; i< EthHandle.RxFrameInfos.SegCount; i++)
+-  {  
+-    dmarxdesc->Status |= ETH_DMARXDESC_OWN;
+-    dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
+-  }
+-    
+-  /* Clear Segment_Count */
+-  EthHandle.RxFrameInfos.SegCount =0;
+-  
+-  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
+-  if ((EthHandle.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
+-  {
+-    /* Clear RBUS ETHERNET DMA flag */
+-    EthHandle.Instance->DMASR = ETH_DMASR_RBUS;
+-    /* Resume DMA reception */
+-    EthHandle.Instance->DMARPDR = 0;
+-  }
+-  return p;
+-}
+-
+-/**
+-  * @brief This function is the ethernetif_input task, it is processed when a packet 
+-  * is ready to be read from the interface. It uses the function low_level_input() 
+-  * that should handle the actual reception of bytes from the network
+-  * interface. Then the type of the received packet is determined and
+-  * the appropriate input function is called.
+-  *
+-  * @param netif the lwip network interface structure for this ethernetif
+-  */
+-void ethernetif_input( void const * argument )
+-{
+-  struct pbuf *p;
+-  struct netif *netif = (struct netif *) argument;
+-  
+-  for( ;; )
+-  {
+-    if (osSemaphoreWait( s_xSemaphore, TIME_WAITING_FOR_INPUT)==osOK)
+-    {
+-      do
+-      {
+-        p = low_level_input( netif );
+-        if (p != NULL)
+-        {
+-          if (netif->input( p, netif) != ERR_OK )
+-          {
+-            pbuf_free(p);
+-          }
+-        }
+-      }while(p!=NULL);
+-    }
+-  }
+-}
+-
+-/**
+-  * @brief Should be called at the beginning of the program to set up the
+-  * network interface. It calls the function low_level_init() to do the
+-  * actual setup of the hardware.
+-  *
+-  * This function should be passed as a parameter to netif_add().
+-  *
+-  * @param netif the lwip network interface structure for this ethernetif
+-  * @return ERR_OK if the loopif is initialized
+-  *         ERR_MEM if private data couldn't be allocated
+-  *         any other err_t on error
+-  */
+-err_t ethernetif_init(struct netif *netif)
+-{
+-  LWIP_ASSERT("netif != NULL", (netif != NULL));
+-
+-#if LWIP_NETIF_HOSTNAME
+-  /* Initialize interface hostname */
+-  netif->hostname = "lwip";
+-#endif /* LWIP_NETIF_HOSTNAME */
+-
+-  netif->name[0] = IFNAME0;
+-  netif->name[1] = IFNAME1;
+-
+-  netif->output = etharp_output;
+-  netif->linkoutput = low_level_output;
+-
+-  /* initialize the hardware */
+-  low_level_init(netif);
+-
+-  return ERR_OK;
+-}
+-
+-/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+-- 
+1.9.1
+
+
+From 31d34fab26b1e3fde99fe7288786725fe5e51b95 Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Mon, 7 Sep 2015 10:17:32 -0400
+Subject: [PATCH 06/29] add low level driver back
+
+---
+ src/netif/ethernetif.c | 496 +++++++++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 496 insertions(+)
+ create mode 100644 src/netif/ethernetif.c
+
+diff --git a/src/netif/ethernetif.c b/src/netif/ethernetif.c
+new file mode 100644
+index 0000000..bc429e9
+--- /dev/null
++++ b/src/netif/ethernetif.c
+@@ -0,0 +1,496 @@
++/**
++  ******************************************************************************
++  * @file    LwIP/LwIP_HTTP_Server_Netconn_RTOS/Src/ethernetif.c
++  * @author  MCD Application Team
++  * @version V1.0.0
++  * @date    25-June-2015
++  * @brief   This file implements Ethernet network interface drivers for lwIP
++  ******************************************************************************
++  * @attention
++  *
++  * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
++  *
++  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
++  * You may not use this file except in compliance with the License.
++  * You may obtain a copy of the License at:
++  *
++  *        http://www.st.com/software_license_agreement_liberty_v2
++  *
++  * Unless required by applicable law or agreed to in writing, software 
++  * distributed under the License is distributed on an "AS IS" BASIS, 
++  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++  * See the License for the specific language governing permissions and
++  * limitations under the License.
++  *
++  ******************************************************************************
++  */
++
++/* Includes ------------------------------------------------------------------*/
++#include <stm32f7xx_hal.h>
++#include <lwip/opt.h>
++#include <lwip/lwip_timers.h>
++#include <netif/etharp.h>
++#include <hal-ethernetif.h>
++#include <string.h>
++
++/* Private typedef -----------------------------------------------------------*/
++/* Private define ------------------------------------------------------------*/
++/* The time to block waiting for input. */
++#define TIME_WAITING_FOR_INPUT                 ( 100 )
++/* Stack size of the interface thread */
++#define INTERFACE_THREAD_STACK_SIZE            ( 350 )
++
++/* Define those to better describe your network interface. */
++#define IFNAME0 'e'
++#define IFNAME1 'n'
++
++#define LAN8742A_PHY_ADDRESS            0x00
++
++/* Private macro -------------------------------------------------------------*/
++/* Private variables ---------------------------------------------------------*/
++
++#if defined ( __ICCARM__ ) /*!< IAR Compiler */
++
++#pragma location=0x2000E000
++__no_init ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
++#pragma location=0x2000E100
++__no_init ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
++#elif defined ( __CC_ARM   )
++ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((at(0x2000E000)));/* Ethernet Rx MA Descriptor */
++ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((at(0x2000E100)));/* Ethernet Tx DMA Descriptor */
++#elif defined ( __GNUC__   )
++//ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".RxDescripSection")));/* Ethernet Rx MA Descriptor */
++//ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".TxDescripSection")));/* Ethernet Tx DMA Descriptor */
++ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Rx MA Descriptor */
++ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Tx DMA Descriptor */
++
++
++#endif
++#if defined ( __ICCARM__ ) /*!< IAR Compiler */
++#pragma location=0x2000E200
++__no_init uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
++#pragma location=0x2000FFC4
++__no_init uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
++#elif defined ( __CC_ARM   )
++uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((at(0x2000E200)));  /* Ethernet Receive Buffer */
++uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]  __attribute__((at(0x2000FFC4))); /* Ethernet Transmit Buffer */
++#elif defined ( __GNUC__   )
++//uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".RxBUF")));/* Ethernet Receive Buffer */
++//uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".TxBUF")));/* Ethernet Transmit Buffer */
++uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Receive Buffer */
++uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Transmit Buffer */
++
++#endif
++/* Semaphore to signal incoming packets */
++osSemaphoreId s_xSemaphore = NULL;
++
++/* Global Ethernet handle*/
++ETH_HandleTypeDef EthHandle;
++
++/* Private function prototypes -----------------------------------------------*/
++static void ethernetif_input( void const * argument );
++
++static void stm32f_ethernet_isr(
++  void* argData
++)
++{
++  ETH_HandleTypeDef* pEth =
++    (ETH_HandleTypeDef*) argData;
++
++  HAL_ETH_IRQHandler(pEth);
++}
++
++/* Private functions ---------------------------------------------------------*/
++/*******************************************************************************
++                       Ethernet MSP Routines
++*******************************************************************************/
++/**
++  * @brief  Initializes the ETH MSP.
++  * @param  heth: ETH handle
++  * @retval None
++  */
++void HAL_ETH_MspInit(ETH_HandleTypeDef *heth)
++{
++  GPIO_InitTypeDef GPIO_InitStructure;
++  
++  /* Enable GPIOs clocks */
++  __HAL_RCC_GPIOA_CLK_ENABLE();
++  __HAL_RCC_GPIOC_CLK_ENABLE();
++  __HAL_RCC_GPIOG_CLK_ENABLE();
++
++/* Ethernet pins configuration ************************************************/
++  /*
++        RMII_REF_CLK ----------------------> PA1
++        RMII_MDIO -------------------------> PA2
++        RMII_MDC --------------------------> PC1
++        RMII_MII_CRS_DV -------------------> PA7
++        RMII_MII_RXD0 ---------------------> PC4
++        RMII_MII_RXD1 ---------------------> PC5
++        RMII_MII_RXER ---------------------> PG2
++        RMII_MII_TX_EN --------------------> PG11
++        RMII_MII_TXD0 ---------------------> PG13
++        RMII_MII_TXD1 ---------------------> PG14
++  */
++
++  /* Configure PA1, PA2 and PA7 */
++  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
++  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
++  GPIO_InitStructure.Pull = GPIO_NOPULL; 
++  GPIO_InitStructure.Alternate = GPIO_AF11_ETH;
++  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
++  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
++  
++  /* Configure PC1, PC4 and PC5 */
++  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;
++  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
++
++  /* Configure PG2, PG11, PG13 and PG14 */
++  GPIO_InitStructure.Pin =  GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14;
++  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
++  
++  // Install HAL Ethernet ISR
++  rtems_interrupt_handler_install(
++    ETH_IRQn,
++    NULL,
++    0,
++    stm32f_ethernet_isr,
++    heth);
++  
++  /* Enable ETHERNET clock  */
++  __HAL_RCC_ETH_CLK_ENABLE();
++}
++
++/**
++  * @brief  Ethernet Rx Transfer completed callback
++  * @param  heth: ETH handle
++  * @retval None
++  */
++void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
++{
++  osSemaphoreRelease(s_xSemaphore);
++}
++
++/**
++  * @brief  Ethernet IRQ Handler
++  * @param  None
++  * @retval None
++  */
++void ETHERNET_IRQHandler(void)
++{
++  HAL_ETH_IRQHandler(&EthHandle);
++}
++
++/*******************************************************************************
++                       LL Driver Interface ( LwIP stack --> ETH) 
++*******************************************************************************/
++/**
++  * @brief In this function, the hardware should be initialized.
++  * Called from ethernetif_init().
++  *
++  * @param netif the already initialized lwip network interface structure
++  *        for this ethernetif
++  */
++static void low_level_init(struct netif *netif)
++{
++  uint8_t macaddress[6]= { MAC_ADDR0, MAC_ADDR1, MAC_ADDR2, MAC_ADDR3, MAC_ADDR4, MAC_ADDR5 };
++  
++  EthHandle.Instance = ETH;  
++  EthHandle.Init.MACAddr = macaddress;
++  EthHandle.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
++  EthHandle.Init.Speed = ETH_SPEED_100M;
++  EthHandle.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
++  EthHandle.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
++  EthHandle.Init.RxMode = ETH_RXINTERRUPT_MODE;
++  EthHandle.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
++  EthHandle.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
++  
++  /* configure ethernet peripheral (GPIOs, clocks, MAC, DMA) */
++  if (HAL_ETH_Init(&EthHandle) == HAL_OK)
++  {
++    /* Set netif link flag */
++    netif->flags |= NETIF_FLAG_LINK_UP;
++  }
++  
++  /* Initialize Tx Descriptors list: Chain Mode */
++  HAL_ETH_DMATxDescListInit(&EthHandle, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
++     
++  /* Initialize Rx Descriptors list: Chain Mode  */
++  HAL_ETH_DMARxDescListInit(&EthHandle, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
++  
++  /* set netif MAC hardware address length */
++  netif->hwaddr_len = ETHARP_HWADDR_LEN;
++
++  /* set netif MAC hardware address */
++  netif->hwaddr[0] =  MAC_ADDR0;
++  netif->hwaddr[1] =  MAC_ADDR1;
++  netif->hwaddr[2] =  MAC_ADDR2;
++  netif->hwaddr[3] =  MAC_ADDR3;
++  netif->hwaddr[4] =  MAC_ADDR4;
++  netif->hwaddr[5] =  MAC_ADDR5;
++
++  /* set netif maximum transfer unit */
++  netif->mtu = 1500;
++
++  /* Accept broadcast address and ARP traffic */
++  netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
++
++  /* create a binary semaphore used for informing ethernetif of frame reception */
++  osSemaphoreDef(SEM);
++  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1 );
++
++  /* create the task that handles the ETH_MAC */
++  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
++  osThreadCreate (osThread(EthIf), netif);
++
++  /* Enable MAC and DMA transmission and reception */
++  HAL_ETH_Start(&EthHandle);
++}
++
++
++/**
++  * @brief This function should do the actual transmission of the packet. The packet is
++  * contained in the pbuf that is passed to the function. This pbuf
++  * might be chained.
++  *
++  * @param netif the lwip network interface structure for this ethernetif
++  * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
++  * @return ERR_OK if the packet could be sent
++  *         an err_t value if the packet couldn't be sent
++  *
++  * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
++  *       strange results. You might consider waiting for space in the DMA queue
++  *       to become available since the stack doesn't retry to send a packet
++  *       dropped because of memory failure (except for the TCP timers).
++  */
++static err_t low_level_output(struct netif *netif, struct pbuf *p)
++{
++  err_t errval;
++  struct pbuf *q;
++  uint8_t *buffer = (uint8_t *)(EthHandle.TxDesc->Buffer1Addr);
++  __IO ETH_DMADescTypeDef *DmaTxDesc;
++  uint32_t framelength = 0;
++  uint32_t bufferoffset = 0;
++  uint32_t byteslefttocopy = 0;
++  uint32_t payloadoffset = 0;
++
++  DmaTxDesc = EthHandle.TxDesc;
++  bufferoffset = 0;
++  
++  /* copy frame from pbufs to driver buffers */
++  for(q = p; q != NULL; q = q->next)
++  {
++    /* Is this buffer available? If not, goto error */
++    if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
++    {
++      errval = ERR_USE;
++      goto error;
++    }
++    
++    /* Get bytes in current lwIP buffer */
++    byteslefttocopy = q->len;
++    payloadoffset = 0;
++    
++    /* Check if the length of data to copy is bigger than Tx buffer size*/
++    while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
++    {
++      /* Copy data to Tx buffer*/
++      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
++      
++      /* Point to next descriptor */
++      DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
++      
++      /* Check if the buffer is available */
++      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
++      {
++        errval = ERR_USE;
++        goto error;
++      }
++      
++      buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
++      
++      byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
++      payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
++      framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
++      bufferoffset = 0;
++    }
++    
++    /* Copy the remaining bytes */
++    memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
++    bufferoffset = bufferoffset + byteslefttocopy;
++    framelength = framelength + byteslefttocopy;
++  }
++  
++  /* Prepare transmit descriptors to give to DMA */ 
++  HAL_ETH_TransmitFrame(&EthHandle, framelength);
++  
++  errval = ERR_OK;
++  
++error:
++  
++  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
++  if ((EthHandle.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
++  {
++    /* Clear TUS ETHERNET DMA flag */
++    EthHandle.Instance->DMASR = ETH_DMASR_TUS;
++    
++    /* Resume DMA transmission*/
++    EthHandle.Instance->DMATPDR = 0;
++  }
++  return errval;
++}
++
++/**
++  * @brief Should allocate a pbuf and transfer the bytes of the incoming
++  * packet from the interface into the pbuf.
++  *
++  * @param netif the lwip network interface structure for this ethernetif
++  * @return a pbuf filled with the received packet (including MAC header)
++  *         NULL on memory error
++  */
++static struct pbuf * low_level_input(struct netif *netif)
++{
++  struct pbuf *p = NULL, *q = NULL;
++  uint16_t len = 0;
++  uint8_t *buffer;
++  __IO ETH_DMADescTypeDef *dmarxdesc;
++  uint32_t bufferoffset = 0;
++  uint32_t payloadoffset = 0;
++  uint32_t byteslefttocopy = 0;
++  uint32_t i=0;
++  
++  /* get received frame */
++  if(HAL_ETH_GetReceivedFrame_IT(&EthHandle) != HAL_OK)
++    return NULL;
++  
++  /* Obtain the size of the packet and put it into the "len" variable. */
++  len = EthHandle.RxFrameInfos.length;
++  buffer = (uint8_t *)EthHandle.RxFrameInfos.buffer;
++  
++  if (len > 0)
++  {
++    /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
++    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
++  }
++  
++  if (p != NULL)
++  {
++    dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
++    bufferoffset = 0;
++    
++    for(q = p; q != NULL; q = q->next)
++    {
++      byteslefttocopy = q->len;
++      payloadoffset = 0;
++      
++      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size */
++      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
++      {
++        /* Copy data to pbuf */
++        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
++        
++        /* Point to next descriptor */
++        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
++        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
++        
++        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
++        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
++        bufferoffset = 0;
++      }
++      
++      /* Copy remaining data in pbuf */
++      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
++      bufferoffset = bufferoffset + byteslefttocopy;
++    }
++  }
++    
++  /* Release descriptors to DMA */
++  /* Point to first descriptor */
++  dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
++  /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
++  for (i=0; i< EthHandle.RxFrameInfos.SegCount; i++)
++  {  
++    dmarxdesc->Status |= ETH_DMARXDESC_OWN;
++    dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
++  }
++    
++  /* Clear Segment_Count */
++  EthHandle.RxFrameInfos.SegCount =0;
++  
++  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
++  if ((EthHandle.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
++  {
++    /* Clear RBUS ETHERNET DMA flag */
++    EthHandle.Instance->DMASR = ETH_DMASR_RBUS;
++    /* Resume DMA reception */
++    EthHandle.Instance->DMARPDR = 0;
++  }
++  return p;
++}
++
++/**
++  * @brief This function is the ethernetif_input task, it is processed when a packet 
++  * is ready to be read from the interface. It uses the function low_level_input() 
++  * that should handle the actual reception of bytes from the network
++  * interface. Then the type of the received packet is determined and
++  * the appropriate input function is called.
++  *
++  * @param netif the lwip network interface structure for this ethernetif
++  */
++void ethernetif_input( void const * argument )
++{
++  struct pbuf *p;
++  struct netif *netif = (struct netif *) argument;
++  
++  for( ;; )
++  {
++    if (osSemaphoreWait( s_xSemaphore, TIME_WAITING_FOR_INPUT)==osOK)
++    {
++      do
++      {
++        p = low_level_input( netif );
++        if (p != NULL)
++        {
++          if (netif->input( p, netif) != ERR_OK )
++          {
++            pbuf_free(p);
++          }
++        }
++      }while(p!=NULL);
++    }
++  }
++}
++
++/**
++  * @brief Should be called at the beginning of the program to set up the
++  * network interface. It calls the function low_level_init() to do the
++  * actual setup of the hardware.
++  *
++  * This function should be passed as a parameter to netif_add().
++  *
++  * @param netif the lwip network interface structure for this ethernetif
++  * @return ERR_OK if the loopif is initialized
++  *         ERR_MEM if private data couldn't be allocated
++  *         any other err_t on error
++  */
++err_t ethernetif_init(struct netif *netif)
++{
++  LWIP_ASSERT("netif != NULL", (netif != NULL));
++
++#if LWIP_NETIF_HOSTNAME
++  /* Initialize interface hostname */
++  netif->hostname = "lwip";
++#endif /* LWIP_NETIF_HOSTNAME */
++
++  netif->name[0] = IFNAME0;
++  netif->name[1] = IFNAME1;
++
++  netif->output = etharp_output;
++  netif->linkoutput = low_level_output;
++
++  /* initialize the hardware */
++  low_level_init(netif);
++
++  return ERR_OK;
++}
++
++/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+-- 
+1.9.1
+
+
+From 81eded01bb2bc35a9b627e5cf35b2021efb5972c Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Mon, 7 Sep 2015 10:22:57 -0400
+Subject: [PATCH 07/29] Added bsp path
+
+---
+ Makefile | 4 +++-
+ 1 file changed, 3 insertions(+), 1 deletion(-)
+
+diff --git a/Makefile b/Makefile
+index 6efa141..a855d9f 100644
+--- a/Makefile
++++ b/Makefile
+@@ -13,6 +13,8 @@ LWIP_EXEC=lwip
+ 
+ #### PATHS #####################################################################
+ 
++BSP_PATH=/opt/rtems-4.11/arm-rtems4.11/stm32f7x/lib/include/bsp
++
+ # LWIP
+ LWIP_PATH=.
+ LWIP_SRC_PATH=$(LWIP_PATH)/src
+@@ -97,7 +99,7 @@ DRIVER_H=$(LWIPDRIVER_INCL_PATH)
+ # HEADERS
+ HEADERS=-I$(CORE_H) -I$(POSIX_H) -I$(POSIX_SYS_H) -I$(NETIF_H) \
+         -I$(NETIF_H_PPP) -I$(NETIF_H_PPP_POLARSSL) -I$(ARCH_H) \
+-        -I$(DRIVER_H) -I$(IPV4_H)
++        -I$(DRIVER_H) -I$(IPV4_H) -I$(BSP_PATH)
+ 
+ 
+ ################################################################################
+-- 
+1.9.1
+
+
+From f114529d5af1e2a83b49b67d631b10c02648e8d8 Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Mon, 7 Sep 2015 10:54:26 -0400
+Subject: [PATCH 08/29] removed ethernetif.c
+
+---
+ src/netif/ethernetif.c | 496 -------------------------------------------------
+ 1 file changed, 496 deletions(-)
+ delete mode 100644 src/netif/ethernetif.c
+
+diff --git a/src/netif/ethernetif.c b/src/netif/ethernetif.c
+deleted file mode 100644
+index bc429e9..0000000
+--- a/src/netif/ethernetif.c
++++ /dev/null
+@@ -1,496 +0,0 @@
+-/**
+-  ******************************************************************************
+-  * @file    LwIP/LwIP_HTTP_Server_Netconn_RTOS/Src/ethernetif.c
+-  * @author  MCD Application Team
+-  * @version V1.0.0
+-  * @date    25-June-2015
+-  * @brief   This file implements Ethernet network interface drivers for lwIP
+-  ******************************************************************************
+-  * @attention
+-  *
+-  * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
+-  *
+-  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+-  * You may not use this file except in compliance with the License.
+-  * You may obtain a copy of the License at:
+-  *
+-  *        http://www.st.com/software_license_agreement_liberty_v2
+-  *
+-  * Unless required by applicable law or agreed to in writing, software 
+-  * distributed under the License is distributed on an "AS IS" BASIS, 
+-  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+-  * See the License for the specific language governing permissions and
+-  * limitations under the License.
+-  *
+-  ******************************************************************************
+-  */
+-
+-/* Includes ------------------------------------------------------------------*/
+-#include <stm32f7xx_hal.h>
+-#include <lwip/opt.h>
+-#include <lwip/lwip_timers.h>
+-#include <netif/etharp.h>
+-#include <hal-ethernetif.h>
+-#include <string.h>
+-
+-/* Private typedef -----------------------------------------------------------*/
+-/* Private define ------------------------------------------------------------*/
+-/* The time to block waiting for input. */
+-#define TIME_WAITING_FOR_INPUT                 ( 100 )
+-/* Stack size of the interface thread */
+-#define INTERFACE_THREAD_STACK_SIZE            ( 350 )
+-
+-/* Define those to better describe your network interface. */
+-#define IFNAME0 'e'
+-#define IFNAME1 'n'
+-
+-#define LAN8742A_PHY_ADDRESS            0x00
+-
+-/* Private macro -------------------------------------------------------------*/
+-/* Private variables ---------------------------------------------------------*/
+-
+-#if defined ( __ICCARM__ ) /*!< IAR Compiler */
+-
+-#pragma location=0x2000E000
+-__no_init ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
+-#pragma location=0x2000E100
+-__no_init ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
+-#elif defined ( __CC_ARM   )
+-ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((at(0x2000E000)));/* Ethernet Rx MA Descriptor */
+-ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((at(0x2000E100)));/* Ethernet Tx DMA Descriptor */
+-#elif defined ( __GNUC__   )
+-//ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".RxDescripSection")));/* Ethernet Rx MA Descriptor */
+-//ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".TxDescripSection")));/* Ethernet Tx DMA Descriptor */
+-ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Rx MA Descriptor */
+-ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Tx DMA Descriptor */
+-
+-
+-#endif
+-#if defined ( __ICCARM__ ) /*!< IAR Compiler */
+-#pragma location=0x2000E200
+-__no_init uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
+-#pragma location=0x2000FFC4
+-__no_init uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
+-#elif defined ( __CC_ARM   )
+-uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((at(0x2000E200)));  /* Ethernet Receive Buffer */
+-uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]  __attribute__((at(0x2000FFC4))); /* Ethernet Transmit Buffer */
+-#elif defined ( __GNUC__   )
+-//uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".RxBUF")));/* Ethernet Receive Buffer */
+-//uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".TxBUF")));/* Ethernet Transmit Buffer */
+-uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Receive Buffer */
+-uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Transmit Buffer */
+-
+-#endif
+-/* Semaphore to signal incoming packets */
+-osSemaphoreId s_xSemaphore = NULL;
+-
+-/* Global Ethernet handle*/
+-ETH_HandleTypeDef EthHandle;
+-
+-/* Private function prototypes -----------------------------------------------*/
+-static void ethernetif_input( void const * argument );
+-
+-static void stm32f_ethernet_isr(
+-  void* argData
+-)
+-{
+-  ETH_HandleTypeDef* pEth =
+-    (ETH_HandleTypeDef*) argData;
+-
+-  HAL_ETH_IRQHandler(pEth);
+-}
+-
+-/* Private functions ---------------------------------------------------------*/
+-/*******************************************************************************
+-                       Ethernet MSP Routines
+-*******************************************************************************/
+-/**
+-  * @brief  Initializes the ETH MSP.
+-  * @param  heth: ETH handle
+-  * @retval None
+-  */
+-void HAL_ETH_MspInit(ETH_HandleTypeDef *heth)
+-{
+-  GPIO_InitTypeDef GPIO_InitStructure;
+-  
+-  /* Enable GPIOs clocks */
+-  __HAL_RCC_GPIOA_CLK_ENABLE();
+-  __HAL_RCC_GPIOC_CLK_ENABLE();
+-  __HAL_RCC_GPIOG_CLK_ENABLE();
+-
+-/* Ethernet pins configuration ************************************************/
+-  /*
+-        RMII_REF_CLK ----------------------> PA1
+-        RMII_MDIO -------------------------> PA2
+-        RMII_MDC --------------------------> PC1
+-        RMII_MII_CRS_DV -------------------> PA7
+-        RMII_MII_RXD0 ---------------------> PC4
+-        RMII_MII_RXD1 ---------------------> PC5
+-        RMII_MII_RXER ---------------------> PG2
+-        RMII_MII_TX_EN --------------------> PG11
+-        RMII_MII_TXD0 ---------------------> PG13
+-        RMII_MII_TXD1 ---------------------> PG14
+-  */
+-
+-  /* Configure PA1, PA2 and PA7 */
+-  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
+-  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
+-  GPIO_InitStructure.Pull = GPIO_NOPULL; 
+-  GPIO_InitStructure.Alternate = GPIO_AF11_ETH;
+-  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
+-  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
+-  
+-  /* Configure PC1, PC4 and PC5 */
+-  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;
+-  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
+-
+-  /* Configure PG2, PG11, PG13 and PG14 */
+-  GPIO_InitStructure.Pin =  GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14;
+-  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
+-  
+-  // Install HAL Ethernet ISR
+-  rtems_interrupt_handler_install(
+-    ETH_IRQn,
+-    NULL,
+-    0,
+-    stm32f_ethernet_isr,
+-    heth);
+-  
+-  /* Enable ETHERNET clock  */
+-  __HAL_RCC_ETH_CLK_ENABLE();
+-}
+-
+-/**
+-  * @brief  Ethernet Rx Transfer completed callback
+-  * @param  heth: ETH handle
+-  * @retval None
+-  */
+-void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
+-{
+-  osSemaphoreRelease(s_xSemaphore);
+-}
+-
+-/**
+-  * @brief  Ethernet IRQ Handler
+-  * @param  None
+-  * @retval None
+-  */
+-void ETHERNET_IRQHandler(void)
+-{
+-  HAL_ETH_IRQHandler(&EthHandle);
+-}
+-
+-/*******************************************************************************
+-                       LL Driver Interface ( LwIP stack --> ETH) 
+-*******************************************************************************/
+-/**
+-  * @brief In this function, the hardware should be initialized.
+-  * Called from ethernetif_init().
+-  *
+-  * @param netif the already initialized lwip network interface structure
+-  *        for this ethernetif
+-  */
+-static void low_level_init(struct netif *netif)
+-{
+-  uint8_t macaddress[6]= { MAC_ADDR0, MAC_ADDR1, MAC_ADDR2, MAC_ADDR3, MAC_ADDR4, MAC_ADDR5 };
+-  
+-  EthHandle.Instance = ETH;  
+-  EthHandle.Init.MACAddr = macaddress;
+-  EthHandle.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
+-  EthHandle.Init.Speed = ETH_SPEED_100M;
+-  EthHandle.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
+-  EthHandle.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
+-  EthHandle.Init.RxMode = ETH_RXINTERRUPT_MODE;
+-  EthHandle.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
+-  EthHandle.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
+-  
+-  /* configure ethernet peripheral (GPIOs, clocks, MAC, DMA) */
+-  if (HAL_ETH_Init(&EthHandle) == HAL_OK)
+-  {
+-    /* Set netif link flag */
+-    netif->flags |= NETIF_FLAG_LINK_UP;
+-  }
+-  
+-  /* Initialize Tx Descriptors list: Chain Mode */
+-  HAL_ETH_DMATxDescListInit(&EthHandle, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
+-     
+-  /* Initialize Rx Descriptors list: Chain Mode  */
+-  HAL_ETH_DMARxDescListInit(&EthHandle, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
+-  
+-  /* set netif MAC hardware address length */
+-  netif->hwaddr_len = ETHARP_HWADDR_LEN;
+-
+-  /* set netif MAC hardware address */
+-  netif->hwaddr[0] =  MAC_ADDR0;
+-  netif->hwaddr[1] =  MAC_ADDR1;
+-  netif->hwaddr[2] =  MAC_ADDR2;
+-  netif->hwaddr[3] =  MAC_ADDR3;
+-  netif->hwaddr[4] =  MAC_ADDR4;
+-  netif->hwaddr[5] =  MAC_ADDR5;
+-
+-  /* set netif maximum transfer unit */
+-  netif->mtu = 1500;
+-
+-  /* Accept broadcast address and ARP traffic */
+-  netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
+-
+-  /* create a binary semaphore used for informing ethernetif of frame reception */
+-  osSemaphoreDef(SEM);
+-  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1 );
+-
+-  /* create the task that handles the ETH_MAC */
+-  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
+-  osThreadCreate (osThread(EthIf), netif);
+-
+-  /* Enable MAC and DMA transmission and reception */
+-  HAL_ETH_Start(&EthHandle);
+-}
+-
+-
+-/**
+-  * @brief This function should do the actual transmission of the packet. The packet is
+-  * contained in the pbuf that is passed to the function. This pbuf
+-  * might be chained.
+-  *
+-  * @param netif the lwip network interface structure for this ethernetif
+-  * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
+-  * @return ERR_OK if the packet could be sent
+-  *         an err_t value if the packet couldn't be sent
+-  *
+-  * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
+-  *       strange results. You might consider waiting for space in the DMA queue
+-  *       to become available since the stack doesn't retry to send a packet
+-  *       dropped because of memory failure (except for the TCP timers).
+-  */
+-static err_t low_level_output(struct netif *netif, struct pbuf *p)
+-{
+-  err_t errval;
+-  struct pbuf *q;
+-  uint8_t *buffer = (uint8_t *)(EthHandle.TxDesc->Buffer1Addr);
+-  __IO ETH_DMADescTypeDef *DmaTxDesc;
+-  uint32_t framelength = 0;
+-  uint32_t bufferoffset = 0;
+-  uint32_t byteslefttocopy = 0;
+-  uint32_t payloadoffset = 0;
+-
+-  DmaTxDesc = EthHandle.TxDesc;
+-  bufferoffset = 0;
+-  
+-  /* copy frame from pbufs to driver buffers */
+-  for(q = p; q != NULL; q = q->next)
+-  {
+-    /* Is this buffer available? If not, goto error */
+-    if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
+-    {
+-      errval = ERR_USE;
+-      goto error;
+-    }
+-    
+-    /* Get bytes in current lwIP buffer */
+-    byteslefttocopy = q->len;
+-    payloadoffset = 0;
+-    
+-    /* Check if the length of data to copy is bigger than Tx buffer size*/
+-    while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
+-    {
+-      /* Copy data to Tx buffer*/
+-      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
+-      
+-      /* Point to next descriptor */
+-      DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
+-      
+-      /* Check if the buffer is available */
+-      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
+-      {
+-        errval = ERR_USE;
+-        goto error;
+-      }
+-      
+-      buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
+-      
+-      byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
+-      payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
+-      framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
+-      bufferoffset = 0;
+-    }
+-    
+-    /* Copy the remaining bytes */
+-    memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
+-    bufferoffset = bufferoffset + byteslefttocopy;
+-    framelength = framelength + byteslefttocopy;
+-  }
+-  
+-  /* Prepare transmit descriptors to give to DMA */ 
+-  HAL_ETH_TransmitFrame(&EthHandle, framelength);
+-  
+-  errval = ERR_OK;
+-  
+-error:
+-  
+-  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
+-  if ((EthHandle.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
+-  {
+-    /* Clear TUS ETHERNET DMA flag */
+-    EthHandle.Instance->DMASR = ETH_DMASR_TUS;
+-    
+-    /* Resume DMA transmission*/
+-    EthHandle.Instance->DMATPDR = 0;
+-  }
+-  return errval;
+-}
+-
+-/**
+-  * @brief Should allocate a pbuf and transfer the bytes of the incoming
+-  * packet from the interface into the pbuf.
+-  *
+-  * @param netif the lwip network interface structure for this ethernetif
+-  * @return a pbuf filled with the received packet (including MAC header)
+-  *         NULL on memory error
+-  */
+-static struct pbuf * low_level_input(struct netif *netif)
+-{
+-  struct pbuf *p = NULL, *q = NULL;
+-  uint16_t len = 0;
+-  uint8_t *buffer;
+-  __IO ETH_DMADescTypeDef *dmarxdesc;
+-  uint32_t bufferoffset = 0;
+-  uint32_t payloadoffset = 0;
+-  uint32_t byteslefttocopy = 0;
+-  uint32_t i=0;
+-  
+-  /* get received frame */
+-  if(HAL_ETH_GetReceivedFrame_IT(&EthHandle) != HAL_OK)
+-    return NULL;
+-  
+-  /* Obtain the size of the packet and put it into the "len" variable. */
+-  len = EthHandle.RxFrameInfos.length;
+-  buffer = (uint8_t *)EthHandle.RxFrameInfos.buffer;
+-  
+-  if (len > 0)
+-  {
+-    /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
+-    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
+-  }
+-  
+-  if (p != NULL)
+-  {
+-    dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
+-    bufferoffset = 0;
+-    
+-    for(q = p; q != NULL; q = q->next)
+-    {
+-      byteslefttocopy = q->len;
+-      payloadoffset = 0;
+-      
+-      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size */
+-      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
+-      {
+-        /* Copy data to pbuf */
+-        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
+-        
+-        /* Point to next descriptor */
+-        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
+-        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
+-        
+-        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
+-        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
+-        bufferoffset = 0;
+-      }
+-      
+-      /* Copy remaining data in pbuf */
+-      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
+-      bufferoffset = bufferoffset + byteslefttocopy;
+-    }
+-  }
+-    
+-  /* Release descriptors to DMA */
+-  /* Point to first descriptor */
+-  dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
+-  /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
+-  for (i=0; i< EthHandle.RxFrameInfos.SegCount; i++)
+-  {  
+-    dmarxdesc->Status |= ETH_DMARXDESC_OWN;
+-    dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
+-  }
+-    
+-  /* Clear Segment_Count */
+-  EthHandle.RxFrameInfos.SegCount =0;
+-  
+-  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
+-  if ((EthHandle.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
+-  {
+-    /* Clear RBUS ETHERNET DMA flag */
+-    EthHandle.Instance->DMASR = ETH_DMASR_RBUS;
+-    /* Resume DMA reception */
+-    EthHandle.Instance->DMARPDR = 0;
+-  }
+-  return p;
+-}
+-
+-/**
+-  * @brief This function is the ethernetif_input task, it is processed when a packet 
+-  * is ready to be read from the interface. It uses the function low_level_input() 
+-  * that should handle the actual reception of bytes from the network
+-  * interface. Then the type of the received packet is determined and
+-  * the appropriate input function is called.
+-  *
+-  * @param netif the lwip network interface structure for this ethernetif
+-  */
+-void ethernetif_input( void const * argument )
+-{
+-  struct pbuf *p;
+-  struct netif *netif = (struct netif *) argument;
+-  
+-  for( ;; )
+-  {
+-    if (osSemaphoreWait( s_xSemaphore, TIME_WAITING_FOR_INPUT)==osOK)
+-    {
+-      do
+-      {
+-        p = low_level_input( netif );
+-        if (p != NULL)
+-        {
+-          if (netif->input( p, netif) != ERR_OK )
+-          {
+-            pbuf_free(p);
+-          }
+-        }
+-      }while(p!=NULL);
+-    }
+-  }
+-}
+-
+-/**
+-  * @brief Should be called at the beginning of the program to set up the
+-  * network interface. It calls the function low_level_init() to do the
+-  * actual setup of the hardware.
+-  *
+-  * This function should be passed as a parameter to netif_add().
+-  *
+-  * @param netif the lwip network interface structure for this ethernetif
+-  * @return ERR_OK if the loopif is initialized
+-  *         ERR_MEM if private data couldn't be allocated
+-  *         any other err_t on error
+-  */
+-err_t ethernetif_init(struct netif *netif)
+-{
+-  LWIP_ASSERT("netif != NULL", (netif != NULL));
+-
+-#if LWIP_NETIF_HOSTNAME
+-  /* Initialize interface hostname */
+-  netif->hostname = "lwip";
+-#endif /* LWIP_NETIF_HOSTNAME */
+-
+-  netif->name[0] = IFNAME0;
+-  netif->name[1] = IFNAME1;
+-
+-  netif->output = etharp_output;
+-  netif->linkoutput = low_level_output;
+-
+-  /* initialize the hardware */
+-  low_level_init(netif);
+-
+-  return ERR_OK;
+-}
+-
+-/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+-- 
+1.9.1
+
+
+From 8f652ac0f1be0f2abc1493981763fc4c402bbfed Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Wed, 16 Sep 2015 09:29:27 -0400
+Subject: [PATCH 09/29] using options from sample project
+
+---
+ ports/include/lwipopts.h | 207 +++++++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 207 insertions(+)
+
+diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
+index 169ba46..68d799b 100644
+--- a/ports/include/lwipopts.h
++++ b/ports/include/lwipopts.h
+@@ -38,6 +38,9 @@
+ #ifndef __LWIPOPTS_H__
+ #define __LWIPOPTS_H__
+ 
++
++#if ORIGINAL_CONFIG_OPTIONS
++
+ /*****************************************************************************
+ **                           CONFIGURATIONS
+ *****************************************************************************/
+@@ -175,4 +178,208 @@
+ 
+  #define LWIP_RAW                       0
+ 
++#else
++
++/**
++ * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
++ * critical regions during buffer allocation, deallocation and memory
++ * allocation and deallocation.
++ */
++#define SYS_LIGHTWEIGHT_PROT    0
++
++#define ETHARP_TRUST_IP_MAC     0
++#define IP_REASSEMBLY           0
++#define IP_FRAG                 0
++#define ARP_QUEUEING            0
++#define TCP_LISTEN_BACKLOG      1
++
++/**
++ * NO_SYS==1: Provides VERY minimal functionality. Otherwise,
++ * use lwIP facilities.
++ */
++#define NO_SYS                  0
++
++/* ---------- Memory options ---------- */
++/* MEM_ALIGNMENT: should be set to the alignment of the CPU for which
++   lwIP is compiled. 4 byte alignment -> define MEM_ALIGNMENT to 4, 2
++   byte alignment -> define MEM_ALIGNMENT to 2. */
++#define MEM_ALIGNMENT           4
++
++/* MEM_SIZE: the size of the heap memory. If the application will send
++a lot of data that needs to be copied, this should be set high. */
++#define MEM_SIZE                (10*1024)
++
++/* MEMP_NUM_PBUF: the number of memp struct pbufs. If the application
++   sends a lot of data out of ROM (or other static memory), this
++   should be set high. */
++#define MEMP_NUM_PBUF           50
++/* MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks. One
++   per active UDP "connection". */
++#define MEMP_NUM_UDP_PCB        6
++/* MEMP_NUM_TCP_PCB: the number of simulatenously active TCP
++   connections. */
++#define MEMP_NUM_TCP_PCB        10
++/* MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP
++   connections. */
++#define MEMP_NUM_TCP_PCB_LISTEN 5
++/* MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP
++   segments. */
++#define MEMP_NUM_TCP_SEG        12
++/* MEMP_NUM_SYS_TIMEOUT: the number of simulateously active
++   timeouts. */
++#define MEMP_NUM_SYS_TIMEOUT    10
++
++
++/* ---------- Pbuf options ---------- */
++/* PBUF_POOL_SIZE: the number of buffers in the pbuf pool. */
++#define PBUF_POOL_SIZE          10
++
++/* PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. */
++#define PBUF_POOL_BUFSIZE       1524
++
++
++/* ---------- TCP options ---------- */
++#define LWIP_TCP                1
++#define TCP_TTL                 255
++
++/* Controls if TCP should queue segments that arrive out of
++   order. Define to 0 if your device is low on memory. */
++#define TCP_QUEUE_OOSEQ         0
++
++/* TCP Maximum segment size. */
++#define TCP_MSS                 (1500 - 40)   /* TCP_MSS = (Ethernet MTU - IP header size - TCP header size) */
++
++/* TCP sender buffer space (bytes). */
++#define TCP_SND_BUF             (4*TCP_MSS)
++
++/*  TCP_SND_QUEUELEN: TCP sender buffer space (pbufs). This must be at least
++  as much as (2 * TCP_SND_BUF/TCP_MSS) for things to work. */
++
++#define TCP_SND_QUEUELEN        (2* TCP_SND_BUF/TCP_MSS)
++
++/* TCP receive window. */
++#define TCP_WND                 (2*TCP_MSS)
++
++
++/* ---------- ICMP options ---------- */
++#define LWIP_ICMP                       1
++
++
++/* ---------- DHCP options ---------- */
++/* Define LWIP_DHCP to 1 if you want DHCP configuration of
++   interfaces. DHCP is not implemented in lwIP 0.5.1, however, so
++   turning this on does currently not work. */
++#define LWIP_DHCP               1
++
++
++/* ---------- UDP options ---------- */
++#define LWIP_UDP                1
++#define UDP_TTL                 255
++
++
++/* ---------- Statistics options ---------- */
++#define LWIP_STATS 0
++#define LWIP_PROVIDE_ERRNO 1
++
++/* ---------- link callback options ---------- */
++/* LWIP_NETIF_LINK_CALLBACK==1: Support a callback function from an interface
++ * whenever the link changes (i.e., link down)
++ */
++#define LWIP_NETIF_LINK_CALLBACK        1
++
++/*
++   --------------------------------------
++   ---------- Checksum options ----------
++   --------------------------------------
++*/
++
++/*
++The STM32F4x7 allows computing and verifying the IP, UDP, TCP and ICMP checksums by hardware:
++ - To use this feature let the following define uncommented.
++ - To disable it and process by CPU comment the  the checksum.
++*/
++#define CHECKSUM_BY_HARDWARE
++
++
++#ifdef CHECKSUM_BY_HARDWARE
++  /* CHECKSUM_GEN_IP==0: Generate checksums by hardware for outgoing IP packets.*/
++  #define CHECKSUM_GEN_IP                 0
++  /* CHECKSUM_GEN_UDP==0: Generate checksums by hardware for outgoing UDP packets.*/
++  #define CHECKSUM_GEN_UDP                0
++  /* CHECKSUM_GEN_TCP==0: Generate checksums by hardware for outgoing TCP packets.*/
++  #define CHECKSUM_GEN_TCP                0
++  /* CHECKSUM_CHECK_IP==0: Check checksums by hardware for incoming IP packets.*/
++  #define CHECKSUM_CHECK_IP               0
++  /* CHECKSUM_CHECK_UDP==0: Check checksums by hardware for incoming UDP packets.*/
++  #define CHECKSUM_CHECK_UDP              0
++  /* CHECKSUM_CHECK_TCP==0: Check checksums by hardware for incoming TCP packets.*/
++  #define CHECKSUM_CHECK_TCP              0
++  /* CHECKSUM_CHECK_ICMP==0: Check checksums by hardware for incoming ICMP packets.*/
++  #define CHECKSUM_GEN_ICMP               0
++#else
++  /* CHECKSUM_GEN_IP==1: Generate checksums in software for outgoing IP packets.*/
++  #define CHECKSUM_GEN_IP                 1
++  /* CHECKSUM_GEN_UDP==1: Generate checksums in software for outgoing UDP packets.*/
++  #define CHECKSUM_GEN_UDP                1
++  /* CHECKSUM_GEN_TCP==1: Generate checksums in software for outgoing TCP packets.*/
++  #define CHECKSUM_GEN_TCP                1
++  /* CHECKSUM_CHECK_IP==1: Check checksums in software for incoming IP packets.*/
++  #define CHECKSUM_CHECK_IP               1
++  /* CHECKSUM_CHECK_UDP==1: Check checksums in software for incoming UDP packets.*/
++  #define CHECKSUM_CHECK_UDP              1
++  /* CHECKSUM_CHECK_TCP==1: Check checksums in software for incoming TCP packets.*/
++  #define CHECKSUM_CHECK_TCP              1
++  /* CHECKSUM_CHECK_ICMP==1: Check checksums by hardware for incoming ICMP packets.*/
++  #define CHECKSUM_GEN_ICMP               1
++#endif
++
++
++/*
++   ----------------------------------------------
++   ---------- Sequential layer options ----------
++   ----------------------------------------------
++*/
++/**
++ * LWIP_NETCONN==1: Enable Netconn API (require to use api_lib.c)
++ */
++#define LWIP_NETCONN                    1
++
++/*
++   ------------------------------------
++   ---------- Socket options ----------
++   ------------------------------------
++*/
++/**
++ * LWIP_SOCKET==1: Enable Socket API (require to use sockets.c)
++ */
++#define LWIP_SOCKET                     1
++
++/*
++   -----------------------------------
++   ---------- DEBUG options ----------
++   -----------------------------------
++*/
++
++#define LWIP_DEBUG                      0
++
++
++/*
++   ---------------------------------
++   ---------- OS options ----------
++   ---------------------------------
++*/
++
++#define TCPIP_THREAD_NAME              "TCP/IP"
++#define TCPIP_THREAD_STACKSIZE          1000
++#define TCPIP_MBOX_SIZE                 5
++#define DEFAULT_UDP_RECVMBOX_SIZE       2000
++#define DEFAULT_TCP_RECVMBOX_SIZE       2000
++#define DEFAULT_ACCEPTMBOX_SIZE         2000
++#define DEFAULT_THREAD_STACKSIZE        500
++#define TCPIP_THREAD_PRIO               (configMAX_PRIORITIES - 2)
++#define LWIP_COMPAT_MUTEX               1
++
++
++#endif
++
+ #endif /* __LWIPOPTS_H__ */
+-- 
+1.9.1
+
+
+From d2624890161b1ec246cd224de8079157367a6346 Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Wed, 16 Sep 2015 10:01:58 -0400
+Subject: [PATCH 10/29] added cache line configuration
+
+---
+ ports/include/lwipopts.h | 3 +++
+ 1 file changed, 3 insertions(+)
+
+diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
+index 68d799b..049d66d 100644
+--- a/ports/include/lwipopts.h
++++ b/ports/include/lwipopts.h
+@@ -180,6 +180,9 @@
+ 
+ #else
+ 
++#define LWIP_CACHE_ENABLED
++#define SOC_CACHELINE_SIZE_BYTES 32
++
+ /**
+  * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
+  * critical regions during buffer allocation, deallocation and memory
+-- 
+1.9.1
+
+
+From 37e5b73c865357e530226ea2a2008aa355f58d55 Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Wed, 16 Sep 2015 10:11:20 -0400
+Subject: [PATCH 11/29] configured for local time structure definition
+
+---
+ ports/include/arch/cc.h  | 2 ++
+ ports/include/lwipopts.h | 1 +
+ 2 files changed, 3 insertions(+)
+
+diff --git a/ports/include/arch/cc.h b/ports/include/arch/cc.h
+index 04ec89f..900e9b6 100644
+--- a/ports/include/arch/cc.h
++++ b/ports/include/arch/cc.h
+@@ -32,6 +32,8 @@
+ #ifndef __CC_H__
+ #define __CC_H__
+ 
++#include <sys/time.h>
++
+ typedef unsigned    char    u8_t;
+ typedef signed      char    s8_t;
+ typedef unsigned    short   u16_t;
+diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
+index 049d66d..05f5b52 100644
+--- a/ports/include/lwipopts.h
++++ b/ports/include/lwipopts.h
+@@ -182,6 +182,7 @@
+ 
+ #define LWIP_CACHE_ENABLED
+ #define SOC_CACHELINE_SIZE_BYTES 32
++#define LWIP_TIMEVAL_PRIVATE 0
+ 
+ /**
+  * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
+-- 
+1.9.1
+
+
+From 9a72a789d145f794b8a4c1084ed50597b71c6e2b Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Wed, 16 Sep 2015 10:16:55 -0400
+Subject: [PATCH 12/29] remove include from cc.h
+
+---
+ ports/include/arch/cc.h | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/ports/include/arch/cc.h b/ports/include/arch/cc.h
+index 900e9b6..8eefd64 100644
+--- a/ports/include/arch/cc.h
++++ b/ports/include/arch/cc.h
+@@ -32,8 +32,6 @@
+ #ifndef __CC_H__
+ #define __CC_H__
+ 
+-#include <sys/time.h>
+-
+ typedef unsigned    char    u8_t;
+ typedef signed      char    s8_t;
+ typedef unsigned    short   u16_t;
+@@ -104,6 +102,8 @@ extern u8_t memp_memory_PBUF_POOL_base[] __attribute__ ((aligned (SOC_CACHELINE_
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <bsp.h>
++//#include <sys/time.h>
++
+ #define LWIP_PLATFORM_DIAG(x)   do { \
+         printk("[%s - %s - %d] ", __PRETTY_FUNCTION__, __FILE__, __LINE__); \
+         printk x; \
+-- 
+1.9.1
+
+
+From a48846deb25945d360543ffe8d86766d323b9859 Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Fri, 18 Sep 2015 13:22:21 -0400
+Subject: [PATCH 13/29] turn off checksum checking by hardware
+
+---
+ ports/include/lwipopts.h | 6 +++---
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
+index 05f5b52..cf11793 100644
+--- a/ports/include/lwipopts.h
++++ b/ports/include/lwipopts.h
+@@ -243,8 +243,8 @@ a lot of data that needs to be copied, this should be set high. */
+ 
+ 
+ /* ---------- TCP options ---------- */
+-#define LWIP_TCP                1
+-#define TCP_TTL                 255
++//#define LWIP_TCP                1
++//#define TCP_TTL                 255
+ 
+ /* Controls if TCP should queue segments that arrive out of
+    order. Define to 0 if your device is low on memory. */
+@@ -302,7 +302,7 @@ The STM32F4x7 allows computing and verifying the IP, UDP, TCP and ICMP checksums
+  - To use this feature let the following define uncommented.
+  - To disable it and process by CPU comment the  the checksum.
+ */
+-#define CHECKSUM_BY_HARDWARE
++//#define CHECKSUM_BY_HARDWARE
+ 
+ 
+ #ifdef CHECKSUM_BY_HARDWARE
+-- 
+1.9.1
+
+
+From ab1a2feb46bbb67eb1639e08dd5ffd2ed1f1933d Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Fri, 18 Sep 2015 13:24:24 -0400
+Subject: [PATCH 14/29] defined configMAX_PRIORITIES
+
+---
+ ports/include/lwipopts.h |    3 +-
+ rtems.patch              | 4105 ++++++++++++++++++++++++++++++++++++++++++++++
+ 2 files changed, 4107 insertions(+), 1 deletion(-)
+ create mode 100644 rtems.patch
+
+diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
+index cf11793..e7f344f 100644
+--- a/ports/include/lwipopts.h
++++ b/ports/include/lwipopts.h
+@@ -180,6 +180,7 @@
+ 
+ #else
+ 
++#define configMAX_PRIORITIES 100
+ #define LWIP_CACHE_ENABLED
+ #define SOC_CACHELINE_SIZE_BYTES 32
+ #define LWIP_TIMEVAL_PRIVATE 0
+@@ -287,7 +288,7 @@ a lot of data that needs to be copied, this should be set high. */
+ 
+ /* ---------- link callback options ---------- */
+ /* LWIP_NETIF_LINK_CALLBACK==1: Support a callback function from an interface
+- * whenever the link changes (i.e., link down)
++ * whenever the link a48846deb25945d360543ffe8d86766d323b9859changes (i.e., link down)
+  */
+ #define LWIP_NETIF_LINK_CALLBACK        1
+ 
+diff --git a/rtems.patch b/rtems.patch
+new file mode 100644
+index 0000000..9ca8d63
+--- /dev/null
++++ b/rtems.patch
+@@ -0,0 +1,4105 @@
++From 2d83d4994e578ec339b2b1baef53090bf7a53570 Mon Sep 17 00:00:00 2001
++From: Jay Doyle <jay.doyle@vecna.com>
++Date: Fri, 4 Sep 2015 17:28:55 -0400
++Subject: [PATCH 01/13] rtems changes necessary
++
++---
++ Makefile                      | 170 +++++++++++
++ ports/include/arch/cc.h       | 123 ++++++++
++ ports/include/arch/perf.h     |  38 +++
++ ports/include/arch/sys_arch.h |  59 ++++
++ ports/include/lwipopts.h      | 178 ++++++++++++
++ ports/sys_arch.c              | 663 ++++++++++++++++++++++++++++++++++++++++++
++ 6 files changed, 1231 insertions(+)
++ create mode 100644 Makefile
++ create mode 100644 ports/include/arch/cc.h
++ create mode 100644 ports/include/arch/perf.h
++ create mode 100644 ports/include/arch/sys_arch.h
++ create mode 100644 ports/include/lwipopts.h
++ create mode 100644 ports/sys_arch.c
++
++diff --git a/Makefile b/Makefile
++new file mode 100644
++index 0000000..0cbae64
++--- /dev/null
+++++ b/Makefile
++@@ -0,0 +1,170 @@
+++include $(RTEMS_MAKEFILE_PATH)/Makefile.inc
+++include $(RTEMS_CUSTOM)
+++include $(PROJECT_ROOT)/make/leaf.cfg
+++
+++#### CONFIG ####################################################################
+++#For debugging symbols add -DLWIP_DEBUG
+++# COMPILER/LINKER
+++CFLAGS+=-g -O2   \
+++ -Wall
+++
+++# OUTPUT
+++LWIP_EXEC=lwip
+++
+++#### PATHS #####################################################################
+++
+++# LWIP
+++LWIP_PATH=.
+++LWIP_SRC_PATH=$(LWIP_PATH)/src
+++LWIP_API_PATH=$(LWIP_SRC_PATH)/api
+++LWIP_CORE_PATH=$(LWIP_SRC_PATH)/core
+++LWIP_INCL_PATH=$(LWIP_SRC_PATH)/include
+++LWIP_NETIF_PATH=$(LWIP_SRC_PATH)/netif
+++
+++# ARCH
+++LWIPARCH_PATH=$(LWIP_PATH)/ports
+++LWIPARCH_SRC_PATH=$(LWIPARCH_PATH)
+++LWIPARCH_INCL_PATH=$(LWIPARCH_PATH)/include
+++
+++# DRIVER
+++LWIPDRIVER_PATH=$(LWIP_PATH)/ports
+++LWIPDRIVER_SRC_PATH=$(LWIPDRIVER_PATH)/netif
+++LWIPDRIVER_INCL_PATH=$(LWIPDRIVER_PATH)/include/netif
+++
+++#### SOURCES ###################################################################
+++
+++## CORE
+++CORE_SRC=$(wildcard $(LWIP_CORE_PATH)/*.c)
+++
+++## IPv4
+++IPV4_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv4/*.c)
+++
+++## IPv6
+++IPV6_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv6/*.c)
+++
+++## SNMP
+++SNMP_SRC=$(wildcard $(LWIP_CORE_PATH)/snmp/*.c)
+++
+++## API
+++API_SRC=$(wildcard $(LWIP_API_PATH)/*.c )
+++
+++## NETIF
+++NETIF_SRC=$(wildcard $(LWIP_NETIF_PATH)/*.c) \
+++          $(wildcard $(LWIP_NETIF_PATH)/ppp/*.c) \
+++          $(wildcard $(LWIP_NETIF_PATH)/ppp/polarssl/*.c)
+++
+++
+++ARCH_SRC=$(wildcard $(LWIPARCH_SRC_PATH)/*.c)
+++
+++# DRIVER
+++DRIVER_SRC=$(wildcard $(LWIPDRIVER_SRC_PATH)/*.c ) \
+++           $(wildcard $(LWIPDRIVER_SRC_PATH)/*.S )
+++
+++
+++SOURCES =  $(DRIVER_SRC) $(SNMP_SRC)\
+++           $(CORE_SRC) $(IPV4_SRC) $(API_SRC) $(NETIF_SRC) $(ARCH_SRC)
+++
+++
+++#### HEADERS ###################################################################
+++
+++## CORE
+++CORE_H=$(LWIP_INCL_PATH)
+++
+++## IPv4
+++#IPV4_H=$(LWIP_INCL_PATH)/ipv4
+++
+++## IPv6
+++#IPV6_H=$(LWIP_INCL_PATH)/ipv6
+++
+++## POSIX
+++POSIX_H=$(LWIP_INCL_PATH)/posix
+++
+++##POSIX_SYS
+++POSIX_SYS_H=$(LWIP_INCL_PATH)/posix/sys
+++
+++
+++## NETIF
+++NETIF_H=$(LWIP_INCL_PATH)/netif
+++NETIF_H_PPP=$(LWIP_INCL_PATH)/netif/ppp
+++NETIF_H_PPP_POLARSSL=$(LWIP_INCL_PATH)/netif/ppp/polarssl
+++
+++## ARCH
+++ARCH_H=$(LWIPARCH_INCL_PATH)
+++
+++## DRIVER
+++DRIVER_H=$(LWIPDRIVER_INCL_PATH)
+++
+++# HEADERS
+++HEADERS=-I$(CORE_H) -I$(POSIX_H) -I$(POSIX_SYS_H) -I$(NETIF_H) \
+++        -I$(NETIF_H_PPP) -I$(NETIF_H_PPP_POLARSSL) -I$(ARCH_H) \
+++        -I$(DRIVER_H)
+++
+++
+++################################################################################
+++
+++
+++BIN=${ARCH}/$(LWIP_EXEC).bin
+++LIB=${ARCH}/lib$(LWIP_EXEC).a
+++
+++# optional managers required
+++MANAGERS=all
+++
+++# C source names
+++CSRCS=$(filter %.c ,$(SOURCES))
+++COBJS=$(patsubst %.c,${ARCH}/%.o,$(notdir $(CSRCS)))
+++
+++ASMSRCS=$(filter %.S , $(SOURCES))
+++ASMOBJS=$(patsubst %.S,${ARCH}/%.o,$(notdir $(ASMSRCS)))
+++
+++OBJS=$(COBJS) $(ASMOBJS)
+++
+++all:${ARCH} $(LIB)
+++
+++$(LIB): $(OBJS)
+++	$(AR)  rcs  $@ $^
+++
+++${ARCH}/%.o: $(LWIP_CORE_PATH)/%.c
+++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+++
+++${ARCH}/%.o: $(LWIP_CORE_PATH)/ipv4/%.c
+++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+++
+++${ARCH}/%.o: $(LWIP_CORE_PATH)/ipv6/%.c
+++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+++
+++${ARCH}/%.o: $(LWIP_CORE_PATH)/snmp/%.c
+++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+++
+++${ARCH}/%.o: $(LWIP_API_PATH)/%.c
+++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+++
+++${ARCH}/%.o: $(LWIP_NETIF_PATH)/%.c
+++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+++
+++${ARCH}/%.o: $(LWIP_NETIF_PATH)/ppp/%.c
+++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+++
+++${ARCH}/%.o: $(LWIP_NETIF_PATH)/ppp/polarssl/%.c
+++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+++
+++${ARCH}/%.o: $(LWIPARCH_SRC_PATH)/%.c
+++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+++
+++${ARCH}/%.o: $(LWIPDRIVER_SRC_PATH)/%.S
+++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+++
+++${ARCH}/%.o: $(LWIPDRIVER_SRC_PATH)/%.c
+++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+++
+++INSTALL_DIR=$(RTEMS_MAKEFILE_PATH)/lwip
+++
+++install:
+++	rm -rf $(INSTALL_DIR)
+++	mkdir -p $(INSTALL_DIR)/include
+++	mkdir -p $(INSTALL_DIR)/lib
+++	cp $(LIB) $(INSTALL_DIR)/lib
+++	cp -r $(CORE_H) $(INSTALL_DIR)
+++	cp $(LWIPARCH_INCL_PATH)/lwipopts.h $(INSTALL_DIR)/include
+++	cp -r $(LWIPARCH_INCL_PATH)/arch $(INSTALL_DIR)/include
+++
+++CPPFLAGS+=$(HEADERS)
++diff --git a/ports/include/arch/cc.h b/ports/include/arch/cc.h
++new file mode 100644
++index 0000000..04ec89f
++--- /dev/null
+++++ b/ports/include/arch/cc.h
++@@ -0,0 +1,123 @@
+++/*
+++ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
+++ * All rights reserved.
+++ *
+++ * Redistribution and use in source and binary forms, with or without modification,
+++ * are permitted provided that the following conditions are met:
+++ *
+++ * 1. Redistributions of source code must retain the above copyright notice,
+++ *    this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright notice,
+++ *    this list of conditions and the following disclaimer in the documentation
+++ *    and/or other materials provided with the distribution.
+++ * 3. The name of the author may not be used to endorse or promote products
+++ *    derived from this software without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+++ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+++ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+++ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+++ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+++ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+++ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+++ * OF SUCH DAMAGE.
+++ *
+++ * This file is part of the lwIP TCP/IP stack.
+++ *
+++ * Author: Adam Dunkels <adam@sics.se>
+++ *
+++ */
+++#ifndef __CC_H__
+++#define __CC_H__
+++
+++typedef unsigned    char    u8_t;
+++typedef signed      char    s8_t;
+++typedef unsigned    short   u16_t;
+++typedef signed      short   s16_t;
+++typedef unsigned    int    u32_t;
+++typedef signed      int    s32_t;
+++typedef u32_t           mem_ptr_t;
+++
+++#ifndef BYTE_ORDER
+++#define BYTE_ORDER LITTLE_ENDIAN
+++#endif
+++
+++#if defined(__arm__) && defined(__ARMCC_VERSION)
+++    //
+++    // Setup PACKing macros for KEIL/RVMDK Tools
+++    //
+++    #define PACK_STRUCT_BEGIN __packed
+++    #define PACK_STRUCT_STRUCT
+++    #define PACK_STRUCT_END
+++    #define PACK_STRUCT_FIELD(x) x
+++#elif defined (__IAR_SYSTEMS_ICC__)
+++    //
+++    // Setup PACKing macros for IAR Tools
+++    //
+++    #define PACK_STRUCT_BEGIN
+++    #define PACK_STRUCT_STRUCT
+++    #define PACK_STRUCT_END
+++    #define PACK_STRUCT_FIELD(x) x
+++    #define PACK_STRUCT_USE_INCLUDES
+++#elif defined (__TMS470__)
+++    #define PACK_STRUCT_BEGIN
+++    #define PACK_STRUCT_STRUCT
+++    #define PACK_STRUCT_END
+++    #define PACK_STRUCT_FIELD(x) x
+++#else
+++    //
+++    // Setup PACKing macros for GCC Tools
+++    //
+++    #define PACK_STRUCT_BEGIN
+++    #define PACK_STRUCT_STRUCT __attribute__ ((__packed__))
+++    #define PACK_STRUCT_END
+++    #define PACK_STRUCT_FIELD(x) x
+++#endif
+++
+++#ifdef LWIP_CACHE_ENABLED
+++/**
+++ * Make the PBUF POOL cacheline aligned.
+++ */
+++#ifdef __IAR_SYSTEMS_ICC__
+++#pragma data_alignment=SOC_CACHELINE_SIZE_BYTES
+++extern u8_t memp_memory_PBUF_POOL_base[];
+++#else /*By default, GCC */
+++extern u8_t memp_memory_PBUF_POOL_base[] __attribute__ ((aligned (SOC_CACHELINE_SIZE_BYTES)));
+++#endif
+++#endif
+++
+++extern u8_t memp_memory_PBUF_POOL_base[] __attribute__ ((aligned (SOC_CACHELINE_SIZE_BYTES)));
+++
+++/* Define (sn)printf formatters for these lwIP types */
+++#define X8_F  "02x"
+++#define U16_F "u"
+++#define S16_F "d"
+++#define X16_F "x"
+++#define U32_F "u"
+++#define S32_F "d"
+++#define X32_F "x"
+++
+++#include <stdio.h>
+++#include <stdlib.h>
+++#include <bsp.h>
+++#define LWIP_PLATFORM_DIAG(x)   do { \
+++        printk("[%s - %s - %d] ", __PRETTY_FUNCTION__, __FILE__, __LINE__); \
+++        printk x; \
+++    } while(0)
+++
+++#ifdef LWIP_DEBUG  //DEBUG
+++extern void __error__(char *pcFilename, unsigned long ulLine);
+++#define LWIP_PLATFORM_ASSERT(expr)   printk("[%s - %s - %d] ", expr , __FILE__, __LINE__);
+++//{
+++    //if(!(expr))
+++    //{
+++        //__error__(__FILE__, __LINE__);
+++    //}
+++//}
+++#else
+++#define LWIP_PLATFORM_ASSERT(expr)
+++#endif
+++
+++#endif /* __CC_H__ */
++diff --git a/ports/include/arch/perf.h b/ports/include/arch/perf.h
++new file mode 100644
++index 0000000..d754157
++--- /dev/null
+++++ b/ports/include/arch/perf.h
++@@ -0,0 +1,38 @@
+++/*
+++ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
+++ * All rights reserved.
+++ *
+++ * Redistribution and use in source and binary forms, with or without modification,
+++ * are permitted provided that the following conditions are met:
+++ *
+++ * 1. Redistributions of source code must retain the above copyright notice,
+++ *    this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright notice,
+++ *    this list of conditions and the following disclaimer in the documentation
+++ *    and/or other materials provided with the distribution.
+++ * 3. The name of the author may not be used to endorse or promote products
+++ *    derived from this software without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+++ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+++ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+++ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+++ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+++ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+++ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+++ * OF SUCH DAMAGE.
+++ *
+++ * This file is part of the lwIP TCP/IP stack.
+++ *
+++ * Author: Adam Dunkels <adam@sics.se>
+++ *
+++ */
+++#ifndef __PERF_H__
+++#define __PERF_H__
+++
+++#define PERF_START    /* null definition */
+++#define PERF_STOP(x)  /* null definition */
+++
+++#endif /* __PERF_H__ */
++diff --git a/ports/include/arch/sys_arch.h b/ports/include/arch/sys_arch.h
++new file mode 100644
++index 0000000..32f0d99
++--- /dev/null
+++++ b/ports/include/arch/sys_arch.h
++@@ -0,0 +1,59 @@
+++/*
+++ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
+++ * All rights reserved.
+++ *
+++ * Redistribution and use in source and binary forms, with or without modification,
+++ * are permitted provided that the following conditions are met:
+++ *
+++ * 1. Redistributions of source code must retain the above copyright notice,
+++ *    this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright notice,
+++ *    this list of conditions and the following disclaimer in the documentation
+++ *    and/or other materials provided with the distribution.
+++ * 3. The name of the author may not be used to endorse or promote products
+++ *    derived from this software without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+++ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+++ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+++ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+++ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+++ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+++ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+++ * OF SUCH DAMAGE.
+++ *
+++ * This file is part of the lwIP TCP/IP stack.
+++ *
+++ * Author: Adam Dunkels <adam@sics.se>
+++ *
+++ */
+++#ifndef LWIP_ARCH_SYS_ARCH_H
+++#define LWIP_ARCH_SYS_ARCH_H
+++
+++#include <errno.h>
+++
+++#define SYS_MBOX_NULL NULL
+++#define SYS_SEM_NULL  NULL
+++
+++typedef u32_t sys_prot_t;
+++
+++struct sys_sem;
+++typedef struct sys_sem * sys_sem_t;
+++#define sys_sem_valid(sem) (((sem) != NULL) && (*(sem) != NULL))
+++#define sys_sem_set_invalid(sem) do { if((sem) != NULL) { *(sem) = NULL; }}while(0)
+++
+++/* let sys.h use binary semaphores for mutexes */
+++#define LWIP_COMPAT_MUTEX 1
+++
+++struct sys_mbox;
+++typedef struct sys_mbox *sys_mbox_t;
+++#define sys_mbox_valid(mbox) ((*(mbox) != NULL))
+++#define sys_mbox_set_invalid(mbox) do { if((mbox) != NULL) { *(mbox) = NULL; }}while(0)
+++
+++struct sys_thread;
+++typedef struct sys_thread * sys_thread_t;
+++
+++#endif /* LWIP_ARCH_SYS_ARCH_H */
+++
++diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
++new file mode 100644
++index 0000000..169ba46
++--- /dev/null
+++++ b/ports/include/lwipopts.h
++@@ -0,0 +1,178 @@
+++/**
+++ * \file lwipopts.h - Configuration options for lwIP
+++ *
+++ * Copyright (c) 2010 Texas Instruments Incorporated
+++ */
+++/*
+++ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+++ * All rights reserved.
+++ *
+++ * Redistribution and use in source and binary forms, with or without modification,
+++ * are permitted provided that the following conditions are met:
+++ *
+++ * 1. Redistributions of source code must retain the above copyright notice,
+++ *    this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright notice,
+++ *    this list of conditions and the following disclaimer in the documentation
+++ *    and/or other materials provided with the distribution.
+++ * 3. The name of the author may not be used to endorse or promote products
+++ *    derived from this software without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+++ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+++ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+++ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+++ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+++ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+++ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+++ * OF SUCH DAMAGE.
+++ *
+++ * This file is part of the lwIP TCP/IP stack.
+++ *
+++ * Author: Adam Dunkels <adam@sics.se>
+++ *
+++ */
+++
+++#ifndef __LWIPOPTS_H__
+++#define __LWIPOPTS_H__
+++
+++/*****************************************************************************
+++**                           CONFIGURATIONS
+++*****************************************************************************/
+++
+++/*
+++** The below macro should be defined for using lwIP with cache. For cache
+++** enabling, pbuf pool shall be cache line aligned. This is done by using
+++** separate pool for each memory. The alignment of pbuf pool to cache line
+++** size is done in /ports/cpsw/include/arch/cc.h.
+++*/
+++/*#define LWIP_CACHE_ENABLED*/
+++
+++#define SOC_CACHELINE_SIZE_BYTES        64            /* Number of bytes in
+++                                                         a cache line */
+++/*
+++** The timeout for DHCP completion. lwIP library will wait for DHCP
+++** completion for (LWIP_DHCP_TIMEOUT / 100) seconds.
+++*/
+++#define LWIP_DHCP_TIMEOUT               500
+++
+++/*
+++** The number of times DHCP is attempted. Each time, the library will wait
+++** for (LWIP_DHCP_TIMEOUT / 100) seconds for DHCP completion.
+++*/
+++#define NUM_DHCP_TRIES                  5
+++
+++#define LWIP_ETHERNET                   1
+++#define LWIP_ARP                        1
+++
+++/*****************************************************************************
+++**            lwIP SPECIFIC DEFINITIONS - To be used by lwIP stack
+++*****************************************************************************/
+++#define HOST_TMR_INTERVAL               0
+++#define DYNAMIC_HTTP_HEADERS
+++
+++/*****************************************************************************
+++**                    Platform specific locking
+++*****************************************************************************/
+++#define SYS_LIGHTWEIGHT_PROT            1
+++#define NO_SYS                          0
+++#define NO_SYS_NO_TIMERS                0
+++
+++/*****************************************************************************
+++**                          Memory Options
+++*****************************************************************************/
+++#define MEM_ALIGNMENT                   4
+++#define MEM_SIZE                        (256 * 1024) /* 128K */
+++
+++#define MEMP_NUM_PBUF                   96
+++#define MEMP_NUM_TCP_PCB                32
+++#define MEMP_NUM_TCP_SEG                32
+++#define PBUF_POOL_SIZE                  512
+++
+++#ifdef LWIP_CACHE_ENABLED
+++#define MEMP_SEPARATE_POOLS             1            /* We want the pbuf
+++                                                        pool cache line
+++                                                        aligned*/
+++#endif
+++
+++#define MEMP_NUM_SYS_TIMEOUT (LWIP_TCP + IP_REASSEMBLY + LWIP_ARP + (2*LWIP_DHCP) + LWIP_AUTOIP + LWIP_IGMP + LWIP_DNS + PPP_SUPPORT)
+++
+++/*****************************************************************************
+++**                           IP Options
+++*****************************************************************************/
+++#define IP_REASSEMBLY                   0
+++#define IP_FRAG                         0
+++
+++/*****************************************************************************
+++**                           DHCP Options
+++*****************************************************************************/
+++#define LWIP_DHCP                       1
+++#define DHCP_DOES_ARP_CHECK             0
+++
+++/*****************************************************************************
+++**                           Auto IP  Options
+++*****************************************************************************/
+++#define LWIP_AUTOIP                     1
+++#define LWIP_DHCP_AUTOIP_COOP           ((LWIP_DHCP) && (LWIP_AUTOIP))
+++
+++/*****************************************************************************
+++**                           TCP  Options
+++*****************************************************************************/
+++#define TCP_MSS                         1500
+++#define TCP_WND                         (8 * TCP_MSS)
+++#define TCP_SND_BUF                     (8 * TCP_MSS)
+++#define TCP_OVERSIZE                    TCP_MSS
+++
+++/*****************************************************************************
+++**                           PBUF  Options
+++*****************************************************************************/
+++#define PBUF_LINK_HLEN                  14
+++#define PBUF_POOL_BUFSIZE               1520         /* + size of struct pbuf
+++                                                        shall be cache line
+++                                                        aligned be enabled */
+++#define ETH_PAD_SIZE                    0
+++#define LWIP_NETCONN                    1
+++
+++/*****************************************************************************
+++**                           Socket  Options
+++*****************************************************************************/
+++#define LWIP_SOCKET                     1
+++
+++/*****************************************************************************
+++**                          Debugging options
+++*****************************************************************************/
+++#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_OFF
+++#define LWIP_DBG_TYPES_ON               (LWIP_DBG_ON | LWIP_DBG_TRACE \
+++                                         |LWIP_DBG_STATE | LWIP_DBG_FRESH)
+++#define DHCP_DEBUG                      LWIP_DBG_OFF
+++#define NETIF_DEBUG                     LWIP_DBG_OFF
+++#define IP_DEBUG			LWIP_DBG_OFF
+++#define UDP_DEBUG			LWIP_DBG_OFF
+++#define ETHARP_DEBUG                    LWIP_DBG_OFF
+++#define SYS_DEBUG                       LWIP_DBG_OFF
+++#define RAW_DEBUG                       LWIP_DBG_OFF
+++#define MEM_DEBUG                       LWIP_DBG_OFF
+++#define MEMP_DEBUG                      LWIP_DBG_OFF
+++#define PBUF_DEBUG			LWIP_DBG_OFF
+++#define TCPIP_DEBUG			LWIP_DBG_OFF
+++#define APP_DEBUG			LWIP_DBG_OFF
+++#define SOCKETS_DEBUG		        LWIP_DBG_OFF
+++#define LWIP_STATS                      0
+++#define LWIP_STATS_DISPLAY              0
+++#define LWIP_STATS_POSIX                0
+++
+++
+++
+++/**
+++ * LWIP_COMPAT_SOCKETS==1: Enable BSD-style sockets functions names.
+++ * (only used if you use sockets.c)
+++ */
+++#define LWIP_COMPAT_SOCKETS             0
+++
+++#define LWIP_TIMEVAL_PRIVATE            0
+++
+++ #define LWIP_RAW                       0
+++
+++#endif /* __LWIPOPTS_H__ */
++diff --git a/ports/sys_arch.c b/ports/sys_arch.c
++new file mode 100644
++index 0000000..360a4e2
++--- /dev/null
+++++ b/ports/sys_arch.c
++@@ -0,0 +1,663 @@
+++/*
+++ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
+++ * All rights reserved.
+++ *
+++ * Redistribution and use in source and binary forms, with or without modification,
+++ * are permitted provided that the following conditions are met:
+++ *
+++ * 1. Redistributions of source code must retain the above copyright notice,
+++ *    this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright notice,
+++ *    this list of conditions and the following disclaimer in the documentation
+++ *    and/or other materials provided with the distribution.
+++ * 3. The name of the author may not be used to endorse or promote products
+++ *    derived from this software without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+++ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+++ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+++ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+++ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+++ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+++ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+++ * OF SUCH DAMAGE.
+++ *
+++ * This file is part of the lwIP TCP/IP stack.
+++ *
+++ * Author: Adam Dunkels <adam@sics.se>
+++ *
+++ */
+++
+++/*
+++ * Wed Apr 17 16:05:29 EDT 2002 (James Roth)
+++ *
+++ *  - Fixed an unlikely sys_thread_new() race condition.
+++ *
+++ *  - Made current_thread() work with threads which where
+++ *    not created with sys_thread_new().  This includes
+++ *    the main thread and threads made with pthread_create().
+++ *
+++ *  - Catch overflows where more than SYS_MBOX_SIZE messages
+++ *    are waiting to be read.  The sys_mbox_post() routine
+++ *    will block until there is more room instead of just
+++ *    leaking messages.
+++ */
+++
+++#include <string.h>
+++#include <sys/time.h>
+++#include <sys/types.h>
+++#include <stdlib.h>
+++#include <unistd.h>
+++#include <pthread.h>
+++
+++#include "lwip/opt.h"
+++#include "lwip/sys.h"
+++#include "lwip/stats.h"
+++#include "lwip/debug.h"
+++
+++#define UMAX(a, b)      ((a) > (b) ? (a) : (b))
+++
+++static struct timeval starttime;
+++
+++#if !NO_SYS
+++
+++static struct sys_thread *threads = NULL;
+++static pthread_mutex_t threads_mutex = PTHREAD_MUTEX_INITIALIZER;
+++
+++struct sys_mbox_msg {
+++  struct sys_mbox_msg *next;
+++  void *msg;
+++};
+++
+++#define SYS_MBOX_SIZE 128
+++
+++struct sys_mbox {
+++  int first, last;
+++  void *msgs[SYS_MBOX_SIZE];
+++  struct sys_sem *not_empty;
+++  struct sys_sem *not_full;
+++  struct sys_sem *mutex;
+++  int wait_send;
+++};
+++
+++struct sys_sem {
+++  unsigned int c;
+++  pthread_cond_t cond;
+++  pthread_mutex_t mutex;
+++};
+++
+++struct sys_thread {
+++  struct sys_thread *next;
+++  pthread_t pthread;
+++};
+++
+++#if SYS_LIGHTWEIGHT_PROT
+++static pthread_mutex_t lwprot_mutex = PTHREAD_MUTEX_INITIALIZER;
+++static pthread_t lwprot_thread = (pthread_t)0xDEAD;
+++static int lwprot_count = 0;
+++#endif /* SYS_LIGHTWEIGHT_PROT */
+++
+++static struct sys_sem *sys_sem_new_internal(u8_t count);
+++static void sys_sem_free_internal(struct sys_sem *sem);
+++
+++static u32_t cond_wait(pthread_cond_t * cond, pthread_mutex_t * mutex,
+++                       u32_t timeout);
+++
+++/*-----------------------------------------------------------------------------------*/
+++static struct sys_thread *
+++introduce_thread(pthread_t id)
+++{
+++  struct sys_thread *thread = NULL;
+++
+++  thread = (struct sys_thread *)malloc(sizeof(struct sys_thread));
+++
+++  if (thread != NULL) {
+++    pthread_mutex_lock(&threads_mutex);
+++    thread->next = threads;
+++    thread->pthread = id;
+++    threads = thread;
+++    pthread_mutex_unlock(&threads_mutex);
+++  }
+++
+++  return thread;
+++}
+++/*-----------------------------------------------------------------------------------*/
+++sys_thread_t
+++sys_thread_new(const char *name, lwip_thread_fn function, void *arg, int stacksize, int prio)
+++{
+++  int code;
+++  int rc;
+++  pthread_t tmp;
+++  pthread_attr_t attr;
+++  struct sys_thread *st = NULL;
+++  LWIP_UNUSED_ARG(name);
+++  LWIP_UNUSED_ARG(stacksize);
+++  LWIP_UNUSED_ARG(prio);
+++
+++  /* Alloc a new pthread with the specified stack size. */
+++  if(stacksize > 0) {
+++    rc = pthread_attr_init(&attr);
+++    if (rc != 0) {
+++      LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: pthread_attr_init error = %d\n", rc));
+++      return NULL;
+++    }
+++    rc = pthread_attr_setstacksize(&attr, stacksize);
+++    if (rc != 0) {
+++      LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: pthread_attr_setstacksize error = %d\n", rc));
+++      pthread_attr_destroy(&attr);
+++      return NULL;
+++    }
+++    pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);
+++    pthread_attr_setschedpolicy(&attr, SCHED_RR);
+++    code = pthread_create(&tmp, &attr, (void *(*)(void *)) function, arg);
+++    pthread_attr_destroy(&attr);
+++  } else {
+++    code = pthread_create(&tmp, NULL, (void *(*)(void *)) function, arg);
+++  }
+++  LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: thread created [name:%s|stacksize:%d|prio:%d|addr:0x%x]\n",
+++                          name, stacksize, prio, (uint)tmp));
+++
+++  if (0 == code) {
+++    st = introduce_thread(tmp);
+++  }
+++
+++  if (NULL == st) {
+++    LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: failed to introduce %d, st = %p\n",
+++                            code, (void*)st));
+++    abort();
+++  } else {
+++    LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: introduced %d, st = %p\n",
+++                            code, (void*)st));
+++  }
+++
+++  return st;
+++}
+++/*-----------------------------------------------------------------------------------*/
+++void sys_thread_signal(sys_thread_t thread, int signal)
+++{
+++    /* Check received parameters. */
+++    if(thread == NULL) {
+++        LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_signal: could not send signal to thread. thread = NULL\n"));
+++        return;
+++    }
+++
+++    /* Send signal. */
+++    pthread_kill(thread->pthread, signal);
+++}
+++/*-----------------------------------------------------------------------------------*/
+++err_t
+++sys_mbox_new(struct sys_mbox **mb, int size)
+++{
+++  struct sys_mbox *mbox = NULL;
+++  LWIP_UNUSED_ARG(size);
+++
+++  mbox = (struct sys_mbox *)malloc(sizeof(struct sys_mbox));
+++  if (mbox == NULL) {
+++    SYS_STATS_INC(mbox.err);
+++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_new: could not create mbox\n"));
+++    return ERR_MEM;
+++  }
+++  mbox->first = mbox->last = 0;
+++  mbox->not_empty = sys_sem_new_internal(0);
+++  mbox->not_full = sys_sem_new_internal(0);
+++  mbox->mutex = sys_sem_new_internal(1);
+++  mbox->wait_send = 0;
+++
+++  SYS_STATS_INC_USED(mbox);
+++
+++  if((mbox->not_empty == NULL) || (mbox->not_full == NULL) || (mbox->mutex == NULL)) {
+++    SYS_STATS_INC(mbox.err);
+++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_new: could not create mbox internals\n"));
+++    sys_mbox_free(&mbox);
+++    return ERR_MEM;
+++  }
+++  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_new: mbox created [not_empty:%X|not_full:%X|mutex:%X] \n",
+++                          mbox->not_empty, mbox->not_full, mbox->mutex));
+++
+++  *mb = mbox;
+++  return ERR_OK;
+++}
+++/*-----------------------------------------------------------------------------------*/
+++void
+++sys_mbox_free(struct sys_mbox **mb)
+++{
+++  if ((mb != NULL) && (*mb != SYS_MBOX_NULL)) {
+++    struct sys_mbox *mbox = *mb;
+++    sys_arch_sem_wait(&mbox->mutex, 0);
+++
+++    sys_sem_free_internal(mbox->not_empty);
+++    sys_sem_free_internal(mbox->not_full);
+++    sys_sem_free_internal(mbox->mutex);
+++    mbox->not_empty = mbox->not_full = mbox->mutex = NULL;
+++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_free: mbox 0x%lx\n", mbox));
+++    free(mbox);
+++    SYS_STATS_DEC(mbox.used);
+++  }
+++}
+++/*-----------------------------------------------------------------------------------*/
+++err_t
+++sys_mbox_trypost(struct sys_mbox **mb, void *msg)
+++{
+++  u8_t first;
+++  struct sys_mbox *mbox;
+++  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
+++  mbox = *mb;
+++  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_trypost: start"));
+++  sys_arch_sem_wait(&mbox->mutex, 0);
+++
+++  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_trypost: mbox %p msg %p\n",
+++                          (void *)mbox, (void *)msg));
+++
+++  if ((mbox->last + 1) >= (mbox->first + SYS_MBOX_SIZE)) {
+++    sys_sem_signal(&mbox->mutex);
+++    return ERR_MEM;
+++  }
+++
+++  mbox->msgs[mbox->last % SYS_MBOX_SIZE] = msg;
+++
+++  if (mbox->last == mbox->first) {
+++    first = 1;
+++  } else {
+++    first = 0;
+++  }
+++
+++  mbox->last++;
+++
+++  if (first) {
+++    sys_sem_signal(&mbox->not_empty);
+++  }
+++
+++  sys_sem_signal(&mbox->mutex);
+++
+++  return ERR_OK;
+++}
+++/*-----------------------------------------------------------------------------------*/
+++void
+++sys_mbox_post(struct sys_mbox **mb, void *msg)
+++{
+++  u8_t first;
+++  struct sys_mbox *mbox;
+++  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
+++  mbox = *mb;
+++
+++  sys_arch_sem_wait(&mbox->mutex, 0);
+++
+++  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_post: mbox %p msg %p\n", (void *)mbox, (void *)msg));
+++
+++  while ((mbox->last + 1) >= (mbox->first + SYS_MBOX_SIZE)) {
+++    mbox->wait_send++;
+++    sys_sem_signal(&mbox->mutex);
+++    sys_arch_sem_wait(&mbox->not_full, 0);
+++    sys_arch_sem_wait(&mbox->mutex, 0);
+++    mbox->wait_send--;
+++  }
+++
+++  mbox->msgs[mbox->last % SYS_MBOX_SIZE] = msg;
+++
+++  if (mbox->last == mbox->first) {
+++    first = 1;
+++  } else {
+++    first = 0;
+++  }
+++
+++  mbox->last++;
+++
+++  if (first) {
+++    sys_sem_signal(&mbox->not_empty);
+++  }
+++
+++  sys_sem_signal(&mbox->mutex);
+++}
+++/*-----------------------------------------------------------------------------------*/
+++u32_t
+++sys_arch_mbox_tryfetch(struct sys_mbox **mb, void **msg)
+++{
+++  struct sys_mbox *mbox;
+++  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
+++  mbox = *mb;
+++
+++  sys_arch_sem_wait(&mbox->mutex, 0);
+++
+++  if (mbox->first == mbox->last) {
+++    sys_sem_signal(&mbox->mutex);
+++    return SYS_MBOX_EMPTY;
+++  }
+++
+++  if (msg != NULL) {
+++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_tryfetch: mbox %p msg %p\n", (void *)mbox, *msg));
+++    *msg = mbox->msgs[mbox->first % SYS_MBOX_SIZE];
+++  }
+++  else{
+++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_tryfetch: mbox %p, null msg\n", (void *)mbox));
+++  }
+++
+++  mbox->first++;
+++
+++  if (mbox->wait_send) {
+++    sys_sem_signal(&mbox->not_full);
+++  }
+++
+++  sys_sem_signal(&mbox->mutex);
+++
+++  return 0;
+++}
+++/*-----------------------------------------------------------------------------------*/
+++u32_t
+++sys_arch_mbox_fetch(struct sys_mbox **mb, void **msg, u32_t timeout)
+++{
+++  u32_t time_needed = 0;
+++  struct sys_mbox *mbox;
+++  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
+++  mbox = *mb;
+++
+++  /* The mutex lock is quick so we don't bother with the timeout
+++     stuff here. */
+++  sys_arch_sem_wait(&mbox->mutex, 0);
+++
+++  while (mbox->first == mbox->last) {
+++    sys_sem_signal(&mbox->mutex);
+++
+++    /* We block while waiting for a mail to arrive in the mailbox. We
+++       must be prepared to timeout. */
+++    if (timeout != 0) {
+++      time_needed = sys_arch_sem_wait(&mbox->not_empty, timeout);
+++
+++      if (time_needed == SYS_ARCH_TIMEOUT) {
+++        return SYS_ARCH_TIMEOUT;
+++      }
+++    } else {
+++      sys_arch_sem_wait(&mbox->not_empty, 0);
+++    }
+++
+++    sys_arch_sem_wait(&mbox->mutex, 0);
+++  }
+++
+++  if (msg != NULL) {
+++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_fetch: mbox %p msg %p\n", (void *)mbox, *msg));
+++    *msg = mbox->msgs[mbox->first % SYS_MBOX_SIZE];
+++  }
+++  else{
+++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_fetch: mbox %p, null msg\n", (void *)mbox));
+++  }
+++
+++  mbox->first++;
+++
+++  if (mbox->wait_send) {
+++    sys_sem_signal(&mbox->not_full);
+++  }
+++
+++  sys_sem_signal(&mbox->mutex);
+++
+++  return time_needed;
+++}
+++/*-----------------------------------------------------------------------------------*/
+++static struct sys_sem *
+++sys_sem_new_internal(u8_t count)
+++{
+++  struct sys_sem *sem = NULL;
+++  int rc;
+++
+++  sem = (struct sys_sem *)malloc(sizeof(struct sys_sem));
+++  if (sem != NULL) {
+++    sem->c = count;
+++    rc = pthread_cond_init(&(sem->cond), NULL);
+++    if(rc != 0) {
+++      LWIP_DEBUGF(SYS_DEBUG, ("sys_sem_new_internal: pthread_cond_init error = %d\n", rc));
+++      return NULL;
+++    }
+++    rc = pthread_mutex_init(&(sem->mutex), NULL);
+++    if(rc != 0) {
+++      LWIP_DEBUGF(SYS_DEBUG, ("sys_sem_new_internal: pthread_mutex_init error = %d\n", rc));
+++      SYS_STATS_INC(mutex.err);
+++      pthread_cond_destroy(&(sem->cond));
+++      return NULL;
+++    }
+++    SYS_STATS_INC_USED(mutex);
+++    SYS_STATS_INC_USED(sem);
+++  } else {
+++    LWIP_DEBUGF(SYS_DEBUG, ("sys_sem_new_internal: could not create semaphore\n"));
+++    SYS_STATS_INC(sem.err);
+++  }
+++  return sem;
+++}
+++/*-----------------------------------------------------------------------------------*/
+++err_t
+++sys_sem_new(struct sys_sem **sem, u8_t count)
+++{
+++  *sem = sys_sem_new_internal(count);
+++  if (*sem == NULL) {
+++    return ERR_MEM;
+++  }
+++  return ERR_OK;
+++}
+++/*-----------------------------------------------------------------------------------*/
+++static u32_t
+++cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex, u32_t timeout)
+++{
+++  time_t tdiff;
+++  time_t sec, usec;
+++  struct timeval rtime1, rtime2;
+++  struct timespec ts;
+++  int retval;
+++
+++  if (timeout > 0) {
+++    /* Get a timestamp and add the timeout value. */
+++    gettimeofday(&rtime1, NULL);
+++    sec = rtime1.tv_sec;
+++    usec = rtime1.tv_usec;
+++    usec += timeout % 1000 * 1000;
+++    sec += (int)(timeout / 1000) + (int)(usec / 1000000);
+++    usec = usec % 1000000;
+++    ts.tv_nsec = usec * 1000;
+++    ts.tv_sec = sec;
+++
+++    retval = pthread_cond_timedwait(cond, mutex, &ts);
+++
+++    if (retval == ETIMEDOUT) {
+++      return SYS_ARCH_TIMEOUT;
+++    } else {
+++      /* Calculate for how long we waited for the cond. */
+++      gettimeofday(&rtime2, NULL);
+++      tdiff = (rtime2.tv_sec - rtime1.tv_sec) * 1000 +
+++        (rtime2.tv_usec - rtime1.tv_usec) / 1000;
+++
+++      if (tdiff <= 0) {
+++        return 0;
+++      }
+++      return (u32_t)tdiff;
+++    }
+++  } else {
+++    pthread_cond_wait(cond, mutex);
+++    return 0;
+++  }
+++}
+++/*-----------------------------------------------------------------------------------*/
+++u32_t
+++sys_arch_sem_wait(struct sys_sem **s, u32_t timeout)
+++{
+++  u32_t time_needed = 0;
+++  struct sys_sem *sem;
+++  LWIP_ASSERT("invalid sem", (s != NULL) && (*s != NULL));
+++  sem = *s;
+++
+++  pthread_mutex_lock(&(sem->mutex));
+++  while (sem->c <= 0) {
+++    if (timeout > 0) {
+++      time_needed = cond_wait(&(sem->cond), &(sem->mutex), timeout);
+++
+++      if (time_needed == SYS_ARCH_TIMEOUT) {
+++        pthread_mutex_unlock(&(sem->mutex));
+++        return SYS_ARCH_TIMEOUT;
+++      }
+++    } else {
+++      cond_wait(&(sem->cond), &(sem->mutex), 0);
+++    }
+++  }
+++  sem->c--;
+++  pthread_mutex_unlock(&(sem->mutex));
+++  return (u32_t)time_needed;
+++}
+++/*-----------------------------------------------------------------------------------*/
+++void
+++sys_sem_signal(struct sys_sem **s)
+++{
+++  struct sys_sem *sem;
+++  LWIP_ASSERT("invalid sem", (s != NULL) && (*s != NULL));
+++  sem = *s;
+++
+++  pthread_mutex_lock(&(sem->mutex));
+++  sem->c++;
+++
+++  if (sem->c > 1) {
+++    sem->c = 1;
+++  }
+++
+++  pthread_cond_broadcast(&(sem->cond));
+++  pthread_mutex_unlock(&(sem->mutex));
+++}
+++/*-----------------------------------------------------------------------------------*/
+++static void
+++sys_sem_free_internal(struct sys_sem *sem)
+++{
+++  if(sem != NULL) {
+++    pthread_cond_destroy(&(sem->cond));
+++    pthread_mutex_destroy(&(sem->mutex));
+++    SYS_STATS_DEC(mutex.used);
+++    SYS_STATS_DEC(sem.used);
+++    free(sem);
+++  }
+++}
+++/*-----------------------------------------------------------------------------------*/
+++void
+++sys_sem_free(struct sys_sem **sem)
+++{
+++  if ((sem != NULL) && (*sem != SYS_SEM_NULL)) {
+++    sys_sem_free_internal(*sem);
+++  }
+++}
+++#endif /* !NO_SYS */
+++/*-----------------------------------------------------------------------------------*/
+++u32_t
+++sys_now(void)
+++{
+++  struct timeval tv;
+++  u32_t sec, usec, msec;
+++  gettimeofday(&tv, NULL);
+++
+++  sec = (u32_t)(tv.tv_sec - starttime.tv_sec);
+++  usec = (u32_t)(tv.tv_usec - starttime.tv_usec);
+++  msec = sec * 1000 + usec / 1000;
+++
+++  return msec;
+++}
+++/*-----------------------------------------------------------------------------------*/
+++void
+++sys_init(void)
+++{
+++  SYS_STATS_INC_USED(mutex);
+++  gettimeofday(&starttime, NULL);
+++}
+++/*-----------------------------------------------------------------------------------*/
+++#if SYS_LIGHTWEIGHT_PROT
+++/** sys_prot_t sys_arch_protect(void)
+++
+++This optional function does a "fast" critical region protection and returns
+++the previous protection level. This function is only called during very short
+++critical regions. An embedded system which supports ISR-based drivers might
+++want to implement this function by disabling interrupts. Task-based systems
+++might want to implement this by using a mutex or disabling tasking. This
+++function should support recursive calls from the same task or interrupt. In
+++other words, sys_arch_protect() could be called while already protected. In
+++that case the return value indicates that it is already protected.
+++
+++sys_arch_protect() is only required if your port is supporting an operating
+++system.
+++*/
+++sys_prot_t
+++sys_arch_protect(void)
+++{
+++    /* Note that for the UNIX port, we are using a lightweight mutex, and our
+++     * own counter (which is locked by the mutex). The return code is not actually
+++     * used. */
+++    if (lwprot_thread != pthread_self())
+++    {
+++        /* We are locking the mutex where it has not been locked before *
+++        * or is being locked by another thread */
+++        pthread_mutex_lock(&lwprot_mutex);
+++        lwprot_thread = pthread_self();
+++        lwprot_count = 1;
+++    }
+++    else
+++    {
+++        /* It is already locked by THIS thread */
+++        lwprot_count++;
+++    }
+++    return 0;
+++}
+++/*-----------------------------------------------------------------------------------*/
+++/** void sys_arch_unprotect(sys_prot_t pval)
+++
+++This optional function does a "fast" set of critical region protection to the
+++value specified by pval. See the documentation for sys_arch_protect() for
+++more information. This function is only required if your port is supporting
+++an operating system.
+++*/
+++void
+++sys_arch_unprotect(sys_prot_t pval)
+++{
+++    LWIP_UNUSED_ARG(pval);
+++    if (lwprot_thread == pthread_self())
+++    {
+++        if (--lwprot_count == 0)
+++        {
+++            lwprot_thread = (pthread_t) 0xDEAD;
+++            pthread_mutex_unlock(&lwprot_mutex);
+++        }
+++    }
+++}
+++#endif /* SYS_LIGHTWEIGHT_PROT */
+++
+++/*-----------------------------------------------------------------------------------*/
+++
+++#ifndef MAX_JIFFY_OFFSET
+++#define MAX_JIFFY_OFFSET ((~0U >> 1)-1)
+++#endif
+++
+++#ifndef HZ
+++#define HZ 100
+++#endif
+++
+++u32_t
+++sys_jiffies(void)
+++{
+++    struct timeval tv;
+++    unsigned long sec;
+++    long usec;
+++
+++    gettimeofday(&tv,NULL);
+++    sec = tv.tv_sec - starttime.tv_sec;
+++    usec = tv.tv_usec;
+++
+++    if (sec >= (MAX_JIFFY_OFFSET / HZ))
+++      return MAX_JIFFY_OFFSET;
+++    usec += 1000000L / HZ - 1;
+++    usec /= 1000000L / HZ;
+++    return HZ * sec + usec;
+++}
+++
+++#if PPP_DEBUG
+++
+++#include <stdarg.h>
+++
+++void ppp_trace(int level, const char *format, ...)
+++{
+++    va_list args;
+++
+++    (void)level;
+++    va_start(args, format);
+++    vprintf(format, args);
+++    va_end(args);
+++}
+++#endif
++-- 
++1.9.1
++
++
++From d053fa836b445b6736bf82d33a33a59055150aa7 Mon Sep 17 00:00:00 2001
++From: Jay Doyle <jay.doyle@vecna.com>
++Date: Fri, 4 Sep 2015 17:30:37 -0400
++Subject: [PATCH 02/13] changed the compiler options
++
++---
++ Makefile | 2 +-
++ 1 file changed, 1 insertion(+), 1 deletion(-)
++
++diff --git a/Makefile b/Makefile
++index 0cbae64..94fcafc 100644
++--- a/Makefile
+++++ b/Makefile
++@@ -5,7 +5,7 @@ include $(PROJECT_ROOT)/make/leaf.cfg
++ #### CONFIG ####################################################################
++ #For debugging symbols add -DLWIP_DEBUG
++ # COMPILER/LINKER
++-CFLAGS+=-g -O2   \
+++CFLAGS+=-g -O0   \
++  -Wall
++ 
++ # OUTPUT
++-- 
++1.9.1
++
++
++From 841adb17430bdb9298dcb6d44ac5dad72e82af80 Mon Sep 17 00:00:00 2001
++From: Jay Doyle <jay.doyle@vecna.com>
++Date: Mon, 7 Sep 2015 08:56:58 -0400
++Subject: [PATCH 03/13] disabled any mention of ipv6
++
++---
++ Makefile | 6 +++---
++ 1 file changed, 3 insertions(+), 3 deletions(-)
++
++diff --git a/Makefile b/Makefile
++index 94fcafc..6efa141 100644
++--- a/Makefile
+++++ b/Makefile
++@@ -40,7 +40,7 @@ CORE_SRC=$(wildcard $(LWIP_CORE_PATH)/*.c)
++ IPV4_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv4/*.c)
++ 
++ ## IPv6
++-IPV6_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv6/*.c)
+++#IPV6_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv6/*.c)
++ 
++ ## SNMP
++ SNMP_SRC=$(wildcard $(LWIP_CORE_PATH)/snmp/*.c)
++@@ -71,7 +71,7 @@ SOURCES =  $(DRIVER_SRC) $(SNMP_SRC)\
++ CORE_H=$(LWIP_INCL_PATH)
++ 
++ ## IPv4
++-#IPV4_H=$(LWIP_INCL_PATH)/ipv4
+++IPV4_H=$(LWIP_INCL_PATH)/ipv4
++ 
++ ## IPv6
++ #IPV6_H=$(LWIP_INCL_PATH)/ipv6
++@@ -97,7 +97,7 @@ DRIVER_H=$(LWIPDRIVER_INCL_PATH)
++ # HEADERS
++ HEADERS=-I$(CORE_H) -I$(POSIX_H) -I$(POSIX_SYS_H) -I$(NETIF_H) \
++         -I$(NETIF_H_PPP) -I$(NETIF_H_PPP_POLARSSL) -I$(ARCH_H) \
++-        -I$(DRIVER_H)
+++        -I$(DRIVER_H) -I$(IPV4_H)
++ 
++ 
++ ################################################################################
++-- 
++1.9.1
++
++
++From a653d818348fef0130e6e497eecb0c3a35822df4 Mon Sep 17 00:00:00 2001
++From: Jay Doyle <jay.doyle@vecna.com>
++Date: Mon, 7 Sep 2015 09:27:48 -0400
++Subject: [PATCH 04/13] added in stm32f low-level driver
++
++---
++ src/netif/ethernetif.c | 709 ++++++++++++++++++++++++++++++-------------------
++ 1 file changed, 435 insertions(+), 274 deletions(-)
++
++diff --git a/src/netif/ethernetif.c b/src/netif/ethernetif.c
++index 7982d11..82c85ae 100644
++--- a/src/netif/ethernetif.c
+++++ b/src/netif/ethernetif.c
++@@ -1,335 +1,496 @@
++ /**
++- * @file
++- * Ethernet Interface Skeleton
++- *
++- */
++-
++-/*
++- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
++- * All rights reserved. 
++- * 
++- * Redistribution and use in source and binary forms, with or without modification, 
++- * are permitted provided that the following conditions are met:
++- *
++- * 1. Redistributions of source code must retain the above copyright notice,
++- *    this list of conditions and the following disclaimer.
++- * 2. Redistributions in binary form must reproduce the above copyright notice,
++- *    this list of conditions and the following disclaimer in the documentation
++- *    and/or other materials provided with the distribution.
++- * 3. The name of the author may not be used to endorse or promote products
++- *    derived from this software without specific prior written permission. 
++- *
++- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
++- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
++- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
++- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
++- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
++- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
++- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
++- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
++- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
++- * OF SUCH DAMAGE.
++- *
++- * This file is part of the lwIP TCP/IP stack.
++- * 
++- * Author: Adam Dunkels <adam@sics.se>
++- *
++- */
++-
++-/*
++- * This file is a skeleton for developing Ethernet network interface
++- * drivers for lwIP. Add code to the low_level functions and do a
++- * search-and-replace for the word "ethernetif" to replace it with
++- * something that better describes your network interface.
++- */
++-
+++  ******************************************************************************
+++  * @file    LwIP/LwIP_HTTP_Server_Netconn_RTOS/Src/ethernetif.c
+++  * @author  MCD Application Team
+++  * @version V1.0.0
+++  * @date    25-June-2015
+++  * @brief   This file implements Ethernet network interface drivers for lwIP
+++  ******************************************************************************
+++  * @attention
+++  *
+++  * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
+++  *
+++  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+++  * You may not use this file except in compliance with the License.
+++  * You may obtain a copy of the License at:
+++  *
+++  *        http://www.st.com/software_license_agreement_liberty_v2
+++  *
+++  * Unless required by applicable law or agreed to in writing, software 
+++  * distributed under the License is distributed on an "AS IS" BASIS, 
+++  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+++  * See the License for the specific language governing permissions and
+++  * limitations under the License.
+++  *
+++  ******************************************************************************
+++  */
+++
+++/* Includes ------------------------------------------------------------------*/
+++#include "stm32f7xx_hal.h"
++ #include "lwip/opt.h"
++-
++-#if 0 /* don't build, this is only a skeleton, see previous comment */
++-
++-#include "lwip/def.h"
++-#include "lwip/mem.h"
++-#include "lwip/pbuf.h"
++-#include "lwip/stats.h"
++-#include "lwip/snmp.h"
++-#include "lwip/ethip6.h"
+++#include "lwip/lwip_timers.h"
++ #include "netif/etharp.h"
++-#include "netif/ppp/pppoe.h"
+++#include "hal-ethernetif.h"
+++#include <string.h>
+++
+++/* Private typedef -----------------------------------------------------------*/
+++/* Private define ------------------------------------------------------------*/
+++/* The time to block waiting for input. */
+++#define TIME_WAITING_FOR_INPUT                 ( 100 )
+++/* Stack size of the interface thread */
+++#define INTERFACE_THREAD_STACK_SIZE            ( 350 )
++ 
++ /* Define those to better describe your network interface. */
++ #define IFNAME0 'e'
++ #define IFNAME1 'n'
++ 
++-/**
++- * Helper struct to hold private data used to operate your ethernet interface.
++- * Keeping the ethernet address of the MAC in this struct is not necessary
++- * as it is already kept in the struct netif.
++- * But this is only an example, anyway...
++- */
++-struct ethernetif {
++-  struct eth_addr *ethaddr;
++-  /* Add whatever per-interface state that is needed here. */
++-};
++-
++-/* Forward declarations. */
++-static void  ethernetif_input(struct netif *netif);
+++#define LAN8742A_PHY_ADDRESS            0x00
++ 
++-/**
++- * In this function, the hardware should be initialized.
++- * Called from ethernetif_init().
++- *
++- * @param netif the already initialized lwip network interface structure
++- *        for this ethernetif
++- */
++-static void
++-low_level_init(struct netif *netif)
++-{
++-  struct ethernetif *ethernetif = netif->state;
++-  
++-  /* set MAC hardware address length */
++-  netif->hwaddr_len = ETHARP_HWADDR_LEN;
+++/* Private macro -------------------------------------------------------------*/
+++/* Private variables ---------------------------------------------------------*/
++ 
++-  /* set MAC hardware address */
++-  netif->hwaddr[0] = ;
++-  ...
++-  netif->hwaddr[5] = ;
+++#if defined ( __ICCARM__ ) /*!< IAR Compiler */
++ 
++-  /* maximum transfer unit */
++-  netif->mtu = 1500;
++-  
++-  /* device capabilities */
++-  /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
++-  netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
++- 
++-#if LWIP_IPV6 && LWIP_IPV6_MLD
++-  /*
++-   * For hardware/netifs that implement MAC filtering.
++-   * All-nodes link-local is handled by default, so we must let the hardware know
++-   * to allow multicast packets in.
++-   * Should set mld_mac_filter previously. */
++-  if (netif->mld_mac_filter != NULL) {
++-    ip6_addr_t ip6_allnodes_ll;
++-    ip6_addr_set_allnodes_linklocal(&ip6_allnodes_ll);
++-    netif->mld_mac_filter(netif, &ip6_allnodes_ll, MLD6_ADD_MAC_FILTER);
++-  }
++-#endif /* LWIP_IPV6 && LWIP_IPV6_MLD */
+++#pragma location=0x2000E000
+++__no_init ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
+++#pragma location=0x2000E100
+++__no_init ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
+++#elif defined ( __CC_ARM   )
+++ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((at(0x2000E000)));/* Ethernet Rx MA Descriptor */
+++ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((at(0x2000E100)));/* Ethernet Tx DMA Descriptor */
+++#elif defined ( __GNUC__   )
+++//ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".RxDescripSection")));/* Ethernet Rx MA Descriptor */
+++//ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".TxDescripSection")));/* Ethernet Tx DMA Descriptor */
+++ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Rx MA Descriptor */
+++ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Tx DMA Descriptor */
+++
+++
+++#endif
+++#if defined ( __ICCARM__ ) /*!< IAR Compiler */
+++#pragma location=0x2000E200
+++__no_init uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
+++#pragma location=0x2000FFC4
+++__no_init uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
+++#elif defined ( __CC_ARM   )
+++uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((at(0x2000E200)));  /* Ethernet Receive Buffer */
+++uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]  __attribute__((at(0x2000FFC4))); /* Ethernet Transmit Buffer */
+++#elif defined ( __GNUC__   )
+++//uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".RxBUF")));/* Ethernet Receive Buffer */
+++//uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".TxBUF")));/* Ethernet Transmit Buffer */
+++uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Receive Buffer */
+++uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Transmit Buffer */
+++
+++#endif
+++/* Semaphore to signal incoming packets */
+++osSemaphoreId s_xSemaphore = NULL;
++ 
++-  /* Do whatever else is needed to initialize interface. */  
+++/* Global Ethernet handle*/
+++ETH_HandleTypeDef EthHandle;
+++
+++/* Private function prototypes -----------------------------------------------*/
+++static void ethernetif_input( void const * argument );
+++
+++static void stm32f_ethernet_isr(
+++  void* argData
+++)
+++{
+++  ETH_HandleTypeDef* pEth =
+++    (ETH_HandleTypeDef*) argData;
+++
+++  HAL_ETH_IRQHandler(pEth);
++ }
++ 
+++/* Private functions ---------------------------------------------------------*/
+++/*******************************************************************************
+++                       Ethernet MSP Routines
+++*******************************************************************************/
++ /**
++- * This function should do the actual transmission of the packet. The packet is
++- * contained in the pbuf that is passed to the function. This pbuf
++- * might be chained.
++- *
++- * @param netif the lwip network interface structure for this ethernetif
++- * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
++- * @return ERR_OK if the packet could be sent
++- *         an err_t value if the packet couldn't be sent
++- *
++- * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
++- *       strange results. You might consider waiting for space in the DMA queue
++- *       to become available since the stack doesn't retry to send a packet
++- *       dropped because of memory failure (except for the TCP timers).
++- */
++-
++-static err_t
++-low_level_output(struct netif *netif, struct pbuf *p)
+++  * @brief  Initializes the ETH MSP.
+++  * @param  heth: ETH handle
+++  * @retval None
+++  */
+++void HAL_ETH_MspInit(ETH_HandleTypeDef *heth)
++ {
++-  struct ethernetif *ethernetif = netif->state;
++-  struct pbuf *q;
++-
++-  initiate transfer();
+++  GPIO_InitTypeDef GPIO_InitStructure;
++   
++-#if ETH_PAD_SIZE
++-  pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
++-#endif
++-
++-  for(q = p; q != NULL; q = q->next) {
++-    /* Send the data from the pbuf to the interface, one pbuf at a
++-       time. The size of the data in each pbuf is kept in the ->len
++-       variable. */
++-    send data from(q->payload, q->len);
++-  }
+++  /* Enable GPIOs clocks */
+++  __HAL_RCC_GPIOA_CLK_ENABLE();
+++  __HAL_RCC_GPIOC_CLK_ENABLE();
+++  __HAL_RCC_GPIOG_CLK_ENABLE();
++ 
++-  signal that packet should be sent();
+++/* Ethernet pins configuration ************************************************/
+++  /*
+++        RMII_REF_CLK ----------------------> PA1
+++        RMII_MDIO -------------------------> PA2
+++        RMII_MDC --------------------------> PC1
+++        RMII_MII_CRS_DV -------------------> PA7
+++        RMII_MII_RXD0 ---------------------> PC4
+++        RMII_MII_RXD1 ---------------------> PC5
+++        RMII_MII_RXER ---------------------> PG2
+++        RMII_MII_TX_EN --------------------> PG11
+++        RMII_MII_TXD0 ---------------------> PG13
+++        RMII_MII_TXD1 ---------------------> PG14
+++  */
+++
+++  /* Configure PA1, PA2 and PA7 */
+++  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
+++  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
+++  GPIO_InitStructure.Pull = GPIO_NOPULL; 
+++  GPIO_InitStructure.Alternate = GPIO_AF11_ETH;
+++  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
+++  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
+++  
+++  /* Configure PC1, PC4 and PC5 */
+++  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;
+++  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
++ 
++-#if ETH_PAD_SIZE
++-  pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
++-#endif
+++  /* Configure PG2, PG11, PG13 and PG14 */
+++  GPIO_InitStructure.Pin =  GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14;
+++  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
++   
++-  LINK_STATS_INC(link.xmit);
+++  // Install HAL Ethernet ISR
+++  rtems_interrupt_handler_install(
+++    ETH_IRQn,
+++    NULL,
+++    0,
+++    stm32f_ethernet_isr,
+++    heth);
+++  
+++  /* Enable ETHERNET clock  */
+++  __HAL_RCC_ETH_CLK_ENABLE();
+++}
++ 
++-  return ERR_OK;
+++/**
+++  * @brief  Ethernet Rx Transfer completed callback
+++  * @param  heth: ETH handle
+++  * @retval None
+++  */
+++void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
+++{
+++  osSemaphoreRelease(s_xSemaphore);
++ }
++ 
++ /**
++- * Should allocate a pbuf and transfer the bytes of the incoming
++- * packet from the interface into the pbuf.
++- *
++- * @param netif the lwip network interface structure for this ethernetif
++- * @return a pbuf filled with the received packet (including MAC header)
++- *         NULL on memory error
++- */
++-static struct pbuf *
++-low_level_input(struct netif *netif)
+++  * @brief  Ethernet IRQ Handler
+++  * @param  None
+++  * @retval None
+++  */
+++void ETHERNET_IRQHandler(void)
++ {
++-  struct ethernetif *ethernetif = netif->state;
++-  struct pbuf *p, *q;
++-  u16_t len;
+++  HAL_ETH_IRQHandler(&EthHandle);
+++}
++ 
++-  /* Obtain the size of the packet and put it into the "len"
++-     variable. */
++-  len = ;
+++/*******************************************************************************
+++                       LL Driver Interface ( LwIP stack --> ETH) 
+++*******************************************************************************/
+++/**
+++  * @brief In this function, the hardware should be initialized.
+++  * Called from ethernetif_init().
+++  *
+++  * @param netif the already initialized lwip network interface structure
+++  *        for this ethernetif
+++  */
+++static void low_level_init(struct netif *netif)
+++{
+++  uint8_t macaddress[6]= { MAC_ADDR0, MAC_ADDR1, MAC_ADDR2, MAC_ADDR3, MAC_ADDR4, MAC_ADDR5 };
+++  
+++  EthHandle.Instance = ETH;  
+++  EthHandle.Init.MACAddr = macaddress;
+++  EthHandle.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
+++  EthHandle.Init.Speed = ETH_SPEED_100M;
+++  EthHandle.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
+++  EthHandle.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
+++  EthHandle.Init.RxMode = ETH_RXINTERRUPT_MODE;
+++  EthHandle.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
+++  EthHandle.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
+++  
+++  /* configure ethernet peripheral (GPIOs, clocks, MAC, DMA) */
+++  if (HAL_ETH_Init(&EthHandle) == HAL_OK)
+++  {
+++    /* Set netif link flag */
+++    netif->flags |= NETIF_FLAG_LINK_UP;
+++  }
+++  
+++  /* Initialize Tx Descriptors list: Chain Mode */
+++  HAL_ETH_DMATxDescListInit(&EthHandle, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
+++     
+++  /* Initialize Rx Descriptors list: Chain Mode  */
+++  HAL_ETH_DMARxDescListInit(&EthHandle, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
+++  
+++  /* set netif MAC hardware address length */
+++  netif->hwaddr_len = ETHARP_HWADDR_LEN;
++ 
++-#if ETH_PAD_SIZE
++-  len += ETH_PAD_SIZE; /* allow room for Ethernet padding */
++-#endif
+++  /* set netif MAC hardware address */
+++  netif->hwaddr[0] =  MAC_ADDR0;
+++  netif->hwaddr[1] =  MAC_ADDR1;
+++  netif->hwaddr[2] =  MAC_ADDR2;
+++  netif->hwaddr[3] =  MAC_ADDR3;
+++  netif->hwaddr[4] =  MAC_ADDR4;
+++  netif->hwaddr[5] =  MAC_ADDR5;
++ 
++-  /* We allocate a pbuf chain of pbufs from the pool. */
++-  p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
++-  
++-  if (p != NULL) {
+++  /* set netif maximum transfer unit */
+++  netif->mtu = 1500;
++ 
++-#if ETH_PAD_SIZE
++-    pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
++-#endif
+++  /* Accept broadcast address and ARP traffic */
+++  netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
++ 
++-    /* We iterate over the pbuf chain until we have read the entire
++-     * packet into the pbuf. */
++-    for(q = p; q != NULL; q = q->next) {
++-      /* Read enough bytes to fill this pbuf in the chain. The
++-       * available data in the pbuf is given by the q->len
++-       * variable.
++-       * This does not necessarily have to be a memcpy, you can also preallocate
++-       * pbufs for a DMA-enabled MAC and after receiving truncate it to the
++-       * actually received size. In this case, ensure the tot_len member of the
++-       * pbuf is the sum of the chained pbuf len members.
++-       */
++-      read data into(q->payload, q->len);
++-    }
++-    acknowledge that packet has been read();
+++  /* create a binary semaphore used for informing ethernetif of frame reception */
+++  osSemaphoreDef(SEM);
+++  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1 );
+++
+++  /* create the task that handles the ETH_MAC */
+++  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
+++  osThreadCreate (osThread(EthIf), netif);
+++
+++  /* Enable MAC and DMA transmission and reception */
+++  HAL_ETH_Start(&EthHandle);
+++}
++ 
++-#if ETH_PAD_SIZE
++-    pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
++-#endif
++ 
++-    LINK_STATS_INC(link.recv);
++-  } else {
++-    drop packet();
++-    LINK_STATS_INC(link.memerr);
++-    LINK_STATS_INC(link.drop);
+++/**
+++  * @brief This function should do the actual transmission of the packet. The packet is
+++  * contained in the pbuf that is passed to the function. This pbuf
+++  * might be chained.
+++  *
+++  * @param netif the lwip network interface structure for this ethernetif
+++  * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
+++  * @return ERR_OK if the packet could be sent
+++  *         an err_t value if the packet couldn't be sent
+++  *
+++  * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
+++  *       strange results. You might consider waiting for space in the DMA queue
+++  *       to become available since the stack doesn't retry to send a packet
+++  *       dropped because of memory failure (except for the TCP timers).
+++  */
+++static err_t low_level_output(struct netif *netif, struct pbuf *p)
+++{
+++  err_t errval;
+++  struct pbuf *q;
+++  uint8_t *buffer = (uint8_t *)(EthHandle.TxDesc->Buffer1Addr);
+++  __IO ETH_DMADescTypeDef *DmaTxDesc;
+++  uint32_t framelength = 0;
+++  uint32_t bufferoffset = 0;
+++  uint32_t byteslefttocopy = 0;
+++  uint32_t payloadoffset = 0;
+++
+++  DmaTxDesc = EthHandle.TxDesc;
+++  bufferoffset = 0;
+++  
+++  /* copy frame from pbufs to driver buffers */
+++  for(q = p; q != NULL; q = q->next)
+++  {
+++    /* Is this buffer available? If not, goto error */
+++    if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
+++    {
+++      errval = ERR_USE;
+++      goto error;
+++    }
+++    
+++    /* Get bytes in current lwIP buffer */
+++    byteslefttocopy = q->len;
+++    payloadoffset = 0;
+++    
+++    /* Check if the length of data to copy is bigger than Tx buffer size*/
+++    while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
+++    {
+++      /* Copy data to Tx buffer*/
+++      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
+++      
+++      /* Point to next descriptor */
+++      DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
+++      
+++      /* Check if the buffer is available */
+++      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
+++      {
+++        errval = ERR_USE;
+++        goto error;
+++      }
+++      
+++      buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
+++      
+++      byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
+++      payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
+++      framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
+++      bufferoffset = 0;
+++    }
+++    
+++    /* Copy the remaining bytes */
+++    memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
+++    bufferoffset = bufferoffset + byteslefttocopy;
+++    framelength = framelength + byteslefttocopy;
+++  }
+++  
+++  /* Prepare transmit descriptors to give to DMA */ 
+++  HAL_ETH_TransmitFrame(&EthHandle, framelength);
+++  
+++  errval = ERR_OK;
+++  
+++error:
+++  
+++  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
+++  if ((EthHandle.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
+++  {
+++    /* Clear TUS ETHERNET DMA flag */
+++    EthHandle.Instance->DMASR = ETH_DMASR_TUS;
+++    
+++    /* Resume DMA transmission*/
+++    EthHandle.Instance->DMATPDR = 0;
++   }
+++  return errval;
+++}
++ 
++-  return p;  
+++/**
+++  * @brief Should allocate a pbuf and transfer the bytes of the incoming
+++  * packet from the interface into the pbuf.
+++  *
+++  * @param netif the lwip network interface structure for this ethernetif
+++  * @return a pbuf filled with the received packet (including MAC header)
+++  *         NULL on memory error
+++  */
+++static struct pbuf * low_level_input(struct netif *netif)
+++{
+++  struct pbuf *p = NULL, *q = NULL;
+++  uint16_t len = 0;
+++  uint8_t *buffer;
+++  __IO ETH_DMADescTypeDef *dmarxdesc;
+++  uint32_t bufferoffset = 0;
+++  uint32_t payloadoffset = 0;
+++  uint32_t byteslefttocopy = 0;
+++  uint32_t i=0;
+++  
+++  /* get received frame */
+++  if(HAL_ETH_GetReceivedFrame_IT(&EthHandle) != HAL_OK)
+++    return NULL;
+++  
+++  /* Obtain the size of the packet and put it into the "len" variable. */
+++  len = EthHandle.RxFrameInfos.length;
+++  buffer = (uint8_t *)EthHandle.RxFrameInfos.buffer;
+++  
+++  if (len > 0)
+++  {
+++    /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
+++    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
+++  }
+++  
+++  if (p != NULL)
+++  {
+++    dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
+++    bufferoffset = 0;
+++    
+++    for(q = p; q != NULL; q = q->next)
+++    {
+++      byteslefttocopy = q->len;
+++      payloadoffset = 0;
+++      
+++      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size */
+++      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
+++      {
+++        /* Copy data to pbuf */
+++        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
+++        
+++        /* Point to next descriptor */
+++        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
+++        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
+++        
+++        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
+++        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
+++        bufferoffset = 0;
+++      }
+++      
+++      /* Copy remaining data in pbuf */
+++      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
+++      bufferoffset = bufferoffset + byteslefttocopy;
+++    }
+++  }
+++    
+++  /* Release descriptors to DMA */
+++  /* Point to first descriptor */
+++  dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
+++  /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
+++  for (i=0; i< EthHandle.RxFrameInfos.SegCount; i++)
+++  {  
+++    dmarxdesc->Status |= ETH_DMARXDESC_OWN;
+++    dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
+++  }
+++    
+++  /* Clear Segment_Count */
+++  EthHandle.RxFrameInfos.SegCount =0;
+++  
+++  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
+++  if ((EthHandle.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
+++  {
+++    /* Clear RBUS ETHERNET DMA flag */
+++    EthHandle.Instance->DMASR = ETH_DMASR_RBUS;
+++    /* Resume DMA reception */
+++    EthHandle.Instance->DMARPDR = 0;
+++  }
+++  return p;
++ }
++ 
++ /**
++- * This function should be called when a packet is ready to be read
++- * from the interface. It uses the function low_level_input() that
++- * should handle the actual reception of bytes from the network
++- * interface. Then the type of the received packet is determined and
++- * the appropriate input function is called.
++- *
++- * @param netif the lwip network interface structure for this ethernetif
++- */
++-static void
++-ethernetif_input(struct netif *netif)
+++  * @brief This function is the ethernetif_input task, it is processed when a packet 
+++  * is ready to be read from the interface. It uses the function low_level_input() 
+++  * that should handle the actual reception of bytes from the network
+++  * interface. Then the type of the received packet is determined and
+++  * the appropriate input function is called.
+++  *
+++  * @param netif the lwip network interface structure for this ethernetif
+++  */
+++void ethernetif_input( void const * argument )
++ {
++-  struct ethernetif *ethernetif;
++-  struct eth_hdr *ethhdr;
++   struct pbuf *p;
++-
++-  ethernetif = netif->state;
++-
++-  /* move received packet into a new pbuf */
++-  p = low_level_input(netif);
++-  /* no packet could be read, silently ignore this */
++-  if (p == NULL) return;
++-  /* points to packet payload, which starts with an Ethernet header */
++-  ethhdr = p->payload;
++-
++-  switch (htons(ethhdr->type)) {
++-  /* IP or ARP packet? */
++-  case ETHTYPE_IP:
++-  case ETHTYPE_IPV6:
++-  case ETHTYPE_ARP:
++-#if PPPOE_SUPPORT
++-  /* PPPoE packet? */
++-  case ETHTYPE_PPPOEDISC:
++-  case ETHTYPE_PPPOE:
++-#endif /* PPPOE_SUPPORT */
++-    /* full packet send to tcpip_thread to process */
++-    if (netif->input(p, netif)!=ERR_OK)
++-     { LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
++-       pbuf_free(p);
++-       p = NULL;
++-     }
++-    break;
++-
++-  default:
++-    pbuf_free(p);
++-    p = NULL;
++-    break;
+++  struct netif *netif = (struct netif *) argument;
+++  
+++  for( ;; )
+++  {
+++    if (osSemaphoreWait( s_xSemaphore, TIME_WAITING_FOR_INPUT)==osOK)
+++    {
+++      do
+++      {
+++        p = low_level_input( netif );
+++        if (p != NULL)
+++        {
+++          if (netif->input( p, netif) != ERR_OK )
+++          {
+++            pbuf_free(p);
+++          }
+++        }
+++      }while(p!=NULL);
+++    }
++   }
++ }
++ 
++ /**
++- * Should be called at the beginning of the program to set up the
++- * network interface. It calls the function low_level_init() to do the
++- * actual setup of the hardware.
++- *
++- * This function should be passed as a parameter to netif_add().
++- *
++- * @param netif the lwip network interface structure for this ethernetif
++- * @return ERR_OK if the loopif is initialized
++- *         ERR_MEM if private data couldn't be allocated
++- *         any other err_t on error
++- */
++-err_t
++-ethernetif_init(struct netif *netif)
+++  * @brief Should be called at the beginning of the program to set up the
+++  * network interface. It calls the function low_level_init() to do the
+++  * actual setup of the hardware.
+++  *
+++  * This function should be passed as a parameter to netif_add().
+++  *
+++  * @param netif the lwip network interface structure for this ethernetif
+++  * @return ERR_OK if the loopif is initialized
+++  *         ERR_MEM if private data couldn't be allocated
+++  *         any other err_t on error
+++  */
+++err_t ethernetif_init(struct netif *netif)
++ {
++-  struct ethernetif *ethernetif;
++-
++   LWIP_ASSERT("netif != NULL", (netif != NULL));
++-    
++-  ethernetif = mem_malloc(sizeof(struct ethernetif));
++-  if (ethernetif == NULL) {
++-    LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_init: out of memory\n"));
++-    return ERR_MEM;
++-  }
++ 
++ #if LWIP_NETIF_HOSTNAME
++   /* Initialize interface hostname */
++   netif->hostname = "lwip";
++ #endif /* LWIP_NETIF_HOSTNAME */
++ 
++-  /*
++-   * Initialize the snmp variables and counters inside the struct netif.
++-   * The last argument should be replaced with your link speed, in units
++-   * of bits per second.
++-   */
++-  NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, LINK_SPEED_OF_YOUR_NETIF_IN_BPS);
++-
++-  netif->state = ethernetif;
++   netif->name[0] = IFNAME0;
++   netif->name[1] = IFNAME1;
++-  /* We directly use etharp_output() here to save a function call.
++-   * You can instead declare your own function an call etharp_output()
++-   * from it if you have to do some checks before sending (e.g. if link
++-   * is available...) */
+++
++   netif->output = etharp_output;
++-#if LWIP_IPV6
++-  netif->output_ip6 = ethip6_output;
++-#endif /* LWIP_IPV6 */
++   netif->linkoutput = low_level_output;
++-  
++-  ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
++-  
+++
++   /* initialize the hardware */
++   low_level_init(netif);
++ 
++   return ERR_OK;
++ }
++ 
++-#endif /* 0 */
+++/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
++-- 
++1.9.1
++
++
++From ab97b49d1d41e34fdfdfb457b397c768ee228c9f Mon Sep 17 00:00:00 2001
++From: Jay Doyle <jay.doyle@vecna.com>
++Date: Mon, 7 Sep 2015 09:39:20 -0400
++Subject: [PATCH 05/13] removed ethernetif (it should be in BSP
++
++---
++ src/netif/ethernetif.c | 496 -------------------------------------------------
++ 1 file changed, 496 deletions(-)
++ delete mode 100644 src/netif/ethernetif.c
++
++diff --git a/src/netif/ethernetif.c b/src/netif/ethernetif.c
++deleted file mode 100644
++index 82c85ae..0000000
++--- a/src/netif/ethernetif.c
+++++ /dev/null
++@@ -1,496 +0,0 @@
++-/**
++-  ******************************************************************************
++-  * @file    LwIP/LwIP_HTTP_Server_Netconn_RTOS/Src/ethernetif.c
++-  * @author  MCD Application Team
++-  * @version V1.0.0
++-  * @date    25-June-2015
++-  * @brief   This file implements Ethernet network interface drivers for lwIP
++-  ******************************************************************************
++-  * @attention
++-  *
++-  * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
++-  *
++-  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
++-  * You may not use this file except in compliance with the License.
++-  * You may obtain a copy of the License at:
++-  *
++-  *        http://www.st.com/software_license_agreement_liberty_v2
++-  *
++-  * Unless required by applicable law or agreed to in writing, software 
++-  * distributed under the License is distributed on an "AS IS" BASIS, 
++-  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++-  * See the License for the specific language governing permissions and
++-  * limitations under the License.
++-  *
++-  ******************************************************************************
++-  */
++-
++-/* Includes ------------------------------------------------------------------*/
++-#include "stm32f7xx_hal.h"
++-#include "lwip/opt.h"
++-#include "lwip/lwip_timers.h"
++-#include "netif/etharp.h"
++-#include "hal-ethernetif.h"
++-#include <string.h>
++-
++-/* Private typedef -----------------------------------------------------------*/
++-/* Private define ------------------------------------------------------------*/
++-/* The time to block waiting for input. */
++-#define TIME_WAITING_FOR_INPUT                 ( 100 )
++-/* Stack size of the interface thread */
++-#define INTERFACE_THREAD_STACK_SIZE            ( 350 )
++-
++-/* Define those to better describe your network interface. */
++-#define IFNAME0 'e'
++-#define IFNAME1 'n'
++-
++-#define LAN8742A_PHY_ADDRESS            0x00
++-
++-/* Private macro -------------------------------------------------------------*/
++-/* Private variables ---------------------------------------------------------*/
++-
++-#if defined ( __ICCARM__ ) /*!< IAR Compiler */
++-
++-#pragma location=0x2000E000
++-__no_init ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
++-#pragma location=0x2000E100
++-__no_init ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
++-#elif defined ( __CC_ARM   )
++-ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((at(0x2000E000)));/* Ethernet Rx MA Descriptor */
++-ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((at(0x2000E100)));/* Ethernet Tx DMA Descriptor */
++-#elif defined ( __GNUC__   )
++-//ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".RxDescripSection")));/* Ethernet Rx MA Descriptor */
++-//ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".TxDescripSection")));/* Ethernet Tx DMA Descriptor */
++-ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Rx MA Descriptor */
++-ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Tx DMA Descriptor */
++-
++-
++-#endif
++-#if defined ( __ICCARM__ ) /*!< IAR Compiler */
++-#pragma location=0x2000E200
++-__no_init uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
++-#pragma location=0x2000FFC4
++-__no_init uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
++-#elif defined ( __CC_ARM   )
++-uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((at(0x2000E200)));  /* Ethernet Receive Buffer */
++-uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]  __attribute__((at(0x2000FFC4))); /* Ethernet Transmit Buffer */
++-#elif defined ( __GNUC__   )
++-//uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".RxBUF")));/* Ethernet Receive Buffer */
++-//uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".TxBUF")));/* Ethernet Transmit Buffer */
++-uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Receive Buffer */
++-uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Transmit Buffer */
++-
++-#endif
++-/* Semaphore to signal incoming packets */
++-osSemaphoreId s_xSemaphore = NULL;
++-
++-/* Global Ethernet handle*/
++-ETH_HandleTypeDef EthHandle;
++-
++-/* Private function prototypes -----------------------------------------------*/
++-static void ethernetif_input( void const * argument );
++-
++-static void stm32f_ethernet_isr(
++-  void* argData
++-)
++-{
++-  ETH_HandleTypeDef* pEth =
++-    (ETH_HandleTypeDef*) argData;
++-
++-  HAL_ETH_IRQHandler(pEth);
++-}
++-
++-/* Private functions ---------------------------------------------------------*/
++-/*******************************************************************************
++-                       Ethernet MSP Routines
++-*******************************************************************************/
++-/**
++-  * @brief  Initializes the ETH MSP.
++-  * @param  heth: ETH handle
++-  * @retval None
++-  */
++-void HAL_ETH_MspInit(ETH_HandleTypeDef *heth)
++-{
++-  GPIO_InitTypeDef GPIO_InitStructure;
++-  
++-  /* Enable GPIOs clocks */
++-  __HAL_RCC_GPIOA_CLK_ENABLE();
++-  __HAL_RCC_GPIOC_CLK_ENABLE();
++-  __HAL_RCC_GPIOG_CLK_ENABLE();
++-
++-/* Ethernet pins configuration ************************************************/
++-  /*
++-        RMII_REF_CLK ----------------------> PA1
++-        RMII_MDIO -------------------------> PA2
++-        RMII_MDC --------------------------> PC1
++-        RMII_MII_CRS_DV -------------------> PA7
++-        RMII_MII_RXD0 ---------------------> PC4
++-        RMII_MII_RXD1 ---------------------> PC5
++-        RMII_MII_RXER ---------------------> PG2
++-        RMII_MII_TX_EN --------------------> PG11
++-        RMII_MII_TXD0 ---------------------> PG13
++-        RMII_MII_TXD1 ---------------------> PG14
++-  */
++-
++-  /* Configure PA1, PA2 and PA7 */
++-  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
++-  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
++-  GPIO_InitStructure.Pull = GPIO_NOPULL; 
++-  GPIO_InitStructure.Alternate = GPIO_AF11_ETH;
++-  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
++-  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
++-  
++-  /* Configure PC1, PC4 and PC5 */
++-  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;
++-  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
++-
++-  /* Configure PG2, PG11, PG13 and PG14 */
++-  GPIO_InitStructure.Pin =  GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14;
++-  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
++-  
++-  // Install HAL Ethernet ISR
++-  rtems_interrupt_handler_install(
++-    ETH_IRQn,
++-    NULL,
++-    0,
++-    stm32f_ethernet_isr,
++-    heth);
++-  
++-  /* Enable ETHERNET clock  */
++-  __HAL_RCC_ETH_CLK_ENABLE();
++-}
++-
++-/**
++-  * @brief  Ethernet Rx Transfer completed callback
++-  * @param  heth: ETH handle
++-  * @retval None
++-  */
++-void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
++-{
++-  osSemaphoreRelease(s_xSemaphore);
++-}
++-
++-/**
++-  * @brief  Ethernet IRQ Handler
++-  * @param  None
++-  * @retval None
++-  */
++-void ETHERNET_IRQHandler(void)
++-{
++-  HAL_ETH_IRQHandler(&EthHandle);
++-}
++-
++-/*******************************************************************************
++-                       LL Driver Interface ( LwIP stack --> ETH) 
++-*******************************************************************************/
++-/**
++-  * @brief In this function, the hardware should be initialized.
++-  * Called from ethernetif_init().
++-  *
++-  * @param netif the already initialized lwip network interface structure
++-  *        for this ethernetif
++-  */
++-static void low_level_init(struct netif *netif)
++-{
++-  uint8_t macaddress[6]= { MAC_ADDR0, MAC_ADDR1, MAC_ADDR2, MAC_ADDR3, MAC_ADDR4, MAC_ADDR5 };
++-  
++-  EthHandle.Instance = ETH;  
++-  EthHandle.Init.MACAddr = macaddress;
++-  EthHandle.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
++-  EthHandle.Init.Speed = ETH_SPEED_100M;
++-  EthHandle.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
++-  EthHandle.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
++-  EthHandle.Init.RxMode = ETH_RXINTERRUPT_MODE;
++-  EthHandle.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
++-  EthHandle.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
++-  
++-  /* configure ethernet peripheral (GPIOs, clocks, MAC, DMA) */
++-  if (HAL_ETH_Init(&EthHandle) == HAL_OK)
++-  {
++-    /* Set netif link flag */
++-    netif->flags |= NETIF_FLAG_LINK_UP;
++-  }
++-  
++-  /* Initialize Tx Descriptors list: Chain Mode */
++-  HAL_ETH_DMATxDescListInit(&EthHandle, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
++-     
++-  /* Initialize Rx Descriptors list: Chain Mode  */
++-  HAL_ETH_DMARxDescListInit(&EthHandle, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
++-  
++-  /* set netif MAC hardware address length */
++-  netif->hwaddr_len = ETHARP_HWADDR_LEN;
++-
++-  /* set netif MAC hardware address */
++-  netif->hwaddr[0] =  MAC_ADDR0;
++-  netif->hwaddr[1] =  MAC_ADDR1;
++-  netif->hwaddr[2] =  MAC_ADDR2;
++-  netif->hwaddr[3] =  MAC_ADDR3;
++-  netif->hwaddr[4] =  MAC_ADDR4;
++-  netif->hwaddr[5] =  MAC_ADDR5;
++-
++-  /* set netif maximum transfer unit */
++-  netif->mtu = 1500;
++-
++-  /* Accept broadcast address and ARP traffic */
++-  netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
++-
++-  /* create a binary semaphore used for informing ethernetif of frame reception */
++-  osSemaphoreDef(SEM);
++-  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1 );
++-
++-  /* create the task that handles the ETH_MAC */
++-  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
++-  osThreadCreate (osThread(EthIf), netif);
++-
++-  /* Enable MAC and DMA transmission and reception */
++-  HAL_ETH_Start(&EthHandle);
++-}
++-
++-
++-/**
++-  * @brief This function should do the actual transmission of the packet. The packet is
++-  * contained in the pbuf that is passed to the function. This pbuf
++-  * might be chained.
++-  *
++-  * @param netif the lwip network interface structure for this ethernetif
++-  * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
++-  * @return ERR_OK if the packet could be sent
++-  *         an err_t value if the packet couldn't be sent
++-  *
++-  * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
++-  *       strange results. You might consider waiting for space in the DMA queue
++-  *       to become available since the stack doesn't retry to send a packet
++-  *       dropped because of memory failure (except for the TCP timers).
++-  */
++-static err_t low_level_output(struct netif *netif, struct pbuf *p)
++-{
++-  err_t errval;
++-  struct pbuf *q;
++-  uint8_t *buffer = (uint8_t *)(EthHandle.TxDesc->Buffer1Addr);
++-  __IO ETH_DMADescTypeDef *DmaTxDesc;
++-  uint32_t framelength = 0;
++-  uint32_t bufferoffset = 0;
++-  uint32_t byteslefttocopy = 0;
++-  uint32_t payloadoffset = 0;
++-
++-  DmaTxDesc = EthHandle.TxDesc;
++-  bufferoffset = 0;
++-  
++-  /* copy frame from pbufs to driver buffers */
++-  for(q = p; q != NULL; q = q->next)
++-  {
++-    /* Is this buffer available? If not, goto error */
++-    if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
++-    {
++-      errval = ERR_USE;
++-      goto error;
++-    }
++-    
++-    /* Get bytes in current lwIP buffer */
++-    byteslefttocopy = q->len;
++-    payloadoffset = 0;
++-    
++-    /* Check if the length of data to copy is bigger than Tx buffer size*/
++-    while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
++-    {
++-      /* Copy data to Tx buffer*/
++-      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
++-      
++-      /* Point to next descriptor */
++-      DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
++-      
++-      /* Check if the buffer is available */
++-      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
++-      {
++-        errval = ERR_USE;
++-        goto error;
++-      }
++-      
++-      buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
++-      
++-      byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
++-      payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
++-      framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
++-      bufferoffset = 0;
++-    }
++-    
++-    /* Copy the remaining bytes */
++-    memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
++-    bufferoffset = bufferoffset + byteslefttocopy;
++-    framelength = framelength + byteslefttocopy;
++-  }
++-  
++-  /* Prepare transmit descriptors to give to DMA */ 
++-  HAL_ETH_TransmitFrame(&EthHandle, framelength);
++-  
++-  errval = ERR_OK;
++-  
++-error:
++-  
++-  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
++-  if ((EthHandle.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
++-  {
++-    /* Clear TUS ETHERNET DMA flag */
++-    EthHandle.Instance->DMASR = ETH_DMASR_TUS;
++-    
++-    /* Resume DMA transmission*/
++-    EthHandle.Instance->DMATPDR = 0;
++-  }
++-  return errval;
++-}
++-
++-/**
++-  * @brief Should allocate a pbuf and transfer the bytes of the incoming
++-  * packet from the interface into the pbuf.
++-  *
++-  * @param netif the lwip network interface structure for this ethernetif
++-  * @return a pbuf filled with the received packet (including MAC header)
++-  *         NULL on memory error
++-  */
++-static struct pbuf * low_level_input(struct netif *netif)
++-{
++-  struct pbuf *p = NULL, *q = NULL;
++-  uint16_t len = 0;
++-  uint8_t *buffer;
++-  __IO ETH_DMADescTypeDef *dmarxdesc;
++-  uint32_t bufferoffset = 0;
++-  uint32_t payloadoffset = 0;
++-  uint32_t byteslefttocopy = 0;
++-  uint32_t i=0;
++-  
++-  /* get received frame */
++-  if(HAL_ETH_GetReceivedFrame_IT(&EthHandle) != HAL_OK)
++-    return NULL;
++-  
++-  /* Obtain the size of the packet and put it into the "len" variable. */
++-  len = EthHandle.RxFrameInfos.length;
++-  buffer = (uint8_t *)EthHandle.RxFrameInfos.buffer;
++-  
++-  if (len > 0)
++-  {
++-    /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
++-    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
++-  }
++-  
++-  if (p != NULL)
++-  {
++-    dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
++-    bufferoffset = 0;
++-    
++-    for(q = p; q != NULL; q = q->next)
++-    {
++-      byteslefttocopy = q->len;
++-      payloadoffset = 0;
++-      
++-      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size */
++-      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
++-      {
++-        /* Copy data to pbuf */
++-        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
++-        
++-        /* Point to next descriptor */
++-        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
++-        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
++-        
++-        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
++-        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
++-        bufferoffset = 0;
++-      }
++-      
++-      /* Copy remaining data in pbuf */
++-      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
++-      bufferoffset = bufferoffset + byteslefttocopy;
++-    }
++-  }
++-    
++-  /* Release descriptors to DMA */
++-  /* Point to first descriptor */
++-  dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
++-  /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
++-  for (i=0; i< EthHandle.RxFrameInfos.SegCount; i++)
++-  {  
++-    dmarxdesc->Status |= ETH_DMARXDESC_OWN;
++-    dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
++-  }
++-    
++-  /* Clear Segment_Count */
++-  EthHandle.RxFrameInfos.SegCount =0;
++-  
++-  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
++-  if ((EthHandle.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
++-  {
++-    /* Clear RBUS ETHERNET DMA flag */
++-    EthHandle.Instance->DMASR = ETH_DMASR_RBUS;
++-    /* Resume DMA reception */
++-    EthHandle.Instance->DMARPDR = 0;
++-  }
++-  return p;
++-}
++-
++-/**
++-  * @brief This function is the ethernetif_input task, it is processed when a packet 
++-  * is ready to be read from the interface. It uses the function low_level_input() 
++-  * that should handle the actual reception of bytes from the network
++-  * interface. Then the type of the received packet is determined and
++-  * the appropriate input function is called.
++-  *
++-  * @param netif the lwip network interface structure for this ethernetif
++-  */
++-void ethernetif_input( void const * argument )
++-{
++-  struct pbuf *p;
++-  struct netif *netif = (struct netif *) argument;
++-  
++-  for( ;; )
++-  {
++-    if (osSemaphoreWait( s_xSemaphore, TIME_WAITING_FOR_INPUT)==osOK)
++-    {
++-      do
++-      {
++-        p = low_level_input( netif );
++-        if (p != NULL)
++-        {
++-          if (netif->input( p, netif) != ERR_OK )
++-          {
++-            pbuf_free(p);
++-          }
++-        }
++-      }while(p!=NULL);
++-    }
++-  }
++-}
++-
++-/**
++-  * @brief Should be called at the beginning of the program to set up the
++-  * network interface. It calls the function low_level_init() to do the
++-  * actual setup of the hardware.
++-  *
++-  * This function should be passed as a parameter to netif_add().
++-  *
++-  * @param netif the lwip network interface structure for this ethernetif
++-  * @return ERR_OK if the loopif is initialized
++-  *         ERR_MEM if private data couldn't be allocated
++-  *         any other err_t on error
++-  */
++-err_t ethernetif_init(struct netif *netif)
++-{
++-  LWIP_ASSERT("netif != NULL", (netif != NULL));
++-
++-#if LWIP_NETIF_HOSTNAME
++-  /* Initialize interface hostname */
++-  netif->hostname = "lwip";
++-#endif /* LWIP_NETIF_HOSTNAME */
++-
++-  netif->name[0] = IFNAME0;
++-  netif->name[1] = IFNAME1;
++-
++-  netif->output = etharp_output;
++-  netif->linkoutput = low_level_output;
++-
++-  /* initialize the hardware */
++-  low_level_init(netif);
++-
++-  return ERR_OK;
++-}
++-
++-/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
++-- 
++1.9.1
++
++
++From 31d34fab26b1e3fde99fe7288786725fe5e51b95 Mon Sep 17 00:00:00 2001
++From: Jay Doyle <jay.doyle@vecna.com>
++Date: Mon, 7 Sep 2015 10:17:32 -0400
++Subject: [PATCH 06/13] add low level driver back
++
++---
++ src/netif/ethernetif.c | 496 +++++++++++++++++++++++++++++++++++++++++++++++++
++ 1 file changed, 496 insertions(+)
++ create mode 100644 src/netif/ethernetif.c
++
++diff --git a/src/netif/ethernetif.c b/src/netif/ethernetif.c
++new file mode 100644
++index 0000000..bc429e9
++--- /dev/null
+++++ b/src/netif/ethernetif.c
++@@ -0,0 +1,496 @@
+++/**
+++  ******************************************************************************
+++  * @file    LwIP/LwIP_HTTP_Server_Netconn_RTOS/Src/ethernetif.c
+++  * @author  MCD Application Team
+++  * @version V1.0.0
+++  * @date    25-June-2015
+++  * @brief   This file implements Ethernet network interface drivers for lwIP
+++  ******************************************************************************
+++  * @attention
+++  *
+++  * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
+++  *
+++  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+++  * You may not use this file except in compliance with the License.
+++  * You may obtain a copy of the License at:
+++  *
+++  *        http://www.st.com/software_license_agreement_liberty_v2
+++  *
+++  * Unless required by applicable law or agreed to in writing, software 
+++  * distributed under the License is distributed on an "AS IS" BASIS, 
+++  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+++  * See the License for the specific language governing permissions and
+++  * limitations under the License.
+++  *
+++  ******************************************************************************
+++  */
+++
+++/* Includes ------------------------------------------------------------------*/
+++#include <stm32f7xx_hal.h>
+++#include <lwip/opt.h>
+++#include <lwip/lwip_timers.h>
+++#include <netif/etharp.h>
+++#include <hal-ethernetif.h>
+++#include <string.h>
+++
+++/* Private typedef -----------------------------------------------------------*/
+++/* Private define ------------------------------------------------------------*/
+++/* The time to block waiting for input. */
+++#define TIME_WAITING_FOR_INPUT                 ( 100 )
+++/* Stack size of the interface thread */
+++#define INTERFACE_THREAD_STACK_SIZE            ( 350 )
+++
+++/* Define those to better describe your network interface. */
+++#define IFNAME0 'e'
+++#define IFNAME1 'n'
+++
+++#define LAN8742A_PHY_ADDRESS            0x00
+++
+++/* Private macro -------------------------------------------------------------*/
+++/* Private variables ---------------------------------------------------------*/
+++
+++#if defined ( __ICCARM__ ) /*!< IAR Compiler */
+++
+++#pragma location=0x2000E000
+++__no_init ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
+++#pragma location=0x2000E100
+++__no_init ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
+++#elif defined ( __CC_ARM   )
+++ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((at(0x2000E000)));/* Ethernet Rx MA Descriptor */
+++ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((at(0x2000E100)));/* Ethernet Tx DMA Descriptor */
+++#elif defined ( __GNUC__   )
+++//ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".RxDescripSection")));/* Ethernet Rx MA Descriptor */
+++//ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".TxDescripSection")));/* Ethernet Tx DMA Descriptor */
+++ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Rx MA Descriptor */
+++ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Tx DMA Descriptor */
+++
+++
+++#endif
+++#if defined ( __ICCARM__ ) /*!< IAR Compiler */
+++#pragma location=0x2000E200
+++__no_init uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
+++#pragma location=0x2000FFC4
+++__no_init uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
+++#elif defined ( __CC_ARM   )
+++uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((at(0x2000E200)));  /* Ethernet Receive Buffer */
+++uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]  __attribute__((at(0x2000FFC4))); /* Ethernet Transmit Buffer */
+++#elif defined ( __GNUC__   )
+++//uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".RxBUF")));/* Ethernet Receive Buffer */
+++//uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".TxBUF")));/* Ethernet Transmit Buffer */
+++uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Receive Buffer */
+++uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Transmit Buffer */
+++
+++#endif
+++/* Semaphore to signal incoming packets */
+++osSemaphoreId s_xSemaphore = NULL;
+++
+++/* Global Ethernet handle*/
+++ETH_HandleTypeDef EthHandle;
+++
+++/* Private function prototypes -----------------------------------------------*/
+++static void ethernetif_input( void const * argument );
+++
+++static void stm32f_ethernet_isr(
+++  void* argData
+++)
+++{
+++  ETH_HandleTypeDef* pEth =
+++    (ETH_HandleTypeDef*) argData;
+++
+++  HAL_ETH_IRQHandler(pEth);
+++}
+++
+++/* Private functions ---------------------------------------------------------*/
+++/*******************************************************************************
+++                       Ethernet MSP Routines
+++*******************************************************************************/
+++/**
+++  * @brief  Initializes the ETH MSP.
+++  * @param  heth: ETH handle
+++  * @retval None
+++  */
+++void HAL_ETH_MspInit(ETH_HandleTypeDef *heth)
+++{
+++  GPIO_InitTypeDef GPIO_InitStructure;
+++  
+++  /* Enable GPIOs clocks */
+++  __HAL_RCC_GPIOA_CLK_ENABLE();
+++  __HAL_RCC_GPIOC_CLK_ENABLE();
+++  __HAL_RCC_GPIOG_CLK_ENABLE();
+++
+++/* Ethernet pins configuration ************************************************/
+++  /*
+++        RMII_REF_CLK ----------------------> PA1
+++        RMII_MDIO -------------------------> PA2
+++        RMII_MDC --------------------------> PC1
+++        RMII_MII_CRS_DV -------------------> PA7
+++        RMII_MII_RXD0 ---------------------> PC4
+++        RMII_MII_RXD1 ---------------------> PC5
+++        RMII_MII_RXER ---------------------> PG2
+++        RMII_MII_TX_EN --------------------> PG11
+++        RMII_MII_TXD0 ---------------------> PG13
+++        RMII_MII_TXD1 ---------------------> PG14
+++  */
+++
+++  /* Configure PA1, PA2 and PA7 */
+++  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
+++  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
+++  GPIO_InitStructure.Pull = GPIO_NOPULL; 
+++  GPIO_InitStructure.Alternate = GPIO_AF11_ETH;
+++  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
+++  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
+++  
+++  /* Configure PC1, PC4 and PC5 */
+++  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;
+++  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
+++
+++  /* Configure PG2, PG11, PG13 and PG14 */
+++  GPIO_InitStructure.Pin =  GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14;
+++  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
+++  
+++  // Install HAL Ethernet ISR
+++  rtems_interrupt_handler_install(
+++    ETH_IRQn,
+++    NULL,
+++    0,
+++    stm32f_ethernet_isr,
+++    heth);
+++  
+++  /* Enable ETHERNET clock  */
+++  __HAL_RCC_ETH_CLK_ENABLE();
+++}
+++
+++/**
+++  * @brief  Ethernet Rx Transfer completed callback
+++  * @param  heth: ETH handle
+++  * @retval None
+++  */
+++void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
+++{
+++  osSemaphoreRelease(s_xSemaphore);
+++}
+++
+++/**
+++  * @brief  Ethernet IRQ Handler
+++  * @param  None
+++  * @retval None
+++  */
+++void ETHERNET_IRQHandler(void)
+++{
+++  HAL_ETH_IRQHandler(&EthHandle);
+++}
+++
+++/*******************************************************************************
+++                       LL Driver Interface ( LwIP stack --> ETH) 
+++*******************************************************************************/
+++/**
+++  * @brief In this function, the hardware should be initialized.
+++  * Called from ethernetif_init().
+++  *
+++  * @param netif the already initialized lwip network interface structure
+++  *        for this ethernetif
+++  */
+++static void low_level_init(struct netif *netif)
+++{
+++  uint8_t macaddress[6]= { MAC_ADDR0, MAC_ADDR1, MAC_ADDR2, MAC_ADDR3, MAC_ADDR4, MAC_ADDR5 };
+++  
+++  EthHandle.Instance = ETH;  
+++  EthHandle.Init.MACAddr = macaddress;
+++  EthHandle.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
+++  EthHandle.Init.Speed = ETH_SPEED_100M;
+++  EthHandle.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
+++  EthHandle.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
+++  EthHandle.Init.RxMode = ETH_RXINTERRUPT_MODE;
+++  EthHandle.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
+++  EthHandle.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
+++  
+++  /* configure ethernet peripheral (GPIOs, clocks, MAC, DMA) */
+++  if (HAL_ETH_Init(&EthHandle) == HAL_OK)
+++  {
+++    /* Set netif link flag */
+++    netif->flags |= NETIF_FLAG_LINK_UP;
+++  }
+++  
+++  /* Initialize Tx Descriptors list: Chain Mode */
+++  HAL_ETH_DMATxDescListInit(&EthHandle, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
+++     
+++  /* Initialize Rx Descriptors list: Chain Mode  */
+++  HAL_ETH_DMARxDescListInit(&EthHandle, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
+++  
+++  /* set netif MAC hardware address length */
+++  netif->hwaddr_len = ETHARP_HWADDR_LEN;
+++
+++  /* set netif MAC hardware address */
+++  netif->hwaddr[0] =  MAC_ADDR0;
+++  netif->hwaddr[1] =  MAC_ADDR1;
+++  netif->hwaddr[2] =  MAC_ADDR2;
+++  netif->hwaddr[3] =  MAC_ADDR3;
+++  netif->hwaddr[4] =  MAC_ADDR4;
+++  netif->hwaddr[5] =  MAC_ADDR5;
+++
+++  /* set netif maximum transfer unit */
+++  netif->mtu = 1500;
+++
+++  /* Accept broadcast address and ARP traffic */
+++  netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
+++
+++  /* create a binary semaphore used for informing ethernetif of frame reception */
+++  osSemaphoreDef(SEM);
+++  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1 );
+++
+++  /* create the task that handles the ETH_MAC */
+++  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
+++  osThreadCreate (osThread(EthIf), netif);
+++
+++  /* Enable MAC and DMA transmission and reception */
+++  HAL_ETH_Start(&EthHandle);
+++}
+++
+++
+++/**
+++  * @brief This function should do the actual transmission of the packet. The packet is
+++  * contained in the pbuf that is passed to the function. This pbuf
+++  * might be chained.
+++  *
+++  * @param netif the lwip network interface structure for this ethernetif
+++  * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
+++  * @return ERR_OK if the packet could be sent
+++  *         an err_t value if the packet couldn't be sent
+++  *
+++  * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
+++  *       strange results. You might consider waiting for space in the DMA queue
+++  *       to become available since the stack doesn't retry to send a packet
+++  *       dropped because of memory failure (except for the TCP timers).
+++  */
+++static err_t low_level_output(struct netif *netif, struct pbuf *p)
+++{
+++  err_t errval;
+++  struct pbuf *q;
+++  uint8_t *buffer = (uint8_t *)(EthHandle.TxDesc->Buffer1Addr);
+++  __IO ETH_DMADescTypeDef *DmaTxDesc;
+++  uint32_t framelength = 0;
+++  uint32_t bufferoffset = 0;
+++  uint32_t byteslefttocopy = 0;
+++  uint32_t payloadoffset = 0;
+++
+++  DmaTxDesc = EthHandle.TxDesc;
+++  bufferoffset = 0;
+++  
+++  /* copy frame from pbufs to driver buffers */
+++  for(q = p; q != NULL; q = q->next)
+++  {
+++    /* Is this buffer available? If not, goto error */
+++    if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
+++    {
+++      errval = ERR_USE;
+++      goto error;
+++    }
+++    
+++    /* Get bytes in current lwIP buffer */
+++    byteslefttocopy = q->len;
+++    payloadoffset = 0;
+++    
+++    /* Check if the length of data to copy is bigger than Tx buffer size*/
+++    while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
+++    {
+++      /* Copy data to Tx buffer*/
+++      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
+++      
+++      /* Point to next descriptor */
+++      DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
+++      
+++      /* Check if the buffer is available */
+++      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
+++      {
+++        errval = ERR_USE;
+++        goto error;
+++      }
+++      
+++      buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
+++      
+++      byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
+++      payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
+++      framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
+++      bufferoffset = 0;
+++    }
+++    
+++    /* Copy the remaining bytes */
+++    memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
+++    bufferoffset = bufferoffset + byteslefttocopy;
+++    framelength = framelength + byteslefttocopy;
+++  }
+++  
+++  /* Prepare transmit descriptors to give to DMA */ 
+++  HAL_ETH_TransmitFrame(&EthHandle, framelength);
+++  
+++  errval = ERR_OK;
+++  
+++error:
+++  
+++  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
+++  if ((EthHandle.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
+++  {
+++    /* Clear TUS ETHERNET DMA flag */
+++    EthHandle.Instance->DMASR = ETH_DMASR_TUS;
+++    
+++    /* Resume DMA transmission*/
+++    EthHandle.Instance->DMATPDR = 0;
+++  }
+++  return errval;
+++}
+++
+++/**
+++  * @brief Should allocate a pbuf and transfer the bytes of the incoming
+++  * packet from the interface into the pbuf.
+++  *
+++  * @param netif the lwip network interface structure for this ethernetif
+++  * @return a pbuf filled with the received packet (including MAC header)
+++  *         NULL on memory error
+++  */
+++static struct pbuf * low_level_input(struct netif *netif)
+++{
+++  struct pbuf *p = NULL, *q = NULL;
+++  uint16_t len = 0;
+++  uint8_t *buffer;
+++  __IO ETH_DMADescTypeDef *dmarxdesc;
+++  uint32_t bufferoffset = 0;
+++  uint32_t payloadoffset = 0;
+++  uint32_t byteslefttocopy = 0;
+++  uint32_t i=0;
+++  
+++  /* get received frame */
+++  if(HAL_ETH_GetReceivedFrame_IT(&EthHandle) != HAL_OK)
+++    return NULL;
+++  
+++  /* Obtain the size of the packet and put it into the "len" variable. */
+++  len = EthHandle.RxFrameInfos.length;
+++  buffer = (uint8_t *)EthHandle.RxFrameInfos.buffer;
+++  
+++  if (len > 0)
+++  {
+++    /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
+++    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
+++  }
+++  
+++  if (p != NULL)
+++  {
+++    dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
+++    bufferoffset = 0;
+++    
+++    for(q = p; q != NULL; q = q->next)
+++    {
+++      byteslefttocopy = q->len;
+++      payloadoffset = 0;
+++      
+++      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size */
+++      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
+++      {
+++        /* Copy data to pbuf */
+++        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
+++        
+++        /* Point to next descriptor */
+++        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
+++        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
+++        
+++        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
+++        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
+++        bufferoffset = 0;
+++      }
+++      
+++      /* Copy remaining data in pbuf */
+++      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
+++      bufferoffset = bufferoffset + byteslefttocopy;
+++    }
+++  }
+++    
+++  /* Release descriptors to DMA */
+++  /* Point to first descriptor */
+++  dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
+++  /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
+++  for (i=0; i< EthHandle.RxFrameInfos.SegCount; i++)
+++  {  
+++    dmarxdesc->Status |= ETH_DMARXDESC_OWN;
+++    dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
+++  }
+++    
+++  /* Clear Segment_Count */
+++  EthHandle.RxFrameInfos.SegCount =0;
+++  
+++  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
+++  if ((EthHandle.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
+++  {
+++    /* Clear RBUS ETHERNET DMA flag */
+++    EthHandle.Instance->DMASR = ETH_DMASR_RBUS;
+++    /* Resume DMA reception */
+++    EthHandle.Instance->DMARPDR = 0;
+++  }
+++  return p;
+++}
+++
+++/**
+++  * @brief This function is the ethernetif_input task, it is processed when a packet 
+++  * is ready to be read from the interface. It uses the function low_level_input() 
+++  * that should handle the actual reception of bytes from the network
+++  * interface. Then the type of the received packet is determined and
+++  * the appropriate input function is called.
+++  *
+++  * @param netif the lwip network interface structure for this ethernetif
+++  */
+++void ethernetif_input( void const * argument )
+++{
+++  struct pbuf *p;
+++  struct netif *netif = (struct netif *) argument;
+++  
+++  for( ;; )
+++  {
+++    if (osSemaphoreWait( s_xSemaphore, TIME_WAITING_FOR_INPUT)==osOK)
+++    {
+++      do
+++      {
+++        p = low_level_input( netif );
+++        if (p != NULL)
+++        {
+++          if (netif->input( p, netif) != ERR_OK )
+++          {
+++            pbuf_free(p);
+++          }
+++        }
+++      }while(p!=NULL);
+++    }
+++  }
+++}
+++
+++/**
+++  * @brief Should be called at the beginning of the program to set up the
+++  * network interface. It calls the function low_level_init() to do the
+++  * actual setup of the hardware.
+++  *
+++  * This function should be passed as a parameter to netif_add().
+++  *
+++  * @param netif the lwip network interface structure for this ethernetif
+++  * @return ERR_OK if the loopif is initialized
+++  *         ERR_MEM if private data couldn't be allocated
+++  *         any other err_t on error
+++  */
+++err_t ethernetif_init(struct netif *netif)
+++{
+++  LWIP_ASSERT("netif != NULL", (netif != NULL));
+++
+++#if LWIP_NETIF_HOSTNAME
+++  /* Initialize interface hostname */
+++  netif->hostname = "lwip";
+++#endif /* LWIP_NETIF_HOSTNAME */
+++
+++  netif->name[0] = IFNAME0;
+++  netif->name[1] = IFNAME1;
+++
+++  netif->output = etharp_output;
+++  netif->linkoutput = low_level_output;
+++
+++  /* initialize the hardware */
+++  low_level_init(netif);
+++
+++  return ERR_OK;
+++}
+++
+++/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
++-- 
++1.9.1
++
++
++From 81eded01bb2bc35a9b627e5cf35b2021efb5972c Mon Sep 17 00:00:00 2001
++From: Jay Doyle <jay.doyle@vecna.com>
++Date: Mon, 7 Sep 2015 10:22:57 -0400
++Subject: [PATCH 07/13] Added bsp path
++
++---
++ Makefile | 4 +++-
++ 1 file changed, 3 insertions(+), 1 deletion(-)
++
++diff --git a/Makefile b/Makefile
++index 6efa141..a855d9f 100644
++--- a/Makefile
+++++ b/Makefile
++@@ -13,6 +13,8 @@ LWIP_EXEC=lwip
++ 
++ #### PATHS #####################################################################
++ 
+++BSP_PATH=/opt/rtems-4.11/arm-rtems4.11/stm32f7x/lib/include/bsp
+++
++ # LWIP
++ LWIP_PATH=.
++ LWIP_SRC_PATH=$(LWIP_PATH)/src
++@@ -97,7 +99,7 @@ DRIVER_H=$(LWIPDRIVER_INCL_PATH)
++ # HEADERS
++ HEADERS=-I$(CORE_H) -I$(POSIX_H) -I$(POSIX_SYS_H) -I$(NETIF_H) \
++         -I$(NETIF_H_PPP) -I$(NETIF_H_PPP_POLARSSL) -I$(ARCH_H) \
++-        -I$(DRIVER_H) -I$(IPV4_H)
+++        -I$(DRIVER_H) -I$(IPV4_H) -I$(BSP_PATH)
++ 
++ 
++ ################################################################################
++-- 
++1.9.1
++
++
++From f114529d5af1e2a83b49b67d631b10c02648e8d8 Mon Sep 17 00:00:00 2001
++From: Jay Doyle <jay.doyle@vecna.com>
++Date: Mon, 7 Sep 2015 10:54:26 -0400
++Subject: [PATCH 08/13] removed ethernetif.c
++
++---
++ src/netif/ethernetif.c | 496 -------------------------------------------------
++ 1 file changed, 496 deletions(-)
++ delete mode 100644 src/netif/ethernetif.c
++
++diff --git a/src/netif/ethernetif.c b/src/netif/ethernetif.c
++deleted file mode 100644
++index bc429e9..0000000
++--- a/src/netif/ethernetif.c
+++++ /dev/null
++@@ -1,496 +0,0 @@
++-/**
++-  ******************************************************************************
++-  * @file    LwIP/LwIP_HTTP_Server_Netconn_RTOS/Src/ethernetif.c
++-  * @author  MCD Application Team
++-  * @version V1.0.0
++-  * @date    25-June-2015
++-  * @brief   This file implements Ethernet network interface drivers for lwIP
++-  ******************************************************************************
++-  * @attention
++-  *
++-  * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
++-  *
++-  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
++-  * You may not use this file except in compliance with the License.
++-  * You may obtain a copy of the License at:
++-  *
++-  *        http://www.st.com/software_license_agreement_liberty_v2
++-  *
++-  * Unless required by applicable law or agreed to in writing, software 
++-  * distributed under the License is distributed on an "AS IS" BASIS, 
++-  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++-  * See the License for the specific language governing permissions and
++-  * limitations under the License.
++-  *
++-  ******************************************************************************
++-  */
++-
++-/* Includes ------------------------------------------------------------------*/
++-#include <stm32f7xx_hal.h>
++-#include <lwip/opt.h>
++-#include <lwip/lwip_timers.h>
++-#include <netif/etharp.h>
++-#include <hal-ethernetif.h>
++-#include <string.h>
++-
++-/* Private typedef -----------------------------------------------------------*/
++-/* Private define ------------------------------------------------------------*/
++-/* The time to block waiting for input. */
++-#define TIME_WAITING_FOR_INPUT                 ( 100 )
++-/* Stack size of the interface thread */
++-#define INTERFACE_THREAD_STACK_SIZE            ( 350 )
++-
++-/* Define those to better describe your network interface. */
++-#define IFNAME0 'e'
++-#define IFNAME1 'n'
++-
++-#define LAN8742A_PHY_ADDRESS            0x00
++-
++-/* Private macro -------------------------------------------------------------*/
++-/* Private variables ---------------------------------------------------------*/
++-
++-#if defined ( __ICCARM__ ) /*!< IAR Compiler */
++-
++-#pragma location=0x2000E000
++-__no_init ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
++-#pragma location=0x2000E100
++-__no_init ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
++-#elif defined ( __CC_ARM   )
++-ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((at(0x2000E000)));/* Ethernet Rx MA Descriptor */
++-ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((at(0x2000E100)));/* Ethernet Tx DMA Descriptor */
++-#elif defined ( __GNUC__   )
++-//ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".RxDescripSection")));/* Ethernet Rx MA Descriptor */
++-//ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".TxDescripSection")));/* Ethernet Tx DMA Descriptor */
++-ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Rx MA Descriptor */
++-ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Tx DMA Descriptor */
++-
++-
++-#endif
++-#if defined ( __ICCARM__ ) /*!< IAR Compiler */
++-#pragma location=0x2000E200
++-__no_init uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
++-#pragma location=0x2000FFC4
++-__no_init uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
++-#elif defined ( __CC_ARM   )
++-uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((at(0x2000E200)));  /* Ethernet Receive Buffer */
++-uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]  __attribute__((at(0x2000FFC4))); /* Ethernet Transmit Buffer */
++-#elif defined ( __GNUC__   )
++-//uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".RxBUF")));/* Ethernet Receive Buffer */
++-//uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".TxBUF")));/* Ethernet Transmit Buffer */
++-uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Receive Buffer */
++-uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Transmit Buffer */
++-
++-#endif
++-/* Semaphore to signal incoming packets */
++-osSemaphoreId s_xSemaphore = NULL;
++-
++-/* Global Ethernet handle*/
++-ETH_HandleTypeDef EthHandle;
++-
++-/* Private function prototypes -----------------------------------------------*/
++-static void ethernetif_input( void const * argument );
++-
++-static void stm32f_ethernet_isr(
++-  void* argData
++-)
++-{
++-  ETH_HandleTypeDef* pEth =
++-    (ETH_HandleTypeDef*) argData;
++-
++-  HAL_ETH_IRQHandler(pEth);
++-}
++-
++-/* Private functions ---------------------------------------------------------*/
++-/*******************************************************************************
++-                       Ethernet MSP Routines
++-*******************************************************************************/
++-/**
++-  * @brief  Initializes the ETH MSP.
++-  * @param  heth: ETH handle
++-  * @retval None
++-  */
++-void HAL_ETH_MspInit(ETH_HandleTypeDef *heth)
++-{
++-  GPIO_InitTypeDef GPIO_InitStructure;
++-  
++-  /* Enable GPIOs clocks */
++-  __HAL_RCC_GPIOA_CLK_ENABLE();
++-  __HAL_RCC_GPIOC_CLK_ENABLE();
++-  __HAL_RCC_GPIOG_CLK_ENABLE();
++-
++-/* Ethernet pins configuration ************************************************/
++-  /*
++-        RMII_REF_CLK ----------------------> PA1
++-        RMII_MDIO -------------------------> PA2
++-        RMII_MDC --------------------------> PC1
++-        RMII_MII_CRS_DV -------------------> PA7
++-        RMII_MII_RXD0 ---------------------> PC4
++-        RMII_MII_RXD1 ---------------------> PC5
++-        RMII_MII_RXER ---------------------> PG2
++-        RMII_MII_TX_EN --------------------> PG11
++-        RMII_MII_TXD0 ---------------------> PG13
++-        RMII_MII_TXD1 ---------------------> PG14
++-  */
++-
++-  /* Configure PA1, PA2 and PA7 */
++-  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
++-  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
++-  GPIO_InitStructure.Pull = GPIO_NOPULL; 
++-  GPIO_InitStructure.Alternate = GPIO_AF11_ETH;
++-  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
++-  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
++-  
++-  /* Configure PC1, PC4 and PC5 */
++-  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;
++-  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
++-
++-  /* Configure PG2, PG11, PG13 and PG14 */
++-  GPIO_InitStructure.Pin =  GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14;
++-  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
++-  
++-  // Install HAL Ethernet ISR
++-  rtems_interrupt_handler_install(
++-    ETH_IRQn,
++-    NULL,
++-    0,
++-    stm32f_ethernet_isr,
++-    heth);
++-  
++-  /* Enable ETHERNET clock  */
++-  __HAL_RCC_ETH_CLK_ENABLE();
++-}
++-
++-/**
++-  * @brief  Ethernet Rx Transfer completed callback
++-  * @param  heth: ETH handle
++-  * @retval None
++-  */
++-void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
++-{
++-  osSemaphoreRelease(s_xSemaphore);
++-}
++-
++-/**
++-  * @brief  Ethernet IRQ Handler
++-  * @param  None
++-  * @retval None
++-  */
++-void ETHERNET_IRQHandler(void)
++-{
++-  HAL_ETH_IRQHandler(&EthHandle);
++-}
++-
++-/*******************************************************************************
++-                       LL Driver Interface ( LwIP stack --> ETH) 
++-*******************************************************************************/
++-/**
++-  * @brief In this function, the hardware should be initialized.
++-  * Called from ethernetif_init().
++-  *
++-  * @param netif the already initialized lwip network interface structure
++-  *        for this ethernetif
++-  */
++-static void low_level_init(struct netif *netif)
++-{
++-  uint8_t macaddress[6]= { MAC_ADDR0, MAC_ADDR1, MAC_ADDR2, MAC_ADDR3, MAC_ADDR4, MAC_ADDR5 };
++-  
++-  EthHandle.Instance = ETH;  
++-  EthHandle.Init.MACAddr = macaddress;
++-  EthHandle.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
++-  EthHandle.Init.Speed = ETH_SPEED_100M;
++-  EthHandle.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
++-  EthHandle.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
++-  EthHandle.Init.RxMode = ETH_RXINTERRUPT_MODE;
++-  EthHandle.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
++-  EthHandle.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
++-  
++-  /* configure ethernet peripheral (GPIOs, clocks, MAC, DMA) */
++-  if (HAL_ETH_Init(&EthHandle) == HAL_OK)
++-  {
++-    /* Set netif link flag */
++-    netif->flags |= NETIF_FLAG_LINK_UP;
++-  }
++-  
++-  /* Initialize Tx Descriptors list: Chain Mode */
++-  HAL_ETH_DMATxDescListInit(&EthHandle, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
++-     
++-  /* Initialize Rx Descriptors list: Chain Mode  */
++-  HAL_ETH_DMARxDescListInit(&EthHandle, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
++-  
++-  /* set netif MAC hardware address length */
++-  netif->hwaddr_len = ETHARP_HWADDR_LEN;
++-
++-  /* set netif MAC hardware address */
++-  netif->hwaddr[0] =  MAC_ADDR0;
++-  netif->hwaddr[1] =  MAC_ADDR1;
++-  netif->hwaddr[2] =  MAC_ADDR2;
++-  netif->hwaddr[3] =  MAC_ADDR3;
++-  netif->hwaddr[4] =  MAC_ADDR4;
++-  netif->hwaddr[5] =  MAC_ADDR5;
++-
++-  /* set netif maximum transfer unit */
++-  netif->mtu = 1500;
++-
++-  /* Accept broadcast address and ARP traffic */
++-  netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
++-
++-  /* create a binary semaphore used for informing ethernetif of frame reception */
++-  osSemaphoreDef(SEM);
++-  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1 );
++-
++-  /* create the task that handles the ETH_MAC */
++-  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
++-  osThreadCreate (osThread(EthIf), netif);
++-
++-  /* Enable MAC and DMA transmission and reception */
++-  HAL_ETH_Start(&EthHandle);
++-}
++-
++-
++-/**
++-  * @brief This function should do the actual transmission of the packet. The packet is
++-  * contained in the pbuf that is passed to the function. This pbuf
++-  * might be chained.
++-  *
++-  * @param netif the lwip network interface structure for this ethernetif
++-  * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
++-  * @return ERR_OK if the packet could be sent
++-  *         an err_t value if the packet couldn't be sent
++-  *
++-  * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
++-  *       strange results. You might consider waiting for space in the DMA queue
++-  *       to become available since the stack doesn't retry to send a packet
++-  *       dropped because of memory failure (except for the TCP timers).
++-  */
++-static err_t low_level_output(struct netif *netif, struct pbuf *p)
++-{
++-  err_t errval;
++-  struct pbuf *q;
++-  uint8_t *buffer = (uint8_t *)(EthHandle.TxDesc->Buffer1Addr);
++-  __IO ETH_DMADescTypeDef *DmaTxDesc;
++-  uint32_t framelength = 0;
++-  uint32_t bufferoffset = 0;
++-  uint32_t byteslefttocopy = 0;
++-  uint32_t payloadoffset = 0;
++-
++-  DmaTxDesc = EthHandle.TxDesc;
++-  bufferoffset = 0;
++-  
++-  /* copy frame from pbufs to driver buffers */
++-  for(q = p; q != NULL; q = q->next)
++-  {
++-    /* Is this buffer available? If not, goto error */
++-    if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
++-    {
++-      errval = ERR_USE;
++-      goto error;
++-    }
++-    
++-    /* Get bytes in current lwIP buffer */
++-    byteslefttocopy = q->len;
++-    payloadoffset = 0;
++-    
++-    /* Check if the length of data to copy is bigger than Tx buffer size*/
++-    while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
++-    {
++-      /* Copy data to Tx buffer*/
++-      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
++-      
++-      /* Point to next descriptor */
++-      DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
++-      
++-      /* Check if the buffer is available */
++-      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
++-      {
++-        errval = ERR_USE;
++-        goto error;
++-      }
++-      
++-      buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
++-      
++-      byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
++-      payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
++-      framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
++-      bufferoffset = 0;
++-    }
++-    
++-    /* Copy the remaining bytes */
++-    memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
++-    bufferoffset = bufferoffset + byteslefttocopy;
++-    framelength = framelength + byteslefttocopy;
++-  }
++-  
++-  /* Prepare transmit descriptors to give to DMA */ 
++-  HAL_ETH_TransmitFrame(&EthHandle, framelength);
++-  
++-  errval = ERR_OK;
++-  
++-error:
++-  
++-  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
++-  if ((EthHandle.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
++-  {
++-    /* Clear TUS ETHERNET DMA flag */
++-    EthHandle.Instance->DMASR = ETH_DMASR_TUS;
++-    
++-    /* Resume DMA transmission*/
++-    EthHandle.Instance->DMATPDR = 0;
++-  }
++-  return errval;
++-}
++-
++-/**
++-  * @brief Should allocate a pbuf and transfer the bytes of the incoming
++-  * packet from the interface into the pbuf.
++-  *
++-  * @param netif the lwip network interface structure for this ethernetif
++-  * @return a pbuf filled with the received packet (including MAC header)
++-  *         NULL on memory error
++-  */
++-static struct pbuf * low_level_input(struct netif *netif)
++-{
++-  struct pbuf *p = NULL, *q = NULL;
++-  uint16_t len = 0;
++-  uint8_t *buffer;
++-  __IO ETH_DMADescTypeDef *dmarxdesc;
++-  uint32_t bufferoffset = 0;
++-  uint32_t payloadoffset = 0;
++-  uint32_t byteslefttocopy = 0;
++-  uint32_t i=0;
++-  
++-  /* get received frame */
++-  if(HAL_ETH_GetReceivedFrame_IT(&EthHandle) != HAL_OK)
++-    return NULL;
++-  
++-  /* Obtain the size of the packet and put it into the "len" variable. */
++-  len = EthHandle.RxFrameInfos.length;
++-  buffer = (uint8_t *)EthHandle.RxFrameInfos.buffer;
++-  
++-  if (len > 0)
++-  {
++-    /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
++-    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
++-  }
++-  
++-  if (p != NULL)
++-  {
++-    dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
++-    bufferoffset = 0;
++-    
++-    for(q = p; q != NULL; q = q->next)
++-    {
++-      byteslefttocopy = q->len;
++-      payloadoffset = 0;
++-      
++-      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size */
++-      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
++-      {
++-        /* Copy data to pbuf */
++-        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
++-        
++-        /* Point to next descriptor */
++-        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
++-        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
++-        
++-        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
++-        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
++-        bufferoffset = 0;
++-      }
++-      
++-      /* Copy remaining data in pbuf */
++-      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
++-      bufferoffset = bufferoffset + byteslefttocopy;
++-    }
++-  }
++-    
++-  /* Release descriptors to DMA */
++-  /* Point to first descriptor */
++-  dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
++-  /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
++-  for (i=0; i< EthHandle.RxFrameInfos.SegCount; i++)
++-  {  
++-    dmarxdesc->Status |= ETH_DMARXDESC_OWN;
++-    dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
++-  }
++-    
++-  /* Clear Segment_Count */
++-  EthHandle.RxFrameInfos.SegCount =0;
++-  
++-  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
++-  if ((EthHandle.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
++-  {
++-    /* Clear RBUS ETHERNET DMA flag */
++-    EthHandle.Instance->DMASR = ETH_DMASR_RBUS;
++-    /* Resume DMA reception */
++-    EthHandle.Instance->DMARPDR = 0;
++-  }
++-  return p;
++-}
++-
++-/**
++-  * @brief This function is the ethernetif_input task, it is processed when a packet 
++-  * is ready to be read from the interface. It uses the function low_level_input() 
++-  * that should handle the actual reception of bytes from the network
++-  * interface. Then the type of the received packet is determined and
++-  * the appropriate input function is called.
++-  *
++-  * @param netif the lwip network interface structure for this ethernetif
++-  */
++-void ethernetif_input( void const * argument )
++-{
++-  struct pbuf *p;
++-  struct netif *netif = (struct netif *) argument;
++-  
++-  for( ;; )
++-  {
++-    if (osSemaphoreWait( s_xSemaphore, TIME_WAITING_FOR_INPUT)==osOK)
++-    {
++-      do
++-      {
++-        p = low_level_input( netif );
++-        if (p != NULL)
++-        {
++-          if (netif->input( p, netif) != ERR_OK )
++-          {
++-            pbuf_free(p);
++-          }
++-        }
++-      }while(p!=NULL);
++-    }
++-  }
++-}
++-
++-/**
++-  * @brief Should be called at the beginning of the program to set up the
++-  * network interface. It calls the function low_level_init() to do the
++-  * actual setup of the hardware.
++-  *
++-  * This function should be passed as a parameter to netif_add().
++-  *
++-  * @param netif the lwip network interface structure for this ethernetif
++-  * @return ERR_OK if the loopif is initialized
++-  *         ERR_MEM if private data couldn't be allocated
++-  *         any other err_t on error
++-  */
++-err_t ethernetif_init(struct netif *netif)
++-{
++-  LWIP_ASSERT("netif != NULL", (netif != NULL));
++-
++-#if LWIP_NETIF_HOSTNAME
++-  /* Initialize interface hostname */
++-  netif->hostname = "lwip";
++-#endif /* LWIP_NETIF_HOSTNAME */
++-
++-  netif->name[0] = IFNAME0;
++-  netif->name[1] = IFNAME1;
++-
++-  netif->output = etharp_output;
++-  netif->linkoutput = low_level_output;
++-
++-  /* initialize the hardware */
++-  low_level_init(netif);
++-
++-  return ERR_OK;
++-}
++-
++-/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
++-- 
++1.9.1
++
++
++From 8f652ac0f1be0f2abc1493981763fc4c402bbfed Mon Sep 17 00:00:00 2001
++From: Jay Doyle <jay.doyle@vecna.com>
++Date: Wed, 16 Sep 2015 09:29:27 -0400
++Subject: [PATCH 09/13] using options from sample project
++
++---
++ ports/include/lwipopts.h | 207 +++++++++++++++++++++++++++++++++++++++++++++++
++ 1 file changed, 207 insertions(+)
++
++diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
++index 169ba46..68d799b 100644
++--- a/ports/include/lwipopts.h
+++++ b/ports/include/lwipopts.h
++@@ -38,6 +38,9 @@
++ #ifndef __LWIPOPTS_H__
++ #define __LWIPOPTS_H__
++ 
+++
+++#if ORIGINAL_CONFIG_OPTIONS
+++
++ /*****************************************************************************
++ **                           CONFIGURATIONS
++ *****************************************************************************/
++@@ -175,4 +178,208 @@
++ 
++  #define LWIP_RAW                       0
++ 
+++#else
+++
+++/**
+++ * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
+++ * critical regions during buffer allocation, deallocation and memory
+++ * allocation and deallocation.
+++ */
+++#define SYS_LIGHTWEIGHT_PROT    0
+++
+++#define ETHARP_TRUST_IP_MAC     0
+++#define IP_REASSEMBLY           0
+++#define IP_FRAG                 0
+++#define ARP_QUEUEING            0
+++#define TCP_LISTEN_BACKLOG      1
+++
+++/**
+++ * NO_SYS==1: Provides VERY minimal functionality. Otherwise,
+++ * use lwIP facilities.
+++ */
+++#define NO_SYS                  0
+++
+++/* ---------- Memory options ---------- */
+++/* MEM_ALIGNMENT: should be set to the alignment of the CPU for which
+++   lwIP is compiled. 4 byte alignment -> define MEM_ALIGNMENT to 4, 2
+++   byte alignment -> define MEM_ALIGNMENT to 2. */
+++#define MEM_ALIGNMENT           4
+++
+++/* MEM_SIZE: the size of the heap memory. If the application will send
+++a lot of data that needs to be copied, this should be set high. */
+++#define MEM_SIZE                (10*1024)
+++
+++/* MEMP_NUM_PBUF: the number of memp struct pbufs. If the application
+++   sends a lot of data out of ROM (or other static memory), this
+++   should be set high. */
+++#define MEMP_NUM_PBUF           50
+++/* MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks. One
+++   per active UDP "connection". */
+++#define MEMP_NUM_UDP_PCB        6
+++/* MEMP_NUM_TCP_PCB: the number of simulatenously active TCP
+++   connections. */
+++#define MEMP_NUM_TCP_PCB        10
+++/* MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP
+++   connections. */
+++#define MEMP_NUM_TCP_PCB_LISTEN 5
+++/* MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP
+++   segments. */
+++#define MEMP_NUM_TCP_SEG        12
+++/* MEMP_NUM_SYS_TIMEOUT: the number of simulateously active
+++   timeouts. */
+++#define MEMP_NUM_SYS_TIMEOUT    10
+++
+++
+++/* ---------- Pbuf options ---------- */
+++/* PBUF_POOL_SIZE: the number of buffers in the pbuf pool. */
+++#define PBUF_POOL_SIZE          10
+++
+++/* PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. */
+++#define PBUF_POOL_BUFSIZE       1524
+++
+++
+++/* ---------- TCP options ---------- */
+++#define LWIP_TCP                1
+++#define TCP_TTL                 255
+++
+++/* Controls if TCP should queue segments that arrive out of
+++   order. Define to 0 if your device is low on memory. */
+++#define TCP_QUEUE_OOSEQ         0
+++
+++/* TCP Maximum segment size. */
+++#define TCP_MSS                 (1500 - 40)   /* TCP_MSS = (Ethernet MTU - IP header size - TCP header size) */
+++
+++/* TCP sender buffer space (bytes). */
+++#define TCP_SND_BUF             (4*TCP_MSS)
+++
+++/*  TCP_SND_QUEUELEN: TCP sender buffer space (pbufs). This must be at least
+++  as much as (2 * TCP_SND_BUF/TCP_MSS) for things to work. */
+++
+++#define TCP_SND_QUEUELEN        (2* TCP_SND_BUF/TCP_MSS)
+++
+++/* TCP receive window. */
+++#define TCP_WND                 (2*TCP_MSS)
+++
+++
+++/* ---------- ICMP options ---------- */
+++#define LWIP_ICMP                       1
+++
+++
+++/* ---------- DHCP options ---------- */
+++/* Define LWIP_DHCP to 1 if you want DHCP configuration of
+++   interfaces. DHCP is not implemented in lwIP 0.5.1, however, so
+++   turning this on does currently not work. */
+++#define LWIP_DHCP               1
+++
+++
+++/* ---------- UDP options ---------- */
+++#define LWIP_UDP                1
+++#define UDP_TTL                 255
+++
+++
+++/* ---------- Statistics options ---------- */
+++#define LWIP_STATS 0
+++#define LWIP_PROVIDE_ERRNO 1
+++
+++/* ---------- link callback options ---------- */
+++/* LWIP_NETIF_LINK_CALLBACK==1: Support a callback function from an interface
+++ * whenever the link changes (i.e., link down)
+++ */
+++#define LWIP_NETIF_LINK_CALLBACK        1
+++
+++/*
+++   --------------------------------------
+++   ---------- Checksum options ----------
+++   --------------------------------------
+++*/
+++
+++/*
+++The STM32F4x7 allows computing and verifying the IP, UDP, TCP and ICMP checksums by hardware:
+++ - To use this feature let the following define uncommented.
+++ - To disable it and process by CPU comment the  the checksum.
+++*/
+++#define CHECKSUM_BY_HARDWARE
+++
+++
+++#ifdef CHECKSUM_BY_HARDWARE
+++  /* CHECKSUM_GEN_IP==0: Generate checksums by hardware for outgoing IP packets.*/
+++  #define CHECKSUM_GEN_IP                 0
+++  /* CHECKSUM_GEN_UDP==0: Generate checksums by hardware for outgoing UDP packets.*/
+++  #define CHECKSUM_GEN_UDP                0
+++  /* CHECKSUM_GEN_TCP==0: Generate checksums by hardware for outgoing TCP packets.*/
+++  #define CHECKSUM_GEN_TCP                0
+++  /* CHECKSUM_CHECK_IP==0: Check checksums by hardware for incoming IP packets.*/
+++  #define CHECKSUM_CHECK_IP               0
+++  /* CHECKSUM_CHECK_UDP==0: Check checksums by hardware for incoming UDP packets.*/
+++  #define CHECKSUM_CHECK_UDP              0
+++  /* CHECKSUM_CHECK_TCP==0: Check checksums by hardware for incoming TCP packets.*/
+++  #define CHECKSUM_CHECK_TCP              0
+++  /* CHECKSUM_CHECK_ICMP==0: Check checksums by hardware for incoming ICMP packets.*/
+++  #define CHECKSUM_GEN_ICMP               0
+++#else
+++  /* CHECKSUM_GEN_IP==1: Generate checksums in software for outgoing IP packets.*/
+++  #define CHECKSUM_GEN_IP                 1
+++  /* CHECKSUM_GEN_UDP==1: Generate checksums in software for outgoing UDP packets.*/
+++  #define CHECKSUM_GEN_UDP                1
+++  /* CHECKSUM_GEN_TCP==1: Generate checksums in software for outgoing TCP packets.*/
+++  #define CHECKSUM_GEN_TCP                1
+++  /* CHECKSUM_CHECK_IP==1: Check checksums in software for incoming IP packets.*/
+++  #define CHECKSUM_CHECK_IP               1
+++  /* CHECKSUM_CHECK_UDP==1: Check checksums in software for incoming UDP packets.*/
+++  #define CHECKSUM_CHECK_UDP              1
+++  /* CHECKSUM_CHECK_TCP==1: Check checksums in software for incoming TCP packets.*/
+++  #define CHECKSUM_CHECK_TCP              1
+++  /* CHECKSUM_CHECK_ICMP==1: Check checksums by hardware for incoming ICMP packets.*/
+++  #define CHECKSUM_GEN_ICMP               1
+++#endif
+++
+++
+++/*
+++   ----------------------------------------------
+++   ---------- Sequential layer options ----------
+++   ----------------------------------------------
+++*/
+++/**
+++ * LWIP_NETCONN==1: Enable Netconn API (require to use api_lib.c)
+++ */
+++#define LWIP_NETCONN                    1
+++
+++/*
+++   ------------------------------------
+++   ---------- Socket options ----------
+++   ------------------------------------
+++*/
+++/**
+++ * LWIP_SOCKET==1: Enable Socket API (require to use sockets.c)
+++ */
+++#define LWIP_SOCKET                     1
+++
+++/*
+++   -----------------------------------
+++   ---------- DEBUG options ----------
+++   -----------------------------------
+++*/
+++
+++#define LWIP_DEBUG                      0
+++
+++
+++/*
+++   ---------------------------------
+++   ---------- OS options ----------
+++   ---------------------------------
+++*/
+++
+++#define TCPIP_THREAD_NAME              "TCP/IP"
+++#define TCPIP_THREAD_STACKSIZE          1000
+++#define TCPIP_MBOX_SIZE                 5
+++#define DEFAULT_UDP_RECVMBOX_SIZE       2000
+++#define DEFAULT_TCP_RECVMBOX_SIZE       2000
+++#define DEFAULT_ACCEPTMBOX_SIZE         2000
+++#define DEFAULT_THREAD_STACKSIZE        500
+++#define TCPIP_THREAD_PRIO               (configMAX_PRIORITIES - 2)
+++#define LWIP_COMPAT_MUTEX               1
+++
+++
+++#endif
+++
++ #endif /* __LWIPOPTS_H__ */
++-- 
++1.9.1
++
++
++From d2624890161b1ec246cd224de8079157367a6346 Mon Sep 17 00:00:00 2001
++From: Jay Doyle <jay.doyle@vecna.com>
++Date: Wed, 16 Sep 2015 10:01:58 -0400
++Subject: [PATCH 10/13] added cache line configuration
++
++---
++ ports/include/lwipopts.h | 3 +++
++ 1 file changed, 3 insertions(+)
++
++diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
++index 68d799b..049d66d 100644
++--- a/ports/include/lwipopts.h
+++++ b/ports/include/lwipopts.h
++@@ -180,6 +180,9 @@
++ 
++ #else
++ 
+++#define LWIP_CACHE_ENABLED
+++#define SOC_CACHELINE_SIZE_BYTES 32
+++
++ /**
++  * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
++  * critical regions during buffer allocation, deallocation and memory
++-- 
++1.9.1
++
++
++From 37e5b73c865357e530226ea2a2008aa355f58d55 Mon Sep 17 00:00:00 2001
++From: Jay Doyle <jay.doyle@vecna.com>
++Date: Wed, 16 Sep 2015 10:11:20 -0400
++Subject: [PATCH 11/13] configured for local time structure definition
++
++---
++ ports/include/arch/cc.h  | 2 ++
++ ports/include/lwipopts.h | 1 +
++ 2 files changed, 3 insertions(+)
++
++diff --git a/ports/include/arch/cc.h b/ports/include/arch/cc.h
++index 04ec89f..900e9b6 100644
++--- a/ports/include/arch/cc.h
+++++ b/ports/include/arch/cc.h
++@@ -32,6 +32,8 @@
++ #ifndef __CC_H__
++ #define __CC_H__
++ 
+++#include <sys/time.h>
+++
++ typedef unsigned    char    u8_t;
++ typedef signed      char    s8_t;
++ typedef unsigned    short   u16_t;
++diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
++index 049d66d..05f5b52 100644
++--- a/ports/include/lwipopts.h
+++++ b/ports/include/lwipopts.h
++@@ -182,6 +182,7 @@
++ 
++ #define LWIP_CACHE_ENABLED
++ #define SOC_CACHELINE_SIZE_BYTES 32
+++#define LWIP_TIMEVAL_PRIVATE 0
++ 
++ /**
++  * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
++-- 
++1.9.1
++
++
++From 9a72a789d145f794b8a4c1084ed50597b71c6e2b Mon Sep 17 00:00:00 2001
++From: Jay Doyle <jay.doyle@vecna.com>
++Date: Wed, 16 Sep 2015 10:16:55 -0400
++Subject: [PATCH 12/13] remove include from cc.h
++
++---
++ ports/include/arch/cc.h | 4 ++--
++ 1 file changed, 2 insertions(+), 2 deletions(-)
++
++diff --git a/ports/include/arch/cc.h b/ports/include/arch/cc.h
++index 900e9b6..8eefd64 100644
++--- a/ports/include/arch/cc.h
+++++ b/ports/include/arch/cc.h
++@@ -32,8 +32,6 @@
++ #ifndef __CC_H__
++ #define __CC_H__
++ 
++-#include <sys/time.h>
++-
++ typedef unsigned    char    u8_t;
++ typedef signed      char    s8_t;
++ typedef unsigned    short   u16_t;
++@@ -104,6 +102,8 @@ extern u8_t memp_memory_PBUF_POOL_base[] __attribute__ ((aligned (SOC_CACHELINE_
++ #include <stdio.h>
++ #include <stdlib.h>
++ #include <bsp.h>
+++//#include <sys/time.h>
+++
++ #define LWIP_PLATFORM_DIAG(x)   do { \
++         printk("[%s - %s - %d] ", __PRETTY_FUNCTION__, __FILE__, __LINE__); \
++         printk x; \
++-- 
++1.9.1
++
++
++From a48846deb25945d360543ffe8d86766d323b9859 Mon Sep 17 00:00:00 2001
++From: Jay Doyle <jay.doyle@vecna.com>
++Date: Fri, 18 Sep 2015 13:22:21 -0400
++Subject: [PATCH 13/13] turn off checksum checking by hardware
++
++---
++ ports/include/lwipopts.h | 6 +++---
++ 1 file changed, 3 insertions(+), 3 deletions(-)
++
++diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
++index 05f5b52..cf11793 100644
++--- a/ports/include/lwipopts.h
+++++ b/ports/include/lwipopts.h
++@@ -243,8 +243,8 @@ a lot of data that needs to be copied, this should be set high. */
++ 
++ 
++ /* ---------- TCP options ---------- */
++-#define LWIP_TCP                1
++-#define TCP_TTL                 255
+++//#define LWIP_TCP                1
+++//#define TCP_TTL                 255
++ 
++ /* Controls if TCP should queue segments that arrive out of
++    order. Define to 0 if your device is low on memory. */
++@@ -302,7 +302,7 @@ The STM32F4x7 allows computing and verifying the IP, UDP, TCP and ICMP checksums
++  - To use this feature let the following define uncommented.
++  - To disable it and process by CPU comment the  the checksum.
++ */
++-#define CHECKSUM_BY_HARDWARE
+++//#define CHECKSUM_BY_HARDWARE
++ 
++ 
++ #ifdef CHECKSUM_BY_HARDWARE
++-- 
++1.9.1
++
+-- 
+1.9.1
+
+
+From 6fef0eeaefffd939b7dfaed53b6aafaf9060ce55 Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Fri, 18 Sep 2015 13:48:53 -0400
+Subject: [PATCH 15/29] potential fix
+
+---
+ ports/include/lwipopts.h | 2 +-
+ src/core/tcp_out.c       | 3 ++-
+ 2 files changed, 3 insertions(+), 2 deletions(-)
+
+diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
+index e7f344f..ea659b6 100644
+--- a/ports/include/lwipopts.h
++++ b/ports/include/lwipopts.h
+@@ -303,7 +303,7 @@ The STM32F4x7 allows computing and verifying the IP, UDP, TCP and ICMP checksums
+  - To use this feature let the following define uncommented.
+  - To disable it and process by CPU comment the  the checksum.
+ */
+-//#define CHECKSUM_BY_HARDWARE
++#define CHECKSUM_BY_HARDWARE
+ 
+ 
+ #ifdef CHECKSUM_BY_HARDWARE
+diff --git a/src/core/tcp_out.c b/src/core/tcp_out.c
+index 567942e..a3ad274 100644
+--- a/src/core/tcp_out.c
++++ b/src/core/tcp_out.c
+@@ -1260,8 +1260,9 @@ tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
+     seg->tcphdr->chksum = ip_chksum_pseudo(seg->p, IP_PROTO_TCP,
+       seg->p->tot_len, &pcb->local_ip, &pcb->remote_ip);
+ #endif /* TCP_CHECKSUM_ON_COPY */
+-#endif /* CHECKSUM_GEN_TCP */
+   }
++#endif /* CHECKSUM_GEN_TCP */
++
+   TCP_STATS_INC(tcp.xmit);
+ 
+   NETIF_SET_HWADDRHINT(netif, &(pcb->addr_hint));
+-- 
+1.9.1
+
+
+From 18ce710395c4ccc708bdab59c97d3884dc7a054e Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Mon, 28 Sep 2015 13:47:22 -0400
+Subject: [PATCH 16/29] enable BSD sockets naming
+
+---
+ ports/include/lwipopts.h | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
+index ea659b6..a085c41 100644
+--- a/ports/include/lwipopts.h
++++ b/ports/include/lwipopts.h
+@@ -172,7 +172,7 @@
+  * LWIP_COMPAT_SOCKETS==1: Enable BSD-style sockets functions names.
+  * (only used if you use sockets.c)
+  */
+-#define LWIP_COMPAT_SOCKETS             0
++#define LWIP_COMPAT_SOCKETS             1
+ 
+ #define LWIP_TIMEVAL_PRIVATE            0
+ 
+-- 
+1.9.1
+
+
+From 5ce5c5555d9e55504350fd4e4d97122b701a7259 Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Mon, 28 Sep 2015 15:28:28 -0400
+Subject: [PATCH 17/29] corrected cache line size
+
+---
+ ports/include/lwipopts.h | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
+index a085c41..2b218ec 100644
+--- a/ports/include/lwipopts.h
++++ b/ports/include/lwipopts.h
+@@ -53,7 +53,7 @@
+ */
+ /*#define LWIP_CACHE_ENABLED*/
+ 
+-#define SOC_CACHELINE_SIZE_BYTES        64            /* Number of bytes in
++#define SOC_CACHELINE_SIZE_BYTES        32            /* Number of bytes in
+                                                          a cache line */
+ /*
+ ** The timeout for DHCP completion. lwIP library will wait for DHCP
+-- 
+1.9.1
+
+
+From bf475c67310de79d262ca8ad90435d94aaee5e5e Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Mon, 28 Sep 2015 16:21:35 -0400
+Subject: [PATCH 18/29] patch file update
+
+---
+ rtems.patch | 390 ++++--------------------------------------------------------
+ 1 file changed, 21 insertions(+), 369 deletions(-)
+
+diff --git a/rtems.patch b/rtems.patch
+index 9ca8d63..c088510 100644
+--- a/rtems.patch
++++ b/rtems.patch
+@@ -1,7 +1,7 @@
+ From 2d83d4994e578ec339b2b1baef53090bf7a53570 Mon Sep 17 00:00:00 2001
+ From: Jay Doyle <jay.doyle@vecna.com>
+ Date: Fri, 4 Sep 2015 17:28:55 -0400
+-Subject: [PATCH 01/13] rtems changes necessary
++Subject: [PATCH 1/9] rtems changes necessary
+ 
+ ---
+  Makefile                      | 170 +++++++++++
+@@ -1292,7 +1292,7 @@ index 0000000..360a4e2
+ From d053fa836b445b6736bf82d33a33a59055150aa7 Mon Sep 17 00:00:00 2001
+ From: Jay Doyle <jay.doyle@vecna.com>
+ Date: Fri, 4 Sep 2015 17:30:37 -0400
+-Subject: [PATCH 02/13] changed the compiler options
++Subject: [PATCH 2/9] changed the compiler options
+ 
+ ---
+  Makefile | 2 +-
+@@ -1318,7 +1318,7 @@ index 0cbae64..94fcafc 100644
+ From 841adb17430bdb9298dcb6d44ac5dad72e82af80 Mon Sep 17 00:00:00 2001
+ From: Jay Doyle <jay.doyle@vecna.com>
+ Date: Mon, 7 Sep 2015 08:56:58 -0400
+-Subject: [PATCH 03/13] disabled any mention of ipv6
++Subject: [PATCH 3/9] disabled any mention of ipv6
+ 
+ ---
+  Makefile | 6 +++---
+@@ -1362,7 +1362,7 @@ index 94fcafc..6efa141 100644
+ From a653d818348fef0130e6e497eecb0c3a35822df4 Mon Sep 17 00:00:00 2001
+ From: Jay Doyle <jay.doyle@vecna.com>
+ Date: Mon, 7 Sep 2015 09:27:48 -0400
+-Subject: [PATCH 04/13] added in stm32f low-level driver
++Subject: [PATCH 4/9] added in stm32f low-level driver
+ 
+ ---
+  src/netif/ethernetif.c | 709 ++++++++++++++++++++++++++++++-------------------
+@@ -2150,7 +2150,7 @@ index 7982d11..82c85ae 100644
+ From ab97b49d1d41e34fdfdfb457b397c768ee228c9f Mon Sep 17 00:00:00 2001
+ From: Jay Doyle <jay.doyle@vecna.com>
+ Date: Mon, 7 Sep 2015 09:39:20 -0400
+-Subject: [PATCH 05/13] removed ethernetif (it should be in BSP
++Subject: [PATCH 5/9] removed ethernetif (it should be in BSP
+ 
+ ---
+  src/netif/ethernetif.c | 496 -------------------------------------------------
+@@ -2666,7 +2666,7 @@ index 82c85ae..0000000
+ From 31d34fab26b1e3fde99fe7288786725fe5e51b95 Mon Sep 17 00:00:00 2001
+ From: Jay Doyle <jay.doyle@vecna.com>
+ Date: Mon, 7 Sep 2015 10:17:32 -0400
+-Subject: [PATCH 06/13] add low level driver back
++Subject: [PATCH 6/9] add low level driver back
+ 
+ ---
+  src/netif/ethernetif.c | 496 +++++++++++++++++++++++++++++++++++++++++++++++++
+@@ -3182,7 +3182,7 @@ index 0000000..bc429e9
+ From 81eded01bb2bc35a9b627e5cf35b2021efb5972c Mon Sep 17 00:00:00 2001
+ From: Jay Doyle <jay.doyle@vecna.com>
+ Date: Mon, 7 Sep 2015 10:22:57 -0400
+-Subject: [PATCH 07/13] Added bsp path
++Subject: [PATCH 7/9] Added bsp path
+ 
+ ---
+  Makefile | 4 +++-
+@@ -3217,7 +3217,7 @@ index 6efa141..a855d9f 100644
+ From f114529d5af1e2a83b49b67d631b10c02648e8d8 Mon Sep 17 00:00:00 2001
+ From: Jay Doyle <jay.doyle@vecna.com>
+ Date: Mon, 7 Sep 2015 10:54:26 -0400
+-Subject: [PATCH 08/13] removed ethernetif.c
++Subject: [PATCH 8/9] removed ethernetif.c
+ 
+ ---
+  src/netif/ethernetif.c | 496 -------------------------------------------------
+@@ -3730,376 +3730,28 @@ index bc429e9..0000000
+ 1.9.1
+ 
+ 
+-From 8f652ac0f1be0f2abc1493981763fc4c402bbfed Mon Sep 17 00:00:00 2001
++From badcd5771d8fa3046a2cd7aa07536c6dcb703891 Mon Sep 17 00:00:00 2001
+ From: Jay Doyle <jay.doyle@vecna.com>
+-Date: Wed, 16 Sep 2015 09:29:27 -0400
+-Subject: [PATCH 09/13] using options from sample project
++Date: Mon, 28 Sep 2015 13:47:22 -0400
++Subject: [PATCH 9/9] enable BSD sockets naming
+ 
+ ---
+- ports/include/lwipopts.h | 207 +++++++++++++++++++++++++++++++++++++++++++++++
+- 1 file changed, 207 insertions(+)
+-
+-diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
+-index 169ba46..68d799b 100644
+---- a/ports/include/lwipopts.h
+-+++ b/ports/include/lwipopts.h
+-@@ -38,6 +38,9 @@
+- #ifndef __LWIPOPTS_H__
+- #define __LWIPOPTS_H__
+- 
+-+
+-+#if ORIGINAL_CONFIG_OPTIONS
+-+
+- /*****************************************************************************
+- **                           CONFIGURATIONS
+- *****************************************************************************/
+-@@ -175,4 +178,208 @@
+- 
+-  #define LWIP_RAW                       0
+- 
+-+#else
+-+
+-+/**
+-+ * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
+-+ * critical regions during buffer allocation, deallocation and memory
+-+ * allocation and deallocation.
+-+ */
+-+#define SYS_LIGHTWEIGHT_PROT    0
+-+
+-+#define ETHARP_TRUST_IP_MAC     0
+-+#define IP_REASSEMBLY           0
+-+#define IP_FRAG                 0
+-+#define ARP_QUEUEING            0
+-+#define TCP_LISTEN_BACKLOG      1
+-+
+-+/**
+-+ * NO_SYS==1: Provides VERY minimal functionality. Otherwise,
+-+ * use lwIP facilities.
+-+ */
+-+#define NO_SYS                  0
+-+
+-+/* ---------- Memory options ---------- */
+-+/* MEM_ALIGNMENT: should be set to the alignment of the CPU for which
+-+   lwIP is compiled. 4 byte alignment -> define MEM_ALIGNMENT to 4, 2
+-+   byte alignment -> define MEM_ALIGNMENT to 2. */
+-+#define MEM_ALIGNMENT           4
+-+
+-+/* MEM_SIZE: the size of the heap memory. If the application will send
+-+a lot of data that needs to be copied, this should be set high. */
+-+#define MEM_SIZE                (10*1024)
+-+
+-+/* MEMP_NUM_PBUF: the number of memp struct pbufs. If the application
+-+   sends a lot of data out of ROM (or other static memory), this
+-+   should be set high. */
+-+#define MEMP_NUM_PBUF           50
+-+/* MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks. One
+-+   per active UDP "connection". */
+-+#define MEMP_NUM_UDP_PCB        6
+-+/* MEMP_NUM_TCP_PCB: the number of simulatenously active TCP
+-+   connections. */
+-+#define MEMP_NUM_TCP_PCB        10
+-+/* MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP
+-+   connections. */
+-+#define MEMP_NUM_TCP_PCB_LISTEN 5
+-+/* MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP
+-+   segments. */
+-+#define MEMP_NUM_TCP_SEG        12
+-+/* MEMP_NUM_SYS_TIMEOUT: the number of simulateously active
+-+   timeouts. */
+-+#define MEMP_NUM_SYS_TIMEOUT    10
+-+
+-+
+-+/* ---------- Pbuf options ---------- */
+-+/* PBUF_POOL_SIZE: the number of buffers in the pbuf pool. */
+-+#define PBUF_POOL_SIZE          10
+-+
+-+/* PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. */
+-+#define PBUF_POOL_BUFSIZE       1524
+-+
+-+
+-+/* ---------- TCP options ---------- */
+-+#define LWIP_TCP                1
+-+#define TCP_TTL                 255
+-+
+-+/* Controls if TCP should queue segments that arrive out of
+-+   order. Define to 0 if your device is low on memory. */
+-+#define TCP_QUEUE_OOSEQ         0
+-+
+-+/* TCP Maximum segment size. */
+-+#define TCP_MSS                 (1500 - 40)   /* TCP_MSS = (Ethernet MTU - IP header size - TCP header size) */
+-+
+-+/* TCP sender buffer space (bytes). */
+-+#define TCP_SND_BUF             (4*TCP_MSS)
+-+
+-+/*  TCP_SND_QUEUELEN: TCP sender buffer space (pbufs). This must be at least
+-+  as much as (2 * TCP_SND_BUF/TCP_MSS) for things to work. */
+-+
+-+#define TCP_SND_QUEUELEN        (2* TCP_SND_BUF/TCP_MSS)
+-+
+-+/* TCP receive window. */
+-+#define TCP_WND                 (2*TCP_MSS)
+-+
+-+
+-+/* ---------- ICMP options ---------- */
+-+#define LWIP_ICMP                       1
+-+
+-+
+-+/* ---------- DHCP options ---------- */
+-+/* Define LWIP_DHCP to 1 if you want DHCP configuration of
+-+   interfaces. DHCP is not implemented in lwIP 0.5.1, however, so
+-+   turning this on does currently not work. */
+-+#define LWIP_DHCP               1
+-+
+-+
+-+/* ---------- UDP options ---------- */
+-+#define LWIP_UDP                1
+-+#define UDP_TTL                 255
+-+
+-+
+-+/* ---------- Statistics options ---------- */
+-+#define LWIP_STATS 0
+-+#define LWIP_PROVIDE_ERRNO 1
+-+
+-+/* ---------- link callback options ---------- */
+-+/* LWIP_NETIF_LINK_CALLBACK==1: Support a callback function from an interface
+-+ * whenever the link changes (i.e., link down)
+-+ */
+-+#define LWIP_NETIF_LINK_CALLBACK        1
+-+
+-+/*
+-+   --------------------------------------
+-+   ---------- Checksum options ----------
+-+   --------------------------------------
+-+*/
+-+
+-+/*
+-+The STM32F4x7 allows computing and verifying the IP, UDP, TCP and ICMP checksums by hardware:
+-+ - To use this feature let the following define uncommented.
+-+ - To disable it and process by CPU comment the  the checksum.
+-+*/
+-+#define CHECKSUM_BY_HARDWARE
+-+
+-+
+-+#ifdef CHECKSUM_BY_HARDWARE
+-+  /* CHECKSUM_GEN_IP==0: Generate checksums by hardware for outgoing IP packets.*/
+-+  #define CHECKSUM_GEN_IP                 0
+-+  /* CHECKSUM_GEN_UDP==0: Generate checksums by hardware for outgoing UDP packets.*/
+-+  #define CHECKSUM_GEN_UDP                0
+-+  /* CHECKSUM_GEN_TCP==0: Generate checksums by hardware for outgoing TCP packets.*/
+-+  #define CHECKSUM_GEN_TCP                0
+-+  /* CHECKSUM_CHECK_IP==0: Check checksums by hardware for incoming IP packets.*/
+-+  #define CHECKSUM_CHECK_IP               0
+-+  /* CHECKSUM_CHECK_UDP==0: Check checksums by hardware for incoming UDP packets.*/
+-+  #define CHECKSUM_CHECK_UDP              0
+-+  /* CHECKSUM_CHECK_TCP==0: Check checksums by hardware for incoming TCP packets.*/
+-+  #define CHECKSUM_CHECK_TCP              0
+-+  /* CHECKSUM_CHECK_ICMP==0: Check checksums by hardware for incoming ICMP packets.*/
+-+  #define CHECKSUM_GEN_ICMP               0
+-+#else
+-+  /* CHECKSUM_GEN_IP==1: Generate checksums in software for outgoing IP packets.*/
+-+  #define CHECKSUM_GEN_IP                 1
+-+  /* CHECKSUM_GEN_UDP==1: Generate checksums in software for outgoing UDP packets.*/
+-+  #define CHECKSUM_GEN_UDP                1
+-+  /* CHECKSUM_GEN_TCP==1: Generate checksums in software for outgoing TCP packets.*/
+-+  #define CHECKSUM_GEN_TCP                1
+-+  /* CHECKSUM_CHECK_IP==1: Check checksums in software for incoming IP packets.*/
+-+  #define CHECKSUM_CHECK_IP               1
+-+  /* CHECKSUM_CHECK_UDP==1: Check checksums in software for incoming UDP packets.*/
+-+  #define CHECKSUM_CHECK_UDP              1
+-+  /* CHECKSUM_CHECK_TCP==1: Check checksums in software for incoming TCP packets.*/
+-+  #define CHECKSUM_CHECK_TCP              1
+-+  /* CHECKSUM_CHECK_ICMP==1: Check checksums by hardware for incoming ICMP packets.*/
+-+  #define CHECKSUM_GEN_ICMP               1
+-+#endif
+-+
+-+
+-+/*
+-+   ----------------------------------------------
+-+   ---------- Sequential layer options ----------
+-+   ----------------------------------------------
+-+*/
+-+/**
+-+ * LWIP_NETCONN==1: Enable Netconn API (require to use api_lib.c)
+-+ */
+-+#define LWIP_NETCONN                    1
+-+
+-+/*
+-+   ------------------------------------
+-+   ---------- Socket options ----------
+-+   ------------------------------------
+-+*/
+-+/**
+-+ * LWIP_SOCKET==1: Enable Socket API (require to use sockets.c)
+-+ */
+-+#define LWIP_SOCKET                     1
+-+
+-+/*
+-+   -----------------------------------
+-+   ---------- DEBUG options ----------
+-+   -----------------------------------
+-+*/
+-+
+-+#define LWIP_DEBUG                      0
+-+
+-+
+-+/*
+-+   ---------------------------------
+-+   ---------- OS options ----------
+-+   ---------------------------------
+-+*/
+-+
+-+#define TCPIP_THREAD_NAME              "TCP/IP"
+-+#define TCPIP_THREAD_STACKSIZE          1000
+-+#define TCPIP_MBOX_SIZE                 5
+-+#define DEFAULT_UDP_RECVMBOX_SIZE       2000
+-+#define DEFAULT_TCP_RECVMBOX_SIZE       2000
+-+#define DEFAULT_ACCEPTMBOX_SIZE         2000
+-+#define DEFAULT_THREAD_STACKSIZE        500
+-+#define TCPIP_THREAD_PRIO               (configMAX_PRIORITIES - 2)
+-+#define LWIP_COMPAT_MUTEX               1
+-+
+-+
+-+#endif
+-+
+- #endif /* __LWIPOPTS_H__ */
+--- 
+-1.9.1
+-
+-
+-From d2624890161b1ec246cd224de8079157367a6346 Mon Sep 17 00:00:00 2001
+-From: Jay Doyle <jay.doyle@vecna.com>
+-Date: Wed, 16 Sep 2015 10:01:58 -0400
+-Subject: [PATCH 10/13] added cache line configuration
+-
+----
+- ports/include/lwipopts.h | 3 +++
+- 1 file changed, 3 insertions(+)
+-
+-diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
+-index 68d799b..049d66d 100644
+---- a/ports/include/lwipopts.h
+-+++ b/ports/include/lwipopts.h
+-@@ -180,6 +180,9 @@
+- 
+- #else
+- 
+-+#define LWIP_CACHE_ENABLED
+-+#define SOC_CACHELINE_SIZE_BYTES 32
+-+
+- /**
+-  * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
+-  * critical regions during buffer allocation, deallocation and memory
+--- 
+-1.9.1
+-
+-
+-From 37e5b73c865357e530226ea2a2008aa355f58d55 Mon Sep 17 00:00:00 2001
+-From: Jay Doyle <jay.doyle@vecna.com>
+-Date: Wed, 16 Sep 2015 10:11:20 -0400
+-Subject: [PATCH 11/13] configured for local time structure definition
+-
+----
+- ports/include/arch/cc.h  | 2 ++
+- ports/include/lwipopts.h | 1 +
+- 2 files changed, 3 insertions(+)
+-
+-diff --git a/ports/include/arch/cc.h b/ports/include/arch/cc.h
+-index 04ec89f..900e9b6 100644
+---- a/ports/include/arch/cc.h
+-+++ b/ports/include/arch/cc.h
+-@@ -32,6 +32,8 @@
+- #ifndef __CC_H__
+- #define __CC_H__
+- 
+-+#include <sys/time.h>
+-+
+- typedef unsigned    char    u8_t;
+- typedef signed      char    s8_t;
+- typedef unsigned    short   u16_t;
+-diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
+-index 049d66d..05f5b52 100644
+---- a/ports/include/lwipopts.h
+-+++ b/ports/include/lwipopts.h
+-@@ -182,6 +182,7 @@
+- 
+- #define LWIP_CACHE_ENABLED
+- #define SOC_CACHELINE_SIZE_BYTES 32
+-+#define LWIP_TIMEVAL_PRIVATE 0
+- 
+- /**
+-  * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
+--- 
+-1.9.1
+-
+-
+-From 9a72a789d145f794b8a4c1084ed50597b71c6e2b Mon Sep 17 00:00:00 2001
+-From: Jay Doyle <jay.doyle@vecna.com>
+-Date: Wed, 16 Sep 2015 10:16:55 -0400
+-Subject: [PATCH 12/13] remove include from cc.h
+-
+----
+- ports/include/arch/cc.h | 4 ++--
+- 1 file changed, 2 insertions(+), 2 deletions(-)
+-
+-diff --git a/ports/include/arch/cc.h b/ports/include/arch/cc.h
+-index 900e9b6..8eefd64 100644
+---- a/ports/include/arch/cc.h
+-+++ b/ports/include/arch/cc.h
+-@@ -32,8 +32,6 @@
+- #ifndef __CC_H__
+- #define __CC_H__
+- 
+--#include <sys/time.h>
+--
+- typedef unsigned    char    u8_t;
+- typedef signed      char    s8_t;
+- typedef unsigned    short   u16_t;
+-@@ -104,6 +102,8 @@ extern u8_t memp_memory_PBUF_POOL_base[] __attribute__ ((aligned (SOC_CACHELINE_
+- #include <stdio.h>
+- #include <stdlib.h>
+- #include <bsp.h>
+-+//#include <sys/time.h>
+-+
+- #define LWIP_PLATFORM_DIAG(x)   do { \
+-         printk("[%s - %s - %d] ", __PRETTY_FUNCTION__, __FILE__, __LINE__); \
+-         printk x; \
+--- 
+-1.9.1
+-
+-
+-From a48846deb25945d360543ffe8d86766d323b9859 Mon Sep 17 00:00:00 2001
+-From: Jay Doyle <jay.doyle@vecna.com>
+-Date: Fri, 18 Sep 2015 13:22:21 -0400
+-Subject: [PATCH 13/13] turn off checksum checking by hardware
+-
+----
+- ports/include/lwipopts.h | 6 +++---
+- 1 file changed, 3 insertions(+), 3 deletions(-)
++ ports/include/lwipopts.h | 2 +-
++ 1 file changed, 1 insertion(+), 1 deletion(-)
+ 
+ diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
+-index 05f5b52..cf11793 100644
++index 169ba46..9149c29 100644
+ --- a/ports/include/lwipopts.h
+ +++ b/ports/include/lwipopts.h
+-@@ -243,8 +243,8 @@ a lot of data that needs to be copied, this should be set high. */
+- 
+- 
+- /* ---------- TCP options ---------- */
+--#define LWIP_TCP                1
+--#define TCP_TTL                 255
+-+//#define LWIP_TCP                1
+-+//#define TCP_TTL                 255
+- 
+- /* Controls if TCP should queue segments that arrive out of
+-    order. Define to 0 if your device is low on memory. */
+-@@ -302,7 +302,7 @@ The STM32F4x7 allows computing and verifying the IP, UDP, TCP and ICMP checksums
+-  - To use this feature let the following define uncommented.
+-  - To disable it and process by CPU comment the  the checksum.
+- */
+--#define CHECKSUM_BY_HARDWARE
+-+//#define CHECKSUM_BY_HARDWARE
++@@ -169,7 +169,7 @@
++  * LWIP_COMPAT_SOCKETS==1: Enable BSD-style sockets functions names.
++  * (only used if you use sockets.c)
++  */
++-#define LWIP_COMPAT_SOCKETS             0
+++#define LWIP_COMPAT_SOCKETS             1
+  
++ #define LWIP_TIMEVAL_PRIVATE            0
+  
+- #ifdef CHECKSUM_BY_HARDWARE
+ -- 
+ 1.9.1
+ 
+-- 
+1.9.1
+
+
+From fe6c775ab3ffb3ae4e2f8fa18bec1ad745e9dca2 Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Mon, 28 Sep 2015 16:36:49 -0400
+Subject: [PATCH 19/29] updated patch
+
+---
+ rtems.patch | 4184 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-
+ 1 file changed, 4172 insertions(+), 12 deletions(-)
+
+diff --git a/rtems.patch b/rtems.patch
+index c088510..1d3b090 100644
+--- a/rtems.patch
++++ b/rtems.patch
+@@ -1,7 +1,7 @@
+ From 2d83d4994e578ec339b2b1baef53090bf7a53570 Mon Sep 17 00:00:00 2001
+ From: Jay Doyle <jay.doyle@vecna.com>
+ Date: Fri, 4 Sep 2015 17:28:55 -0400
+-Subject: [PATCH 1/9] rtems changes necessary
++Subject: [PATCH 01/10] rtems changes necessary
+ 
+ ---
+  Makefile                      | 170 +++++++++++
+@@ -1292,7 +1292,7 @@ index 0000000..360a4e2
+ From d053fa836b445b6736bf82d33a33a59055150aa7 Mon Sep 17 00:00:00 2001
+ From: Jay Doyle <jay.doyle@vecna.com>
+ Date: Fri, 4 Sep 2015 17:30:37 -0400
+-Subject: [PATCH 2/9] changed the compiler options
++Subject: [PATCH 02/10] changed the compiler options
+ 
+ ---
+  Makefile | 2 +-
+@@ -1318,7 +1318,7 @@ index 0cbae64..94fcafc 100644
+ From 841adb17430bdb9298dcb6d44ac5dad72e82af80 Mon Sep 17 00:00:00 2001
+ From: Jay Doyle <jay.doyle@vecna.com>
+ Date: Mon, 7 Sep 2015 08:56:58 -0400
+-Subject: [PATCH 3/9] disabled any mention of ipv6
++Subject: [PATCH 03/10] disabled any mention of ipv6
+ 
+ ---
+  Makefile | 6 +++---
+@@ -1362,7 +1362,7 @@ index 94fcafc..6efa141 100644
+ From a653d818348fef0130e6e497eecb0c3a35822df4 Mon Sep 17 00:00:00 2001
+ From: Jay Doyle <jay.doyle@vecna.com>
+ Date: Mon, 7 Sep 2015 09:27:48 -0400
+-Subject: [PATCH 4/9] added in stm32f low-level driver
++Subject: [PATCH 04/10] added in stm32f low-level driver
+ 
+ ---
+  src/netif/ethernetif.c | 709 ++++++++++++++++++++++++++++++-------------------
+@@ -2150,7 +2150,7 @@ index 7982d11..82c85ae 100644
+ From ab97b49d1d41e34fdfdfb457b397c768ee228c9f Mon Sep 17 00:00:00 2001
+ From: Jay Doyle <jay.doyle@vecna.com>
+ Date: Mon, 7 Sep 2015 09:39:20 -0400
+-Subject: [PATCH 5/9] removed ethernetif (it should be in BSP
++Subject: [PATCH 05/10] removed ethernetif (it should be in BSP
+ 
+ ---
+  src/netif/ethernetif.c | 496 -------------------------------------------------
+@@ -2666,7 +2666,7 @@ index 82c85ae..0000000
+ From 31d34fab26b1e3fde99fe7288786725fe5e51b95 Mon Sep 17 00:00:00 2001
+ From: Jay Doyle <jay.doyle@vecna.com>
+ Date: Mon, 7 Sep 2015 10:17:32 -0400
+-Subject: [PATCH 6/9] add low level driver back
++Subject: [PATCH 06/10] add low level driver back
+ 
+ ---
+  src/netif/ethernetif.c | 496 +++++++++++++++++++++++++++++++++++++++++++++++++
+@@ -3182,7 +3182,7 @@ index 0000000..bc429e9
+ From 81eded01bb2bc35a9b627e5cf35b2021efb5972c Mon Sep 17 00:00:00 2001
+ From: Jay Doyle <jay.doyle@vecna.com>
+ Date: Mon, 7 Sep 2015 10:22:57 -0400
+-Subject: [PATCH 7/9] Added bsp path
++Subject: [PATCH 07/10] Added bsp path
+ 
+ ---
+  Makefile | 4 +++-
+@@ -3217,7 +3217,7 @@ index 6efa141..a855d9f 100644
+ From f114529d5af1e2a83b49b67d631b10c02648e8d8 Mon Sep 17 00:00:00 2001
+ From: Jay Doyle <jay.doyle@vecna.com>
+ Date: Mon, 7 Sep 2015 10:54:26 -0400
+-Subject: [PATCH 8/9] removed ethernetif.c
++Subject: [PATCH 08/10] removed ethernetif.c
+ 
+ ---
+  src/netif/ethernetif.c | 496 -------------------------------------------------
+@@ -3730,20 +3730,256 @@ index bc429e9..0000000
+ 1.9.1
+ 
+ 
+-From badcd5771d8fa3046a2cd7aa07536c6dcb703891 Mon Sep 17 00:00:00 2001
++From 8f652ac0f1be0f2abc1493981763fc4c402bbfed Mon Sep 17 00:00:00 2001
++From: Jay Doyle <jay.doyle@vecna.com>
++Date: Wed, 16 Sep 2015 09:29:27 -0400
++Subject: [PATCH 09/13] using options from sample project
++
++---
++ ports/include/lwipopts.h | 207 +++++++++++++++++++++++++++++++++++++++++++++++
++ 1 file changed, 207 insertions(+)
++
++diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
++index 169ba46..68d799b 100644
++--- a/ports/include/lwipopts.h
+++++ b/ports/include/lwipopts.h
++@@ -38,6 +38,9 @@
++ #ifndef __LWIPOPTS_H__
++ #define __LWIPOPTS_H__
++ 
+++
+++#if ORIGINAL_CONFIG_OPTIONS
+++
++ /*****************************************************************************
++ **                           CONFIGURATIONS
++ *****************************************************************************/
++@@ -175,4 +178,208 @@
++ 
++  #define LWIP_RAW                       0
++ 
+++#else
+++
+++/**
+++ * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
+++ * critical regions during buffer allocation, deallocation and memory
+++ * allocation and deallocation.
+++ */
+++#define SYS_LIGHTWEIGHT_PROT    0
+++
+++#define ETHARP_TRUST_IP_MAC     0
+++#define IP_REASSEMBLY           0
+++#define IP_FRAG                 0
+++#define ARP_QUEUEING            0
+++#define TCP_LISTEN_BACKLOG      1
+++
+++/**
+++ * NO_SYS==1: Provides VERY minimal functionality. Otherwise,
+++ * use lwIP facilities.
+++ */
+++#define NO_SYS                  0
+++
+++/* ---------- Memory options ---------- */
+++/* MEM_ALIGNMENT: should be set to the alignment of the CPU for which
+++   lwIP is compiled. 4 byte alignment -> define MEM_ALIGNMENT to 4, 2
+++   byte alignment -> define MEM_ALIGNMENT to 2. */
+++#define MEM_ALIGNMENT           4
+++
+++/* MEM_SIZE: the size of the heap memory. If the application will send
+++a lot of data that needs to be copied, this should be set high. */
+++#define MEM_SIZE                (10*1024)
+++
+++/* MEMP_NUM_PBUF: the number of memp struct pbufs. If the application
+++   sends a lot of data out of ROM (or other static memory), this
+++   should be set high. */
+++#define MEMP_NUM_PBUF           50
+++/* MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks. One
+++   per active UDP "connection". */
+++#define MEMP_NUM_UDP_PCB        6
+++/* MEMP_NUM_TCP_PCB: the number of simulatenously active TCP
+++   connections. */
+++#define MEMP_NUM_TCP_PCB        10
+++/* MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP
+++   connections. */
+++#define MEMP_NUM_TCP_PCB_LISTEN 5
+++/* MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP
+++   segments. */
+++#define MEMP_NUM_TCP_SEG        12
+++/* MEMP_NUM_SYS_TIMEOUT: the number of simulateously active
+++   timeouts. */
+++#define MEMP_NUM_SYS_TIMEOUT    10
+++
+++
+++/* ---------- Pbuf options ---------- */
+++/* PBUF_POOL_SIZE: the number of buffers in the pbuf pool. */
+++#define PBUF_POOL_SIZE          10
+++
+++/* PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. */
+++#define PBUF_POOL_BUFSIZE       1524
+++
+++
+++/* ---------- TCP options ---------- */
+++#define LWIP_TCP                1
+++#define TCP_TTL                 255
+++
+++/* Controls if TCP should queue segments that arrive out of
+++   order. Define to 0 if your device is low on memory. */
+++#define TCP_QUEUE_OOSEQ         0
+++
+++/* TCP Maximum segment size. */
+++#define TCP_MSS                 (1500 - 40)   /* TCP_MSS = (Ethernet MTU - IP header size - TCP header size) */
+++
+++/* TCP sender buffer space (bytes). */
+++#define TCP_SND_BUF             (4*TCP_MSS)
+++
+++/*  TCP_SND_QUEUELEN: TCP sender buffer space (pbufs). This must be at least
+++  as much as (2 * TCP_SND_BUF/TCP_MSS) for things to work. */
+++
+++#define TCP_SND_QUEUELEN        (2* TCP_SND_BUF/TCP_MSS)
+++
+++/* TCP receive window. */
+++#define TCP_WND                 (2*TCP_MSS)
+++
+++
+++/* ---------- ICMP options ---------- */
+++#define LWIP_ICMP                       1
+++
+++
+++/* ---------- DHCP options ---------- */
+++/* Define LWIP_DHCP to 1 if you want DHCP configuration of
+++   interfaces. DHCP is not implemented in lwIP 0.5.1, however, so
+++   turning this on does currently not work. */
+++#define LWIP_DHCP               1
+++
+++
+++/* ---------- UDP options ---------- */
+++#define LWIP_UDP                1
+++#define UDP_TTL                 255
+++
+++
+++/* ---------- Statistics options ---------- */
+++#define LWIP_STATS 0
+++#define LWIP_PROVIDE_ERRNO 1
+++
+++/* ---------- link callback options ---------- */
+++/* LWIP_NETIF_LINK_CALLBACK==1: Support a callback function from an interface
+++ * whenever the link changes (i.e., link down)
+++ */
+++#define LWIP_NETIF_LINK_CALLBACK        1
+++
+++/*
+++   --------------------------------------
+++   ---------- Checksum options ----------
+++   --------------------------------------
+++*/
+++
+++/*
+++The STM32F4x7 allows computing and verifying the IP, UDP, TCP and ICMP checksums by hardware:
+++ - To use this feature let the following define uncommented.
+++ - To disable it and process by CPU comment the  the checksum.
+++*/
+++#define CHECKSUM_BY_HARDWARE
+++
+++
+++#ifdef CHECKSUM_BY_HARDWARE
+++  /* CHECKSUM_GEN_IP==0: Generate checksums by hardware for outgoing IP packets.*/
+++  #define CHECKSUM_GEN_IP                 0
+++  /* CHECKSUM_GEN_UDP==0: Generate checksums by hardware for outgoing UDP packets.*/
+++  #define CHECKSUM_GEN_UDP                0
+++  /* CHECKSUM_GEN_TCP==0: Generate checksums by hardware for outgoing TCP packets.*/
+++  #define CHECKSUM_GEN_TCP                0
+++  /* CHECKSUM_CHECK_IP==0: Check checksums by hardware for incoming IP packets.*/
+++  #define CHECKSUM_CHECK_IP               0
+++  /* CHECKSUM_CHECK_UDP==0: Check checksums by hardware for incoming UDP packets.*/
+++  #define CHECKSUM_CHECK_UDP              0
+++  /* CHECKSUM_CHECK_TCP==0: Check checksums by hardware for incoming TCP packets.*/
+++  #define CHECKSUM_CHECK_TCP              0
+++  /* CHECKSUM_CHECK_ICMP==0: Check checksums by hardware for incoming ICMP packets.*/
+++  #define CHECKSUM_GEN_ICMP               0
+++#else
+++  /* CHECKSUM_GEN_IP==1: Generate checksums in software for outgoing IP packets.*/
+++  #define CHECKSUM_GEN_IP                 1
+++  /* CHECKSUM_GEN_UDP==1: Generate checksums in software for outgoing UDP packets.*/
+++  #define CHECKSUM_GEN_UDP                1
+++  /* CHECKSUM_GEN_TCP==1: Generate checksums in software for outgoing TCP packets.*/
+++  #define CHECKSUM_GEN_TCP                1
+++  /* CHECKSUM_CHECK_IP==1: Check checksums in software for incoming IP packets.*/
+++  #define CHECKSUM_CHECK_IP               1
+++  /* CHECKSUM_CHECK_UDP==1: Check checksums in software for incoming UDP packets.*/
+++  #define CHECKSUM_CHECK_UDP              1
+++  /* CHECKSUM_CHECK_TCP==1: Check checksums in software for incoming TCP packets.*/
+++  #define CHECKSUM_CHECK_TCP              1
+++  /* CHECKSUM_CHECK_ICMP==1: Check checksums by hardware for incoming ICMP packets.*/
+++  #define CHECKSUM_GEN_ICMP               1
+++#endif
+++
+++
+++/*
+++   ----------------------------------------------
+++   ---------- Sequential layer options ----------
+++   ----------------------------------------------
+++*/
+++/**
+++ * LWIP_NETCONN==1: Enable Netconn API (require to use api_lib.c)
+++ */
+++#define LWIP_NETCONN                    1
+++
+++/*
+++   ------------------------------------
+++   ---------- Socket options ----------
+++   ------------------------------------
+++*/
+++/**
+++ * LWIP_SOCKET==1: Enable Socket API (require to use sockets.c)
+++ */
+++#define LWIP_SOCKET                     1
+++
+++/*
+++   -----------------------------------
+++   ---------- DEBUG options ----------
+++   -----------------------------------
+++*/
+++
+++#define LWIP_DEBUG                      0
+++
+++
+++/*
+++   ---------------------------------
+++   ---------- OS options ----------
+++   ---------------------------------
+++*/
+++
+++#define TCPIP_THREAD_NAME              "TCP/IP"
+++#define TCPIP_THREAD_STACKSIZE          1000
+++#define TCPIP_MBOX_SIZE                 5
+++#define DEFAULT_UDP_RECVMBOX_SIZE       2000
+++#define DEFAULT_TCP_RECVMBOX_SIZE       2000
+++#define DEFAULT_ACCEPTMBOX_SIZE         2000
+++#define DEFAULT_THREAD_STACKSIZE        500
+++#define TCPIP_THREAD_PRIO               (configMAX_PRIORITIES - 2)
+++#define LWIP_COMPAT_MUTEX               1
+++
+++
+++#endif
+++
++ #endif /* __LWIPOPTS_H__ */
++-- 
++1.9.1
++
++
++From c5a4114e1f21fe408301a2e5a8ae3a3f22fdea0f Mon Sep 17 00:00:00 2001
+ From: Jay Doyle <jay.doyle@vecna.com>
+ Date: Mon, 28 Sep 2015 13:47:22 -0400
+-Subject: [PATCH 9/9] enable BSD sockets naming
++Subject: [PATCH 09/10] enable BSD sockets naming
+ 
+ ---
+  ports/include/lwipopts.h | 2 +-
+  1 file changed, 1 insertion(+), 1 deletion(-)
+ 
+ diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
+-index 169ba46..9149c29 100644
++index 68d799b..40170c3 100644
+ --- a/ports/include/lwipopts.h
+ +++ b/ports/include/lwipopts.h
+-@@ -169,7 +169,7 @@
++@@ -172,7 +172,7 @@
+   * LWIP_COMPAT_SOCKETS==1: Enable BSD-style sockets functions names.
+   * (only used if you use sockets.c)
+   */
+@@ -3755,3 +3991,3927 @@ index 169ba46..9149c29 100644
+ -- 
+ 1.9.1
+ 
++
++From db7b9a1f9d9d2cba75a14e49e393c88e199ead20 Mon Sep 17 00:00:00 2001
++Subject: [PATCH 10/10] corrected cache line size
++index 9149c29..7b44db3 100644
++@@ -50,7 +50,7 @@
++-- 
++1.9.1
++
++
++From 35d7bb6c5d762616e71c785143ac2fb3c7c3ae86 Mon Sep 17 00:00:00 2001
++From: Jay Doyle <jay.doyle@vecna.com>
++Date: Mon, 28 Sep 2015 16:21:35 -0400
++Subject: [PATCH 12/13] patch file update
++
++---
++ rtems.patch | 3809 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-
++ 1 file changed, 3800 insertions(+), 9 deletions(-)
++
++diff --git a/rtems.patch b/rtems.patch
++index c088510..3ec5fb0 100644
++--- a/rtems.patch
+++++ b/rtems.patch
++@@ -1,7 +1,7 @@
++ From 2d83d4994e578ec339b2b1baef53090bf7a53570 Mon Sep 17 00:00:00 2001
++ From: Jay Doyle <jay.doyle@vecna.com>
++ Date: Fri, 4 Sep 2015 17:28:55 -0400
++-Subject: [PATCH 1/9] rtems changes necessary
+++Subject: [PATCH 01/10] rtems changes necessary
++ 
++ ---
++  Makefile                      | 170 +++++++++++
++@@ -1292,7 +1292,7 @@ index 0000000..360a4e2
++ From d053fa836b445b6736bf82d33a33a59055150aa7 Mon Sep 17 00:00:00 2001
++ From: Jay Doyle <jay.doyle@vecna.com>
++ Date: Fri, 4 Sep 2015 17:30:37 -0400
++-Subject: [PATCH 2/9] changed the compiler options
+++Subject: [PATCH 02/10] changed the compiler options
++ 
++ ---
++  Makefile | 2 +-
++@@ -1318,7 +1318,7 @@ index 0cbae64..94fcafc 100644
++ From 841adb17430bdb9298dcb6d44ac5dad72e82af80 Mon Sep 17 00:00:00 2001
++ From: Jay Doyle <jay.doyle@vecna.com>
++ Date: Mon, 7 Sep 2015 08:56:58 -0400
++-Subject: [PATCH 3/9] disabled any mention of ipv6
+++Subject: [PATCH 03/10] disabled any mention of ipv6
++ 
++ ---
++  Makefile | 6 +++---
++@@ -1362,7 +1362,7 @@ index 94fcafc..6efa141 100644
++ From a653d818348fef0130e6e497eecb0c3a35822df4 Mon Sep 17 00:00:00 2001
++ From: Jay Doyle <jay.doyle@vecna.com>
++ Date: Mon, 7 Sep 2015 09:27:48 -0400
++-Subject: [PATCH 4/9] added in stm32f low-level driver
+++Subject: [PATCH 04/10] added in stm32f low-level driver
++ 
++ ---
++  src/netif/ethernetif.c | 709 ++++++++++++++++++++++++++++++-------------------
++@@ -2150,7 +2150,7 @@ index 7982d11..82c85ae 100644
++ From ab97b49d1d41e34fdfdfb457b397c768ee228c9f Mon Sep 17 00:00:00 2001
++ From: Jay Doyle <jay.doyle@vecna.com>
++ Date: Mon, 7 Sep 2015 09:39:20 -0400
++-Subject: [PATCH 5/9] removed ethernetif (it should be in BSP
+++Subject: [PATCH 05/10] removed ethernetif (it should be in BSP
++ 
++ ---
++  src/netif/ethernetif.c | 496 -------------------------------------------------
++@@ -2666,7 +2666,7 @@ index 82c85ae..0000000
++ From 31d34fab26b1e3fde99fe7288786725fe5e51b95 Mon Sep 17 00:00:00 2001
++ From: Jay Doyle <jay.doyle@vecna.com>
++ Date: Mon, 7 Sep 2015 10:17:32 -0400
++-Subject: [PATCH 6/9] add low level driver back
+++Subject: [PATCH 06/10] add low level driver back
++ 
++ ---
++  src/netif/ethernetif.c | 496 +++++++++++++++++++++++++++++++++++++++++++++++++
++@@ -3182,7 +3182,7 @@ index 0000000..bc429e9
++ From 81eded01bb2bc35a9b627e5cf35b2021efb5972c Mon Sep 17 00:00:00 2001
++ From: Jay Doyle <jay.doyle@vecna.com>
++ Date: Mon, 7 Sep 2015 10:22:57 -0400
++-Subject: [PATCH 7/9] Added bsp path
+++Subject: [PATCH 07/10] Added bsp path
++ 
++ ---
++  Makefile | 4 +++-
++@@ -3217,7 +3217,7 @@ index 6efa141..a855d9f 100644
++ From f114529d5af1e2a83b49b67d631b10c02648e8d8 Mon Sep 17 00:00:00 2001
++ From: Jay Doyle <jay.doyle@vecna.com>
++ Date: Mon, 7 Sep 2015 10:54:26 -0400
++-Subject: [PATCH 8/9] removed ethernetif.c
+++Subject: [PATCH 08/10] removed ethernetif.c
++ 
++ ---
++  src/netif/ethernetif.c | 496 -------------------------------------------------
++@@ -3733,7 +3733,7 @@ index bc429e9..0000000
++ From badcd5771d8fa3046a2cd7aa07536c6dcb703891 Mon Sep 17 00:00:00 2001
++ From: Jay Doyle <jay.doyle@vecna.com>
++ Date: Mon, 28 Sep 2015 13:47:22 -0400
++-Subject: [PATCH 9/9] enable BSD sockets naming
+++Subject: [PATCH 09/10] enable BSD sockets naming
++ 
++ ---
++  ports/include/lwipopts.h | 2 +-
++@@ -3755,3 +3755,3794 @@ index 169ba46..9149c29 100644
++ -- 
++ 1.9.1
++ 
+++
+++From db7b9a1f9d9d2cba75a14e49e393c88e199ead20 Mon Sep 17 00:00:00 2001
+++From: Jay Doyle <jay.doyle@vecna.com>
+++Date: Mon, 28 Sep 2015 15:28:28 -0400
+++Subject: [PATCH 10/10] corrected cache line size
+++
+++---
+++ ports/include/lwipopts.h |    2 +-
+++ rtems.patch              | 3757 ++++++++++++++++++++++++++++++++++++++++++++++
+++ 2 files changed, 3758 insertions(+), 1 deletion(-)
+++ create mode 100644 rtems.patch
+++
+++diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
+++index 9149c29..7b44db3 100644
+++--- a/ports/include/lwipopts.h
++++++ b/ports/include/lwipopts.h
+++@@ -50,7 +50,7 @@
+++ */
+++ /*#define LWIP_CACHE_ENABLED*/
+++ 
+++-#define SOC_CACHELINE_SIZE_BYTES        64            /* Number of bytes in
++++#define SOC_CACHELINE_SIZE_BYTES        32            /* Number of bytes in
+++                                                          a cache line */
+++ /*
+++ ** The timeout for DHCP completion. lwIP library will wait for DHCP
+++diff --git a/rtems.patch b/rtems.patch
+++new file mode 100644
+++index 0000000..c088510
+++--- /dev/null
++++++ b/rtems.patch
+++@@ -0,0 +1,3757 @@
++++From 2d83d4994e578ec339b2b1baef53090bf7a53570 Mon Sep 17 00:00:00 2001
++++From: Jay Doyle <jay.doyle@vecna.com>
++++Date: Fri, 4 Sep 2015 17:28:55 -0400
++++Subject: [PATCH 1/9] rtems changes necessary
++++
++++---
++++ Makefile                      | 170 +++++++++++
++++ ports/include/arch/cc.h       | 123 ++++++++
++++ ports/include/arch/perf.h     |  38 +++
++++ ports/include/arch/sys_arch.h |  59 ++++
++++ ports/include/lwipopts.h      | 178 ++++++++++++
++++ ports/sys_arch.c              | 663 ++++++++++++++++++++++++++++++++++++++++++
++++ 6 files changed, 1231 insertions(+)
++++ create mode 100644 Makefile
++++ create mode 100644 ports/include/arch/cc.h
++++ create mode 100644 ports/include/arch/perf.h
++++ create mode 100644 ports/include/arch/sys_arch.h
++++ create mode 100644 ports/include/lwipopts.h
++++ create mode 100644 ports/sys_arch.c
++++
++++diff --git a/Makefile b/Makefile
++++new file mode 100644
++++index 0000000..0cbae64
++++--- /dev/null
+++++++ b/Makefile
++++@@ -0,0 +1,170 @@
+++++include $(RTEMS_MAKEFILE_PATH)/Makefile.inc
+++++include $(RTEMS_CUSTOM)
+++++include $(PROJECT_ROOT)/make/leaf.cfg
+++++
+++++#### CONFIG ####################################################################
+++++#For debugging symbols add -DLWIP_DEBUG
+++++# COMPILER/LINKER
+++++CFLAGS+=-g -O2   \
+++++ -Wall
+++++
+++++# OUTPUT
+++++LWIP_EXEC=lwip
+++++
+++++#### PATHS #####################################################################
+++++
+++++# LWIP
+++++LWIP_PATH=.
+++++LWIP_SRC_PATH=$(LWIP_PATH)/src
+++++LWIP_API_PATH=$(LWIP_SRC_PATH)/api
+++++LWIP_CORE_PATH=$(LWIP_SRC_PATH)/core
+++++LWIP_INCL_PATH=$(LWIP_SRC_PATH)/include
+++++LWIP_NETIF_PATH=$(LWIP_SRC_PATH)/netif
+++++
+++++# ARCH
+++++LWIPARCH_PATH=$(LWIP_PATH)/ports
+++++LWIPARCH_SRC_PATH=$(LWIPARCH_PATH)
+++++LWIPARCH_INCL_PATH=$(LWIPARCH_PATH)/include
+++++
+++++# DRIVER
+++++LWIPDRIVER_PATH=$(LWIP_PATH)/ports
+++++LWIPDRIVER_SRC_PATH=$(LWIPDRIVER_PATH)/netif
+++++LWIPDRIVER_INCL_PATH=$(LWIPDRIVER_PATH)/include/netif
+++++
+++++#### SOURCES ###################################################################
+++++
+++++## CORE
+++++CORE_SRC=$(wildcard $(LWIP_CORE_PATH)/*.c)
+++++
+++++## IPv4
+++++IPV4_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv4/*.c)
+++++
+++++## IPv6
+++++IPV6_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv6/*.c)
+++++
+++++## SNMP
+++++SNMP_SRC=$(wildcard $(LWIP_CORE_PATH)/snmp/*.c)
+++++
+++++## API
+++++API_SRC=$(wildcard $(LWIP_API_PATH)/*.c )
+++++
+++++## NETIF
+++++NETIF_SRC=$(wildcard $(LWIP_NETIF_PATH)/*.c) \
+++++          $(wildcard $(LWIP_NETIF_PATH)/ppp/*.c) \
+++++          $(wildcard $(LWIP_NETIF_PATH)/ppp/polarssl/*.c)
+++++
+++++
+++++ARCH_SRC=$(wildcard $(LWIPARCH_SRC_PATH)/*.c)
+++++
+++++# DRIVER
+++++DRIVER_SRC=$(wildcard $(LWIPDRIVER_SRC_PATH)/*.c ) \
+++++           $(wildcard $(LWIPDRIVER_SRC_PATH)/*.S )
+++++
+++++
+++++SOURCES =  $(DRIVER_SRC) $(SNMP_SRC)\
+++++           $(CORE_SRC) $(IPV4_SRC) $(API_SRC) $(NETIF_SRC) $(ARCH_SRC)
+++++
+++++
+++++#### HEADERS ###################################################################
+++++
+++++## CORE
+++++CORE_H=$(LWIP_INCL_PATH)
+++++
+++++## IPv4
+++++#IPV4_H=$(LWIP_INCL_PATH)/ipv4
+++++
+++++## IPv6
+++++#IPV6_H=$(LWIP_INCL_PATH)/ipv6
+++++
+++++## POSIX
+++++POSIX_H=$(LWIP_INCL_PATH)/posix
+++++
+++++##POSIX_SYS
+++++POSIX_SYS_H=$(LWIP_INCL_PATH)/posix/sys
+++++
+++++
+++++## NETIF
+++++NETIF_H=$(LWIP_INCL_PATH)/netif
+++++NETIF_H_PPP=$(LWIP_INCL_PATH)/netif/ppp
+++++NETIF_H_PPP_POLARSSL=$(LWIP_INCL_PATH)/netif/ppp/polarssl
+++++
+++++## ARCH
+++++ARCH_H=$(LWIPARCH_INCL_PATH)
+++++
+++++## DRIVER
+++++DRIVER_H=$(LWIPDRIVER_INCL_PATH)
+++++
+++++# HEADERS
+++++HEADERS=-I$(CORE_H) -I$(POSIX_H) -I$(POSIX_SYS_H) -I$(NETIF_H) \
+++++        -I$(NETIF_H_PPP) -I$(NETIF_H_PPP_POLARSSL) -I$(ARCH_H) \
+++++        -I$(DRIVER_H)
+++++
+++++
+++++################################################################################
+++++
+++++
+++++BIN=${ARCH}/$(LWIP_EXEC).bin
+++++LIB=${ARCH}/lib$(LWIP_EXEC).a
+++++
+++++# optional managers required
+++++MANAGERS=all
+++++
+++++# C source names
+++++CSRCS=$(filter %.c ,$(SOURCES))
+++++COBJS=$(patsubst %.c,${ARCH}/%.o,$(notdir $(CSRCS)))
+++++
+++++ASMSRCS=$(filter %.S , $(SOURCES))
+++++ASMOBJS=$(patsubst %.S,${ARCH}/%.o,$(notdir $(ASMSRCS)))
+++++
+++++OBJS=$(COBJS) $(ASMOBJS)
+++++
+++++all:${ARCH} $(LIB)
+++++
+++++$(LIB): $(OBJS)
+++++	$(AR)  rcs  $@ $^
+++++
+++++${ARCH}/%.o: $(LWIP_CORE_PATH)/%.c
+++++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+++++
+++++${ARCH}/%.o: $(LWIP_CORE_PATH)/ipv4/%.c
+++++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+++++
+++++${ARCH}/%.o: $(LWIP_CORE_PATH)/ipv6/%.c
+++++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+++++
+++++${ARCH}/%.o: $(LWIP_CORE_PATH)/snmp/%.c
+++++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+++++
+++++${ARCH}/%.o: $(LWIP_API_PATH)/%.c
+++++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+++++
+++++${ARCH}/%.o: $(LWIP_NETIF_PATH)/%.c
+++++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+++++
+++++${ARCH}/%.o: $(LWIP_NETIF_PATH)/ppp/%.c
+++++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+++++
+++++${ARCH}/%.o: $(LWIP_NETIF_PATH)/ppp/polarssl/%.c
+++++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+++++
+++++${ARCH}/%.o: $(LWIPARCH_SRC_PATH)/%.c
+++++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+++++
+++++${ARCH}/%.o: $(LWIPDRIVER_SRC_PATH)/%.S
+++++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+++++
+++++${ARCH}/%.o: $(LWIPDRIVER_SRC_PATH)/%.c
+++++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+++++
+++++INSTALL_DIR=$(RTEMS_MAKEFILE_PATH)/lwip
+++++
+++++install:
+++++	rm -rf $(INSTALL_DIR)
+++++	mkdir -p $(INSTALL_DIR)/include
+++++	mkdir -p $(INSTALL_DIR)/lib
+++++	cp $(LIB) $(INSTALL_DIR)/lib
+++++	cp -r $(CORE_H) $(INSTALL_DIR)
+++++	cp $(LWIPARCH_INCL_PATH)/lwipopts.h $(INSTALL_DIR)/include
+++++	cp -r $(LWIPARCH_INCL_PATH)/arch $(INSTALL_DIR)/include
+++++
+++++CPPFLAGS+=$(HEADERS)
++++diff --git a/ports/include/arch/cc.h b/ports/include/arch/cc.h
++++new file mode 100644
++++index 0000000..04ec89f
++++--- /dev/null
+++++++ b/ports/include/arch/cc.h
++++@@ -0,0 +1,123 @@
+++++/*
+++++ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
+++++ * All rights reserved.
+++++ *
+++++ * Redistribution and use in source and binary forms, with or without modification,
+++++ * are permitted provided that the following conditions are met:
+++++ *
+++++ * 1. Redistributions of source code must retain the above copyright notice,
+++++ *    this list of conditions and the following disclaimer.
+++++ * 2. Redistributions in binary form must reproduce the above copyright notice,
+++++ *    this list of conditions and the following disclaimer in the documentation
+++++ *    and/or other materials provided with the distribution.
+++++ * 3. The name of the author may not be used to endorse or promote products
+++++ *    derived from this software without specific prior written permission.
+++++ *
+++++ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+++++ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+++++ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+++++ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+++++ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+++++ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+++++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+++++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+++++ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+++++ * OF SUCH DAMAGE.
+++++ *
+++++ * This file is part of the lwIP TCP/IP stack.
+++++ *
+++++ * Author: Adam Dunkels <adam@sics.se>
+++++ *
+++++ */
+++++#ifndef __CC_H__
+++++#define __CC_H__
+++++
+++++typedef unsigned    char    u8_t;
+++++typedef signed      char    s8_t;
+++++typedef unsigned    short   u16_t;
+++++typedef signed      short   s16_t;
+++++typedef unsigned    int    u32_t;
+++++typedef signed      int    s32_t;
+++++typedef u32_t           mem_ptr_t;
+++++
+++++#ifndef BYTE_ORDER
+++++#define BYTE_ORDER LITTLE_ENDIAN
+++++#endif
+++++
+++++#if defined(__arm__) && defined(__ARMCC_VERSION)
+++++    //
+++++    // Setup PACKing macros for KEIL/RVMDK Tools
+++++    //
+++++    #define PACK_STRUCT_BEGIN __packed
+++++    #define PACK_STRUCT_STRUCT
+++++    #define PACK_STRUCT_END
+++++    #define PACK_STRUCT_FIELD(x) x
+++++#elif defined (__IAR_SYSTEMS_ICC__)
+++++    //
+++++    // Setup PACKing macros for IAR Tools
+++++    //
+++++    #define PACK_STRUCT_BEGIN
+++++    #define PACK_STRUCT_STRUCT
+++++    #define PACK_STRUCT_END
+++++    #define PACK_STRUCT_FIELD(x) x
+++++    #define PACK_STRUCT_USE_INCLUDES
+++++#elif defined (__TMS470__)
+++++    #define PACK_STRUCT_BEGIN
+++++    #define PACK_STRUCT_STRUCT
+++++    #define PACK_STRUCT_END
+++++    #define PACK_STRUCT_FIELD(x) x
+++++#else
+++++    //
+++++    // Setup PACKing macros for GCC Tools
+++++    //
+++++    #define PACK_STRUCT_BEGIN
+++++    #define PACK_STRUCT_STRUCT __attribute__ ((__packed__))
+++++    #define PACK_STRUCT_END
+++++    #define PACK_STRUCT_FIELD(x) x
+++++#endif
+++++
+++++#ifdef LWIP_CACHE_ENABLED
+++++/**
+++++ * Make the PBUF POOL cacheline aligned.
+++++ */
+++++#ifdef __IAR_SYSTEMS_ICC__
+++++#pragma data_alignment=SOC_CACHELINE_SIZE_BYTES
+++++extern u8_t memp_memory_PBUF_POOL_base[];
+++++#else /*By default, GCC */
+++++extern u8_t memp_memory_PBUF_POOL_base[] __attribute__ ((aligned (SOC_CACHELINE_SIZE_BYTES)));
+++++#endif
+++++#endif
+++++
+++++extern u8_t memp_memory_PBUF_POOL_base[] __attribute__ ((aligned (SOC_CACHELINE_SIZE_BYTES)));
+++++
+++++/* Define (sn)printf formatters for these lwIP types */
+++++#define X8_F  "02x"
+++++#define U16_F "u"
+++++#define S16_F "d"
+++++#define X16_F "x"
+++++#define U32_F "u"
+++++#define S32_F "d"
+++++#define X32_F "x"
+++++
+++++#include <stdio.h>
+++++#include <stdlib.h>
+++++#include <bsp.h>
+++++#define LWIP_PLATFORM_DIAG(x)   do { \
+++++        printk("[%s - %s - %d] ", __PRETTY_FUNCTION__, __FILE__, __LINE__); \
+++++        printk x; \
+++++    } while(0)
+++++
+++++#ifdef LWIP_DEBUG  //DEBUG
+++++extern void __error__(char *pcFilename, unsigned long ulLine);
+++++#define LWIP_PLATFORM_ASSERT(expr)   printk("[%s - %s - %d] ", expr , __FILE__, __LINE__);
+++++//{
+++++    //if(!(expr))
+++++    //{
+++++        //__error__(__FILE__, __LINE__);
+++++    //}
+++++//}
+++++#else
+++++#define LWIP_PLATFORM_ASSERT(expr)
+++++#endif
+++++
+++++#endif /* __CC_H__ */
++++diff --git a/ports/include/arch/perf.h b/ports/include/arch/perf.h
++++new file mode 100644
++++index 0000000..d754157
++++--- /dev/null
+++++++ b/ports/include/arch/perf.h
++++@@ -0,0 +1,38 @@
+++++/*
+++++ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
+++++ * All rights reserved.
+++++ *
+++++ * Redistribution and use in source and binary forms, with or without modification,
+++++ * are permitted provided that the following conditions are met:
+++++ *
+++++ * 1. Redistributions of source code must retain the above copyright notice,
+++++ *    this list of conditions and the following disclaimer.
+++++ * 2. Redistributions in binary form must reproduce the above copyright notice,
+++++ *    this list of conditions and the following disclaimer in the documentation
+++++ *    and/or other materials provided with the distribution.
+++++ * 3. The name of the author may not be used to endorse or promote products
+++++ *    derived from this software without specific prior written permission.
+++++ *
+++++ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+++++ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+++++ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+++++ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+++++ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+++++ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+++++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+++++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+++++ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+++++ * OF SUCH DAMAGE.
+++++ *
+++++ * This file is part of the lwIP TCP/IP stack.
+++++ *
+++++ * Author: Adam Dunkels <adam@sics.se>
+++++ *
+++++ */
+++++#ifndef __PERF_H__
+++++#define __PERF_H__
+++++
+++++#define PERF_START    /* null definition */
+++++#define PERF_STOP(x)  /* null definition */
+++++
+++++#endif /* __PERF_H__ */
++++diff --git a/ports/include/arch/sys_arch.h b/ports/include/arch/sys_arch.h
++++new file mode 100644
++++index 0000000..32f0d99
++++--- /dev/null
+++++++ b/ports/include/arch/sys_arch.h
++++@@ -0,0 +1,59 @@
+++++/*
+++++ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
+++++ * All rights reserved.
+++++ *
+++++ * Redistribution and use in source and binary forms, with or without modification,
+++++ * are permitted provided that the following conditions are met:
+++++ *
+++++ * 1. Redistributions of source code must retain the above copyright notice,
+++++ *    this list of conditions and the following disclaimer.
+++++ * 2. Redistributions in binary form must reproduce the above copyright notice,
+++++ *    this list of conditions and the following disclaimer in the documentation
+++++ *    and/or other materials provided with the distribution.
+++++ * 3. The name of the author may not be used to endorse or promote products
+++++ *    derived from this software without specific prior written permission.
+++++ *
+++++ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+++++ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+++++ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+++++ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+++++ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+++++ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+++++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+++++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+++++ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+++++ * OF SUCH DAMAGE.
+++++ *
+++++ * This file is part of the lwIP TCP/IP stack.
+++++ *
+++++ * Author: Adam Dunkels <adam@sics.se>
+++++ *
+++++ */
+++++#ifndef LWIP_ARCH_SYS_ARCH_H
+++++#define LWIP_ARCH_SYS_ARCH_H
+++++
+++++#include <errno.h>
+++++
+++++#define SYS_MBOX_NULL NULL
+++++#define SYS_SEM_NULL  NULL
+++++
+++++typedef u32_t sys_prot_t;
+++++
+++++struct sys_sem;
+++++typedef struct sys_sem * sys_sem_t;
+++++#define sys_sem_valid(sem) (((sem) != NULL) && (*(sem) != NULL))
+++++#define sys_sem_set_invalid(sem) do { if((sem) != NULL) { *(sem) = NULL; }}while(0)
+++++
+++++/* let sys.h use binary semaphores for mutexes */
+++++#define LWIP_COMPAT_MUTEX 1
+++++
+++++struct sys_mbox;
+++++typedef struct sys_mbox *sys_mbox_t;
+++++#define sys_mbox_valid(mbox) ((*(mbox) != NULL))
+++++#define sys_mbox_set_invalid(mbox) do { if((mbox) != NULL) { *(mbox) = NULL; }}while(0)
+++++
+++++struct sys_thread;
+++++typedef struct sys_thread * sys_thread_t;
+++++
+++++#endif /* LWIP_ARCH_SYS_ARCH_H */
+++++
++++diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
++++new file mode 100644
++++index 0000000..169ba46
++++--- /dev/null
+++++++ b/ports/include/lwipopts.h
++++@@ -0,0 +1,178 @@
+++++/**
+++++ * \file lwipopts.h - Configuration options for lwIP
+++++ *
+++++ * Copyright (c) 2010 Texas Instruments Incorporated
+++++ */
+++++/*
+++++ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+++++ * All rights reserved.
+++++ *
+++++ * Redistribution and use in source and binary forms, with or without modification,
+++++ * are permitted provided that the following conditions are met:
+++++ *
+++++ * 1. Redistributions of source code must retain the above copyright notice,
+++++ *    this list of conditions and the following disclaimer.
+++++ * 2. Redistributions in binary form must reproduce the above copyright notice,
+++++ *    this list of conditions and the following disclaimer in the documentation
+++++ *    and/or other materials provided with the distribution.
+++++ * 3. The name of the author may not be used to endorse or promote products
+++++ *    derived from this software without specific prior written permission.
+++++ *
+++++ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+++++ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+++++ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+++++ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+++++ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+++++ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+++++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+++++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+++++ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+++++ * OF SUCH DAMAGE.
+++++ *
+++++ * This file is part of the lwIP TCP/IP stack.
+++++ *
+++++ * Author: Adam Dunkels <adam@sics.se>
+++++ *
+++++ */
+++++
+++++#ifndef __LWIPOPTS_H__
+++++#define __LWIPOPTS_H__
+++++
+++++/*****************************************************************************
+++++**                           CONFIGURATIONS
+++++*****************************************************************************/
+++++
+++++/*
+++++** The below macro should be defined for using lwIP with cache. For cache
+++++** enabling, pbuf pool shall be cache line aligned. This is done by using
+++++** separate pool for each memory. The alignment of pbuf pool to cache line
+++++** size is done in /ports/cpsw/include/arch/cc.h.
+++++*/
+++++/*#define LWIP_CACHE_ENABLED*/
+++++
+++++#define SOC_CACHELINE_SIZE_BYTES        64            /* Number of bytes in
+++++                                                         a cache line */
+++++/*
+++++** The timeout for DHCP completion. lwIP library will wait for DHCP
+++++** completion for (LWIP_DHCP_TIMEOUT / 100) seconds.
+++++*/
+++++#define LWIP_DHCP_TIMEOUT               500
+++++
+++++/*
+++++** The number of times DHCP is attempted. Each time, the library will wait
+++++** for (LWIP_DHCP_TIMEOUT / 100) seconds for DHCP completion.
+++++*/
+++++#define NUM_DHCP_TRIES                  5
+++++
+++++#define LWIP_ETHERNET                   1
+++++#define LWIP_ARP                        1
+++++
+++++/*****************************************************************************
+++++**            lwIP SPECIFIC DEFINITIONS - To be used by lwIP stack
+++++*****************************************************************************/
+++++#define HOST_TMR_INTERVAL               0
+++++#define DYNAMIC_HTTP_HEADERS
+++++
+++++/*****************************************************************************
+++++**                    Platform specific locking
+++++*****************************************************************************/
+++++#define SYS_LIGHTWEIGHT_PROT            1
+++++#define NO_SYS                          0
+++++#define NO_SYS_NO_TIMERS                0
+++++
+++++/*****************************************************************************
+++++**                          Memory Options
+++++*****************************************************************************/
+++++#define MEM_ALIGNMENT                   4
+++++#define MEM_SIZE                        (256 * 1024) /* 128K */
+++++
+++++#define MEMP_NUM_PBUF                   96
+++++#define MEMP_NUM_TCP_PCB                32
+++++#define MEMP_NUM_TCP_SEG                32
+++++#define PBUF_POOL_SIZE                  512
+++++
+++++#ifdef LWIP_CACHE_ENABLED
+++++#define MEMP_SEPARATE_POOLS             1            /* We want the pbuf
+++++                                                        pool cache line
+++++                                                        aligned*/
+++++#endif
+++++
+++++#define MEMP_NUM_SYS_TIMEOUT (LWIP_TCP + IP_REASSEMBLY + LWIP_ARP + (2*LWIP_DHCP) + LWIP_AUTOIP + LWIP_IGMP + LWIP_DNS + PPP_SUPPORT)
+++++
+++++/*****************************************************************************
+++++**                           IP Options
+++++*****************************************************************************/
+++++#define IP_REASSEMBLY                   0
+++++#define IP_FRAG                         0
+++++
+++++/*****************************************************************************
+++++**                           DHCP Options
+++++*****************************************************************************/
+++++#define LWIP_DHCP                       1
+++++#define DHCP_DOES_ARP_CHECK             0
+++++
+++++/*****************************************************************************
+++++**                           Auto IP  Options
+++++*****************************************************************************/
+++++#define LWIP_AUTOIP                     1
+++++#define LWIP_DHCP_AUTOIP_COOP           ((LWIP_DHCP) && (LWIP_AUTOIP))
+++++
+++++/*****************************************************************************
+++++**                           TCP  Options
+++++*****************************************************************************/
+++++#define TCP_MSS                         1500
+++++#define TCP_WND                         (8 * TCP_MSS)
+++++#define TCP_SND_BUF                     (8 * TCP_MSS)
+++++#define TCP_OVERSIZE                    TCP_MSS
+++++
+++++/*****************************************************************************
+++++**                           PBUF  Options
+++++*****************************************************************************/
+++++#define PBUF_LINK_HLEN                  14
+++++#define PBUF_POOL_BUFSIZE               1520         /* + size of struct pbuf
+++++                                                        shall be cache line
+++++                                                        aligned be enabled */
+++++#define ETH_PAD_SIZE                    0
+++++#define LWIP_NETCONN                    1
+++++
+++++/*****************************************************************************
+++++**                           Socket  Options
+++++*****************************************************************************/
+++++#define LWIP_SOCKET                     1
+++++
+++++/*****************************************************************************
+++++**                          Debugging options
+++++*****************************************************************************/
+++++#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_OFF
+++++#define LWIP_DBG_TYPES_ON               (LWIP_DBG_ON | LWIP_DBG_TRACE \
+++++                                         |LWIP_DBG_STATE | LWIP_DBG_FRESH)
+++++#define DHCP_DEBUG                      LWIP_DBG_OFF
+++++#define NETIF_DEBUG                     LWIP_DBG_OFF
+++++#define IP_DEBUG			LWIP_DBG_OFF
+++++#define UDP_DEBUG			LWIP_DBG_OFF
+++++#define ETHARP_DEBUG                    LWIP_DBG_OFF
+++++#define SYS_DEBUG                       LWIP_DBG_OFF
+++++#define RAW_DEBUG                       LWIP_DBG_OFF
+++++#define MEM_DEBUG                       LWIP_DBG_OFF
+++++#define MEMP_DEBUG                      LWIP_DBG_OFF
+++++#define PBUF_DEBUG			LWIP_DBG_OFF
+++++#define TCPIP_DEBUG			LWIP_DBG_OFF
+++++#define APP_DEBUG			LWIP_DBG_OFF
+++++#define SOCKETS_DEBUG		        LWIP_DBG_OFF
+++++#define LWIP_STATS                      0
+++++#define LWIP_STATS_DISPLAY              0
+++++#define LWIP_STATS_POSIX                0
+++++
+++++
+++++
+++++/**
+++++ * LWIP_COMPAT_SOCKETS==1: Enable BSD-style sockets functions names.
+++++ * (only used if you use sockets.c)
+++++ */
+++++#define LWIP_COMPAT_SOCKETS             0
+++++
+++++#define LWIP_TIMEVAL_PRIVATE            0
+++++
+++++ #define LWIP_RAW                       0
+++++
+++++#endif /* __LWIPOPTS_H__ */
++++diff --git a/ports/sys_arch.c b/ports/sys_arch.c
++++new file mode 100644
++++index 0000000..360a4e2
++++--- /dev/null
+++++++ b/ports/sys_arch.c
++++@@ -0,0 +1,663 @@
+++++/*
+++++ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
+++++ * All rights reserved.
+++++ *
+++++ * Redistribution and use in source and binary forms, with or without modification,
+++++ * are permitted provided that the following conditions are met:
+++++ *
+++++ * 1. Redistributions of source code must retain the above copyright notice,
+++++ *    this list of conditions and the following disclaimer.
+++++ * 2. Redistributions in binary form must reproduce the above copyright notice,
+++++ *    this list of conditions and the following disclaimer in the documentation
+++++ *    and/or other materials provided with the distribution.
+++++ * 3. The name of the author may not be used to endorse or promote products
+++++ *    derived from this software without specific prior written permission.
+++++ *
+++++ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+++++ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+++++ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+++++ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+++++ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+++++ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+++++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+++++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+++++ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+++++ * OF SUCH DAMAGE.
+++++ *
+++++ * This file is part of the lwIP TCP/IP stack.
+++++ *
+++++ * Author: Adam Dunkels <adam@sics.se>
+++++ *
+++++ */
+++++
+++++/*
+++++ * Wed Apr 17 16:05:29 EDT 2002 (James Roth)
+++++ *
+++++ *  - Fixed an unlikely sys_thread_new() race condition.
+++++ *
+++++ *  - Made current_thread() work with threads which where
+++++ *    not created with sys_thread_new().  This includes
+++++ *    the main thread and threads made with pthread_create().
+++++ *
+++++ *  - Catch overflows where more than SYS_MBOX_SIZE messages
+++++ *    are waiting to be read.  The sys_mbox_post() routine
+++++ *    will block until there is more room instead of just
+++++ *    leaking messages.
+++++ */
+++++
+++++#include <string.h>
+++++#include <sys/time.h>
+++++#include <sys/types.h>
+++++#include <stdlib.h>
+++++#include <unistd.h>
+++++#include <pthread.h>
+++++
+++++#include "lwip/opt.h"
+++++#include "lwip/sys.h"
+++++#include "lwip/stats.h"
+++++#include "lwip/debug.h"
+++++
+++++#define UMAX(a, b)      ((a) > (b) ? (a) : (b))
+++++
+++++static struct timeval starttime;
+++++
+++++#if !NO_SYS
+++++
+++++static struct sys_thread *threads = NULL;
+++++static pthread_mutex_t threads_mutex = PTHREAD_MUTEX_INITIALIZER;
+++++
+++++struct sys_mbox_msg {
+++++  struct sys_mbox_msg *next;
+++++  void *msg;
+++++};
+++++
+++++#define SYS_MBOX_SIZE 128
+++++
+++++struct sys_mbox {
+++++  int first, last;
+++++  void *msgs[SYS_MBOX_SIZE];
+++++  struct sys_sem *not_empty;
+++++  struct sys_sem *not_full;
+++++  struct sys_sem *mutex;
+++++  int wait_send;
+++++};
+++++
+++++struct sys_sem {
+++++  unsigned int c;
+++++  pthread_cond_t cond;
+++++  pthread_mutex_t mutex;
+++++};
+++++
+++++struct sys_thread {
+++++  struct sys_thread *next;
+++++  pthread_t pthread;
+++++};
+++++
+++++#if SYS_LIGHTWEIGHT_PROT
+++++static pthread_mutex_t lwprot_mutex = PTHREAD_MUTEX_INITIALIZER;
+++++static pthread_t lwprot_thread = (pthread_t)0xDEAD;
+++++static int lwprot_count = 0;
+++++#endif /* SYS_LIGHTWEIGHT_PROT */
+++++
+++++static struct sys_sem *sys_sem_new_internal(u8_t count);
+++++static void sys_sem_free_internal(struct sys_sem *sem);
+++++
+++++static u32_t cond_wait(pthread_cond_t * cond, pthread_mutex_t * mutex,
+++++                       u32_t timeout);
+++++
+++++/*-----------------------------------------------------------------------------------*/
+++++static struct sys_thread *
+++++introduce_thread(pthread_t id)
+++++{
+++++  struct sys_thread *thread = NULL;
+++++
+++++  thread = (struct sys_thread *)malloc(sizeof(struct sys_thread));
+++++
+++++  if (thread != NULL) {
+++++    pthread_mutex_lock(&threads_mutex);
+++++    thread->next = threads;
+++++    thread->pthread = id;
+++++    threads = thread;
+++++    pthread_mutex_unlock(&threads_mutex);
+++++  }
+++++
+++++  return thread;
+++++}
+++++/*-----------------------------------------------------------------------------------*/
+++++sys_thread_t
+++++sys_thread_new(const char *name, lwip_thread_fn function, void *arg, int stacksize, int prio)
+++++{
+++++  int code;
+++++  int rc;
+++++  pthread_t tmp;
+++++  pthread_attr_t attr;
+++++  struct sys_thread *st = NULL;
+++++  LWIP_UNUSED_ARG(name);
+++++  LWIP_UNUSED_ARG(stacksize);
+++++  LWIP_UNUSED_ARG(prio);
+++++
+++++  /* Alloc a new pthread with the specified stack size. */
+++++  if(stacksize > 0) {
+++++    rc = pthread_attr_init(&attr);
+++++    if (rc != 0) {
+++++      LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: pthread_attr_init error = %d\n", rc));
+++++      return NULL;
+++++    }
+++++    rc = pthread_attr_setstacksize(&attr, stacksize);
+++++    if (rc != 0) {
+++++      LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: pthread_attr_setstacksize error = %d\n", rc));
+++++      pthread_attr_destroy(&attr);
+++++      return NULL;
+++++    }
+++++    pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);
+++++    pthread_attr_setschedpolicy(&attr, SCHED_RR);
+++++    code = pthread_create(&tmp, &attr, (void *(*)(void *)) function, arg);
+++++    pthread_attr_destroy(&attr);
+++++  } else {
+++++    code = pthread_create(&tmp, NULL, (void *(*)(void *)) function, arg);
+++++  }
+++++  LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: thread created [name:%s|stacksize:%d|prio:%d|addr:0x%x]\n",
+++++                          name, stacksize, prio, (uint)tmp));
+++++
+++++  if (0 == code) {
+++++    st = introduce_thread(tmp);
+++++  }
+++++
+++++  if (NULL == st) {
+++++    LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: failed to introduce %d, st = %p\n",
+++++                            code, (void*)st));
+++++    abort();
+++++  } else {
+++++    LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: introduced %d, st = %p\n",
+++++                            code, (void*)st));
+++++  }
+++++
+++++  return st;
+++++}
+++++/*-----------------------------------------------------------------------------------*/
+++++void sys_thread_signal(sys_thread_t thread, int signal)
+++++{
+++++    /* Check received parameters. */
+++++    if(thread == NULL) {
+++++        LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_signal: could not send signal to thread. thread = NULL\n"));
+++++        return;
+++++    }
+++++
+++++    /* Send signal. */
+++++    pthread_kill(thread->pthread, signal);
+++++}
+++++/*-----------------------------------------------------------------------------------*/
+++++err_t
+++++sys_mbox_new(struct sys_mbox **mb, int size)
+++++{
+++++  struct sys_mbox *mbox = NULL;
+++++  LWIP_UNUSED_ARG(size);
+++++
+++++  mbox = (struct sys_mbox *)malloc(sizeof(struct sys_mbox));
+++++  if (mbox == NULL) {
+++++    SYS_STATS_INC(mbox.err);
+++++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_new: could not create mbox\n"));
+++++    return ERR_MEM;
+++++  }
+++++  mbox->first = mbox->last = 0;
+++++  mbox->not_empty = sys_sem_new_internal(0);
+++++  mbox->not_full = sys_sem_new_internal(0);
+++++  mbox->mutex = sys_sem_new_internal(1);
+++++  mbox->wait_send = 0;
+++++
+++++  SYS_STATS_INC_USED(mbox);
+++++
+++++  if((mbox->not_empty == NULL) || (mbox->not_full == NULL) || (mbox->mutex == NULL)) {
+++++    SYS_STATS_INC(mbox.err);
+++++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_new: could not create mbox internals\n"));
+++++    sys_mbox_free(&mbox);
+++++    return ERR_MEM;
+++++  }
+++++  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_new: mbox created [not_empty:%X|not_full:%X|mutex:%X] \n",
+++++                          mbox->not_empty, mbox->not_full, mbox->mutex));
+++++
+++++  *mb = mbox;
+++++  return ERR_OK;
+++++}
+++++/*-----------------------------------------------------------------------------------*/
+++++void
+++++sys_mbox_free(struct sys_mbox **mb)
+++++{
+++++  if ((mb != NULL) && (*mb != SYS_MBOX_NULL)) {
+++++    struct sys_mbox *mbox = *mb;
+++++    sys_arch_sem_wait(&mbox->mutex, 0);
+++++
+++++    sys_sem_free_internal(mbox->not_empty);
+++++    sys_sem_free_internal(mbox->not_full);
+++++    sys_sem_free_internal(mbox->mutex);
+++++    mbox->not_empty = mbox->not_full = mbox->mutex = NULL;
+++++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_free: mbox 0x%lx\n", mbox));
+++++    free(mbox);
+++++    SYS_STATS_DEC(mbox.used);
+++++  }
+++++}
+++++/*-----------------------------------------------------------------------------------*/
+++++err_t
+++++sys_mbox_trypost(struct sys_mbox **mb, void *msg)
+++++{
+++++  u8_t first;
+++++  struct sys_mbox *mbox;
+++++  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
+++++  mbox = *mb;
+++++  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_trypost: start"));
+++++  sys_arch_sem_wait(&mbox->mutex, 0);
+++++
+++++  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_trypost: mbox %p msg %p\n",
+++++                          (void *)mbox, (void *)msg));
+++++
+++++  if ((mbox->last + 1) >= (mbox->first + SYS_MBOX_SIZE)) {
+++++    sys_sem_signal(&mbox->mutex);
+++++    return ERR_MEM;
+++++  }
+++++
+++++  mbox->msgs[mbox->last % SYS_MBOX_SIZE] = msg;
+++++
+++++  if (mbox->last == mbox->first) {
+++++    first = 1;
+++++  } else {
+++++    first = 0;
+++++  }
+++++
+++++  mbox->last++;
+++++
+++++  if (first) {
+++++    sys_sem_signal(&mbox->not_empty);
+++++  }
+++++
+++++  sys_sem_signal(&mbox->mutex);
+++++
+++++  return ERR_OK;
+++++}
+++++/*-----------------------------------------------------------------------------------*/
+++++void
+++++sys_mbox_post(struct sys_mbox **mb, void *msg)
+++++{
+++++  u8_t first;
+++++  struct sys_mbox *mbox;
+++++  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
+++++  mbox = *mb;
+++++
+++++  sys_arch_sem_wait(&mbox->mutex, 0);
+++++
+++++  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_post: mbox %p msg %p\n", (void *)mbox, (void *)msg));
+++++
+++++  while ((mbox->last + 1) >= (mbox->first + SYS_MBOX_SIZE)) {
+++++    mbox->wait_send++;
+++++    sys_sem_signal(&mbox->mutex);
+++++    sys_arch_sem_wait(&mbox->not_full, 0);
+++++    sys_arch_sem_wait(&mbox->mutex, 0);
+++++    mbox->wait_send--;
+++++  }
+++++
+++++  mbox->msgs[mbox->last % SYS_MBOX_SIZE] = msg;
+++++
+++++  if (mbox->last == mbox->first) {
+++++    first = 1;
+++++  } else {
+++++    first = 0;
+++++  }
+++++
+++++  mbox->last++;
+++++
+++++  if (first) {
+++++    sys_sem_signal(&mbox->not_empty);
+++++  }
+++++
+++++  sys_sem_signal(&mbox->mutex);
+++++}
+++++/*-----------------------------------------------------------------------------------*/
+++++u32_t
+++++sys_arch_mbox_tryfetch(struct sys_mbox **mb, void **msg)
+++++{
+++++  struct sys_mbox *mbox;
+++++  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
+++++  mbox = *mb;
+++++
+++++  sys_arch_sem_wait(&mbox->mutex, 0);
+++++
+++++  if (mbox->first == mbox->last) {
+++++    sys_sem_signal(&mbox->mutex);
+++++    return SYS_MBOX_EMPTY;
+++++  }
+++++
+++++  if (msg != NULL) {
+++++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_tryfetch: mbox %p msg %p\n", (void *)mbox, *msg));
+++++    *msg = mbox->msgs[mbox->first % SYS_MBOX_SIZE];
+++++  }
+++++  else{
+++++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_tryfetch: mbox %p, null msg\n", (void *)mbox));
+++++  }
+++++
+++++  mbox->first++;
+++++
+++++  if (mbox->wait_send) {
+++++    sys_sem_signal(&mbox->not_full);
+++++  }
+++++
+++++  sys_sem_signal(&mbox->mutex);
+++++
+++++  return 0;
+++++}
+++++/*-----------------------------------------------------------------------------------*/
+++++u32_t
+++++sys_arch_mbox_fetch(struct sys_mbox **mb, void **msg, u32_t timeout)
+++++{
+++++  u32_t time_needed = 0;
+++++  struct sys_mbox *mbox;
+++++  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
+++++  mbox = *mb;
+++++
+++++  /* The mutex lock is quick so we don't bother with the timeout
+++++     stuff here. */
+++++  sys_arch_sem_wait(&mbox->mutex, 0);
+++++
+++++  while (mbox->first == mbox->last) {
+++++    sys_sem_signal(&mbox->mutex);
+++++
+++++    /* We block while waiting for a mail to arrive in the mailbox. We
+++++       must be prepared to timeout. */
+++++    if (timeout != 0) {
+++++      time_needed = sys_arch_sem_wait(&mbox->not_empty, timeout);
+++++
+++++      if (time_needed == SYS_ARCH_TIMEOUT) {
+++++        return SYS_ARCH_TIMEOUT;
+++++      }
+++++    } else {
+++++      sys_arch_sem_wait(&mbox->not_empty, 0);
+++++    }
+++++
+++++    sys_arch_sem_wait(&mbox->mutex, 0);
+++++  }
+++++
+++++  if (msg != NULL) {
+++++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_fetch: mbox %p msg %p\n", (void *)mbox, *msg));
+++++    *msg = mbox->msgs[mbox->first % SYS_MBOX_SIZE];
+++++  }
+++++  else{
+++++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_fetch: mbox %p, null msg\n", (void *)mbox));
+++++  }
+++++
+++++  mbox->first++;
+++++
+++++  if (mbox->wait_send) {
+++++    sys_sem_signal(&mbox->not_full);
+++++  }
+++++
+++++  sys_sem_signal(&mbox->mutex);
+++++
+++++  return time_needed;
+++++}
+++++/*-----------------------------------------------------------------------------------*/
+++++static struct sys_sem *
+++++sys_sem_new_internal(u8_t count)
+++++{
+++++  struct sys_sem *sem = NULL;
+++++  int rc;
+++++
+++++  sem = (struct sys_sem *)malloc(sizeof(struct sys_sem));
+++++  if (sem != NULL) {
+++++    sem->c = count;
+++++    rc = pthread_cond_init(&(sem->cond), NULL);
+++++    if(rc != 0) {
+++++      LWIP_DEBUGF(SYS_DEBUG, ("sys_sem_new_internal: pthread_cond_init error = %d\n", rc));
+++++      return NULL;
+++++    }
+++++    rc = pthread_mutex_init(&(sem->mutex), NULL);
+++++    if(rc != 0) {
+++++      LWIP_DEBUGF(SYS_DEBUG, ("sys_sem_new_internal: pthread_mutex_init error = %d\n", rc));
+++++      SYS_STATS_INC(mutex.err);
+++++      pthread_cond_destroy(&(sem->cond));
+++++      return NULL;
+++++    }
+++++    SYS_STATS_INC_USED(mutex);
+++++    SYS_STATS_INC_USED(sem);
+++++  } else {
+++++    LWIP_DEBUGF(SYS_DEBUG, ("sys_sem_new_internal: could not create semaphore\n"));
+++++    SYS_STATS_INC(sem.err);
+++++  }
+++++  return sem;
+++++}
+++++/*-----------------------------------------------------------------------------------*/
+++++err_t
+++++sys_sem_new(struct sys_sem **sem, u8_t count)
+++++{
+++++  *sem = sys_sem_new_internal(count);
+++++  if (*sem == NULL) {
+++++    return ERR_MEM;
+++++  }
+++++  return ERR_OK;
+++++}
+++++/*-----------------------------------------------------------------------------------*/
+++++static u32_t
+++++cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex, u32_t timeout)
+++++{
+++++  time_t tdiff;
+++++  time_t sec, usec;
+++++  struct timeval rtime1, rtime2;
+++++  struct timespec ts;
+++++  int retval;
+++++
+++++  if (timeout > 0) {
+++++    /* Get a timestamp and add the timeout value. */
+++++    gettimeofday(&rtime1, NULL);
+++++    sec = rtime1.tv_sec;
+++++    usec = rtime1.tv_usec;
+++++    usec += timeout % 1000 * 1000;
+++++    sec += (int)(timeout / 1000) + (int)(usec / 1000000);
+++++    usec = usec % 1000000;
+++++    ts.tv_nsec = usec * 1000;
+++++    ts.tv_sec = sec;
+++++
+++++    retval = pthread_cond_timedwait(cond, mutex, &ts);
+++++
+++++    if (retval == ETIMEDOUT) {
+++++      return SYS_ARCH_TIMEOUT;
+++++    } else {
+++++      /* Calculate for how long we waited for the cond. */
+++++      gettimeofday(&rtime2, NULL);
+++++      tdiff = (rtime2.tv_sec - rtime1.tv_sec) * 1000 +
+++++        (rtime2.tv_usec - rtime1.tv_usec) / 1000;
+++++
+++++      if (tdiff <= 0) {
+++++        return 0;
+++++      }
+++++      return (u32_t)tdiff;
+++++    }
+++++  } else {
+++++    pthread_cond_wait(cond, mutex);
+++++    return 0;
+++++  }
+++++}
+++++/*-----------------------------------------------------------------------------------*/
+++++u32_t
+++++sys_arch_sem_wait(struct sys_sem **s, u32_t timeout)
+++++{
+++++  u32_t time_needed = 0;
+++++  struct sys_sem *sem;
+++++  LWIP_ASSERT("invalid sem", (s != NULL) && (*s != NULL));
+++++  sem = *s;
+++++
+++++  pthread_mutex_lock(&(sem->mutex));
+++++  while (sem->c <= 0) {
+++++    if (timeout > 0) {
+++++      time_needed = cond_wait(&(sem->cond), &(sem->mutex), timeout);
+++++
+++++      if (time_needed == SYS_ARCH_TIMEOUT) {
+++++        pthread_mutex_unlock(&(sem->mutex));
+++++        return SYS_ARCH_TIMEOUT;
+++++      }
+++++    } else {
+++++      cond_wait(&(sem->cond), &(sem->mutex), 0);
+++++    }
+++++  }
+++++  sem->c--;
+++++  pthread_mutex_unlock(&(sem->mutex));
+++++  return (u32_t)time_needed;
+++++}
+++++/*-----------------------------------------------------------------------------------*/
+++++void
+++++sys_sem_signal(struct sys_sem **s)
+++++{
+++++  struct sys_sem *sem;
+++++  LWIP_ASSERT("invalid sem", (s != NULL) && (*s != NULL));
+++++  sem = *s;
+++++
+++++  pthread_mutex_lock(&(sem->mutex));
+++++  sem->c++;
+++++
+++++  if (sem->c > 1) {
+++++    sem->c = 1;
+++++  }
+++++
+++++  pthread_cond_broadcast(&(sem->cond));
+++++  pthread_mutex_unlock(&(sem->mutex));
+++++}
+++++/*-----------------------------------------------------------------------------------*/
+++++static void
+++++sys_sem_free_internal(struct sys_sem *sem)
+++++{
+++++  if(sem != NULL) {
+++++    pthread_cond_destroy(&(sem->cond));
+++++    pthread_mutex_destroy(&(sem->mutex));
+++++    SYS_STATS_DEC(mutex.used);
+++++    SYS_STATS_DEC(sem.used);
+++++    free(sem);
+++++  }
+++++}
+++++/*-----------------------------------------------------------------------------------*/
+++++void
+++++sys_sem_free(struct sys_sem **sem)
+++++{
+++++  if ((sem != NULL) && (*sem != SYS_SEM_NULL)) {
+++++    sys_sem_free_internal(*sem);
+++++  }
+++++}
+++++#endif /* !NO_SYS */
+++++/*-----------------------------------------------------------------------------------*/
+++++u32_t
+++++sys_now(void)
+++++{
+++++  struct timeval tv;
+++++  u32_t sec, usec, msec;
+++++  gettimeofday(&tv, NULL);
+++++
+++++  sec = (u32_t)(tv.tv_sec - starttime.tv_sec);
+++++  usec = (u32_t)(tv.tv_usec - starttime.tv_usec);
+++++  msec = sec * 1000 + usec / 1000;
+++++
+++++  return msec;
+++++}
+++++/*-----------------------------------------------------------------------------------*/
+++++void
+++++sys_init(void)
+++++{
+++++  SYS_STATS_INC_USED(mutex);
+++++  gettimeofday(&starttime, NULL);
+++++}
+++++/*-----------------------------------------------------------------------------------*/
+++++#if SYS_LIGHTWEIGHT_PROT
+++++/** sys_prot_t sys_arch_protect(void)
+++++
+++++This optional function does a "fast" critical region protection and returns
+++++the previous protection level. This function is only called during very short
+++++critical regions. An embedded system which supports ISR-based drivers might
+++++want to implement this function by disabling interrupts. Task-based systems
+++++might want to implement this by using a mutex or disabling tasking. This
+++++function should support recursive calls from the same task or interrupt. In
+++++other words, sys_arch_protect() could be called while already protected. In
+++++that case the return value indicates that it is already protected.
+++++
+++++sys_arch_protect() is only required if your port is supporting an operating
+++++system.
+++++*/
+++++sys_prot_t
+++++sys_arch_protect(void)
+++++{
+++++    /* Note that for the UNIX port, we are using a lightweight mutex, and our
+++++     * own counter (which is locked by the mutex). The return code is not actually
+++++     * used. */
+++++    if (lwprot_thread != pthread_self())
+++++    {
+++++        /* We are locking the mutex where it has not been locked before *
+++++        * or is being locked by another thread */
+++++        pthread_mutex_lock(&lwprot_mutex);
+++++        lwprot_thread = pthread_self();
+++++        lwprot_count = 1;
+++++    }
+++++    else
+++++    {
+++++        /* It is already locked by THIS thread */
+++++        lwprot_count++;
+++++    }
+++++    return 0;
+++++}
+++++/*-----------------------------------------------------------------------------------*/
+++++/** void sys_arch_unprotect(sys_prot_t pval)
+++++
+++++This optional function does a "fast" set of critical region protection to the
+++++value specified by pval. See the documentation for sys_arch_protect() for
+++++more information. This function is only required if your port is supporting
+++++an operating system.
+++++*/
+++++void
+++++sys_arch_unprotect(sys_prot_t pval)
+++++{
+++++    LWIP_UNUSED_ARG(pval);
+++++    if (lwprot_thread == pthread_self())
+++++    {
+++++        if (--lwprot_count == 0)
+++++        {
+++++            lwprot_thread = (pthread_t) 0xDEAD;
+++++            pthread_mutex_unlock(&lwprot_mutex);
+++++        }
+++++    }
+++++}
+++++#endif /* SYS_LIGHTWEIGHT_PROT */
+++++
+++++/*-----------------------------------------------------------------------------------*/
+++++
+++++#ifndef MAX_JIFFY_OFFSET
+++++#define MAX_JIFFY_OFFSET ((~0U >> 1)-1)
+++++#endif
+++++
+++++#ifndef HZ
+++++#define HZ 100
+++++#endif
+++++
+++++u32_t
+++++sys_jiffies(void)
+++++{
+++++    struct timeval tv;
+++++    unsigned long sec;
+++++    long usec;
+++++
+++++    gettimeofday(&tv,NULL);
+++++    sec = tv.tv_sec - starttime.tv_sec;
+++++    usec = tv.tv_usec;
+++++
+++++    if (sec >= (MAX_JIFFY_OFFSET / HZ))
+++++      return MAX_JIFFY_OFFSET;
+++++    usec += 1000000L / HZ - 1;
+++++    usec /= 1000000L / HZ;
+++++    return HZ * sec + usec;
+++++}
+++++
+++++#if PPP_DEBUG
+++++
+++++#include <stdarg.h>
+++++
+++++void ppp_trace(int level, const char *format, ...)
+++++{
+++++    va_list args;
+++++
+++++    (void)level;
+++++    va_start(args, format);
+++++    vprintf(format, args);
+++++    va_end(args);
+++++}
+++++#endif
++++-- 
++++1.9.1
++++
++++
++++From d053fa836b445b6736bf82d33a33a59055150aa7 Mon Sep 17 00:00:00 2001
++++From: Jay Doyle <jay.doyle@vecna.com>
++++Date: Fri, 4 Sep 2015 17:30:37 -0400
++++Subject: [PATCH 2/9] changed the compiler options
++++
++++---
++++ Makefile | 2 +-
++++ 1 file changed, 1 insertion(+), 1 deletion(-)
++++
++++diff --git a/Makefile b/Makefile
++++index 0cbae64..94fcafc 100644
++++--- a/Makefile
+++++++ b/Makefile
++++@@ -5,7 +5,7 @@ include $(PROJECT_ROOT)/make/leaf.cfg
++++ #### CONFIG ####################################################################
++++ #For debugging symbols add -DLWIP_DEBUG
++++ # COMPILER/LINKER
++++-CFLAGS+=-g -O2   \
+++++CFLAGS+=-g -O0   \
++++  -Wall
++++ 
++++ # OUTPUT
++++-- 
++++1.9.1
++++
++++
++++From 841adb17430bdb9298dcb6d44ac5dad72e82af80 Mon Sep 17 00:00:00 2001
++++From: Jay Doyle <jay.doyle@vecna.com>
++++Date: Mon, 7 Sep 2015 08:56:58 -0400
++++Subject: [PATCH 3/9] disabled any mention of ipv6
++++
++++---
++++ Makefile | 6 +++---
++++ 1 file changed, 3 insertions(+), 3 deletions(-)
++++
++++diff --git a/Makefile b/Makefile
++++index 94fcafc..6efa141 100644
++++--- a/Makefile
+++++++ b/Makefile
++++@@ -40,7 +40,7 @@ CORE_SRC=$(wildcard $(LWIP_CORE_PATH)/*.c)
++++ IPV4_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv4/*.c)
++++ 
++++ ## IPv6
++++-IPV6_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv6/*.c)
+++++#IPV6_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv6/*.c)
++++ 
++++ ## SNMP
++++ SNMP_SRC=$(wildcard $(LWIP_CORE_PATH)/snmp/*.c)
++++@@ -71,7 +71,7 @@ SOURCES =  $(DRIVER_SRC) $(SNMP_SRC)\
++++ CORE_H=$(LWIP_INCL_PATH)
++++ 
++++ ## IPv4
++++-#IPV4_H=$(LWIP_INCL_PATH)/ipv4
+++++IPV4_H=$(LWIP_INCL_PATH)/ipv4
++++ 
++++ ## IPv6
++++ #IPV6_H=$(LWIP_INCL_PATH)/ipv6
++++@@ -97,7 +97,7 @@ DRIVER_H=$(LWIPDRIVER_INCL_PATH)
++++ # HEADERS
++++ HEADERS=-I$(CORE_H) -I$(POSIX_H) -I$(POSIX_SYS_H) -I$(NETIF_H) \
++++         -I$(NETIF_H_PPP) -I$(NETIF_H_PPP_POLARSSL) -I$(ARCH_H) \
++++-        -I$(DRIVER_H)
+++++        -I$(DRIVER_H) -I$(IPV4_H)
++++ 
++++ 
++++ ################################################################################
++++-- 
++++1.9.1
++++
++++
++++From a653d818348fef0130e6e497eecb0c3a35822df4 Mon Sep 17 00:00:00 2001
++++From: Jay Doyle <jay.doyle@vecna.com>
++++Date: Mon, 7 Sep 2015 09:27:48 -0400
++++Subject: [PATCH 4/9] added in stm32f low-level driver
++++
++++---
++++ src/netif/ethernetif.c | 709 ++++++++++++++++++++++++++++++-------------------
++++ 1 file changed, 435 insertions(+), 274 deletions(-)
++++
++++diff --git a/src/netif/ethernetif.c b/src/netif/ethernetif.c
++++index 7982d11..82c85ae 100644
++++--- a/src/netif/ethernetif.c
+++++++ b/src/netif/ethernetif.c
++++@@ -1,335 +1,496 @@
++++ /**
++++- * @file
++++- * Ethernet Interface Skeleton
++++- *
++++- */
++++-
++++-/*
++++- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
++++- * All rights reserved. 
++++- * 
++++- * Redistribution and use in source and binary forms, with or without modification, 
++++- * are permitted provided that the following conditions are met:
++++- *
++++- * 1. Redistributions of source code must retain the above copyright notice,
++++- *    this list of conditions and the following disclaimer.
++++- * 2. Redistributions in binary form must reproduce the above copyright notice,
++++- *    this list of conditions and the following disclaimer in the documentation
++++- *    and/or other materials provided with the distribution.
++++- * 3. The name of the author may not be used to endorse or promote products
++++- *    derived from this software without specific prior written permission. 
++++- *
++++- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
++++- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
++++- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
++++- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
++++- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
++++- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
++++- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
++++- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
++++- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
++++- * OF SUCH DAMAGE.
++++- *
++++- * This file is part of the lwIP TCP/IP stack.
++++- * 
++++- * Author: Adam Dunkels <adam@sics.se>
++++- *
++++- */
++++-
++++-/*
++++- * This file is a skeleton for developing Ethernet network interface
++++- * drivers for lwIP. Add code to the low_level functions and do a
++++- * search-and-replace for the word "ethernetif" to replace it with
++++- * something that better describes your network interface.
++++- */
++++-
+++++  ******************************************************************************
+++++  * @file    LwIP/LwIP_HTTP_Server_Netconn_RTOS/Src/ethernetif.c
+++++  * @author  MCD Application Team
+++++  * @version V1.0.0
+++++  * @date    25-June-2015
+++++  * @brief   This file implements Ethernet network interface drivers for lwIP
+++++  ******************************************************************************
+++++  * @attention
+++++  *
+++++  * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
+++++  *
+++++  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+++++  * You may not use this file except in compliance with the License.
+++++  * You may obtain a copy of the License at:
+++++  *
+++++  *        http://www.st.com/software_license_agreement_liberty_v2
+++++  *
+++++  * Unless required by applicable law or agreed to in writing, software 
+++++  * distributed under the License is distributed on an "AS IS" BASIS, 
+++++  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+++++  * See the License for the specific language governing permissions and
+++++  * limitations under the License.
+++++  *
+++++  ******************************************************************************
+++++  */
+++++
+++++/* Includes ------------------------------------------------------------------*/
+++++#include "stm32f7xx_hal.h"
++++ #include "lwip/opt.h"
++++-
++++-#if 0 /* don't build, this is only a skeleton, see previous comment */
++++-
++++-#include "lwip/def.h"
++++-#include "lwip/mem.h"
++++-#include "lwip/pbuf.h"
++++-#include "lwip/stats.h"
++++-#include "lwip/snmp.h"
++++-#include "lwip/ethip6.h"
+++++#include "lwip/lwip_timers.h"
++++ #include "netif/etharp.h"
++++-#include "netif/ppp/pppoe.h"
+++++#include "hal-ethernetif.h"
+++++#include <string.h>
+++++
+++++/* Private typedef -----------------------------------------------------------*/
+++++/* Private define ------------------------------------------------------------*/
+++++/* The time to block waiting for input. */
+++++#define TIME_WAITING_FOR_INPUT                 ( 100 )
+++++/* Stack size of the interface thread */
+++++#define INTERFACE_THREAD_STACK_SIZE            ( 350 )
++++ 
++++ /* Define those to better describe your network interface. */
++++ #define IFNAME0 'e'
++++ #define IFNAME1 'n'
++++ 
++++-/**
++++- * Helper struct to hold private data used to operate your ethernet interface.
++++- * Keeping the ethernet address of the MAC in this struct is not necessary
++++- * as it is already kept in the struct netif.
++++- * But this is only an example, anyway...
++++- */
++++-struct ethernetif {
++++-  struct eth_addr *ethaddr;
++++-  /* Add whatever per-interface state that is needed here. */
++++-};
++++-
++++-/* Forward declarations. */
++++-static void  ethernetif_input(struct netif *netif);
+++++#define LAN8742A_PHY_ADDRESS            0x00
++++ 
++++-/**
++++- * In this function, the hardware should be initialized.
++++- * Called from ethernetif_init().
++++- *
++++- * @param netif the already initialized lwip network interface structure
++++- *        for this ethernetif
++++- */
++++-static void
++++-low_level_init(struct netif *netif)
++++-{
++++-  struct ethernetif *ethernetif = netif->state;
++++-  
++++-  /* set MAC hardware address length */
++++-  netif->hwaddr_len = ETHARP_HWADDR_LEN;
+++++/* Private macro -------------------------------------------------------------*/
+++++/* Private variables ---------------------------------------------------------*/
++++ 
++++-  /* set MAC hardware address */
++++-  netif->hwaddr[0] = ;
++++-  ...
++++-  netif->hwaddr[5] = ;
+++++#if defined ( __ICCARM__ ) /*!< IAR Compiler */
++++ 
++++-  /* maximum transfer unit */
++++-  netif->mtu = 1500;
++++-  
++++-  /* device capabilities */
++++-  /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
++++-  netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
++++- 
++++-#if LWIP_IPV6 && LWIP_IPV6_MLD
++++-  /*
++++-   * For hardware/netifs that implement MAC filtering.
++++-   * All-nodes link-local is handled by default, so we must let the hardware know
++++-   * to allow multicast packets in.
++++-   * Should set mld_mac_filter previously. */
++++-  if (netif->mld_mac_filter != NULL) {
++++-    ip6_addr_t ip6_allnodes_ll;
++++-    ip6_addr_set_allnodes_linklocal(&ip6_allnodes_ll);
++++-    netif->mld_mac_filter(netif, &ip6_allnodes_ll, MLD6_ADD_MAC_FILTER);
++++-  }
++++-#endif /* LWIP_IPV6 && LWIP_IPV6_MLD */
+++++#pragma location=0x2000E000
+++++__no_init ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
+++++#pragma location=0x2000E100
+++++__no_init ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
+++++#elif defined ( __CC_ARM   )
+++++ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((at(0x2000E000)));/* Ethernet Rx MA Descriptor */
+++++ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((at(0x2000E100)));/* Ethernet Tx DMA Descriptor */
+++++#elif defined ( __GNUC__   )
+++++//ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".RxDescripSection")));/* Ethernet Rx MA Descriptor */
+++++//ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".TxDescripSection")));/* Ethernet Tx DMA Descriptor */
+++++ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Rx MA Descriptor */
+++++ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Tx DMA Descriptor */
+++++
+++++
+++++#endif
+++++#if defined ( __ICCARM__ ) /*!< IAR Compiler */
+++++#pragma location=0x2000E200
+++++__no_init uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
+++++#pragma location=0x2000FFC4
+++++__no_init uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
+++++#elif defined ( __CC_ARM   )
+++++uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((at(0x2000E200)));  /* Ethernet Receive Buffer */
+++++uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]  __attribute__((at(0x2000FFC4))); /* Ethernet Transmit Buffer */
+++++#elif defined ( __GNUC__   )
+++++//uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".RxBUF")));/* Ethernet Receive Buffer */
+++++//uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".TxBUF")));/* Ethernet Transmit Buffer */
+++++uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Receive Buffer */
+++++uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Transmit Buffer */
+++++
+++++#endif
+++++/* Semaphore to signal incoming packets */
+++++osSemaphoreId s_xSemaphore = NULL;
++++ 
++++-  /* Do whatever else is needed to initialize interface. */  
+++++/* Global Ethernet handle*/
+++++ETH_HandleTypeDef EthHandle;
+++++
+++++/* Private function prototypes -----------------------------------------------*/
+++++static void ethernetif_input( void const * argument );
+++++
+++++static void stm32f_ethernet_isr(
+++++  void* argData
+++++)
+++++{
+++++  ETH_HandleTypeDef* pEth =
+++++    (ETH_HandleTypeDef*) argData;
+++++
+++++  HAL_ETH_IRQHandler(pEth);
++++ }
++++ 
+++++/* Private functions ---------------------------------------------------------*/
+++++/*******************************************************************************
+++++                       Ethernet MSP Routines
+++++*******************************************************************************/
++++ /**
++++- * This function should do the actual transmission of the packet. The packet is
++++- * contained in the pbuf that is passed to the function. This pbuf
++++- * might be chained.
++++- *
++++- * @param netif the lwip network interface structure for this ethernetif
++++- * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
++++- * @return ERR_OK if the packet could be sent
++++- *         an err_t value if the packet couldn't be sent
++++- *
++++- * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
++++- *       strange results. You might consider waiting for space in the DMA queue
++++- *       to become available since the stack doesn't retry to send a packet
++++- *       dropped because of memory failure (except for the TCP timers).
++++- */
++++-
++++-static err_t
++++-low_level_output(struct netif *netif, struct pbuf *p)
+++++  * @brief  Initializes the ETH MSP.
+++++  * @param  heth: ETH handle
+++++  * @retval None
+++++  */
+++++void HAL_ETH_MspInit(ETH_HandleTypeDef *heth)
++++ {
++++-  struct ethernetif *ethernetif = netif->state;
++++-  struct pbuf *q;
++++-
++++-  initiate transfer();
+++++  GPIO_InitTypeDef GPIO_InitStructure;
++++   
++++-#if ETH_PAD_SIZE
++++-  pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
++++-#endif
++++-
++++-  for(q = p; q != NULL; q = q->next) {
++++-    /* Send the data from the pbuf to the interface, one pbuf at a
++++-       time. The size of the data in each pbuf is kept in the ->len
++++-       variable. */
++++-    send data from(q->payload, q->len);
++++-  }
+++++  /* Enable GPIOs clocks */
+++++  __HAL_RCC_GPIOA_CLK_ENABLE();
+++++  __HAL_RCC_GPIOC_CLK_ENABLE();
+++++  __HAL_RCC_GPIOG_CLK_ENABLE();
++++ 
++++-  signal that packet should be sent();
+++++/* Ethernet pins configuration ************************************************/
+++++  /*
+++++        RMII_REF_CLK ----------------------> PA1
+++++        RMII_MDIO -------------------------> PA2
+++++        RMII_MDC --------------------------> PC1
+++++        RMII_MII_CRS_DV -------------------> PA7
+++++        RMII_MII_RXD0 ---------------------> PC4
+++++        RMII_MII_RXD1 ---------------------> PC5
+++++        RMII_MII_RXER ---------------------> PG2
+++++        RMII_MII_TX_EN --------------------> PG11
+++++        RMII_MII_TXD0 ---------------------> PG13
+++++        RMII_MII_TXD1 ---------------------> PG14
+++++  */
+++++
+++++  /* Configure PA1, PA2 and PA7 */
+++++  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
+++++  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
+++++  GPIO_InitStructure.Pull = GPIO_NOPULL; 
+++++  GPIO_InitStructure.Alternate = GPIO_AF11_ETH;
+++++  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
+++++  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
+++++  
+++++  /* Configure PC1, PC4 and PC5 */
+++++  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;
+++++  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
++++ 
++++-#if ETH_PAD_SIZE
++++-  pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
++++-#endif
+++++  /* Configure PG2, PG11, PG13 and PG14 */
+++++  GPIO_InitStructure.Pin =  GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14;
+++++  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
++++   
++++-  LINK_STATS_INC(link.xmit);
+++++  // Install HAL Ethernet ISR
+++++  rtems_interrupt_handler_install(
+++++    ETH_IRQn,
+++++    NULL,
+++++    0,
+++++    stm32f_ethernet_isr,
+++++    heth);
+++++  
+++++  /* Enable ETHERNET clock  */
+++++  __HAL_RCC_ETH_CLK_ENABLE();
+++++}
++++ 
++++-  return ERR_OK;
+++++/**
+++++  * @brief  Ethernet Rx Transfer completed callback
+++++  * @param  heth: ETH handle
+++++  * @retval None
+++++  */
+++++void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
+++++{
+++++  osSemaphoreRelease(s_xSemaphore);
++++ }
++++ 
++++ /**
++++- * Should allocate a pbuf and transfer the bytes of the incoming
++++- * packet from the interface into the pbuf.
++++- *
++++- * @param netif the lwip network interface structure for this ethernetif
++++- * @return a pbuf filled with the received packet (including MAC header)
++++- *         NULL on memory error
++++- */
++++-static struct pbuf *
++++-low_level_input(struct netif *netif)
+++++  * @brief  Ethernet IRQ Handler
+++++  * @param  None
+++++  * @retval None
+++++  */
+++++void ETHERNET_IRQHandler(void)
++++ {
++++-  struct ethernetif *ethernetif = netif->state;
++++-  struct pbuf *p, *q;
++++-  u16_t len;
+++++  HAL_ETH_IRQHandler(&EthHandle);
+++++}
++++ 
++++-  /* Obtain the size of the packet and put it into the "len"
++++-     variable. */
++++-  len = ;
+++++/*******************************************************************************
+++++                       LL Driver Interface ( LwIP stack --> ETH) 
+++++*******************************************************************************/
+++++/**
+++++  * @brief In this function, the hardware should be initialized.
+++++  * Called from ethernetif_init().
+++++  *
+++++  * @param netif the already initialized lwip network interface structure
+++++  *        for this ethernetif
+++++  */
+++++static void low_level_init(struct netif *netif)
+++++{
+++++  uint8_t macaddress[6]= { MAC_ADDR0, MAC_ADDR1, MAC_ADDR2, MAC_ADDR3, MAC_ADDR4, MAC_ADDR5 };
+++++  
+++++  EthHandle.Instance = ETH;  
+++++  EthHandle.Init.MACAddr = macaddress;
+++++  EthHandle.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
+++++  EthHandle.Init.Speed = ETH_SPEED_100M;
+++++  EthHandle.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
+++++  EthHandle.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
+++++  EthHandle.Init.RxMode = ETH_RXINTERRUPT_MODE;
+++++  EthHandle.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
+++++  EthHandle.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
+++++  
+++++  /* configure ethernet peripheral (GPIOs, clocks, MAC, DMA) */
+++++  if (HAL_ETH_Init(&EthHandle) == HAL_OK)
+++++  {
+++++    /* Set netif link flag */
+++++    netif->flags |= NETIF_FLAG_LINK_UP;
+++++  }
+++++  
+++++  /* Initialize Tx Descriptors list: Chain Mode */
+++++  HAL_ETH_DMATxDescListInit(&EthHandle, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
+++++     
+++++  /* Initialize Rx Descriptors list: Chain Mode  */
+++++  HAL_ETH_DMARxDescListInit(&EthHandle, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
+++++  
+++++  /* set netif MAC hardware address length */
+++++  netif->hwaddr_len = ETHARP_HWADDR_LEN;
++++ 
++++-#if ETH_PAD_SIZE
++++-  len += ETH_PAD_SIZE; /* allow room for Ethernet padding */
++++-#endif
+++++  /* set netif MAC hardware address */
+++++  netif->hwaddr[0] =  MAC_ADDR0;
+++++  netif->hwaddr[1] =  MAC_ADDR1;
+++++  netif->hwaddr[2] =  MAC_ADDR2;
+++++  netif->hwaddr[3] =  MAC_ADDR3;
+++++  netif->hwaddr[4] =  MAC_ADDR4;
+++++  netif->hwaddr[5] =  MAC_ADDR5;
++++ 
++++-  /* We allocate a pbuf chain of pbufs from the pool. */
++++-  p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
++++-  
++++-  if (p != NULL) {
+++++  /* set netif maximum transfer unit */
+++++  netif->mtu = 1500;
++++ 
++++-#if ETH_PAD_SIZE
++++-    pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
++++-#endif
+++++  /* Accept broadcast address and ARP traffic */
+++++  netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
++++ 
++++-    /* We iterate over the pbuf chain until we have read the entire
++++-     * packet into the pbuf. */
++++-    for(q = p; q != NULL; q = q->next) {
++++-      /* Read enough bytes to fill this pbuf in the chain. The
++++-       * available data in the pbuf is given by the q->len
++++-       * variable.
++++-       * This does not necessarily have to be a memcpy, you can also preallocate
++++-       * pbufs for a DMA-enabled MAC and after receiving truncate it to the
++++-       * actually received size. In this case, ensure the tot_len member of the
++++-       * pbuf is the sum of the chained pbuf len members.
++++-       */
++++-      read data into(q->payload, q->len);
++++-    }
++++-    acknowledge that packet has been read();
+++++  /* create a binary semaphore used for informing ethernetif of frame reception */
+++++  osSemaphoreDef(SEM);
+++++  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1 );
+++++
+++++  /* create the task that handles the ETH_MAC */
+++++  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
+++++  osThreadCreate (osThread(EthIf), netif);
+++++
+++++  /* Enable MAC and DMA transmission and reception */
+++++  HAL_ETH_Start(&EthHandle);
+++++}
++++ 
++++-#if ETH_PAD_SIZE
++++-    pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
++++-#endif
++++ 
++++-    LINK_STATS_INC(link.recv);
++++-  } else {
++++-    drop packet();
++++-    LINK_STATS_INC(link.memerr);
++++-    LINK_STATS_INC(link.drop);
+++++/**
+++++  * @brief This function should do the actual transmission of the packet. The packet is
+++++  * contained in the pbuf that is passed to the function. This pbuf
+++++  * might be chained.
+++++  *
+++++  * @param netif the lwip network interface structure for this ethernetif
+++++  * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
+++++  * @return ERR_OK if the packet could be sent
+++++  *         an err_t value if the packet couldn't be sent
+++++  *
+++++  * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
+++++  *       strange results. You might consider waiting for space in the DMA queue
+++++  *       to become available since the stack doesn't retry to send a packet
+++++  *       dropped because of memory failure (except for the TCP timers).
+++++  */
+++++static err_t low_level_output(struct netif *netif, struct pbuf *p)
+++++{
+++++  err_t errval;
+++++  struct pbuf *q;
+++++  uint8_t *buffer = (uint8_t *)(EthHandle.TxDesc->Buffer1Addr);
+++++  __IO ETH_DMADescTypeDef *DmaTxDesc;
+++++  uint32_t framelength = 0;
+++++  uint32_t bufferoffset = 0;
+++++  uint32_t byteslefttocopy = 0;
+++++  uint32_t payloadoffset = 0;
+++++
+++++  DmaTxDesc = EthHandle.TxDesc;
+++++  bufferoffset = 0;
+++++  
+++++  /* copy frame from pbufs to driver buffers */
+++++  for(q = p; q != NULL; q = q->next)
+++++  {
+++++    /* Is this buffer available? If not, goto error */
+++++    if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
+++++    {
+++++      errval = ERR_USE;
+++++      goto error;
+++++    }
+++++    
+++++    /* Get bytes in current lwIP buffer */
+++++    byteslefttocopy = q->len;
+++++    payloadoffset = 0;
+++++    
+++++    /* Check if the length of data to copy is bigger than Tx buffer size*/
+++++    while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
+++++    {
+++++      /* Copy data to Tx buffer*/
+++++      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
+++++      
+++++      /* Point to next descriptor */
+++++      DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
+++++      
+++++      /* Check if the buffer is available */
+++++      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
+++++      {
+++++        errval = ERR_USE;
+++++        goto error;
+++++      }
+++++      
+++++      buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
+++++      
+++++      byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
+++++      payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
+++++      framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
+++++      bufferoffset = 0;
+++++    }
+++++    
+++++    /* Copy the remaining bytes */
+++++    memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
+++++    bufferoffset = bufferoffset + byteslefttocopy;
+++++    framelength = framelength + byteslefttocopy;
+++++  }
+++++  
+++++  /* Prepare transmit descriptors to give to DMA */ 
+++++  HAL_ETH_TransmitFrame(&EthHandle, framelength);
+++++  
+++++  errval = ERR_OK;
+++++  
+++++error:
+++++  
+++++  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
+++++  if ((EthHandle.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
+++++  {
+++++    /* Clear TUS ETHERNET DMA flag */
+++++    EthHandle.Instance->DMASR = ETH_DMASR_TUS;
+++++    
+++++    /* Resume DMA transmission*/
+++++    EthHandle.Instance->DMATPDR = 0;
++++   }
+++++  return errval;
+++++}
++++ 
++++-  return p;  
+++++/**
+++++  * @brief Should allocate a pbuf and transfer the bytes of the incoming
+++++  * packet from the interface into the pbuf.
+++++  *
+++++  * @param netif the lwip network interface structure for this ethernetif
+++++  * @return a pbuf filled with the received packet (including MAC header)
+++++  *         NULL on memory error
+++++  */
+++++static struct pbuf * low_level_input(struct netif *netif)
+++++{
+++++  struct pbuf *p = NULL, *q = NULL;
+++++  uint16_t len = 0;
+++++  uint8_t *buffer;
+++++  __IO ETH_DMADescTypeDef *dmarxdesc;
+++++  uint32_t bufferoffset = 0;
+++++  uint32_t payloadoffset = 0;
+++++  uint32_t byteslefttocopy = 0;
+++++  uint32_t i=0;
+++++  
+++++  /* get received frame */
+++++  if(HAL_ETH_GetReceivedFrame_IT(&EthHandle) != HAL_OK)
+++++    return NULL;
+++++  
+++++  /* Obtain the size of the packet and put it into the "len" variable. */
+++++  len = EthHandle.RxFrameInfos.length;
+++++  buffer = (uint8_t *)EthHandle.RxFrameInfos.buffer;
+++++  
+++++  if (len > 0)
+++++  {
+++++    /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
+++++    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
+++++  }
+++++  
+++++  if (p != NULL)
+++++  {
+++++    dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
+++++    bufferoffset = 0;
+++++    
+++++    for(q = p; q != NULL; q = q->next)
+++++    {
+++++      byteslefttocopy = q->len;
+++++      payloadoffset = 0;
+++++      
+++++      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size */
+++++      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
+++++      {
+++++        /* Copy data to pbuf */
+++++        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
+++++        
+++++        /* Point to next descriptor */
+++++        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
+++++        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
+++++        
+++++        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
+++++        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
+++++        bufferoffset = 0;
+++++      }
+++++      
+++++      /* Copy remaining data in pbuf */
+++++      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
+++++      bufferoffset = bufferoffset + byteslefttocopy;
+++++    }
+++++  }
+++++    
+++++  /* Release descriptors to DMA */
+++++  /* Point to first descriptor */
+++++  dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
+++++  /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
+++++  for (i=0; i< EthHandle.RxFrameInfos.SegCount; i++)
+++++  {  
+++++    dmarxdesc->Status |= ETH_DMARXDESC_OWN;
+++++    dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
+++++  }
+++++    
+++++  /* Clear Segment_Count */
+++++  EthHandle.RxFrameInfos.SegCount =0;
+++++  
+++++  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
+++++  if ((EthHandle.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
+++++  {
+++++    /* Clear RBUS ETHERNET DMA flag */
+++++    EthHandle.Instance->DMASR = ETH_DMASR_RBUS;
+++++    /* Resume DMA reception */
+++++    EthHandle.Instance->DMARPDR = 0;
+++++  }
+++++  return p;
++++ }
++++ 
++++ /**
++++- * This function should be called when a packet is ready to be read
++++- * from the interface. It uses the function low_level_input() that
++++- * should handle the actual reception of bytes from the network
++++- * interface. Then the type of the received packet is determined and
++++- * the appropriate input function is called.
++++- *
++++- * @param netif the lwip network interface structure for this ethernetif
++++- */
++++-static void
++++-ethernetif_input(struct netif *netif)
+++++  * @brief This function is the ethernetif_input task, it is processed when a packet 
+++++  * is ready to be read from the interface. It uses the function low_level_input() 
+++++  * that should handle the actual reception of bytes from the network
+++++  * interface. Then the type of the received packet is determined and
+++++  * the appropriate input function is called.
+++++  *
+++++  * @param netif the lwip network interface structure for this ethernetif
+++++  */
+++++void ethernetif_input( void const * argument )
++++ {
++++-  struct ethernetif *ethernetif;
++++-  struct eth_hdr *ethhdr;
++++   struct pbuf *p;
++++-
++++-  ethernetif = netif->state;
++++-
++++-  /* move received packet into a new pbuf */
++++-  p = low_level_input(netif);
++++-  /* no packet could be read, silently ignore this */
++++-  if (p == NULL) return;
++++-  /* points to packet payload, which starts with an Ethernet header */
++++-  ethhdr = p->payload;
++++-
++++-  switch (htons(ethhdr->type)) {
++++-  /* IP or ARP packet? */
++++-  case ETHTYPE_IP:
++++-  case ETHTYPE_IPV6:
++++-  case ETHTYPE_ARP:
++++-#if PPPOE_SUPPORT
++++-  /* PPPoE packet? */
++++-  case ETHTYPE_PPPOEDISC:
++++-  case ETHTYPE_PPPOE:
++++-#endif /* PPPOE_SUPPORT */
++++-    /* full packet send to tcpip_thread to process */
++++-    if (netif->input(p, netif)!=ERR_OK)
++++-     { LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
++++-       pbuf_free(p);
++++-       p = NULL;
++++-     }
++++-    break;
++++-
++++-  default:
++++-    pbuf_free(p);
++++-    p = NULL;
++++-    break;
+++++  struct netif *netif = (struct netif *) argument;
+++++  
+++++  for( ;; )
+++++  {
+++++    if (osSemaphoreWait( s_xSemaphore, TIME_WAITING_FOR_INPUT)==osOK)
+++++    {
+++++      do
+++++      {
+++++        p = low_level_input( netif );
+++++        if (p != NULL)
+++++        {
+++++          if (netif->input( p, netif) != ERR_OK )
+++++          {
+++++            pbuf_free(p);
+++++          }
+++++        }
+++++      }while(p!=NULL);
+++++    }
++++   }
++++ }
++++ 
++++ /**
++++- * Should be called at the beginning of the program to set up the
++++- * network interface. It calls the function low_level_init() to do the
++++- * actual setup of the hardware.
++++- *
++++- * This function should be passed as a parameter to netif_add().
++++- *
++++- * @param netif the lwip network interface structure for this ethernetif
++++- * @return ERR_OK if the loopif is initialized
++++- *         ERR_MEM if private data couldn't be allocated
++++- *         any other err_t on error
++++- */
++++-err_t
++++-ethernetif_init(struct netif *netif)
+++++  * @brief Should be called at the beginning of the program to set up the
+++++  * network interface. It calls the function low_level_init() to do the
+++++  * actual setup of the hardware.
+++++  *
+++++  * This function should be passed as a parameter to netif_add().
+++++  *
+++++  * @param netif the lwip network interface structure for this ethernetif
+++++  * @return ERR_OK if the loopif is initialized
+++++  *         ERR_MEM if private data couldn't be allocated
+++++  *         any other err_t on error
+++++  */
+++++err_t ethernetif_init(struct netif *netif)
++++ {
++++-  struct ethernetif *ethernetif;
++++-
++++   LWIP_ASSERT("netif != NULL", (netif != NULL));
++++-    
++++-  ethernetif = mem_malloc(sizeof(struct ethernetif));
++++-  if (ethernetif == NULL) {
++++-    LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_init: out of memory\n"));
++++-    return ERR_MEM;
++++-  }
++++ 
++++ #if LWIP_NETIF_HOSTNAME
++++   /* Initialize interface hostname */
++++   netif->hostname = "lwip";
++++ #endif /* LWIP_NETIF_HOSTNAME */
++++ 
++++-  /*
++++-   * Initialize the snmp variables and counters inside the struct netif.
++++-   * The last argument should be replaced with your link speed, in units
++++-   * of bits per second.
++++-   */
++++-  NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, LINK_SPEED_OF_YOUR_NETIF_IN_BPS);
++++-
++++-  netif->state = ethernetif;
++++   netif->name[0] = IFNAME0;
++++   netif->name[1] = IFNAME1;
++++-  /* We directly use etharp_output() here to save a function call.
++++-   * You can instead declare your own function an call etharp_output()
++++-   * from it if you have to do some checks before sending (e.g. if link
++++-   * is available...) */
+++++
++++   netif->output = etharp_output;
++++-#if LWIP_IPV6
++++-  netif->output_ip6 = ethip6_output;
++++-#endif /* LWIP_IPV6 */
++++   netif->linkoutput = low_level_output;
++++-  
++++-  ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
++++-  
+++++
++++   /* initialize the hardware */
++++   low_level_init(netif);
++++ 
++++   return ERR_OK;
++++ }
++++ 
++++-#endif /* 0 */
+++++/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
++++-- 
++++1.9.1
++++
++++
++++From ab97b49d1d41e34fdfdfb457b397c768ee228c9f Mon Sep 17 00:00:00 2001
++++From: Jay Doyle <jay.doyle@vecna.com>
++++Date: Mon, 7 Sep 2015 09:39:20 -0400
++++Subject: [PATCH 5/9] removed ethernetif (it should be in BSP
++++
++++---
++++ src/netif/ethernetif.c | 496 -------------------------------------------------
++++ 1 file changed, 496 deletions(-)
++++ delete mode 100644 src/netif/ethernetif.c
++++
++++diff --git a/src/netif/ethernetif.c b/src/netif/ethernetif.c
++++deleted file mode 100644
++++index 82c85ae..0000000
++++--- a/src/netif/ethernetif.c
+++++++ /dev/null
++++@@ -1,496 +0,0 @@
++++-/**
++++-  ******************************************************************************
++++-  * @file    LwIP/LwIP_HTTP_Server_Netconn_RTOS/Src/ethernetif.c
++++-  * @author  MCD Application Team
++++-  * @version V1.0.0
++++-  * @date    25-June-2015
++++-  * @brief   This file implements Ethernet network interface drivers for lwIP
++++-  ******************************************************************************
++++-  * @attention
++++-  *
++++-  * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
++++-  *
++++-  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
++++-  * You may not use this file except in compliance with the License.
++++-  * You may obtain a copy of the License at:
++++-  *
++++-  *        http://www.st.com/software_license_agreement_liberty_v2
++++-  *
++++-  * Unless required by applicable law or agreed to in writing, software 
++++-  * distributed under the License is distributed on an "AS IS" BASIS, 
++++-  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++++-  * See the License for the specific language governing permissions and
++++-  * limitations under the License.
++++-  *
++++-  ******************************************************************************
++++-  */
++++-
++++-/* Includes ------------------------------------------------------------------*/
++++-#include "stm32f7xx_hal.h"
++++-#include "lwip/opt.h"
++++-#include "lwip/lwip_timers.h"
++++-#include "netif/etharp.h"
++++-#include "hal-ethernetif.h"
++++-#include <string.h>
++++-
++++-/* Private typedef -----------------------------------------------------------*/
++++-/* Private define ------------------------------------------------------------*/
++++-/* The time to block waiting for input. */
++++-#define TIME_WAITING_FOR_INPUT                 ( 100 )
++++-/* Stack size of the interface thread */
++++-#define INTERFACE_THREAD_STACK_SIZE            ( 350 )
++++-
++++-/* Define those to better describe your network interface. */
++++-#define IFNAME0 'e'
++++-#define IFNAME1 'n'
++++-
++++-#define LAN8742A_PHY_ADDRESS            0x00
++++-
++++-/* Private macro -------------------------------------------------------------*/
++++-/* Private variables ---------------------------------------------------------*/
++++-
++++-#if defined ( __ICCARM__ ) /*!< IAR Compiler */
++++-
++++-#pragma location=0x2000E000
++++-__no_init ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
++++-#pragma location=0x2000E100
++++-__no_init ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
++++-#elif defined ( __CC_ARM   )
++++-ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((at(0x2000E000)));/* Ethernet Rx MA Descriptor */
++++-ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((at(0x2000E100)));/* Ethernet Tx DMA Descriptor */
++++-#elif defined ( __GNUC__   )
++++-//ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".RxDescripSection")));/* Ethernet Rx MA Descriptor */
++++-//ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".TxDescripSection")));/* Ethernet Tx DMA Descriptor */
++++-ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Rx MA Descriptor */
++++-ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Tx DMA Descriptor */
++++-
++++-
++++-#endif
++++-#if defined ( __ICCARM__ ) /*!< IAR Compiler */
++++-#pragma location=0x2000E200
++++-__no_init uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
++++-#pragma location=0x2000FFC4
++++-__no_init uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
++++-#elif defined ( __CC_ARM   )
++++-uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((at(0x2000E200)));  /* Ethernet Receive Buffer */
++++-uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]  __attribute__((at(0x2000FFC4))); /* Ethernet Transmit Buffer */
++++-#elif defined ( __GNUC__   )
++++-//uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".RxBUF")));/* Ethernet Receive Buffer */
++++-//uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".TxBUF")));/* Ethernet Transmit Buffer */
++++-uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Receive Buffer */
++++-uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Transmit Buffer */
++++-
++++-#endif
++++-/* Semaphore to signal incoming packets */
++++-osSemaphoreId s_xSemaphore = NULL;
++++-
++++-/* Global Ethernet handle*/
++++-ETH_HandleTypeDef EthHandle;
++++-
++++-/* Private function prototypes -----------------------------------------------*/
++++-static void ethernetif_input( void const * argument );
++++-
++++-static void stm32f_ethernet_isr(
++++-  void* argData
++++-)
++++-{
++++-  ETH_HandleTypeDef* pEth =
++++-    (ETH_HandleTypeDef*) argData;
++++-
++++-  HAL_ETH_IRQHandler(pEth);
++++-}
++++-
++++-/* Private functions ---------------------------------------------------------*/
++++-/*******************************************************************************
++++-                       Ethernet MSP Routines
++++-*******************************************************************************/
++++-/**
++++-  * @brief  Initializes the ETH MSP.
++++-  * @param  heth: ETH handle
++++-  * @retval None
++++-  */
++++-void HAL_ETH_MspInit(ETH_HandleTypeDef *heth)
++++-{
++++-  GPIO_InitTypeDef GPIO_InitStructure;
++++-  
++++-  /* Enable GPIOs clocks */
++++-  __HAL_RCC_GPIOA_CLK_ENABLE();
++++-  __HAL_RCC_GPIOC_CLK_ENABLE();
++++-  __HAL_RCC_GPIOG_CLK_ENABLE();
++++-
++++-/* Ethernet pins configuration ************************************************/
++++-  /*
++++-        RMII_REF_CLK ----------------------> PA1
++++-        RMII_MDIO -------------------------> PA2
++++-        RMII_MDC --------------------------> PC1
++++-        RMII_MII_CRS_DV -------------------> PA7
++++-        RMII_MII_RXD0 ---------------------> PC4
++++-        RMII_MII_RXD1 ---------------------> PC5
++++-        RMII_MII_RXER ---------------------> PG2
++++-        RMII_MII_TX_EN --------------------> PG11
++++-        RMII_MII_TXD0 ---------------------> PG13
++++-        RMII_MII_TXD1 ---------------------> PG14
++++-  */
++++-
++++-  /* Configure PA1, PA2 and PA7 */
++++-  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
++++-  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
++++-  GPIO_InitStructure.Pull = GPIO_NOPULL; 
++++-  GPIO_InitStructure.Alternate = GPIO_AF11_ETH;
++++-  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
++++-  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
++++-  
++++-  /* Configure PC1, PC4 and PC5 */
++++-  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;
++++-  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
++++-
++++-  /* Configure PG2, PG11, PG13 and PG14 */
++++-  GPIO_InitStructure.Pin =  GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14;
++++-  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
++++-  
++++-  // Install HAL Ethernet ISR
++++-  rtems_interrupt_handler_install(
++++-    ETH_IRQn,
++++-    NULL,
++++-    0,
++++-    stm32f_ethernet_isr,
++++-    heth);
++++-  
++++-  /* Enable ETHERNET clock  */
++++-  __HAL_RCC_ETH_CLK_ENABLE();
++++-}
++++-
++++-/**
++++-  * @brief  Ethernet Rx Transfer completed callback
++++-  * @param  heth: ETH handle
++++-  * @retval None
++++-  */
++++-void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
++++-{
++++-  osSemaphoreRelease(s_xSemaphore);
++++-}
++++-
++++-/**
++++-  * @brief  Ethernet IRQ Handler
++++-  * @param  None
++++-  * @retval None
++++-  */
++++-void ETHERNET_IRQHandler(void)
++++-{
++++-  HAL_ETH_IRQHandler(&EthHandle);
++++-}
++++-
++++-/*******************************************************************************
++++-                       LL Driver Interface ( LwIP stack --> ETH) 
++++-*******************************************************************************/
++++-/**
++++-  * @brief In this function, the hardware should be initialized.
++++-  * Called from ethernetif_init().
++++-  *
++++-  * @param netif the already initialized lwip network interface structure
++++-  *        for this ethernetif
++++-  */
++++-static void low_level_init(struct netif *netif)
++++-{
++++-  uint8_t macaddress[6]= { MAC_ADDR0, MAC_ADDR1, MAC_ADDR2, MAC_ADDR3, MAC_ADDR4, MAC_ADDR5 };
++++-  
++++-  EthHandle.Instance = ETH;  
++++-  EthHandle.Init.MACAddr = macaddress;
++++-  EthHandle.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
++++-  EthHandle.Init.Speed = ETH_SPEED_100M;
++++-  EthHandle.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
++++-  EthHandle.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
++++-  EthHandle.Init.RxMode = ETH_RXINTERRUPT_MODE;
++++-  EthHandle.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
++++-  EthHandle.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
++++-  
++++-  /* configure ethernet peripheral (GPIOs, clocks, MAC, DMA) */
++++-  if (HAL_ETH_Init(&EthHandle) == HAL_OK)
++++-  {
++++-    /* Set netif link flag */
++++-    netif->flags |= NETIF_FLAG_LINK_UP;
++++-  }
++++-  
++++-  /* Initialize Tx Descriptors list: Chain Mode */
++++-  HAL_ETH_DMATxDescListInit(&EthHandle, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
++++-     
++++-  /* Initialize Rx Descriptors list: Chain Mode  */
++++-  HAL_ETH_DMARxDescListInit(&EthHandle, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
++++-  
++++-  /* set netif MAC hardware address length */
++++-  netif->hwaddr_len = ETHARP_HWADDR_LEN;
++++-
++++-  /* set netif MAC hardware address */
++++-  netif->hwaddr[0] =  MAC_ADDR0;
++++-  netif->hwaddr[1] =  MAC_ADDR1;
++++-  netif->hwaddr[2] =  MAC_ADDR2;
++++-  netif->hwaddr[3] =  MAC_ADDR3;
++++-  netif->hwaddr[4] =  MAC_ADDR4;
++++-  netif->hwaddr[5] =  MAC_ADDR5;
++++-
++++-  /* set netif maximum transfer unit */
++++-  netif->mtu = 1500;
++++-
++++-  /* Accept broadcast address and ARP traffic */
++++-  netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
++++-
++++-  /* create a binary semaphore used for informing ethernetif of frame reception */
++++-  osSemaphoreDef(SEM);
++++-  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1 );
++++-
++++-  /* create the task that handles the ETH_MAC */
++++-  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
++++-  osThreadCreate (osThread(EthIf), netif);
++++-
++++-  /* Enable MAC and DMA transmission and reception */
++++-  HAL_ETH_Start(&EthHandle);
++++-}
++++-
++++-
++++-/**
++++-  * @brief This function should do the actual transmission of the packet. The packet is
++++-  * contained in the pbuf that is passed to the function. This pbuf
++++-  * might be chained.
++++-  *
++++-  * @param netif the lwip network interface structure for this ethernetif
++++-  * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
++++-  * @return ERR_OK if the packet could be sent
++++-  *         an err_t value if the packet couldn't be sent
++++-  *
++++-  * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
++++-  *       strange results. You might consider waiting for space in the DMA queue
++++-  *       to become available since the stack doesn't retry to send a packet
++++-  *       dropped because of memory failure (except for the TCP timers).
++++-  */
++++-static err_t low_level_output(struct netif *netif, struct pbuf *p)
++++-{
++++-  err_t errval;
++++-  struct pbuf *q;
++++-  uint8_t *buffer = (uint8_t *)(EthHandle.TxDesc->Buffer1Addr);
++++-  __IO ETH_DMADescTypeDef *DmaTxDesc;
++++-  uint32_t framelength = 0;
++++-  uint32_t bufferoffset = 0;
++++-  uint32_t byteslefttocopy = 0;
++++-  uint32_t payloadoffset = 0;
++++-
++++-  DmaTxDesc = EthHandle.TxDesc;
++++-  bufferoffset = 0;
++++-  
++++-  /* copy frame from pbufs to driver buffers */
++++-  for(q = p; q != NULL; q = q->next)
++++-  {
++++-    /* Is this buffer available? If not, goto error */
++++-    if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
++++-    {
++++-      errval = ERR_USE;
++++-      goto error;
++++-    }
++++-    
++++-    /* Get bytes in current lwIP buffer */
++++-    byteslefttocopy = q->len;
++++-    payloadoffset = 0;
++++-    
++++-    /* Check if the length of data to copy is bigger than Tx buffer size*/
++++-    while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
++++-    {
++++-      /* Copy data to Tx buffer*/
++++-      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
++++-      
++++-      /* Point to next descriptor */
++++-      DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
++++-      
++++-      /* Check if the buffer is available */
++++-      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
++++-      {
++++-        errval = ERR_USE;
++++-        goto error;
++++-      }
++++-      
++++-      buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
++++-      
++++-      byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
++++-      payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
++++-      framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
++++-      bufferoffset = 0;
++++-    }
++++-    
++++-    /* Copy the remaining bytes */
++++-    memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
++++-    bufferoffset = bufferoffset + byteslefttocopy;
++++-    framelength = framelength + byteslefttocopy;
++++-  }
++++-  
++++-  /* Prepare transmit descriptors to give to DMA */ 
++++-  HAL_ETH_TransmitFrame(&EthHandle, framelength);
++++-  
++++-  errval = ERR_OK;
++++-  
++++-error:
++++-  
++++-  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
++++-  if ((EthHandle.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
++++-  {
++++-    /* Clear TUS ETHERNET DMA flag */
++++-    EthHandle.Instance->DMASR = ETH_DMASR_TUS;
++++-    
++++-    /* Resume DMA transmission*/
++++-    EthHandle.Instance->DMATPDR = 0;
++++-  }
++++-  return errval;
++++-}
++++-
++++-/**
++++-  * @brief Should allocate a pbuf and transfer the bytes of the incoming
++++-  * packet from the interface into the pbuf.
++++-  *
++++-  * @param netif the lwip network interface structure for this ethernetif
++++-  * @return a pbuf filled with the received packet (including MAC header)
++++-  *         NULL on memory error
++++-  */
++++-static struct pbuf * low_level_input(struct netif *netif)
++++-{
++++-  struct pbuf *p = NULL, *q = NULL;
++++-  uint16_t len = 0;
++++-  uint8_t *buffer;
++++-  __IO ETH_DMADescTypeDef *dmarxdesc;
++++-  uint32_t bufferoffset = 0;
++++-  uint32_t payloadoffset = 0;
++++-  uint32_t byteslefttocopy = 0;
++++-  uint32_t i=0;
++++-  
++++-  /* get received frame */
++++-  if(HAL_ETH_GetReceivedFrame_IT(&EthHandle) != HAL_OK)
++++-    return NULL;
++++-  
++++-  /* Obtain the size of the packet and put it into the "len" variable. */
++++-  len = EthHandle.RxFrameInfos.length;
++++-  buffer = (uint8_t *)EthHandle.RxFrameInfos.buffer;
++++-  
++++-  if (len > 0)
++++-  {
++++-    /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
++++-    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
++++-  }
++++-  
++++-  if (p != NULL)
++++-  {
++++-    dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
++++-    bufferoffset = 0;
++++-    
++++-    for(q = p; q != NULL; q = q->next)
++++-    {
++++-      byteslefttocopy = q->len;
++++-      payloadoffset = 0;
++++-      
++++-      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size */
++++-      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
++++-      {
++++-        /* Copy data to pbuf */
++++-        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
++++-        
++++-        /* Point to next descriptor */
++++-        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
++++-        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
++++-        
++++-        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
++++-        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
++++-        bufferoffset = 0;
++++-      }
++++-      
++++-      /* Copy remaining data in pbuf */
++++-      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
++++-      bufferoffset = bufferoffset + byteslefttocopy;
++++-    }
++++-  }
++++-    
++++-  /* Release descriptors to DMA */
++++-  /* Point to first descriptor */
++++-  dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
++++-  /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
++++-  for (i=0; i< EthHandle.RxFrameInfos.SegCount; i++)
++++-  {  
++++-    dmarxdesc->Status |= ETH_DMARXDESC_OWN;
++++-    dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
++++-  }
++++-    
++++-  /* Clear Segment_Count */
++++-  EthHandle.RxFrameInfos.SegCount =0;
++++-  
++++-  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
++++-  if ((EthHandle.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
++++-  {
++++-    /* Clear RBUS ETHERNET DMA flag */
++++-    EthHandle.Instance->DMASR = ETH_DMASR_RBUS;
++++-    /* Resume DMA reception */
++++-    EthHandle.Instance->DMARPDR = 0;
++++-  }
++++-  return p;
++++-}
++++-
++++-/**
++++-  * @brief This function is the ethernetif_input task, it is processed when a packet 
++++-  * is ready to be read from the interface. It uses the function low_level_input() 
++++-  * that should handle the actual reception of bytes from the network
++++-  * interface. Then the type of the received packet is determined and
++++-  * the appropriate input function is called.
++++-  *
++++-  * @param netif the lwip network interface structure for this ethernetif
++++-  */
++++-void ethernetif_input( void const * argument )
++++-{
++++-  struct pbuf *p;
++++-  struct netif *netif = (struct netif *) argument;
++++-  
++++-  for( ;; )
++++-  {
++++-    if (osSemaphoreWait( s_xSemaphore, TIME_WAITING_FOR_INPUT)==osOK)
++++-    {
++++-      do
++++-      {
++++-        p = low_level_input( netif );
++++-        if (p != NULL)
++++-        {
++++-          if (netif->input( p, netif) != ERR_OK )
++++-          {
++++-            pbuf_free(p);
++++-          }
++++-        }
++++-      }while(p!=NULL);
++++-    }
++++-  }
++++-}
++++-
++++-/**
++++-  * @brief Should be called at the beginning of the program to set up the
++++-  * network interface. It calls the function low_level_init() to do the
++++-  * actual setup of the hardware.
++++-  *
++++-  * This function should be passed as a parameter to netif_add().
++++-  *
++++-  * @param netif the lwip network interface structure for this ethernetif
++++-  * @return ERR_OK if the loopif is initialized
++++-  *         ERR_MEM if private data couldn't be allocated
++++-  *         any other err_t on error
++++-  */
++++-err_t ethernetif_init(struct netif *netif)
++++-{
++++-  LWIP_ASSERT("netif != NULL", (netif != NULL));
++++-
++++-#if LWIP_NETIF_HOSTNAME
++++-  /* Initialize interface hostname */
++++-  netif->hostname = "lwip";
++++-#endif /* LWIP_NETIF_HOSTNAME */
++++-
++++-  netif->name[0] = IFNAME0;
++++-  netif->name[1] = IFNAME1;
++++-
++++-  netif->output = etharp_output;
++++-  netif->linkoutput = low_level_output;
++++-
++++-  /* initialize the hardware */
++++-  low_level_init(netif);
++++-
++++-  return ERR_OK;
++++-}
++++-
++++-/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
++++-- 
++++1.9.1
++++
++++
++++From 31d34fab26b1e3fde99fe7288786725fe5e51b95 Mon Sep 17 00:00:00 2001
++++From: Jay Doyle <jay.doyle@vecna.com>
++++Date: Mon, 7 Sep 2015 10:17:32 -0400
++++Subject: [PATCH 6/9] add low level driver back
++++
++++---
++++ src/netif/ethernetif.c | 496 +++++++++++++++++++++++++++++++++++++++++++++++++
++++ 1 file changed, 496 insertions(+)
++++ create mode 100644 src/netif/ethernetif.c
++++
++++diff --git a/src/netif/ethernetif.c b/src/netif/ethernetif.c
++++new file mode 100644
++++index 0000000..bc429e9
++++--- /dev/null
+++++++ b/src/netif/ethernetif.c
++++@@ -0,0 +1,496 @@
+++++/**
+++++  ******************************************************************************
+++++  * @file    LwIP/LwIP_HTTP_Server_Netconn_RTOS/Src/ethernetif.c
+++++  * @author  MCD Application Team
+++++  * @version V1.0.0
+++++  * @date    25-June-2015
+++++  * @brief   This file implements Ethernet network interface drivers for lwIP
+++++  ******************************************************************************
+++++  * @attention
+++++  *
+++++  * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
+++++  *
+++++  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+++++  * You may not use this file except in compliance with the License.
+++++  * You may obtain a copy of the License at:
+++++  *
+++++  *        http://www.st.com/software_license_agreement_liberty_v2
+++++  *
+++++  * Unless required by applicable law or agreed to in writing, software 
+++++  * distributed under the License is distributed on an "AS IS" BASIS, 
+++++  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+++++  * See the License for the specific language governing permissions and
+++++  * limitations under the License.
+++++  *
+++++  ******************************************************************************
+++++  */
+++++
+++++/* Includes ------------------------------------------------------------------*/
+++++#include <stm32f7xx_hal.h>
+++++#include <lwip/opt.h>
+++++#include <lwip/lwip_timers.h>
+++++#include <netif/etharp.h>
+++++#include <hal-ethernetif.h>
+++++#include <string.h>
+++++
+++++/* Private typedef -----------------------------------------------------------*/
+++++/* Private define ------------------------------------------------------------*/
+++++/* The time to block waiting for input. */
+++++#define TIME_WAITING_FOR_INPUT                 ( 100 )
+++++/* Stack size of the interface thread */
+++++#define INTERFACE_THREAD_STACK_SIZE            ( 350 )
+++++
+++++/* Define those to better describe your network interface. */
+++++#define IFNAME0 'e'
+++++#define IFNAME1 'n'
+++++
+++++#define LAN8742A_PHY_ADDRESS            0x00
+++++
+++++/* Private macro -------------------------------------------------------------*/
+++++/* Private variables ---------------------------------------------------------*/
+++++
+++++#if defined ( __ICCARM__ ) /*!< IAR Compiler */
+++++
+++++#pragma location=0x2000E000
+++++__no_init ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
+++++#pragma location=0x2000E100
+++++__no_init ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
+++++#elif defined ( __CC_ARM   )
+++++ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((at(0x2000E000)));/* Ethernet Rx MA Descriptor */
+++++ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((at(0x2000E100)));/* Ethernet Tx DMA Descriptor */
+++++#elif defined ( __GNUC__   )
+++++//ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".RxDescripSection")));/* Ethernet Rx MA Descriptor */
+++++//ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".TxDescripSection")));/* Ethernet Tx DMA Descriptor */
+++++ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Rx MA Descriptor */
+++++ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Tx DMA Descriptor */
+++++
+++++
+++++#endif
+++++#if defined ( __ICCARM__ ) /*!< IAR Compiler */
+++++#pragma location=0x2000E200
+++++__no_init uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
+++++#pragma location=0x2000FFC4
+++++__no_init uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
+++++#elif defined ( __CC_ARM   )
+++++uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((at(0x2000E200)));  /* Ethernet Receive Buffer */
+++++uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]  __attribute__((at(0x2000FFC4))); /* Ethernet Transmit Buffer */
+++++#elif defined ( __GNUC__   )
+++++//uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".RxBUF")));/* Ethernet Receive Buffer */
+++++//uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".TxBUF")));/* Ethernet Transmit Buffer */
+++++uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Receive Buffer */
+++++uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Transmit Buffer */
+++++
+++++#endif
+++++/* Semaphore to signal incoming packets */
+++++osSemaphoreId s_xSemaphore = NULL;
+++++
+++++/* Global Ethernet handle*/
+++++ETH_HandleTypeDef EthHandle;
+++++
+++++/* Private function prototypes -----------------------------------------------*/
+++++static void ethernetif_input( void const * argument );
+++++
+++++static void stm32f_ethernet_isr(
+++++  void* argData
+++++)
+++++{
+++++  ETH_HandleTypeDef* pEth =
+++++    (ETH_HandleTypeDef*) argData;
+++++
+++++  HAL_ETH_IRQHandler(pEth);
+++++}
+++++
+++++/* Private functions ---------------------------------------------------------*/
+++++/*******************************************************************************
+++++                       Ethernet MSP Routines
+++++*******************************************************************************/
+++++/**
+++++  * @brief  Initializes the ETH MSP.
+++++  * @param  heth: ETH handle
+++++  * @retval None
+++++  */
+++++void HAL_ETH_MspInit(ETH_HandleTypeDef *heth)
+++++{
+++++  GPIO_InitTypeDef GPIO_InitStructure;
+++++  
+++++  /* Enable GPIOs clocks */
+++++  __HAL_RCC_GPIOA_CLK_ENABLE();
+++++  __HAL_RCC_GPIOC_CLK_ENABLE();
+++++  __HAL_RCC_GPIOG_CLK_ENABLE();
+++++
+++++/* Ethernet pins configuration ************************************************/
+++++  /*
+++++        RMII_REF_CLK ----------------------> PA1
+++++        RMII_MDIO -------------------------> PA2
+++++        RMII_MDC --------------------------> PC1
+++++        RMII_MII_CRS_DV -------------------> PA7
+++++        RMII_MII_RXD0 ---------------------> PC4
+++++        RMII_MII_RXD1 ---------------------> PC5
+++++        RMII_MII_RXER ---------------------> PG2
+++++        RMII_MII_TX_EN --------------------> PG11
+++++        RMII_MII_TXD0 ---------------------> PG13
+++++        RMII_MII_TXD1 ---------------------> PG14
+++++  */
+++++
+++++  /* Configure PA1, PA2 and PA7 */
+++++  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
+++++  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
+++++  GPIO_InitStructure.Pull = GPIO_NOPULL; 
+++++  GPIO_InitStructure.Alternate = GPIO_AF11_ETH;
+++++  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
+++++  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
+++++  
+++++  /* Configure PC1, PC4 and PC5 */
+++++  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;
+++++  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
+++++
+++++  /* Configure PG2, PG11, PG13 and PG14 */
+++++  GPIO_InitStructure.Pin =  GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14;
+++++  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
+++++  
+++++  // Install HAL Ethernet ISR
+++++  rtems_interrupt_handler_install(
+++++    ETH_IRQn,
+++++    NULL,
+++++    0,
+++++    stm32f_ethernet_isr,
+++++    heth);
+++++  
+++++  /* Enable ETHERNET clock  */
+++++  __HAL_RCC_ETH_CLK_ENABLE();
+++++}
+++++
+++++/**
+++++  * @brief  Ethernet Rx Transfer completed callback
+++++  * @param  heth: ETH handle
+++++  * @retval None
+++++  */
+++++void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
+++++{
+++++  osSemaphoreRelease(s_xSemaphore);
+++++}
+++++
+++++/**
+++++  * @brief  Ethernet IRQ Handler
+++++  * @param  None
+++++  * @retval None
+++++  */
+++++void ETHERNET_IRQHandler(void)
+++++{
+++++  HAL_ETH_IRQHandler(&EthHandle);
+++++}
+++++
+++++/*******************************************************************************
+++++                       LL Driver Interface ( LwIP stack --> ETH) 
+++++*******************************************************************************/
+++++/**
+++++  * @brief In this function, the hardware should be initialized.
+++++  * Called from ethernetif_init().
+++++  *
+++++  * @param netif the already initialized lwip network interface structure
+++++  *        for this ethernetif
+++++  */
+++++static void low_level_init(struct netif *netif)
+++++{
+++++  uint8_t macaddress[6]= { MAC_ADDR0, MAC_ADDR1, MAC_ADDR2, MAC_ADDR3, MAC_ADDR4, MAC_ADDR5 };
+++++  
+++++  EthHandle.Instance = ETH;  
+++++  EthHandle.Init.MACAddr = macaddress;
+++++  EthHandle.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
+++++  EthHandle.Init.Speed = ETH_SPEED_100M;
+++++  EthHandle.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
+++++  EthHandle.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
+++++  EthHandle.Init.RxMode = ETH_RXINTERRUPT_MODE;
+++++  EthHandle.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
+++++  EthHandle.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
+++++  
+++++  /* configure ethernet peripheral (GPIOs, clocks, MAC, DMA) */
+++++  if (HAL_ETH_Init(&EthHandle) == HAL_OK)
+++++  {
+++++    /* Set netif link flag */
+++++    netif->flags |= NETIF_FLAG_LINK_UP;
+++++  }
+++++  
+++++  /* Initialize Tx Descriptors list: Chain Mode */
+++++  HAL_ETH_DMATxDescListInit(&EthHandle, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
+++++     
+++++  /* Initialize Rx Descriptors list: Chain Mode  */
+++++  HAL_ETH_DMARxDescListInit(&EthHandle, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
+++++  
+++++  /* set netif MAC hardware address length */
+++++  netif->hwaddr_len = ETHARP_HWADDR_LEN;
+++++
+++++  /* set netif MAC hardware address */
+++++  netif->hwaddr[0] =  MAC_ADDR0;
+++++  netif->hwaddr[1] =  MAC_ADDR1;
+++++  netif->hwaddr[2] =  MAC_ADDR2;
+++++  netif->hwaddr[3] =  MAC_ADDR3;
+++++  netif->hwaddr[4] =  MAC_ADDR4;
+++++  netif->hwaddr[5] =  MAC_ADDR5;
+++++
+++++  /* set netif maximum transfer unit */
+++++  netif->mtu = 1500;
+++++
+++++  /* Accept broadcast address and ARP traffic */
+++++  netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
+++++
+++++  /* create a binary semaphore used for informing ethernetif of frame reception */
+++++  osSemaphoreDef(SEM);
+++++  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1 );
+++++
+++++  /* create the task that handles the ETH_MAC */
+++++  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
+++++  osThreadCreate (osThread(EthIf), netif);
+++++
+++++  /* Enable MAC and DMA transmission and reception */
+++++  HAL_ETH_Start(&EthHandle);
+++++}
+++++
+++++
+++++/**
+++++  * @brief This function should do the actual transmission of the packet. The packet is
+++++  * contained in the pbuf that is passed to the function. This pbuf
+++++  * might be chained.
+++++  *
+++++  * @param netif the lwip network interface structure for this ethernetif
+++++  * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
+++++  * @return ERR_OK if the packet could be sent
+++++  *         an err_t value if the packet couldn't be sent
+++++  *
+++++  * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
+++++  *       strange results. You might consider waiting for space in the DMA queue
+++++  *       to become available since the stack doesn't retry to send a packet
+++++  *       dropped because of memory failure (except for the TCP timers).
+++++  */
+++++static err_t low_level_output(struct netif *netif, struct pbuf *p)
+++++{
+++++  err_t errval;
+++++  struct pbuf *q;
+++++  uint8_t *buffer = (uint8_t *)(EthHandle.TxDesc->Buffer1Addr);
+++++  __IO ETH_DMADescTypeDef *DmaTxDesc;
+++++  uint32_t framelength = 0;
+++++  uint32_t bufferoffset = 0;
+++++  uint32_t byteslefttocopy = 0;
+++++  uint32_t payloadoffset = 0;
+++++
+++++  DmaTxDesc = EthHandle.TxDesc;
+++++  bufferoffset = 0;
+++++  
+++++  /* copy frame from pbufs to driver buffers */
+++++  for(q = p; q != NULL; q = q->next)
+++++  {
+++++    /* Is this buffer available? If not, goto error */
+++++    if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
+++++    {
+++++      errval = ERR_USE;
+++++      goto error;
+++++    }
+++++    
+++++    /* Get bytes in current lwIP buffer */
+++++    byteslefttocopy = q->len;
+++++    payloadoffset = 0;
+++++    
+++++    /* Check if the length of data to copy is bigger than Tx buffer size*/
+++++    while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
+++++    {
+++++      /* Copy data to Tx buffer*/
+++++      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
+++++      
+++++      /* Point to next descriptor */
+++++      DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
+++++      
+++++      /* Check if the buffer is available */
+++++      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
+++++      {
+++++        errval = ERR_USE;
+++++        goto error;
+++++      }
+++++      
+++++      buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
+++++      
+++++      byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
+++++      payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
+++++      framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
+++++      bufferoffset = 0;
+++++    }
+++++    
+++++    /* Copy the remaining bytes */
+++++    memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
+++++    bufferoffset = bufferoffset + byteslefttocopy;
+++++    framelength = framelength + byteslefttocopy;
+++++  }
+++++  
+++++  /* Prepare transmit descriptors to give to DMA */ 
+++++  HAL_ETH_TransmitFrame(&EthHandle, framelength);
+++++  
+++++  errval = ERR_OK;
+++++  
+++++error:
+++++  
+++++  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
+++++  if ((EthHandle.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
+++++  {
+++++    /* Clear TUS ETHERNET DMA flag */
+++++    EthHandle.Instance->DMASR = ETH_DMASR_TUS;
+++++    
+++++    /* Resume DMA transmission*/
+++++    EthHandle.Instance->DMATPDR = 0;
+++++  }
+++++  return errval;
+++++}
+++++
+++++/**
+++++  * @brief Should allocate a pbuf and transfer the bytes of the incoming
+++++  * packet from the interface into the pbuf.
+++++  *
+++++  * @param netif the lwip network interface structure for this ethernetif
+++++  * @return a pbuf filled with the received packet (including MAC header)
+++++  *         NULL on memory error
+++++  */
+++++static struct pbuf * low_level_input(struct netif *netif)
+++++{
+++++  struct pbuf *p = NULL, *q = NULL;
+++++  uint16_t len = 0;
+++++  uint8_t *buffer;
+++++  __IO ETH_DMADescTypeDef *dmarxdesc;
+++++  uint32_t bufferoffset = 0;
+++++  uint32_t payloadoffset = 0;
+++++  uint32_t byteslefttocopy = 0;
+++++  uint32_t i=0;
+++++  
+++++  /* get received frame */
+++++  if(HAL_ETH_GetReceivedFrame_IT(&EthHandle) != HAL_OK)
+++++    return NULL;
+++++  
+++++  /* Obtain the size of the packet and put it into the "len" variable. */
+++++  len = EthHandle.RxFrameInfos.length;
+++++  buffer = (uint8_t *)EthHandle.RxFrameInfos.buffer;
+++++  
+++++  if (len > 0)
+++++  {
+++++    /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
+++++    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
+++++  }
+++++  
+++++  if (p != NULL)
+++++  {
+++++    dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
+++++    bufferoffset = 0;
+++++    
+++++    for(q = p; q != NULL; q = q->next)
+++++    {
+++++      byteslefttocopy = q->len;
+++++      payloadoffset = 0;
+++++      
+++++      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size */
+++++      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
+++++      {
+++++        /* Copy data to pbuf */
+++++        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
+++++        
+++++        /* Point to next descriptor */
+++++        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
+++++        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
+++++        
+++++        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
+++++        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
+++++        bufferoffset = 0;
+++++      }
+++++      
+++++      /* Copy remaining data in pbuf */
+++++      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
+++++      bufferoffset = bufferoffset + byteslefttocopy;
+++++    }
+++++  }
+++++    
+++++  /* Release descriptors to DMA */
+++++  /* Point to first descriptor */
+++++  dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
+++++  /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
+++++  for (i=0; i< EthHandle.RxFrameInfos.SegCount; i++)
+++++  {  
+++++    dmarxdesc->Status |= ETH_DMARXDESC_OWN;
+++++    dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
+++++  }
+++++    
+++++  /* Clear Segment_Count */
+++++  EthHandle.RxFrameInfos.SegCount =0;
+++++  
+++++  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
+++++  if ((EthHandle.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
+++++  {
+++++    /* Clear RBUS ETHERNET DMA flag */
+++++    EthHandle.Instance->DMASR = ETH_DMASR_RBUS;
+++++    /* Resume DMA reception */
+++++    EthHandle.Instance->DMARPDR = 0;
+++++  }
+++++  return p;
+++++}
+++++
+++++/**
+++++  * @brief This function is the ethernetif_input task, it is processed when a packet 
+++++  * is ready to be read from the interface. It uses the function low_level_input() 
+++++  * that should handle the actual reception of bytes from the network
+++++  * interface. Then the type of the received packet is determined and
+++++  * the appropriate input function is called.
+++++  *
+++++  * @param netif the lwip network interface structure for this ethernetif
+++++  */
+++++void ethernetif_input( void const * argument )
+++++{
+++++  struct pbuf *p;
+++++  struct netif *netif = (struct netif *) argument;
+++++  
+++++  for( ;; )
+++++  {
+++++    if (osSemaphoreWait( s_xSemaphore, TIME_WAITING_FOR_INPUT)==osOK)
+++++    {
+++++      do
+++++      {
+++++        p = low_level_input( netif );
+++++        if (p != NULL)
+++++        {
+++++          if (netif->input( p, netif) != ERR_OK )
+++++          {
+++++            pbuf_free(p);
+++++          }
+++++        }
+++++      }while(p!=NULL);
+++++    }
+++++  }
+++++}
+++++
+++++/**
+++++  * @brief Should be called at the beginning of the program to set up the
+++++  * network interface. It calls the function low_level_init() to do the
+++++  * actual setup of the hardware.
+++++  *
+++++  * This function should be passed as a parameter to netif_add().
+++++  *
+++++  * @param netif the lwip network interface structure for this ethernetif
+++++  * @return ERR_OK if the loopif is initialized
+++++  *         ERR_MEM if private data couldn't be allocated
+++++  *         any other err_t on error
+++++  */
+++++err_t ethernetif_init(struct netif *netif)
+++++{
+++++  LWIP_ASSERT("netif != NULL", (netif != NULL));
+++++
+++++#if LWIP_NETIF_HOSTNAME
+++++  /* Initialize interface hostname */
+++++  netif->hostname = "lwip";
+++++#endif /* LWIP_NETIF_HOSTNAME */
+++++
+++++  netif->name[0] = IFNAME0;
+++++  netif->name[1] = IFNAME1;
+++++
+++++  netif->output = etharp_output;
+++++  netif->linkoutput = low_level_output;
+++++
+++++  /* initialize the hardware */
+++++  low_level_init(netif);
+++++
+++++  return ERR_OK;
+++++}
+++++
+++++/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
++++-- 
++++1.9.1
++++
++++
++++From 81eded01bb2bc35a9b627e5cf35b2021efb5972c Mon Sep 17 00:00:00 2001
++++From: Jay Doyle <jay.doyle@vecna.com>
++++Date: Mon, 7 Sep 2015 10:22:57 -0400
++++Subject: [PATCH 7/9] Added bsp path
++++
++++---
++++ Makefile | 4 +++-
++++ 1 file changed, 3 insertions(+), 1 deletion(-)
++++
++++diff --git a/Makefile b/Makefile
++++index 6efa141..a855d9f 100644
++++--- a/Makefile
+++++++ b/Makefile
++++@@ -13,6 +13,8 @@ LWIP_EXEC=lwip
++++ 
++++ #### PATHS #####################################################################
++++ 
+++++BSP_PATH=/opt/rtems-4.11/arm-rtems4.11/stm32f7x/lib/include/bsp
+++++
++++ # LWIP
++++ LWIP_PATH=.
++++ LWIP_SRC_PATH=$(LWIP_PATH)/src
++++@@ -97,7 +99,7 @@ DRIVER_H=$(LWIPDRIVER_INCL_PATH)
++++ # HEADERS
++++ HEADERS=-I$(CORE_H) -I$(POSIX_H) -I$(POSIX_SYS_H) -I$(NETIF_H) \
++++         -I$(NETIF_H_PPP) -I$(NETIF_H_PPP_POLARSSL) -I$(ARCH_H) \
++++-        -I$(DRIVER_H) -I$(IPV4_H)
+++++        -I$(DRIVER_H) -I$(IPV4_H) -I$(BSP_PATH)
++++ 
++++ 
++++ ################################################################################
++++-- 
++++1.9.1
++++
++++
++++From f114529d5af1e2a83b49b67d631b10c02648e8d8 Mon Sep 17 00:00:00 2001
++++From: Jay Doyle <jay.doyle@vecna.com>
++++Date: Mon, 7 Sep 2015 10:54:26 -0400
++++Subject: [PATCH 8/9] removed ethernetif.c
++++
++++---
++++ src/netif/ethernetif.c | 496 -------------------------------------------------
++++ 1 file changed, 496 deletions(-)
++++ delete mode 100644 src/netif/ethernetif.c
++++
++++diff --git a/src/netif/ethernetif.c b/src/netif/ethernetif.c
++++deleted file mode 100644
++++index bc429e9..0000000
++++--- a/src/netif/ethernetif.c
+++++++ /dev/null
++++@@ -1,496 +0,0 @@
++++-/**
++++-  ******************************************************************************
++++-  * @file    LwIP/LwIP_HTTP_Server_Netconn_RTOS/Src/ethernetif.c
++++-  * @author  MCD Application Team
++++-  * @version V1.0.0
++++-  * @date    25-June-2015
++++-  * @brief   This file implements Ethernet network interface drivers for lwIP
++++-  ******************************************************************************
++++-  * @attention
++++-  *
++++-  * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
++++-  *
++++-  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
++++-  * You may not use this file except in compliance with the License.
++++-  * You may obtain a copy of the License at:
++++-  *
++++-  *        http://www.st.com/software_license_agreement_liberty_v2
++++-  *
++++-  * Unless required by applicable law or agreed to in writing, software 
++++-  * distributed under the License is distributed on an "AS IS" BASIS, 
++++-  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++++-  * See the License for the specific language governing permissions and
++++-  * limitations under the License.
++++-  *
++++-  ******************************************************************************
++++-  */
++++-
++++-/* Includes ------------------------------------------------------------------*/
++++-#include <stm32f7xx_hal.h>
++++-#include <lwip/opt.h>
++++-#include <lwip/lwip_timers.h>
++++-#include <netif/etharp.h>
++++-#include <hal-ethernetif.h>
++++-#include <string.h>
++++-
++++-/* Private typedef -----------------------------------------------------------*/
++++-/* Private define ------------------------------------------------------------*/
++++-/* The time to block waiting for input. */
++++-#define TIME_WAITING_FOR_INPUT                 ( 100 )
++++-/* Stack size of the interface thread */
++++-#define INTERFACE_THREAD_STACK_SIZE            ( 350 )
++++-
++++-/* Define those to better describe your network interface. */
++++-#define IFNAME0 'e'
++++-#define IFNAME1 'n'
++++-
++++-#define LAN8742A_PHY_ADDRESS            0x00
++++-
++++-/* Private macro -------------------------------------------------------------*/
++++-/* Private variables ---------------------------------------------------------*/
++++-
++++-#if defined ( __ICCARM__ ) /*!< IAR Compiler */
++++-
++++-#pragma location=0x2000E000
++++-__no_init ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
++++-#pragma location=0x2000E100
++++-__no_init ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
++++-#elif defined ( __CC_ARM   )
++++-ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((at(0x2000E000)));/* Ethernet Rx MA Descriptor */
++++-ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((at(0x2000E100)));/* Ethernet Tx DMA Descriptor */
++++-#elif defined ( __GNUC__   )
++++-//ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".RxDescripSection")));/* Ethernet Rx MA Descriptor */
++++-//ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".TxDescripSection")));/* Ethernet Tx DMA Descriptor */
++++-ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Rx MA Descriptor */
++++-ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Tx DMA Descriptor */
++++-
++++-
++++-#endif
++++-#if defined ( __ICCARM__ ) /*!< IAR Compiler */
++++-#pragma location=0x2000E200
++++-__no_init uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
++++-#pragma location=0x2000FFC4
++++-__no_init uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
++++-#elif defined ( __CC_ARM   )
++++-uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((at(0x2000E200)));  /* Ethernet Receive Buffer */
++++-uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]  __attribute__((at(0x2000FFC4))); /* Ethernet Transmit Buffer */
++++-#elif defined ( __GNUC__   )
++++-//uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".RxBUF")));/* Ethernet Receive Buffer */
++++-//uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".TxBUF")));/* Ethernet Transmit Buffer */
++++-uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Receive Buffer */
++++-uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Transmit Buffer */
++++-
++++-#endif
++++-/* Semaphore to signal incoming packets */
++++-osSemaphoreId s_xSemaphore = NULL;
++++-
++++-/* Global Ethernet handle*/
++++-ETH_HandleTypeDef EthHandle;
++++-
++++-/* Private function prototypes -----------------------------------------------*/
++++-static void ethernetif_input( void const * argument );
++++-
++++-static void stm32f_ethernet_isr(
++++-  void* argData
++++-)
++++-{
++++-  ETH_HandleTypeDef* pEth =
++++-    (ETH_HandleTypeDef*) argData;
++++-
++++-  HAL_ETH_IRQHandler(pEth);
++++-}
++++-
++++-/* Private functions ---------------------------------------------------------*/
++++-/*******************************************************************************
++++-                       Ethernet MSP Routines
++++-*******************************************************************************/
++++-/**
++++-  * @brief  Initializes the ETH MSP.
++++-  * @param  heth: ETH handle
++++-  * @retval None
++++-  */
++++-void HAL_ETH_MspInit(ETH_HandleTypeDef *heth)
++++-{
++++-  GPIO_InitTypeDef GPIO_InitStructure;
++++-  
++++-  /* Enable GPIOs clocks */
++++-  __HAL_RCC_GPIOA_CLK_ENABLE();
++++-  __HAL_RCC_GPIOC_CLK_ENABLE();
++++-  __HAL_RCC_GPIOG_CLK_ENABLE();
++++-
++++-/* Ethernet pins configuration ************************************************/
++++-  /*
++++-        RMII_REF_CLK ----------------------> PA1
++++-        RMII_MDIO -------------------------> PA2
++++-        RMII_MDC --------------------------> PC1
++++-        RMII_MII_CRS_DV -------------------> PA7
++++-        RMII_MII_RXD0 ---------------------> PC4
++++-        RMII_MII_RXD1 ---------------------> PC5
++++-        RMII_MII_RXER ---------------------> PG2
++++-        RMII_MII_TX_EN --------------------> PG11
++++-        RMII_MII_TXD0 ---------------------> PG13
++++-        RMII_MII_TXD1 ---------------------> PG14
++++-  */
++++-
++++-  /* Configure PA1, PA2 and PA7 */
++++-  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
++++-  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
++++-  GPIO_InitStructure.Pull = GPIO_NOPULL; 
++++-  GPIO_InitStructure.Alternate = GPIO_AF11_ETH;
++++-  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
++++-  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
++++-  
++++-  /* Configure PC1, PC4 and PC5 */
++++-  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;
++++-  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
++++-
++++-  /* Configure PG2, PG11, PG13 and PG14 */
++++-  GPIO_InitStructure.Pin =  GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14;
++++-  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
++++-  
++++-  // Install HAL Ethernet ISR
++++-  rtems_interrupt_handler_install(
++++-    ETH_IRQn,
++++-    NULL,
++++-    0,
++++-    stm32f_ethernet_isr,
++++-    heth);
++++-  
++++-  /* Enable ETHERNET clock  */
++++-  __HAL_RCC_ETH_CLK_ENABLE();
++++-}
++++-
++++-/**
++++-  * @brief  Ethernet Rx Transfer completed callback
++++-  * @param  heth: ETH handle
++++-  * @retval None
++++-  */
++++-void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
++++-{
++++-  osSemaphoreRelease(s_xSemaphore);
++++-}
++++-
++++-/**
++++-  * @brief  Ethernet IRQ Handler
++++-  * @param  None
++++-  * @retval None
++++-  */
++++-void ETHERNET_IRQHandler(void)
++++-{
++++-  HAL_ETH_IRQHandler(&EthHandle);
++++-}
++++-
++++-/*******************************************************************************
++++-                       LL Driver Interface ( LwIP stack --> ETH) 
++++-*******************************************************************************/
++++-/**
++++-  * @brief In this function, the hardware should be initialized.
++++-  * Called from ethernetif_init().
++++-  *
++++-  * @param netif the already initialized lwip network interface structure
++++-  *        for this ethernetif
++++-  */
++++-static void low_level_init(struct netif *netif)
++++-{
++++-  uint8_t macaddress[6]= { MAC_ADDR0, MAC_ADDR1, MAC_ADDR2, MAC_ADDR3, MAC_ADDR4, MAC_ADDR5 };
++++-  
++++-  EthHandle.Instance = ETH;  
++++-  EthHandle.Init.MACAddr = macaddress;
++++-  EthHandle.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
++++-  EthHandle.Init.Speed = ETH_SPEED_100M;
++++-  EthHandle.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
++++-  EthHandle.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
++++-  EthHandle.Init.RxMode = ETH_RXINTERRUPT_MODE;
++++-  EthHandle.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
++++-  EthHandle.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
++++-  
++++-  /* configure ethernet peripheral (GPIOs, clocks, MAC, DMA) */
++++-  if (HAL_ETH_Init(&EthHandle) == HAL_OK)
++++-  {
++++-    /* Set netif link flag */
++++-    netif->flags |= NETIF_FLAG_LINK_UP;
++++-  }
++++-  
++++-  /* Initialize Tx Descriptors list: Chain Mode */
++++-  HAL_ETH_DMATxDescListInit(&EthHandle, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
++++-     
++++-  /* Initialize Rx Descriptors list: Chain Mode  */
++++-  HAL_ETH_DMARxDescListInit(&EthHandle, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
++++-  
++++-  /* set netif MAC hardware address length */
++++-  netif->hwaddr_len = ETHARP_HWADDR_LEN;
++++-
++++-  /* set netif MAC hardware address */
++++-  netif->hwaddr[0] =  MAC_ADDR0;
++++-  netif->hwaddr[1] =  MAC_ADDR1;
++++-  netif->hwaddr[2] =  MAC_ADDR2;
++++-  netif->hwaddr[3] =  MAC_ADDR3;
++++-  netif->hwaddr[4] =  MAC_ADDR4;
++++-  netif->hwaddr[5] =  MAC_ADDR5;
++++-
++++-  /* set netif maximum transfer unit */
++++-  netif->mtu = 1500;
++++-
++++-  /* Accept broadcast address and ARP traffic */
++++-  netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
++++-
++++-  /* create a binary semaphore used for informing ethernetif of frame reception */
++++-  osSemaphoreDef(SEM);
++++-  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1 );
++++-
++++-  /* create the task that handles the ETH_MAC */
++++-  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
++++-  osThreadCreate (osThread(EthIf), netif);
++++-
++++-  /* Enable MAC and DMA transmission and reception */
++++-  HAL_ETH_Start(&EthHandle);
++++-}
++++-
++++-
++++-/**
++++-  * @brief This function should do the actual transmission of the packet. The packet is
++++-  * contained in the pbuf that is passed to the function. This pbuf
++++-  * might be chained.
++++-  *
++++-  * @param netif the lwip network interface structure for this ethernetif
++++-  * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
++++-  * @return ERR_OK if the packet could be sent
++++-  *         an err_t value if the packet couldn't be sent
++++-  *
++++-  * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
++++-  *       strange results. You might consider waiting for space in the DMA queue
++++-  *       to become available since the stack doesn't retry to send a packet
++++-  *       dropped because of memory failure (except for the TCP timers).
++++-  */
++++-static err_t low_level_output(struct netif *netif, struct pbuf *p)
++++-{
++++-  err_t errval;
++++-  struct pbuf *q;
++++-  uint8_t *buffer = (uint8_t *)(EthHandle.TxDesc->Buffer1Addr);
++++-  __IO ETH_DMADescTypeDef *DmaTxDesc;
++++-  uint32_t framelength = 0;
++++-  uint32_t bufferoffset = 0;
++++-  uint32_t byteslefttocopy = 0;
++++-  uint32_t payloadoffset = 0;
++++-
++++-  DmaTxDesc = EthHandle.TxDesc;
++++-  bufferoffset = 0;
++++-  
++++-  /* copy frame from pbufs to driver buffers */
++++-  for(q = p; q != NULL; q = q->next)
++++-  {
++++-    /* Is this buffer available? If not, goto error */
++++-    if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
++++-    {
++++-      errval = ERR_USE;
++++-      goto error;
++++-    }
++++-    
++++-    /* Get bytes in current lwIP buffer */
++++-    byteslefttocopy = q->len;
++++-    payloadoffset = 0;
++++-    
++++-    /* Check if the length of data to copy is bigger than Tx buffer size*/
++++-    while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
++++-    {
++++-      /* Copy data to Tx buffer*/
++++-      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
++++-      
++++-      /* Point to next descriptor */
++++-      DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
++++-      
++++-      /* Check if the buffer is available */
++++-      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
++++-      {
++++-        errval = ERR_USE;
++++-        goto error;
++++-      }
++++-      
++++-      buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
++++-      
++++-      byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
++++-      payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
++++-      framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
++++-      bufferoffset = 0;
++++-    }
++++-    
++++-    /* Copy the remaining bytes */
++++-    memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
++++-    bufferoffset = bufferoffset + byteslefttocopy;
++++-    framelength = framelength + byteslefttocopy;
++++-  }
++++-  
++++-  /* Prepare transmit descriptors to give to DMA */ 
++++-  HAL_ETH_TransmitFrame(&EthHandle, framelength);
++++-  
++++-  errval = ERR_OK;
++++-  
++++-error:
++++-  
++++-  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
++++-  if ((EthHandle.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
++++-  {
++++-    /* Clear TUS ETHERNET DMA flag */
++++-    EthHandle.Instance->DMASR = ETH_DMASR_TUS;
++++-    
++++-    /* Resume DMA transmission*/
++++-    EthHandle.Instance->DMATPDR = 0;
++++-  }
++++-  return errval;
++++-}
++++-
++++-/**
++++-  * @brief Should allocate a pbuf and transfer the bytes of the incoming
++++-  * packet from the interface into the pbuf.
++++-  *
++++-  * @param netif the lwip network interface structure for this ethernetif
++++-  * @return a pbuf filled with the received packet (including MAC header)
++++-  *         NULL on memory error
++++-  */
++++-static struct pbuf * low_level_input(struct netif *netif)
++++-{
++++-  struct pbuf *p = NULL, *q = NULL;
++++-  uint16_t len = 0;
++++-  uint8_t *buffer;
++++-  __IO ETH_DMADescTypeDef *dmarxdesc;
++++-  uint32_t bufferoffset = 0;
++++-  uint32_t payloadoffset = 0;
++++-  uint32_t byteslefttocopy = 0;
++++-  uint32_t i=0;
++++-  
++++-  /* get received frame */
++++-  if(HAL_ETH_GetReceivedFrame_IT(&EthHandle) != HAL_OK)
++++-    return NULL;
++++-  
++++-  /* Obtain the size of the packet and put it into the "len" variable. */
++++-  len = EthHandle.RxFrameInfos.length;
++++-  buffer = (uint8_t *)EthHandle.RxFrameInfos.buffer;
++++-  
++++-  if (len > 0)
++++-  {
++++-    /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
++++-    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
++++-  }
++++-  
++++-  if (p != NULL)
++++-  {
++++-    dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
++++-    bufferoffset = 0;
++++-    
++++-    for(q = p; q != NULL; q = q->next)
++++-    {
++++-      byteslefttocopy = q->len;
++++-      payloadoffset = 0;
++++-      
++++-      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size */
++++-      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
++++-      {
++++-        /* Copy data to pbuf */
++++-        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
++++-        
++++-        /* Point to next descriptor */
++++-        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
++++-        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
++++-        
++++-        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
++++-        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
++++-        bufferoffset = 0;
++++-      }
++++-      
++++-      /* Copy remaining data in pbuf */
++++-      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
++++-      bufferoffset = bufferoffset + byteslefttocopy;
++++-    }
++++-  }
++++-    
++++-  /* Release descriptors to DMA */
++++-  /* Point to first descriptor */
++++-  dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
++++-  /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
++++-  for (i=0; i< EthHandle.RxFrameInfos.SegCount; i++)
++++-  {  
++++-    dmarxdesc->Status |= ETH_DMARXDESC_OWN;
++++-    dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
++++-  }
++++-    
++++-  /* Clear Segment_Count */
++++-  EthHandle.RxFrameInfos.SegCount =0;
++++-  
++++-  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
++++-  if ((EthHandle.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
++++-  {
++++-    /* Clear RBUS ETHERNET DMA flag */
++++-    EthHandle.Instance->DMASR = ETH_DMASR_RBUS;
++++-    /* Resume DMA reception */
++++-    EthHandle.Instance->DMARPDR = 0;
++++-  }
++++-  return p;
++++-}
++++-
++++-/**
++++-  * @brief This function is the ethernetif_input task, it is processed when a packet 
++++-  * is ready to be read from the interface. It uses the function low_level_input() 
++++-  * that should handle the actual reception of bytes from the network
++++-  * interface. Then the type of the received packet is determined and
++++-  * the appropriate input function is called.
++++-  *
++++-  * @param netif the lwip network interface structure for this ethernetif
++++-  */
++++-void ethernetif_input( void const * argument )
++++-{
++++-  struct pbuf *p;
++++-  struct netif *netif = (struct netif *) argument;
++++-  
++++-  for( ;; )
++++-  {
++++-    if (osSemaphoreWait( s_xSemaphore, TIME_WAITING_FOR_INPUT)==osOK)
++++-    {
++++-      do
++++-      {
++++-        p = low_level_input( netif );
++++-        if (p != NULL)
++++-        {
++++-          if (netif->input( p, netif) != ERR_OK )
++++-          {
++++-            pbuf_free(p);
++++-          }
++++-        }
++++-      }while(p!=NULL);
++++-    }
++++-  }
++++-}
++++-
++++-/**
++++-  * @brief Should be called at the beginning of the program to set up the
++++-  * network interface. It calls the function low_level_init() to do the
++++-  * actual setup of the hardware.
++++-  *
++++-  * This function should be passed as a parameter to netif_add().
++++-  *
++++-  * @param netif the lwip network interface structure for this ethernetif
++++-  * @return ERR_OK if the loopif is initialized
++++-  *         ERR_MEM if private data couldn't be allocated
++++-  *         any other err_t on error
++++-  */
++++-err_t ethernetif_init(struct netif *netif)
++++-{
++++-  LWIP_ASSERT("netif != NULL", (netif != NULL));
++++-
++++-#if LWIP_NETIF_HOSTNAME
++++-  /* Initialize interface hostname */
++++-  netif->hostname = "lwip";
++++-#endif /* LWIP_NETIF_HOSTNAME */
++++-
++++-  netif->name[0] = IFNAME0;
++++-  netif->name[1] = IFNAME1;
++++-
++++-  netif->output = etharp_output;
++++-  netif->linkoutput = low_level_output;
++++-
++++-  /* initialize the hardware */
++++-  low_level_init(netif);
++++-
++++-  return ERR_OK;
++++-}
++++-
++++-/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
++++-- 
++++1.9.1
++++
++++
++++From badcd5771d8fa3046a2cd7aa07536c6dcb703891 Mon Sep 17 00:00:00 2001
++++From: Jay Doyle <jay.doyle@vecna.com>
++++Date: Mon, 28 Sep 2015 13:47:22 -0400
++++Subject: [PATCH 9/9] enable BSD sockets naming
++++
++++---
++++ ports/include/lwipopts.h | 2 +-
++++ 1 file changed, 1 insertion(+), 1 deletion(-)
++++
++++diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
++++index 169ba46..9149c29 100644
++++--- a/ports/include/lwipopts.h
+++++++ b/ports/include/lwipopts.h
++++@@ -169,7 +169,7 @@
++++  * LWIP_COMPAT_SOCKETS==1: Enable BSD-style sockets functions names.
++++  * (only used if you use sockets.c)
++++  */
++++-#define LWIP_COMPAT_SOCKETS             0
+++++#define LWIP_COMPAT_SOCKETS             1
++++ 
++++ #define LWIP_TIMEVAL_PRIVATE            0
++++ 
++++-- 
++++1.9.1
++++
+++-- 
+++1.9.1
+++
++-- 
++1.9.1
++
++
++From 6e898ad87870ca775a3c9a38a05437d02b6f6ba5 Mon Sep 17 00:00:00 2001
++From: Jay Doyle <jay.doyle@vecna.com>
++Date: Mon, 28 Sep 2015 16:33:04 -0400
++Subject: [PATCH 13/13] defined cache line size
++
++---
++ ports/include/lwipopts.h | 2 ++
++ 1 file changed, 2 insertions(+)
++
++diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
++index 4c23d97..41b67a1 100644
++--- a/ports/include/lwipopts.h
+++++ b/ports/include/lwipopts.h
++@@ -180,6 +180,8 @@
++ 
++ #else
++ 
+++#define SOC_CACHELINE_SIZE_BYTES        32            /* Number of bytes in
+++                                                         a cache line */
++ /**
++  * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
++  * critical regions during buffer allocation, deallocation and memory
+\ No newline at end of file
+-- 
+1.9.1
+
+
+From 5ebf0076b70c1c78c5761d3689972b397558824f Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Mon, 28 Sep 2015 16:44:20 -0400
+Subject: [PATCH 20/29] revert to original settings
+
+---
+ ports/include/lwipopts.h | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
+index 2b218ec..ea8e09c 100644
+--- a/ports/include/lwipopts.h
++++ b/ports/include/lwipopts.h
+@@ -38,7 +38,7 @@
+ #ifndef __LWIPOPTS_H__
+ #define __LWIPOPTS_H__
+ 
+-
++#define ORIGINAL_CONFIG_OPTIONS 1
+ #if ORIGINAL_CONFIG_OPTIONS
+ 
+ /*****************************************************************************
+-- 
+1.9.1
+
+
+From 8bc5b4e5120e3190ef2405dd9ae476477ec768b1 Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Mon, 28 Sep 2015 16:53:05 -0400
+Subject: [PATCH 21/29] increased memory
+
+---
+ ports/include/lwipopts.h | 19 +++++++++++--------
+ 1 file changed, 11 insertions(+), 8 deletions(-)
+
+diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
+index ea8e09c..ec45f74 100644
+--- a/ports/include/lwipopts.h
++++ b/ports/include/lwipopts.h
+@@ -51,8 +51,7 @@
+ ** separate pool for each memory. The alignment of pbuf pool to cache line
+ ** size is done in /ports/cpsw/include/arch/cc.h.
+ */
+-/*#define LWIP_CACHE_ENABLED*/
+-
++#define LWIP_CACHE_ENABLED
+ #define SOC_CACHELINE_SIZE_BYTES        32            /* Number of bytes in
+                                                          a cache line */
+ /*
+@@ -87,16 +86,21 @@
+ **                          Memory Options
+ *****************************************************************************/
+ #define MEM_ALIGNMENT                   4
+-#define MEM_SIZE                        (256 * 1024) /* 128K */
++#define MEM_SIZE                        (512 * 1024) /* 256K */
+ 
+ #define MEMP_NUM_PBUF                   96
+ #define MEMP_NUM_TCP_PCB                32
+ #define MEMP_NUM_TCP_SEG                32
++
++/* ---------- Pbuf options ---------- */
++/* PBUF_POOL_SIZE: the number of buffers in the pbuf pool. */
+ #define PBUF_POOL_SIZE                  512
+ 
++/* PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. */
++#define PBUF_POOL_BUFSIZE               1524
++
+ #ifdef LWIP_CACHE_ENABLED
+-#define MEMP_SEPARATE_POOLS             1            /* We want the pbuf
+-                                                        pool cache line
++#define MEMP_SEPARATE_POOLS             1            /* We want the pbuf                                                        pool cache line
+                                                         aligned*/
+ #endif
+ 
+@@ -166,8 +170,6 @@
+ #define LWIP_STATS_DISPLAY              0
+ #define LWIP_STATS_POSIX                0
+ 
+-
+-
+ /**
+  * LWIP_COMPAT_SOCKETS==1: Enable BSD-style sockets functions names.
+  * (only used if you use sockets.c)
+@@ -175,8 +177,9 @@
+ #define LWIP_COMPAT_SOCKETS             1
+ 
+ #define LWIP_TIMEVAL_PRIVATE            0
++#define LWIP_RAW                        0
+ 
+- #define LWIP_RAW                       0
++#define configMAX_PRIORITIES            100
+ 
+ #else
+ 
+-- 
+1.9.1
+
+
+From b93de9cb181989cc08db04536ce8e784b5a38de2 Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Fri, 2 Oct 2015 11:16:09 -0400
+Subject: [PATCH 22/29] turn on memp buffer overflow check
+
+---
+ ports/include/lwipopts.h | 2 ++
+ 1 file changed, 2 insertions(+)
+
+diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
+index ec45f74..d2612e8 100644
+--- a/ports/include/lwipopts.h
++++ b/ports/include/lwipopts.h
+@@ -181,6 +181,8 @@
+ 
+ #define configMAX_PRIORITIES            100
+ 
++#define MEMP_OVERFLOW_CHECK             2
++
+ #else
+ 
+ #define configMAX_PRIORITIES 100
+-- 
+1.9.1
+
+
+From e1dc0d9fdf7a784a317a92a2524f4201822dea00 Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Fri, 2 Oct 2015 11:29:05 -0400
+Subject: [PATCH 23/29] enabled debug mode
+
+---
+ ports/include/lwipopts.h | 8 ++++++++
+ 1 file changed, 8 insertions(+)
+
+diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
+index d2612e8..c35bb0e 100644
+--- a/ports/include/lwipopts.h
++++ b/ports/include/lwipopts.h
+@@ -182,6 +182,14 @@
+ #define configMAX_PRIORITIES            100
+ 
+ #define MEMP_OVERFLOW_CHECK             2
++/*
++   -----------------------------------
++   ---------- DEBUG options ----------
++   -----------------------------------
++*/
++
++#define LWIP_DEBUG                      1
++
+ 
+ #else
+ 
+-- 
+1.9.1
+
+
+From 71b73cbbd89bff8deb521e605a7e9af1150dbdd8 Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Fri, 2 Oct 2015 11:41:53 -0400
+Subject: [PATCH 24/29] more magic
+
+---
+ ports/include/lwipopts.h | 9 ++-------
+ 1 file changed, 2 insertions(+), 7 deletions(-)
+
+diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
+index c35bb0e..1feb8b3 100644
+--- a/ports/include/lwipopts.h
++++ b/ports/include/lwipopts.h
+@@ -181,15 +181,10 @@
+ 
+ #define configMAX_PRIORITIES            100
+ 
++// The following should be removed -- there just debugging tests
+ #define MEMP_OVERFLOW_CHECK             2
+-/*
+-   -----------------------------------
+-   ---------- DEBUG options ----------
+-   -----------------------------------
+-*/
+-
+ #define LWIP_DEBUG                      1
+-
++#define MEMP_MEM_MALLOC                 1
+ 
+ #else
+ 
+-- 
+1.9.1
+
+
+From f1828cc5d26de48e1e5d2bb5358aa53a06e5cef8 Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Fri, 2 Oct 2015 13:39:45 -0400
+Subject: [PATCH 25/29] return to old settings
+
+---
+ ports/include/lwipopts.h | 5 -----
+ 1 file changed, 5 deletions(-)
+
+diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
+index 1feb8b3..ec45f74 100644
+--- a/ports/include/lwipopts.h
++++ b/ports/include/lwipopts.h
+@@ -181,11 +181,6 @@
+ 
+ #define configMAX_PRIORITIES            100
+ 
+-// The following should be removed -- there just debugging tests
+-#define MEMP_OVERFLOW_CHECK             2
+-#define LWIP_DEBUG                      1
+-#define MEMP_MEM_MALLOC                 1
+-
+ #else
+ 
+ #define configMAX_PRIORITIES 100
+-- 
+1.9.1
+
+
+From 38530494195183314291c300a316f51a13fad368 Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Mon, 5 Oct 2015 09:31:48 -0400
+Subject: [PATCH 26/29] fixed redefinition of PBUF_POOL_SIZE
+
+---
+ ports/include/lwipopts.h | 13 ++++++-------
+ 1 file changed, 6 insertions(+), 7 deletions(-)
+
+diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
+index ec45f74..ffdfcdd 100644
+--- a/ports/include/lwipopts.h
++++ b/ports/include/lwipopts.h
+@@ -93,11 +93,7 @@
+ #define MEMP_NUM_TCP_SEG                32
+ 
+ /* ---------- Pbuf options ---------- */
+-/* PBUF_POOL_SIZE: the number of buffers in the pbuf pool. */
+-#define PBUF_POOL_SIZE                  512
+ 
+-/* PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. */
+-#define PBUF_POOL_BUFSIZE               1524
+ 
+ #ifdef LWIP_CACHE_ENABLED
+ #define MEMP_SEPARATE_POOLS             1            /* We want the pbuf                                                        pool cache line
+@@ -136,9 +132,12 @@
+ **                           PBUF  Options
+ *****************************************************************************/
+ #define PBUF_LINK_HLEN                  14
+-#define PBUF_POOL_BUFSIZE               1520         /* + size of struct pbuf
+-                                                        shall be cache line
+-                                                        aligned be enabled */
++/* PBUF_POOL_SIZE: the number of buffers in the pbuf pool. */
++#define PBUF_POOL_SIZE                  512
++
++/* PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. */
++#define PBUF_POOL_BUFSIZE               1524
++
+ #define ETH_PAD_SIZE                    0
+ #define LWIP_NETCONN                    1
+ 
+-- 
+1.9.1
+
+
+From 32c9f02bc8c4b98addbfd80c73761684f02684a4 Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Mon, 5 Oct 2015 09:32:31 -0400
+Subject: [PATCH 27/29] cleanup
+
+---
+ ports/include/lwipopts.h | 211 -----------------------------------------------
+ 1 file changed, 211 deletions(-)
+
+diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
+index ffdfcdd..4ecfb9c 100644
+--- a/ports/include/lwipopts.h
++++ b/ports/include/lwipopts.h
+@@ -38,8 +38,6 @@
+ #ifndef __LWIPOPTS_H__
+ #define __LWIPOPTS_H__
+ 
+-#define ORIGINAL_CONFIG_OPTIONS 1
+-#if ORIGINAL_CONFIG_OPTIONS
+ 
+ /*****************************************************************************
+ **                           CONFIGURATIONS
+@@ -180,213 +178,4 @@
+ 
+ #define configMAX_PRIORITIES            100
+ 
+-#else
+-
+-#define configMAX_PRIORITIES 100
+-#define LWIP_CACHE_ENABLED
+-#define SOC_CACHELINE_SIZE_BYTES 32
+-#define LWIP_TIMEVAL_PRIVATE 0
+-
+-/**
+- * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
+- * critical regions during buffer allocation, deallocation and memory
+- * allocation and deallocation.
+- */
+-#define SYS_LIGHTWEIGHT_PROT    0
+-
+-#define ETHARP_TRUST_IP_MAC     0
+-#define IP_REASSEMBLY           0
+-#define IP_FRAG                 0
+-#define ARP_QUEUEING            0
+-#define TCP_LISTEN_BACKLOG      1
+-
+-/**
+- * NO_SYS==1: Provides VERY minimal functionality. Otherwise,
+- * use lwIP facilities.
+- */
+-#define NO_SYS                  0
+-
+-/* ---------- Memory options ---------- */
+-/* MEM_ALIGNMENT: should be set to the alignment of the CPU for which
+-   lwIP is compiled. 4 byte alignment -> define MEM_ALIGNMENT to 4, 2
+-   byte alignment -> define MEM_ALIGNMENT to 2. */
+-#define MEM_ALIGNMENT           4
+-
+-/* MEM_SIZE: the size of the heap memory. If the application will send
+-a lot of data that needs to be copied, this should be set high. */
+-#define MEM_SIZE                (10*1024)
+-
+-/* MEMP_NUM_PBUF: the number of memp struct pbufs. If the application
+-   sends a lot of data out of ROM (or other static memory), this
+-   should be set high. */
+-#define MEMP_NUM_PBUF           50
+-/* MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks. One
+-   per active UDP "connection". */
+-#define MEMP_NUM_UDP_PCB        6
+-/* MEMP_NUM_TCP_PCB: the number of simulatenously active TCP
+-   connections. */
+-#define MEMP_NUM_TCP_PCB        10
+-/* MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP
+-   connections. */
+-#define MEMP_NUM_TCP_PCB_LISTEN 5
+-/* MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP
+-   segments. */
+-#define MEMP_NUM_TCP_SEG        12
+-/* MEMP_NUM_SYS_TIMEOUT: the number of simulateously active
+-   timeouts. */
+-#define MEMP_NUM_SYS_TIMEOUT    10
+-
+-
+-/* ---------- Pbuf options ---------- */
+-/* PBUF_POOL_SIZE: the number of buffers in the pbuf pool. */
+-#define PBUF_POOL_SIZE          10
+-
+-/* PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. */
+-#define PBUF_POOL_BUFSIZE       1524
+-
+-
+-/* ---------- TCP options ---------- */
+-//#define LWIP_TCP                1
+-//#define TCP_TTL                 255
+-
+-/* Controls if TCP should queue segments that arrive out of
+-   order. Define to 0 if your device is low on memory. */
+-#define TCP_QUEUE_OOSEQ         0
+-
+-/* TCP Maximum segment size. */
+-#define TCP_MSS                 (1500 - 40)   /* TCP_MSS = (Ethernet MTU - IP header size - TCP header size) */
+-
+-/* TCP sender buffer space (bytes). */
+-#define TCP_SND_BUF             (4*TCP_MSS)
+-
+-/*  TCP_SND_QUEUELEN: TCP sender buffer space (pbufs). This must be at least
+-  as much as (2 * TCP_SND_BUF/TCP_MSS) for things to work. */
+-
+-#define TCP_SND_QUEUELEN        (2* TCP_SND_BUF/TCP_MSS)
+-
+-/* TCP receive window. */
+-#define TCP_WND                 (2*TCP_MSS)
+-
+-
+-/* ---------- ICMP options ---------- */
+-#define LWIP_ICMP                       1
+-
+-
+-/* ---------- DHCP options ---------- */
+-/* Define LWIP_DHCP to 1 if you want DHCP configuration of
+-   interfaces. DHCP is not implemented in lwIP 0.5.1, however, so
+-   turning this on does currently not work. */
+-#define LWIP_DHCP               1
+-
+-
+-/* ---------- UDP options ---------- */
+-#define LWIP_UDP                1
+-#define UDP_TTL                 255
+-
+-
+-/* ---------- Statistics options ---------- */
+-#define LWIP_STATS 0
+-#define LWIP_PROVIDE_ERRNO 1
+-
+-/* ---------- link callback options ---------- */
+-/* LWIP_NETIF_LINK_CALLBACK==1: Support a callback function from an interface
+- * whenever the link a48846deb25945d360543ffe8d86766d323b9859changes (i.e., link down)
+- */
+-#define LWIP_NETIF_LINK_CALLBACK        1
+-
+-/*
+-   --------------------------------------
+-   ---------- Checksum options ----------
+-   --------------------------------------
+-*/
+-
+-/*
+-The STM32F4x7 allows computing and verifying the IP, UDP, TCP and ICMP checksums by hardware:
+- - To use this feature let the following define uncommented.
+- - To disable it and process by CPU comment the  the checksum.
+-*/
+-#define CHECKSUM_BY_HARDWARE
+-
+-
+-#ifdef CHECKSUM_BY_HARDWARE
+-  /* CHECKSUM_GEN_IP==0: Generate checksums by hardware for outgoing IP packets.*/
+-  #define CHECKSUM_GEN_IP                 0
+-  /* CHECKSUM_GEN_UDP==0: Generate checksums by hardware for outgoing UDP packets.*/
+-  #define CHECKSUM_GEN_UDP                0
+-  /* CHECKSUM_GEN_TCP==0: Generate checksums by hardware for outgoing TCP packets.*/
+-  #define CHECKSUM_GEN_TCP                0
+-  /* CHECKSUM_CHECK_IP==0: Check checksums by hardware for incoming IP packets.*/
+-  #define CHECKSUM_CHECK_IP               0
+-  /* CHECKSUM_CHECK_UDP==0: Check checksums by hardware for incoming UDP packets.*/
+-  #define CHECKSUM_CHECK_UDP              0
+-  /* CHECKSUM_CHECK_TCP==0: Check checksums by hardware for incoming TCP packets.*/
+-  #define CHECKSUM_CHECK_TCP              0
+-  /* CHECKSUM_CHECK_ICMP==0: Check checksums by hardware for incoming ICMP packets.*/
+-  #define CHECKSUM_GEN_ICMP               0
+-#else
+-  /* CHECKSUM_GEN_IP==1: Generate checksums in software for outgoing IP packets.*/
+-  #define CHECKSUM_GEN_IP                 1
+-  /* CHECKSUM_GEN_UDP==1: Generate checksums in software for outgoing UDP packets.*/
+-  #define CHECKSUM_GEN_UDP                1
+-  /* CHECKSUM_GEN_TCP==1: Generate checksums in software for outgoing TCP packets.*/
+-  #define CHECKSUM_GEN_TCP                1
+-  /* CHECKSUM_CHECK_IP==1: Check checksums in software for incoming IP packets.*/
+-  #define CHECKSUM_CHECK_IP               1
+-  /* CHECKSUM_CHECK_UDP==1: Check checksums in software for incoming UDP packets.*/
+-  #define CHECKSUM_CHECK_UDP              1
+-  /* CHECKSUM_CHECK_TCP==1: Check checksums in software for incoming TCP packets.*/
+-  #define CHECKSUM_CHECK_TCP              1
+-  /* CHECKSUM_CHECK_ICMP==1: Check checksums by hardware for incoming ICMP packets.*/
+-  #define CHECKSUM_GEN_ICMP               1
+-#endif
+-
+-
+-/*
+-   ----------------------------------------------
+-   ---------- Sequential layer options ----------
+-   ----------------------------------------------
+-*/
+-/**
+- * LWIP_NETCONN==1: Enable Netconn API (require to use api_lib.c)
+- */
+-#define LWIP_NETCONN                    1
+-
+-/*
+-   ------------------------------------
+-   ---------- Socket options ----------
+-   ------------------------------------
+-*/
+-/**
+- * LWIP_SOCKET==1: Enable Socket API (require to use sockets.c)
+- */
+-#define LWIP_SOCKET                     1
+-
+-/*
+-   -----------------------------------
+-   ---------- DEBUG options ----------
+-   -----------------------------------
+-*/
+-
+-#define LWIP_DEBUG                      0
+-
+-
+-/*
+-   ---------------------------------
+-   ---------- OS options ----------
+-   ---------------------------------
+-*/
+-
+-#define TCPIP_THREAD_NAME              "TCP/IP"
+-#define TCPIP_THREAD_STACKSIZE          1000
+-#define TCPIP_MBOX_SIZE                 5
+-#define DEFAULT_UDP_RECVMBOX_SIZE       2000
+-#define DEFAULT_TCP_RECVMBOX_SIZE       2000
+-#define DEFAULT_ACCEPTMBOX_SIZE         2000
+-#define DEFAULT_THREAD_STACKSIZE        500
+-#define TCPIP_THREAD_PRIO               (configMAX_PRIORITIES - 2)
+-#define LWIP_COMPAT_MUTEX               1
+-
+-
+-#endif
+-
+ #endif /* __LWIPOPTS_H__ */
+-- 
+1.9.1
+
+
+From 574361aec0a26cdfa5b0800cffd489876b6a3c61 Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Mon, 5 Oct 2015 14:52:43 -0400
+Subject: [PATCH 28/29] changed tcp/ip thread priority
+
+---
+ ports/include/lwipopts.h | 1 +
+ 1 file changed, 1 insertion(+)
+
+diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
+index 4ecfb9c..5922306 100644
+--- a/ports/include/lwipopts.h
++++ b/ports/include/lwipopts.h
+@@ -177,5 +177,6 @@
+ #define LWIP_RAW                        0
+ 
+ #define configMAX_PRIORITIES            100
++#define TCPIP_THREAD_PRIO               200
+ 
+ #endif /* __LWIPOPTS_H__ */
+-- 
+1.9.1
+
+
+From 4f484a2e51c2a098e03ad72dc9e9ccff0f28780d Mon Sep 17 00:00:00 2001
+From: Jay Doyle <jay.doyle@vecna.com>
+Date: Mon, 12 Oct 2015 08:42:21 -0400
+Subject: [PATCH 29/29] updated using native RTEMS implementation
+
+---
+ ports/include/arch/cc.h       | 144 ++++----
+ ports/include/arch/perf.h     |  46 +--
+ ports/include/arch/sys_arch.h | 100 ++++--
+ ports/sys_arch.c              | 800 +++++++++++++-----------------------------
+ 4 files changed, 421 insertions(+), 669 deletions(-)
+
+diff --git a/ports/include/arch/cc.h b/ports/include/arch/cc.h
+index 8eefd64..5964091 100644
+--- a/ports/include/arch/cc.h
++++ b/ports/include/arch/cc.h
+@@ -24,38 +24,62 @@
+  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+  * OF SUCH DAMAGE.
+  *
+- * This file is part of the lwIP TCP/IP stack.
++ * This file is system adaptation of the lwIP TCP/IP stack
++ * by Adam Dunkels <adam@sics.se> for RTEMS system.
+  *
+- * Author: Adam Dunkels <adam@sics.se>
++ * Author: Premysl Houdek <houdepre@fel.cvut.cz>
++ * Mentor: Pavel Pisa <pisa@cmp.felk.cvut.cz>
++ * Industrial Informatics Group, FEE, Czech Technical University in Prague
+  *
+  */
++/*
++ * settings to adapt lwIP for compiler and machine architecture for RTEMS/GCC
++ * DETAILS: ./lwip/doc/sys_arch.txt
++ */
+ #ifndef __CC_H__
+ #define __CC_H__
+ 
+-typedef unsigned    char    u8_t;
+-typedef signed      char    s8_t;
+-typedef unsigned    short   u16_t;
+-typedef signed      short   s16_t;
+-typedef unsigned    int    u32_t;
+-typedef signed      int    s32_t;
+-typedef u32_t           mem_ptr_t;
++#include <stdio.h>
++#include <rtems/malloc.h>  /*printk*/
++#include <inttypes.h>
++#include <malloc.h>
+ 
+-#ifndef BYTE_ORDER
+-#define BYTE_ORDER LITTLE_ENDIAN
+-#endif
++/* This file must either include a system-local <errno.h> which defines
++   the standard *nix error codes, or it should #define LWIP_PROVIDE_ERRNO
++   to make lwip/arch.h define the codes which are used throughout. */
++#undef LWIP_PROVIDE_ERRNO
++
++/* type definitions */
++typedef uint8_t             u8_t;
++typedef int8_t              s8_t;
++typedef uint16_t            u16_t;
++typedef int16_t             s16_t;
++typedef uint32_t            u32_t;
++typedef int32_t             s32_t;
++typedef u32_t               mem_ptr_t;
++
++#define BYTE_ORDER BIG_ENDIAN
++
++/* Define (sn)printf formatters for these lwIP types */
++#define U16_F PRIu16
++#define S16_F PRId16
++#define X16_F PRIx16
++#define U32_F PRIu32
++#define S32_F PRId32
++#define X32_F PRIx32
+ 
+ #if defined(__arm__) && defined(__ARMCC_VERSION)
+-    //
+-    // Setup PACKing macros for KEIL/RVMDK Tools
+-    //
++//
++// Setup PACKing macros for KEIL/RVMDK Tools
++//
+     #define PACK_STRUCT_BEGIN __packed
+     #define PACK_STRUCT_STRUCT
+     #define PACK_STRUCT_END
+     #define PACK_STRUCT_FIELD(x) x
+ #elif defined (__IAR_SYSTEMS_ICC__)
+-    //
+-    // Setup PACKing macros for IAR Tools
+-    //
++//
++// Setup PACKing macros for IAR Tools
++//
+     #define PACK_STRUCT_BEGIN
+     #define PACK_STRUCT_STRUCT
+     #define PACK_STRUCT_END
+@@ -67,59 +91,61 @@ typedef u32_t           mem_ptr_t;
+     #define PACK_STRUCT_END
+     #define PACK_STRUCT_FIELD(x) x
+ #else
+-    //
+-    // Setup PACKing macros for GCC Tools
+-    //
++//
++// Setup PACKing macros for GCC Tools
++//
+     #define PACK_STRUCT_BEGIN
+     #define PACK_STRUCT_STRUCT __attribute__ ((__packed__))
+     #define PACK_STRUCT_END
+     #define PACK_STRUCT_FIELD(x) x
+ #endif
+ 
+-#ifdef LWIP_CACHE_ENABLED
+-/**
+- * Make the PBUF POOL cacheline aligned.
++/*
++ *     1 - load byte by byte, construct 16 bits word and add: not efficient for most platforms
++ *     2 - load first byte if odd address, loop processing 16 bits words, add last byte.
++ *     3 - load first byte and word if not 4 byte aligned, loop processing 32 bits words, add last word/byte.
++ *
++ *     see inet_chksum.c
+  */
+-#ifdef __IAR_SYSTEMS_ICC__
+-#pragma data_alignment=SOC_CACHELINE_SIZE_BYTES
+-extern u8_t memp_memory_PBUF_POOL_base[];
+-#else /*By default, GCC */
+-extern u8_t memp_memory_PBUF_POOL_base[] __attribute__ ((aligned (SOC_CACHELINE_SIZE_BYTES)));
+-#endif
++#ifndef LWIP_CHKSUM_ALGORITHM
++#define LWIP_CHKSUM_ALGORITHM 2
+ #endif
+ 
+-extern u8_t memp_memory_PBUF_POOL_base[] __attribute__ ((aligned (SOC_CACHELINE_SIZE_BYTES)));
++/* this is used for 1) displaying statistics and 2) lwip debugging (set appropriate debugging level in lwipopts.h) */
++//#ifdef LWIP_DEBUG
+ 
+-/* Define (sn)printf formatters for these lwIP types */
+-#define X8_F  "02x"
+-#define U16_F "u"
+-#define S16_F "d"
+-#define X16_F "x"
+-#define U32_F "u"
+-#define S32_F "d"
+-#define X32_F "x"
+ 
+-#include <stdio.h>
+-#include <stdlib.h>
+-#include <bsp.h>
+-//#include <sys/time.h>
+-
+-#define LWIP_PLATFORM_DIAG(x)   do { \
+-        printk("[%s - %s - %d] ", __PRETTY_FUNCTION__, __FILE__, __LINE__); \
+-        printk x; \
+-    } while(0)
+-
+-#ifdef LWIP_DEBUG  //DEBUG
+-extern void __error__(char *pcFilename, unsigned long ulLine);
+-#define LWIP_PLATFORM_ASSERT(expr)   printk("[%s - %s - %d] ", expr , __FILE__, __LINE__);
+-//{
+-    //if(!(expr))
+-    //{
+-        //__error__(__FILE__, __LINE__);
+-    //}
+-//}
++#define LWIP_PLATFORM_DIAG(expr)        printk expr
++
++//#else
++//#define LWIP_PLATFORM_DIAG(expr)
++//#endif
++
++//#define DEBUG
++#ifdef DEBUG
++
++/* for passing arguments to print function */
++#define CC_ASSERT(message, assertion) do { if (!(assertion)) \
++					     LWIP_PLATFORM_DIAG(message); } while (0)
++
++//extern void __error__(char *pcFilename, unsigned long ulLine);
++#define LWIP_PLATFORM_ASSERT(expr)      printk((const char *)expr)
++/*
++{                                       \
++    if(!(expr))                         \
++    {                                   \
++        __error__(__FILE__, __LINE__);  \
++    }                                   \
++}
++*/
+ #else
+ #define LWIP_PLATFORM_ASSERT(expr)
+-#endif
++#define CC_ASSERT(message, assertion)
++#endif /* DEBUG */
++
++/* "lightweight" synchronization mechanisms */
++/* #define SYS_ARCH_DECL_PROTECT(x) */ /* declare a protection state variable */
++/* #define SYS_ARCH_PROTECT(x) */ /* enter protection mode */
++/* #define SYS_ARCH_UNPROTECT(x) */ /* leave protection mode */
+ 
+ #endif /* __CC_H__ */
+diff --git a/ports/include/arch/perf.h b/ports/include/arch/perf.h
+index d754157..1f799b3 100644
+--- a/ports/include/arch/perf.h
++++ b/ports/include/arch/perf.h
+@@ -1,38 +1,12 @@
+-/*
+- * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
+- * All rights reserved.
+- *
+- * Redistribution and use in source and binary forms, with or without modification,
+- * are permitted provided that the following conditions are met:
+- *
+- * 1. Redistributions of source code must retain the above copyright notice,
+- *    this list of conditions and the following disclaimer.
+- * 2. Redistributions in binary form must reproduce the above copyright notice,
+- *    this list of conditions and the following disclaimer in the documentation
+- *    and/or other materials provided with the distribution.
+- * 3. The name of the author may not be used to endorse or promote products
+- *    derived from this software without specific prior written permission.
+- *
+- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+- * OF SUCH DAMAGE.
+- *
+- * This file is part of the lwIP TCP/IP stack.
+- *
+- * Author: Adam Dunkels <adam@sics.se>
+- *
+- */
+-#ifndef __PERF_H__
+-#define __PERF_H__
++#ifndef _LWIP_ARCH_PERF_H_
++#define _LWIP_ARCH_PERF_H_
+ 
+-#define PERF_START    /* null definition */
+-#define PERF_STOP(x)  /* null definition */
++//perf.h     - Architecture specific performance measurement.
++//Measurement calls made throughout lwip, these can be defined to nothing.
+ 
+-#endif /* __PERF_H__ */
++#define PERF_START
++
++#define PERF_STOP(x)
++
++
++#endif /* _LWIP_ARCH_PERF_H_ */
+diff --git a/ports/include/arch/sys_arch.h b/ports/include/arch/sys_arch.h
+index 32f0d99..087892b 100644
+--- a/ports/include/arch/sys_arch.h
++++ b/ports/include/arch/sys_arch.h
+@@ -24,36 +24,94 @@
+  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+  * OF SUCH DAMAGE.
+  *
+- * This file is part of the lwIP TCP/IP stack.
++ * This file is system adaptation of the lwIP TCP/IP stack
++ * by Adam Dunkels <adam@sics.se> for RTEMS system.
+  *
+- * Author: Adam Dunkels <adam@sics.se>
++ * Author: Premysl Houdek <houdepre@fel.cvut.cz>
++ * Mentor: Pavel Pisa <pisa@cmp.felk.cvut.cz>
++ * Industrial Informatics Group, FEE, Czech Technical University in Prague
+  *
+  */
+-#ifndef LWIP_ARCH_SYS_ARCH_H
+-#define LWIP_ARCH_SYS_ARCH_H
++/*
++ * mapping of lwIP system dependencies to RTEMS system services and types.
++ * DETAILS: ./lwip/doc/sys_arch.txt
++ */
++#ifndef __ARCH_SYS_ARCH_H__
++#define __ARCH_SYS_ARCH_H__
++
++#include <rtems/rtems/sem.h>
++#include <rtems/rtems/intr.h>
++#include <bsp/irq-generic.h>
++
++/* Typedefs for the various port-specific types. */
++#if defined(NO_SYS) && NO_SYS
++  #error "RTEMS SYS_ARCH cannot be compiled in NO_SYS variant"
++#endif
++
++#define sys_arch_printk printk
++
++typedef struct {
++  rtems_id mailbox;
++  rtems_id sem;
++} port_mailbox_t;
++
++typedef struct {
++  rtems_id semaphore;
++} port_sem_t;
++
++typedef struct {
++  rtems_id mutex;
++} port_mutex_t;
++
++typedef port_mailbox_t sys_mbox_t;
++typedef port_sem_t sys_sem_t;
++typedef rtems_id sys_thread_t;
++typedef port_mutex_t sys_mutex_t;
++typedef rtems_interrupt_level sys_prot_t;
+ 
+-#include <errno.h>
++void
++sys_arch_delay(unsigned int x);
++void
++sys_sem_signal_from_ISR(sys_sem_t *sem);
+ 
+-#define SYS_MBOX_NULL NULL
+-#define SYS_SEM_NULL  NULL
++typedef void sys_irqreturn_t;
++#define SYS_IRQ_NONE       ((void)0)
++#define SYS_IRQ_HANDLED    ((void)1)
++#define SYS_IRQ_RETVAL(x)  (IRQ_HANDLED)
++typedef rtems_interrupt_handler sys_irq_handler_t;
++#define SYS_IRQ_HANDLER_FNC(M_fnc_name)	\
++  sys_irqreturn_t M_fnc_name(void *__irq_handler_context)
++#define sys_irq_handler_get_context() (__irq_handler_context)
+ 
+-typedef u32_t sys_prot_t;
++int
++sys_request_irq(unsigned int irqnum, sys_irq_handler_t handler,
++		unsigned long flags, const char *name, void *context);
+ 
+-struct sys_sem;
+-typedef struct sys_sem * sys_sem_t;
+-#define sys_sem_valid(sem) (((sem) != NULL) && (*(sem) != NULL))
+-#define sys_sem_set_invalid(sem) do { if((sem) != NULL) { *(sem) = NULL; }}while(0)
++static inline void
++sys_arch_mask_interrupt_source(unsigned int x)
++{
++  bsp_interrupt_vector_disable(x);
++}
+ 
+-/* let sys.h use binary semaphores for mutexes */
+-#define LWIP_COMPAT_MUTEX 1
++static inline void
++sys_arch_unmask_interrupt_source(unsigned int x)
++{
++  bsp_interrupt_vector_enable(x);
++}
+ 
+-struct sys_mbox;
+-typedef struct sys_mbox *sys_mbox_t;
+-#define sys_mbox_valid(mbox) ((*(mbox) != NULL))
+-#define sys_mbox_set_invalid(mbox) do { if((mbox) != NULL) { *(mbox) = NULL; }}while(0)
++static inline sys_prot_t
++sys_arch_protect(void)
++{
++  sys_prot_t pval;
+ 
+-struct sys_thread;
+-typedef struct sys_thread * sys_thread_t;
++  rtems_interrupt_disable(pval);
++  return pval;
++}
+ 
+-#endif /* LWIP_ARCH_SYS_ARCH_H */
++static inline void
++sys_arch_unprotect(sys_prot_t pval)
++{
++  rtems_interrupt_enable(pval);
++}
+ 
++#endif /* __ARCH_SYS_ARCH_H__ */
+diff --git a/ports/sys_arch.c b/ports/sys_arch.c
+index 360a4e2..24d1133 100644
+--- a/ports/sys_arch.c
++++ b/ports/sys_arch.c
+@@ -24,640 +24,334 @@
+  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+  * OF SUCH DAMAGE.
+  *
+- * This file is part of the lwIP TCP/IP stack.
++ * This file is system adaptation of the lwIP TCP/IP stack
++ * by Adam Dunkels <adam@sics.se> for RTEMS system.
+  *
+- * Author: Adam Dunkels <adam@sics.se>
++ * Author: Premysl Houdek <houdepre@fel.cvut.cz>
++ * Mentor: Pavel Pisa <pisa@cmp.felk.cvut.cz>
++ * Industrial Informatics Group, FEE, Czech Technical University in Prague
+  *
+  */
+-
+ /*
+- * Wed Apr 17 16:05:29 EDT 2002 (James Roth)
+- *
+- *  - Fixed an unlikely sys_thread_new() race condition.
+- *
+- *  - Made current_thread() work with threads which where
+- *    not created with sys_thread_new().  This includes
+- *    the main thread and threads made with pthread_create().
+- *
+- *  - Catch overflows where more than SYS_MBOX_SIZE messages
+- *    are waiting to be read.  The sys_mbox_post() routine
+- *    will block until there is more room instead of just
+- *    leaking messages.
++ * mapping of lwIP system dependencies to RTEMS system services and types.
++ * DETAILS: ./lwip/doc/sys_arch.txt
+  */
+ 
+-#include <string.h>
+-#include <sys/time.h>
+-#include <sys/types.h>
+-#include <stdlib.h>
+-#include <unistd.h>
+-#include <pthread.h>
+-
+-#include "lwip/opt.h"
+-#include "lwip/sys.h"
+-#include "lwip/stats.h"
+-#include "lwip/debug.h"
+-
+-#define UMAX(a, b)      ((a) > (b) ? (a) : (b))
+-
+-static struct timeval starttime;
+-
+-#if !NO_SYS
+-
+-static struct sys_thread *threads = NULL;
+-static pthread_mutex_t threads_mutex = PTHREAD_MUTEX_INITIALIZER;
+-
+-struct sys_mbox_msg {
+-  struct sys_mbox_msg *next;
+-  void *msg;
+-};
+-
+-#define SYS_MBOX_SIZE 128
+-
+-struct sys_mbox {
+-  int first, last;
+-  void *msgs[SYS_MBOX_SIZE];
+-  struct sys_sem *not_empty;
+-  struct sys_sem *not_full;
+-  struct sys_sem *mutex;
+-  int wait_send;
+-};
+-
+-struct sys_sem {
+-  unsigned int c;
+-  pthread_cond_t cond;
+-  pthread_mutex_t mutex;
+-};
+-
+-struct sys_thread {
+-  struct sys_thread *next;
+-  pthread_t pthread;
+-};
+-
+-#if SYS_LIGHTWEIGHT_PROT
+-static pthread_mutex_t lwprot_mutex = PTHREAD_MUTEX_INITIALIZER;
+-static pthread_t lwprot_thread = (pthread_t)0xDEAD;
+-static int lwprot_count = 0;
+-#endif /* SYS_LIGHTWEIGHT_PROT */
+-
+-static struct sys_sem *sys_sem_new_internal(u8_t count);
+-static void sys_sem_free_internal(struct sys_sem *sem);
+-
+-static u32_t cond_wait(pthread_cond_t * cond, pthread_mutex_t * mutex,
+-                       u32_t timeout);
+-
+-/*-----------------------------------------------------------------------------------*/
+-static struct sys_thread *
+-introduce_thread(pthread_t id)
+-{
+-  struct sys_thread *thread = NULL;
++#include <stdint.h>
++#include <arch/cc.h>
++#include <rtems/rtems/clock.h>
++#include <rtems/rtems/sem.h>
++#include <rtems.h>
++#include "sys_arch.h"
++#include "lwip/err.h"
++#include "lwip/tcpip.h"
++#include "lwipopts.h"
+ 
+-  thread = (struct sys_thread *)malloc(sizeof(struct sys_thread));
++#define SYS_LWIP_MBOX_SIZE (sizeof(void *))
+ 
+-  if (thread != NULL) {
+-    pthread_mutex_lock(&threads_mutex);
+-    thread->next = threads;
+-    thread->pthread = id;
+-    threads = thread;
+-    pthread_mutex_unlock(&threads_mutex);
+-  }
++uint32_t
++sys_now()
++{
++  uint64_t temp = rtems_clock_get_uptime_nanoseconds() / (1000 * 1000);
+ 
+-  return thread;
++  return temp;
+ }
+-/*-----------------------------------------------------------------------------------*/
+-sys_thread_t
+-sys_thread_new(const char *name, lwip_thread_fn function, void *arg, int stacksize, int prio)
++
++void
++sys_init(void)
+ {
+-  int code;
+-  int rc;
+-  pthread_t tmp;
+-  pthread_attr_t attr;
+-  struct sys_thread *st = NULL;
+-  LWIP_UNUSED_ARG(name);
+-  LWIP_UNUSED_ARG(stacksize);
+-  LWIP_UNUSED_ARG(prio);
+-
+-  /* Alloc a new pthread with the specified stack size. */
+-  if(stacksize > 0) {
+-    rc = pthread_attr_init(&attr);
+-    if (rc != 0) {
+-      LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: pthread_attr_init error = %d\n", rc));
+-      return NULL;
+-    }
+-    rc = pthread_attr_setstacksize(&attr, stacksize);
+-    if (rc != 0) {
+-      LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: pthread_attr_setstacksize error = %d\n", rc));
+-      pthread_attr_destroy(&attr);
+-      return NULL;
+-    }
+-    pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);
+-    pthread_attr_setschedpolicy(&attr, SCHED_RR);
+-    code = pthread_create(&tmp, &attr, (void *(*)(void *)) function, arg);
+-    pthread_attr_destroy(&attr);
+-  } else {
+-    code = pthread_create(&tmp, NULL, (void *(*)(void *)) function, arg);
+-  }
+-  LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: thread created [name:%s|stacksize:%d|prio:%d|addr:0x%x]\n",
+-                          name, stacksize, prio, (uint)tmp));
++  //  Is called to initialize the sys_arch layer.
++  return;
++}
+ 
+-  if (0 == code) {
+-    st = introduce_thread(tmp);
++err_t
++sys_sem_new(sys_sem_t *sem, u8_t count)
++{
++  rtems_status_code ret = rtems_semaphore_create(
++    rtems_build_name('L', 'W', 'I', 'P'),
++    count,
++    RTEMS_COUNTING_SEMAPHORE,
++    0,
++    &sem->semaphore
++    );
++
++  if (ret != RTEMS_SUCCESSFUL) {
++    sem->semaphore = RTEMS_ID_NONE;
++    return ret;
+   }
++  return ERR_OK;
++}
+ 
+-  if (NULL == st) {
+-    LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: failed to introduce %d, st = %p\n",
+-                            code, (void*)st));
+-    abort();
+-  } else {
+-    LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: introduced %d, st = %p\n",
+-                            code, (void*)st));
+-  }
+ 
+-  return st;
++void
++sys_sem_free(sys_sem_t *sem)
++{
++  rtems_semaphore_delete(
++    sem->semaphore
++    );
++  sem->semaphore = RTEMS_ID_NONE;
+ }
+-/*-----------------------------------------------------------------------------------*/
+-void sys_thread_signal(sys_thread_t thread, int signal)
++
++void
++sys_sem_signal(sys_sem_t *sem)
+ {
+-    /* Check received parameters. */
+-    if(thread == NULL) {
+-        LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_signal: could not send signal to thread. thread = NULL\n"));
+-        return;
+-    }
+-
+-    /* Send signal. */
+-    pthread_kill(thread->pthread, signal);
++  rtems_semaphore_release(sem->semaphore);
+ }
+-/*-----------------------------------------------------------------------------------*/
+-err_t
+-sys_mbox_new(struct sys_mbox **mb, int size)
++
++void
++sys_sem_signal_from_ISR(sys_sem_t *sem)
+ {
+-  struct sys_mbox *mbox = NULL;
+-  LWIP_UNUSED_ARG(size);
++  rtems_semaphore_release(sem->semaphore);
++}
+ 
+-  mbox = (struct sys_mbox *)malloc(sizeof(struct sys_mbox));
+-  if (mbox == NULL) {
+-    SYS_STATS_INC(mbox.err);
+-    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_new: could not create mbox\n"));
+-    return ERR_MEM;
++
++u32_t
++sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout)
++{
++  rtems_status_code status;
++  rtems_interval tps = rtems_clock_get_ticks_per_second();
++  rtems_interval tick_timeout;
++  uint64_t       start_time;
++  uint64_t       wait_time;
++
++  start_time = rtems_clock_get_uptime_nanoseconds();
++  if (timeout == 0) {
++    tick_timeout = RTEMS_NO_TIMEOUT;
++  } else {
++    tick_timeout = (timeout * tps + 999) / 1000;
+   }
+-  mbox->first = mbox->last = 0;
+-  mbox->not_empty = sys_sem_new_internal(0);
+-  mbox->not_full = sys_sem_new_internal(0);
+-  mbox->mutex = sys_sem_new_internal(1);
+-  mbox->wait_send = 0;
+-
+-  SYS_STATS_INC_USED(mbox);
+-
+-  if((mbox->not_empty == NULL) || (mbox->not_full == NULL) || (mbox->mutex == NULL)) {
+-    SYS_STATS_INC(mbox.err);
+-    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_new: could not create mbox internals\n"));
+-    sys_mbox_free(&mbox);
+-    return ERR_MEM;
++  status = rtems_semaphore_obtain(sem->semaphore, RTEMS_WAIT, tick_timeout);
++  if (status == RTEMS_TIMEOUT) {
++    return SYS_ARCH_TIMEOUT;
+   }
+-  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_new: mbox created [not_empty:%X|not_full:%X|mutex:%X] \n",
+-                          mbox->not_empty, mbox->not_full, mbox->mutex));
++  if (status != RTEMS_SUCCESSFUL) {
++    return SYS_ARCH_TIMEOUT;
++  }
++  wait_time = rtems_clock_get_uptime_nanoseconds() - start_time;
++  return wait_time / (1000 * 1000);
++}
+ 
+-  *mb = mbox;
+-  return ERR_OK;
++int
++sys_sem_valid(sys_sem_t *sem)
++{
++  return sem->semaphore == RTEMS_ID_NONE ? 0 : 1;
+ }
+-/*-----------------------------------------------------------------------------------*/
++
+ void
+-sys_mbox_free(struct sys_mbox **mb)
++sys_sem_set_invalid(sys_sem_t *sem)
+ {
+-  if ((mb != NULL) && (*mb != SYS_MBOX_NULL)) {
+-    struct sys_mbox *mbox = *mb;
+-    sys_arch_sem_wait(&mbox->mutex, 0);
+-
+-    sys_sem_free_internal(mbox->not_empty);
+-    sys_sem_free_internal(mbox->not_full);
+-    sys_sem_free_internal(mbox->mutex);
+-    mbox->not_empty = mbox->not_full = mbox->mutex = NULL;
+-    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_free: mbox 0x%lx\n", mbox));
+-    free(mbox);
+-    SYS_STATS_DEC(mbox.used);
+-  }
++  sem->semaphore = RTEMS_ID_NONE;
+ }
+-/*-----------------------------------------------------------------------------------*/
++
+ err_t
+-sys_mbox_trypost(struct sys_mbox **mb, void *msg)
++sys_mbox_new(sys_mbox_t *mbox, int size)
+ {
+-  u8_t first;
+-  struct sys_mbox *mbox;
+-  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
+-  mbox = *mb;
+-  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_trypost: start"));
+-  sys_arch_sem_wait(&mbox->mutex, 0);
+-
+-  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_trypost: mbox %p msg %p\n",
+-                          (void *)mbox, (void *)msg));
+-
+-  if ((mbox->last + 1) >= (mbox->first + SYS_MBOX_SIZE)) {
+-    sys_sem_signal(&mbox->mutex);
+-    return ERR_MEM;
+-  }
+-
+-  mbox->msgs[mbox->last % SYS_MBOX_SIZE] = msg;
+-
+-  if (mbox->last == mbox->first) {
+-    first = 1;
+-  } else {
+-    first = 0;
+-  }
+-
+-  mbox->last++;
+-
+-  if (first) {
+-    sys_sem_signal(&mbox->not_empty);
++  rtems_status_code ret;
++
++  ret = rtems_message_queue_create(
++    rtems_build_name('L', 'W', 'I', 'P'),
++    size,
++    SYS_LWIP_MBOX_SIZE,
++    0,
++    &mbox->mailbox
++    );
++  ret |= rtems_semaphore_create(
++    rtems_build_name('L', 'W', 'I', 'P'),
++    size,
++    RTEMS_COUNTING_SEMAPHORE,
++    0,
++    &mbox->sem
++    );
++  if (ret != RTEMS_SUCCESSFUL) {
++    mbox->mailbox = RTEMS_ID_NONE;
++    mbox->sem = RTEMS_ID_NONE;
++    return ret;
+   }
+-
+-  sys_sem_signal(&mbox->mutex);
+-
+   return ERR_OK;
+ }
+-/*-----------------------------------------------------------------------------------*/
++
+ void
+-sys_mbox_post(struct sys_mbox **mb, void *msg)
++sys_mbox_free(sys_mbox_t *mbox)
+ {
+-  u8_t first;
+-  struct sys_mbox *mbox;
+-  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
+-  mbox = *mb;
+-
+-  sys_arch_sem_wait(&mbox->mutex, 0);
+-
+-  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_post: mbox %p msg %p\n", (void *)mbox, (void *)msg));
+-
+-  while ((mbox->last + 1) >= (mbox->first + SYS_MBOX_SIZE)) {
+-    mbox->wait_send++;
+-    sys_sem_signal(&mbox->mutex);
+-    sys_arch_sem_wait(&mbox->not_full, 0);
+-    sys_arch_sem_wait(&mbox->mutex, 0);
+-    mbox->wait_send--;
+-  }
++  rtems_message_queue_delete(mbox->mailbox);
++  rtems_semaphore_delete(mbox->sem);
++  sys_mbox_set_invalid(mbox);
++}
+ 
+-  mbox->msgs[mbox->last % SYS_MBOX_SIZE] = msg;
++void
++sys_mbox_post(sys_mbox_t *mbox, void *msg)
++{
++  rtems_semaphore_obtain(mbox->sem, RTEMS_WAIT, RTEMS_NO_TIMEOUT);
++  rtems_message_queue_send(mbox->mailbox, &msg, SYS_LWIP_MBOX_SIZE);
++}
++err_t
++sys_mbox_trypost(sys_mbox_t *mbox, void *msg)
++{
++  rtems_status_code status = rtems_semaphore_obtain(mbox->sem,
++						    RTEMS_NO_WAIT, 0);
+ 
+-  if (mbox->last == mbox->first) {
+-    first = 1;
++  if (status != RTEMS_SUCCESSFUL) {
++    return ERR_MEM;
+   } else {
+-    first = 0;
++    rtems_message_queue_send(mbox->mailbox, &msg, SYS_LWIP_MBOX_SIZE);
++    return ERR_OK;
+   }
+-
+-  mbox->last++;
+-
+-  if (first) {
+-    sys_sem_signal(&mbox->not_empty);
+-  }
+-
+-  sys_sem_signal(&mbox->mutex);
+ }
+-/*-----------------------------------------------------------------------------------*/
++
+ u32_t
+-sys_arch_mbox_tryfetch(struct sys_mbox **mb, void **msg)
++sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeout)
+ {
+-  struct sys_mbox *mbox;
+-  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
+-  mbox = *mb;
+-
+-  sys_arch_sem_wait(&mbox->mutex, 0);
+-
+-  if (mbox->first == mbox->last) {
+-    sys_sem_signal(&mbox->mutex);
+-    return SYS_MBOX_EMPTY;
+-  }
+-
+-  if (msg != NULL) {
+-    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_tryfetch: mbox %p msg %p\n", (void *)mbox, *msg));
+-    *msg = mbox->msgs[mbox->first % SYS_MBOX_SIZE];
++  rtems_status_code status;
++  rtems_interval tps = rtems_clock_get_ticks_per_second();
++  rtems_interval tick_timeout;
++  uint64_t       start_time;
++  uint64_t       wait_time;
++  size_t         dummy;
++
++  start_time = rtems_clock_get_uptime_nanoseconds();
++  if (timeout == 0) {
++    tick_timeout = RTEMS_NO_TIMEOUT;
++  } else {
++    tick_timeout = (timeout * tps + 999) / 1000;
+   }
+-  else{
+-    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_tryfetch: mbox %p, null msg\n", (void *)mbox));
++  status = rtems_message_queue_receive(mbox->mailbox,
++				       msg,
++				       &dummy,
++				       RTEMS_WAIT,
++				       tick_timeout
++				       );
++  if (status == RTEMS_TIMEOUT) {
++    return SYS_ARCH_TIMEOUT;
+   }
+-
+-  mbox->first++;
+-
+-  if (mbox->wait_send) {
+-    sys_sem_signal(&mbox->not_full);
++  if (status != RTEMS_SUCCESSFUL) {
++    return SYS_ARCH_TIMEOUT;
+   }
+-
+-  sys_sem_signal(&mbox->mutex);
+-
+-  return 0;
++  wait_time = rtems_clock_get_uptime_nanoseconds() - start_time;
++  rtems_semaphore_release(mbox->sem);
++  return wait_time / (1000 * 1000);
+ }
+-/*-----------------------------------------------------------------------------------*/
++
+ u32_t
+-sys_arch_mbox_fetch(struct sys_mbox **mb, void **msg, u32_t timeout)
++sys_arch_mbox_tryfetch(sys_mbox_t *mbox, void **msg)
+ {
+-  u32_t time_needed = 0;
+-  struct sys_mbox *mbox;
+-  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
+-  mbox = *mb;
+-
+-  /* The mutex lock is quick so we don't bother with the timeout
+-     stuff here. */
+-  sys_arch_sem_wait(&mbox->mutex, 0);
+-
+-  while (mbox->first == mbox->last) {
+-    sys_sem_signal(&mbox->mutex);
+-
+-    /* We block while waiting for a mail to arrive in the mailbox. We
+-       must be prepared to timeout. */
+-    if (timeout != 0) {
+-      time_needed = sys_arch_sem_wait(&mbox->not_empty, timeout);
+-
+-      if (time_needed == SYS_ARCH_TIMEOUT) {
+-        return SYS_ARCH_TIMEOUT;
+-      }
+-    } else {
+-      sys_arch_sem_wait(&mbox->not_empty, 0);
+-    }
+-
+-    sys_arch_sem_wait(&mbox->mutex, 0);
+-  }
++  rtems_status_code status;
++  size_t         dummy;
+ 
+-  if (msg != NULL) {
+-    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_fetch: mbox %p msg %p\n", (void *)mbox, *msg));
+-    *msg = mbox->msgs[mbox->first % SYS_MBOX_SIZE];
+-  }
+-  else{
+-    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_fetch: mbox %p, null msg\n", (void *)mbox));
+-  }
+-
+-  mbox->first++;
+-
+-  if (mbox->wait_send) {
+-    sys_sem_signal(&mbox->not_full);
+-  }
+-
+-  sys_sem_signal(&mbox->mutex);
++  status = rtems_message_queue_receive(mbox->mailbox, msg,
++				       &dummy,
++				       RTEMS_NO_WAIT,
++				       0
++				       );
+ 
+-  return time_needed;
+-}
+-/*-----------------------------------------------------------------------------------*/
+-static struct sys_sem *
+-sys_sem_new_internal(u8_t count)
+-{
+-  struct sys_sem *sem = NULL;
+-  int rc;
+-
+-  sem = (struct sys_sem *)malloc(sizeof(struct sys_sem));
+-  if (sem != NULL) {
+-    sem->c = count;
+-    rc = pthread_cond_init(&(sem->cond), NULL);
+-    if(rc != 0) {
+-      LWIP_DEBUGF(SYS_DEBUG, ("sys_sem_new_internal: pthread_cond_init error = %d\n", rc));
+-      return NULL;
+-    }
+-    rc = pthread_mutex_init(&(sem->mutex), NULL);
+-    if(rc != 0) {
+-      LWIP_DEBUGF(SYS_DEBUG, ("sys_sem_new_internal: pthread_mutex_init error = %d\n", rc));
+-      SYS_STATS_INC(mutex.err);
+-      pthread_cond_destroy(&(sem->cond));
+-      return NULL;
+-    }
+-    SYS_STATS_INC_USED(mutex);
+-    SYS_STATS_INC_USED(sem);
++  if (status != RTEMS_SUCCESSFUL) {
++    return SYS_MBOX_EMPTY;
+   } else {
+-    LWIP_DEBUGF(SYS_DEBUG, ("sys_sem_new_internal: could not create semaphore\n"));
+-    SYS_STATS_INC(sem.err);
++    rtems_semaphore_release(mbox->sem);
++    return 0;
+   }
+-  return sem;
+ }
+-/*-----------------------------------------------------------------------------------*/
+-err_t
+-sys_sem_new(struct sys_sem **sem, u8_t count)
++int
++sys_mbox_valid(sys_mbox_t *mbox)
+ {
+-  *sem = sys_sem_new_internal(count);
+-  if (*sem == NULL) {
+-    return ERR_MEM;
+-  }
+-  return ERR_OK;
++  return mbox->mailbox == RTEMS_ID_NONE ? 0 : 1;
+ }
+-/*-----------------------------------------------------------------------------------*/
+-static u32_t
+-cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex, u32_t timeout)
++void
++sys_mbox_set_invalid(sys_mbox_t *mbox)
+ {
+-  time_t tdiff;
+-  time_t sec, usec;
+-  struct timeval rtime1, rtime2;
+-  struct timespec ts;
+-  int retval;
+-
+-  if (timeout > 0) {
+-    /* Get a timestamp and add the timeout value. */
+-    gettimeofday(&rtime1, NULL);
+-    sec = rtime1.tv_sec;
+-    usec = rtime1.tv_usec;
+-    usec += timeout % 1000 * 1000;
+-    sec += (int)(timeout / 1000) + (int)(usec / 1000000);
+-    usec = usec % 1000000;
+-    ts.tv_nsec = usec * 1000;
+-    ts.tv_sec = sec;
+-
+-    retval = pthread_cond_timedwait(cond, mutex, &ts);
+-
+-    if (retval == ETIMEDOUT) {
+-      return SYS_ARCH_TIMEOUT;
+-    } else {
+-      /* Calculate for how long we waited for the cond. */
+-      gettimeofday(&rtime2, NULL);
+-      tdiff = (rtime2.tv_sec - rtime1.tv_sec) * 1000 +
+-        (rtime2.tv_usec - rtime1.tv_usec) / 1000;
+-
+-      if (tdiff <= 0) {
+-        return 0;
+-      }
+-      return (u32_t)tdiff;
+-    }
+-  } else {
+-    pthread_cond_wait(cond, mutex);
+-    return 0;
+-  }
++  mbox->sem = RTEMS_ID_NONE;
++  mbox->mailbox = RTEMS_ID_NONE;
+ }
+-/*-----------------------------------------------------------------------------------*/
+-u32_t
+-sys_arch_sem_wait(struct sys_sem **s, u32_t timeout)
++
++sys_thread_t
++sys_thread_new(const char *name, lwip_thread_fn function, void *arg, int stack_size, int prio)
+ {
+-  u32_t time_needed = 0;
+-  struct sys_sem *sem;
+-  LWIP_ASSERT("invalid sem", (s != NULL) && (*s != NULL));
+-  sem = *s;
+-
+-  pthread_mutex_lock(&(sem->mutex));
+-  while (sem->c <= 0) {
+-    if (timeout > 0) {
+-      time_needed = cond_wait(&(sem->cond), &(sem->mutex), timeout);
+-
+-      if (time_needed == SYS_ARCH_TIMEOUT) {
+-        pthread_mutex_unlock(&(sem->mutex));
+-        return SYS_ARCH_TIMEOUT;
+-      }
+-    } else {
+-      cond_wait(&(sem->cond), &(sem->mutex), 0);
+-    }
++  rtems_id id;
++  rtems_status_code res;
++
++  res = rtems_task_create(
++    rtems_build_name('L', 'W', 'I', 'P'),
++    prio,
++    stack_size,
++    RTEMS_PREEMPT,
++    0,
++    &id
++    );
++
++  if (res != RTEMS_SUCCESSFUL) {
++    return 0;
+   }
+-  sem->c--;
+-  pthread_mutex_unlock(&(sem->mutex));
+-  return (u32_t)time_needed;
+-}
+-/*-----------------------------------------------------------------------------------*/
+-void
+-sys_sem_signal(struct sys_sem **s)
+-{
+-  struct sys_sem *sem;
+-  LWIP_ASSERT("invalid sem", (s != NULL) && (*s != NULL));
+-  sem = *s;
+ 
+-  pthread_mutex_lock(&(sem->mutex));
+-  sem->c++;
++  res = rtems_task_start(id, (rtems_task_entry)function, (rtems_task_argument)arg);
+ 
+-  if (sem->c > 1) {
+-    sem->c = 1;
++  if (res != RTEMS_SUCCESSFUL) {
++    rtems_task_delete(id);
++    return 0;
+   }
+-
+-  pthread_cond_broadcast(&(sem->cond));
+-  pthread_mutex_unlock(&(sem->mutex));
++  return id;
+ }
+-/*-----------------------------------------------------------------------------------*/
+-static void
+-sys_sem_free_internal(struct sys_sem *sem)
++
++err_t
++sys_mutex_new(sys_mutex_t *mutex)
+ {
+-  if(sem != NULL) {
+-    pthread_cond_destroy(&(sem->cond));
+-    pthread_mutex_destroy(&(sem->mutex));
+-    SYS_STATS_DEC(mutex.used);
+-    SYS_STATS_DEC(sem.used);
+-    free(sem);
++  rtems_status_code ret = rtems_semaphore_create(
++    rtems_build_name('L', 'W', 'I', 'P'),
++    1,
++    RTEMS_PRIORITY|RTEMS_BINARY_SEMAPHORE|RTEMS_INHERIT_PRIORITY|RTEMS_LOCAL,
++    0,
++    &mutex->mutex
++    );
++
++  if (ret != RTEMS_SUCCESSFUL) {
++    mutex->mutex = RTEMS_ID_NONE;
++    return ret;
+   }
++  return ERR_OK;
+ }
+-/*-----------------------------------------------------------------------------------*/
++/** Lock a mutex
++ * @param mutex the mutex to lock */
+ void
+-sys_sem_free(struct sys_sem **sem)
++sys_mutex_lock(sys_mutex_t *mutex)
+ {
+-  if ((sem != NULL) && (*sem != SYS_SEM_NULL)) {
+-    sys_sem_free_internal(*sem);
+-  }
++  rtems_semaphore_obtain(mutex->mutex, RTEMS_WAIT, RTEMS_NO_TIMEOUT);
+ }
+-#endif /* !NO_SYS */
+-/*-----------------------------------------------------------------------------------*/
+-u32_t
+-sys_now(void)
+-{
+-  struct timeval tv;
+-  u32_t sec, usec, msec;
+-  gettimeofday(&tv, NULL);
+-
+-  sec = (u32_t)(tv.tv_sec - starttime.tv_sec);
+-  usec = (u32_t)(tv.tv_usec - starttime.tv_usec);
+-  msec = sec * 1000 + usec / 1000;
+-
+-  return msec;
+-}
+-/*-----------------------------------------------------------------------------------*/
++/** Unlock a mutex
++ * @param mutex the mutex to unlock */
+ void
+-sys_init(void)
+-{
+-  SYS_STATS_INC_USED(mutex);
+-  gettimeofday(&starttime, NULL);
+-}
+-/*-----------------------------------------------------------------------------------*/
+-#if SYS_LIGHTWEIGHT_PROT
+-/** sys_prot_t sys_arch_protect(void)
+-
+-This optional function does a "fast" critical region protection and returns
+-the previous protection level. This function is only called during very short
+-critical regions. An embedded system which supports ISR-based drivers might
+-want to implement this function by disabling interrupts. Task-based systems
+-might want to implement this by using a mutex or disabling tasking. This
+-function should support recursive calls from the same task or interrupt. In
+-other words, sys_arch_protect() could be called while already protected. In
+-that case the return value indicates that it is already protected.
+-
+-sys_arch_protect() is only required if your port is supporting an operating
+-system.
+-*/
+-sys_prot_t
+-sys_arch_protect(void)
++sys_mutex_unlock(sys_mutex_t *mutex)
+ {
+-    /* Note that for the UNIX port, we are using a lightweight mutex, and our
+-     * own counter (which is locked by the mutex). The return code is not actually
+-     * used. */
+-    if (lwprot_thread != pthread_self())
+-    {
+-        /* We are locking the mutex where it has not been locked before *
+-        * or is being locked by another thread */
+-        pthread_mutex_lock(&lwprot_mutex);
+-        lwprot_thread = pthread_self();
+-        lwprot_count = 1;
+-    }
+-    else
+-    {
+-        /* It is already locked by THIS thread */
+-        lwprot_count++;
+-    }
+-    return 0;
++  rtems_semaphore_release(mutex->mutex);
+ }
+-/*-----------------------------------------------------------------------------------*/
+-/** void sys_arch_unprotect(sys_prot_t pval)
+-
+-This optional function does a "fast" set of critical region protection to the
+-value specified by pval. See the documentation for sys_arch_protect() for
+-more information. This function is only required if your port is supporting
+-an operating system.
+-*/
++/** Delete a semaphore
++ * @param mutex the mutex to delete */
+ void
+-sys_arch_unprotect(sys_prot_t pval)
++sys_mutex_free(sys_mutex_t *mutex)
+ {
+-    LWIP_UNUSED_ARG(pval);
+-    if (lwprot_thread == pthread_self())
+-    {
+-        if (--lwprot_count == 0)
+-        {
+-            lwprot_thread = (pthread_t) 0xDEAD;
+-            pthread_mutex_unlock(&lwprot_mutex);
+-        }
+-    }
++  rtems_semaphore_delete(mutex->mutex);
+ }
+-#endif /* SYS_LIGHTWEIGHT_PROT */
+ 
+-/*-----------------------------------------------------------------------------------*/
+-
+-#ifndef MAX_JIFFY_OFFSET
+-#define MAX_JIFFY_OFFSET ((~0U >> 1)-1)
+-#endif
++void
++sys_arch_delay(unsigned int timeout)
++{
++  rtems_interval tps = rtems_clock_get_ticks_per_second();
++  rtems_interval tick_timeout = (timeout * tps + 999) / 1000;
+ 
+-#ifndef HZ
+-#define HZ 100
+-#endif
++  rtems_task_wake_after(tick_timeout);
++}
+ 
+-u32_t
++/** Ticks/jiffies since power up. */
++uint32_t
+ sys_jiffies(void)
+ {
+-    struct timeval tv;
+-    unsigned long sec;
+-    long usec;
+-
+-    gettimeofday(&tv,NULL);
+-    sec = tv.tv_sec - starttime.tv_sec;
+-    usec = tv.tv_usec;
+-
+-    if (sec >= (MAX_JIFFY_OFFSET / HZ))
+-      return MAX_JIFFY_OFFSET;
+-    usec += 1000000L / HZ - 1;
+-    usec /= 1000000L / HZ;
+-    return HZ * sec + usec;
++  return rtems_clock_get_ticks_since_boot();
+ }
+ 
+-#if PPP_DEBUG
+-
+-#include <stdarg.h>
+-
+-void ppp_trace(int level, const char *format, ...)
++int
++sys_request_irq(unsigned int irqnum, sys_irq_handler_t handler,
++		unsigned long flags, const char *name, void *context)
+ {
+-    va_list args;
++  rtems_status_code res;
+ 
+-    (void)level;
+-    va_start(args, format);
+-    vprintf(format, args);
+-    va_end(args);
++  res = rtems_interrupt_handler_install(irqnum,  name, flags,
++					handler, context);
++  return (res != RTEMS_SUCCESSFUL) ? -1 : 0;
+ }
+-#endif
+-- 
+1.9.1
+
diff --git a/ports/sys_arch.c b/ports/sys_arch.c
index 360a4e2..24d1133 100644
--- a/ports/sys_arch.c
+++ b/ports/sys_arch.c
@@ -24,640 +24,334 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
  * OF SUCH DAMAGE.
  *
- * This file is part of the lwIP TCP/IP stack.
+ * This file is system adaptation of the lwIP TCP/IP stack
+ * by Adam Dunkels <adam@sics.se> for RTEMS system.
  *
- * Author: Adam Dunkels <adam@sics.se>
+ * Author: Premysl Houdek <houdepre@fel.cvut.cz>
+ * Mentor: Pavel Pisa <pisa@cmp.felk.cvut.cz>
+ * Industrial Informatics Group, FEE, Czech Technical University in Prague
  *
  */
-
 /*
- * Wed Apr 17 16:05:29 EDT 2002 (James Roth)
- *
- *  - Fixed an unlikely sys_thread_new() race condition.
- *
- *  - Made current_thread() work with threads which where
- *    not created with sys_thread_new().  This includes
- *    the main thread and threads made with pthread_create().
- *
- *  - Catch overflows where more than SYS_MBOX_SIZE messages
- *    are waiting to be read.  The sys_mbox_post() routine
- *    will block until there is more room instead of just
- *    leaking messages.
+ * mapping of lwIP system dependencies to RTEMS system services and types.
+ * DETAILS: ./lwip/doc/sys_arch.txt
  */
 
-#include <string.h>
-#include <sys/time.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <pthread.h>
-
-#include "lwip/opt.h"
-#include "lwip/sys.h"
-#include "lwip/stats.h"
-#include "lwip/debug.h"
-
-#define UMAX(a, b)      ((a) > (b) ? (a) : (b))
-
-static struct timeval starttime;
-
-#if !NO_SYS
-
-static struct sys_thread *threads = NULL;
-static pthread_mutex_t threads_mutex = PTHREAD_MUTEX_INITIALIZER;
-
-struct sys_mbox_msg {
-  struct sys_mbox_msg *next;
-  void *msg;
-};
-
-#define SYS_MBOX_SIZE 128
-
-struct sys_mbox {
-  int first, last;
-  void *msgs[SYS_MBOX_SIZE];
-  struct sys_sem *not_empty;
-  struct sys_sem *not_full;
-  struct sys_sem *mutex;
-  int wait_send;
-};
-
-struct sys_sem {
-  unsigned int c;
-  pthread_cond_t cond;
-  pthread_mutex_t mutex;
-};
-
-struct sys_thread {
-  struct sys_thread *next;
-  pthread_t pthread;
-};
-
-#if SYS_LIGHTWEIGHT_PROT
-static pthread_mutex_t lwprot_mutex = PTHREAD_MUTEX_INITIALIZER;
-static pthread_t lwprot_thread = (pthread_t)0xDEAD;
-static int lwprot_count = 0;
-#endif /* SYS_LIGHTWEIGHT_PROT */
-
-static struct sys_sem *sys_sem_new_internal(u8_t count);
-static void sys_sem_free_internal(struct sys_sem *sem);
-
-static u32_t cond_wait(pthread_cond_t * cond, pthread_mutex_t * mutex,
-                       u32_t timeout);
-
-/*-----------------------------------------------------------------------------------*/
-static struct sys_thread *
-introduce_thread(pthread_t id)
-{
-  struct sys_thread *thread = NULL;
+#include <stdint.h>
+#include <arch/cc.h>
+#include <rtems/rtems/clock.h>
+#include <rtems/rtems/sem.h>
+#include <rtems.h>
+#include "sys_arch.h"
+#include "lwip/err.h"
+#include "lwip/tcpip.h"
+#include "lwipopts.h"
 
-  thread = (struct sys_thread *)malloc(sizeof(struct sys_thread));
+#define SYS_LWIP_MBOX_SIZE (sizeof(void *))
 
-  if (thread != NULL) {
-    pthread_mutex_lock(&threads_mutex);
-    thread->next = threads;
-    thread->pthread = id;
-    threads = thread;
-    pthread_mutex_unlock(&threads_mutex);
-  }
+uint32_t
+sys_now()
+{
+  uint64_t temp = rtems_clock_get_uptime_nanoseconds() / (1000 * 1000);
 
-  return thread;
+  return temp;
 }
-/*-----------------------------------------------------------------------------------*/
-sys_thread_t
-sys_thread_new(const char *name, lwip_thread_fn function, void *arg, int stacksize, int prio)
+
+void
+sys_init(void)
 {
-  int code;
-  int rc;
-  pthread_t tmp;
-  pthread_attr_t attr;
-  struct sys_thread *st = NULL;
-  LWIP_UNUSED_ARG(name);
-  LWIP_UNUSED_ARG(stacksize);
-  LWIP_UNUSED_ARG(prio);
-
-  /* Alloc a new pthread with the specified stack size. */
-  if(stacksize > 0) {
-    rc = pthread_attr_init(&attr);
-    if (rc != 0) {
-      LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: pthread_attr_init error = %d\n", rc));
-      return NULL;
-    }
-    rc = pthread_attr_setstacksize(&attr, stacksize);
-    if (rc != 0) {
-      LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: pthread_attr_setstacksize error = %d\n", rc));
-      pthread_attr_destroy(&attr);
-      return NULL;
-    }
-    pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);
-    pthread_attr_setschedpolicy(&attr, SCHED_RR);
-    code = pthread_create(&tmp, &attr, (void *(*)(void *)) function, arg);
-    pthread_attr_destroy(&attr);
-  } else {
-    code = pthread_create(&tmp, NULL, (void *(*)(void *)) function, arg);
-  }
-  LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: thread created [name:%s|stacksize:%d|prio:%d|addr:0x%x]\n",
-                          name, stacksize, prio, (uint)tmp));
+  //  Is called to initialize the sys_arch layer.
+  return;
+}
 
-  if (0 == code) {
-    st = introduce_thread(tmp);
+err_t
+sys_sem_new(sys_sem_t *sem, u8_t count)
+{
+  rtems_status_code ret = rtems_semaphore_create(
+    rtems_build_name('L', 'W', 'I', 'P'),
+    count,
+    RTEMS_COUNTING_SEMAPHORE,
+    0,
+    &sem->semaphore
+    );
+
+  if (ret != RTEMS_SUCCESSFUL) {
+    sem->semaphore = RTEMS_ID_NONE;
+    return ret;
   }
+  return ERR_OK;
+}
 
-  if (NULL == st) {
-    LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: failed to introduce %d, st = %p\n",
-                            code, (void*)st));
-    abort();
-  } else {
-    LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: introduced %d, st = %p\n",
-                            code, (void*)st));
-  }
 
-  return st;
+void
+sys_sem_free(sys_sem_t *sem)
+{
+  rtems_semaphore_delete(
+    sem->semaphore
+    );
+  sem->semaphore = RTEMS_ID_NONE;
 }
-/*-----------------------------------------------------------------------------------*/
-void sys_thread_signal(sys_thread_t thread, int signal)
+
+void
+sys_sem_signal(sys_sem_t *sem)
 {
-    /* Check received parameters. */
-    if(thread == NULL) {
-        LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_signal: could not send signal to thread. thread = NULL\n"));
-        return;
-    }
-
-    /* Send signal. */
-    pthread_kill(thread->pthread, signal);
+  rtems_semaphore_release(sem->semaphore);
 }
-/*-----------------------------------------------------------------------------------*/
-err_t
-sys_mbox_new(struct sys_mbox **mb, int size)
+
+void
+sys_sem_signal_from_ISR(sys_sem_t *sem)
 {
-  struct sys_mbox *mbox = NULL;
-  LWIP_UNUSED_ARG(size);
+  rtems_semaphore_release(sem->semaphore);
+}
 
-  mbox = (struct sys_mbox *)malloc(sizeof(struct sys_mbox));
-  if (mbox == NULL) {
-    SYS_STATS_INC(mbox.err);
-    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_new: could not create mbox\n"));
-    return ERR_MEM;
+
+u32_t
+sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout)
+{
+  rtems_status_code status;
+  rtems_interval tps = rtems_clock_get_ticks_per_second();
+  rtems_interval tick_timeout;
+  uint64_t       start_time;
+  uint64_t       wait_time;
+
+  start_time = rtems_clock_get_uptime_nanoseconds();
+  if (timeout == 0) {
+    tick_timeout = RTEMS_NO_TIMEOUT;
+  } else {
+    tick_timeout = (timeout * tps + 999) / 1000;
   }
-  mbox->first = mbox->last = 0;
-  mbox->not_empty = sys_sem_new_internal(0);
-  mbox->not_full = sys_sem_new_internal(0);
-  mbox->mutex = sys_sem_new_internal(1);
-  mbox->wait_send = 0;
-
-  SYS_STATS_INC_USED(mbox);
-
-  if((mbox->not_empty == NULL) || (mbox->not_full == NULL) || (mbox->mutex == NULL)) {
-    SYS_STATS_INC(mbox.err);
-    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_new: could not create mbox internals\n"));
-    sys_mbox_free(&mbox);
-    return ERR_MEM;
+  status = rtems_semaphore_obtain(sem->semaphore, RTEMS_WAIT, tick_timeout);
+  if (status == RTEMS_TIMEOUT) {
+    return SYS_ARCH_TIMEOUT;
   }
-  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_new: mbox created [not_empty:%X|not_full:%X|mutex:%X] \n",
-                          mbox->not_empty, mbox->not_full, mbox->mutex));
+  if (status != RTEMS_SUCCESSFUL) {
+    return SYS_ARCH_TIMEOUT;
+  }
+  wait_time = rtems_clock_get_uptime_nanoseconds() - start_time;
+  return wait_time / (1000 * 1000);
+}
 
-  *mb = mbox;
-  return ERR_OK;
+int
+sys_sem_valid(sys_sem_t *sem)
+{
+  return sem->semaphore == RTEMS_ID_NONE ? 0 : 1;
 }
-/*-----------------------------------------------------------------------------------*/
+
 void
-sys_mbox_free(struct sys_mbox **mb)
+sys_sem_set_invalid(sys_sem_t *sem)
 {
-  if ((mb != NULL) && (*mb != SYS_MBOX_NULL)) {
-    struct sys_mbox *mbox = *mb;
-    sys_arch_sem_wait(&mbox->mutex, 0);
-
-    sys_sem_free_internal(mbox->not_empty);
-    sys_sem_free_internal(mbox->not_full);
-    sys_sem_free_internal(mbox->mutex);
-    mbox->not_empty = mbox->not_full = mbox->mutex = NULL;
-    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_free: mbox 0x%lx\n", mbox));
-    free(mbox);
-    SYS_STATS_DEC(mbox.used);
-  }
+  sem->semaphore = RTEMS_ID_NONE;
 }
-/*-----------------------------------------------------------------------------------*/
+
 err_t
-sys_mbox_trypost(struct sys_mbox **mb, void *msg)
+sys_mbox_new(sys_mbox_t *mbox, int size)
 {
-  u8_t first;
-  struct sys_mbox *mbox;
-  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
-  mbox = *mb;
-  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_trypost: start"));
-  sys_arch_sem_wait(&mbox->mutex, 0);
-
-  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_trypost: mbox %p msg %p\n",
-                          (void *)mbox, (void *)msg));
-
-  if ((mbox->last + 1) >= (mbox->first + SYS_MBOX_SIZE)) {
-    sys_sem_signal(&mbox->mutex);
-    return ERR_MEM;
-  }
-
-  mbox->msgs[mbox->last % SYS_MBOX_SIZE] = msg;
-
-  if (mbox->last == mbox->first) {
-    first = 1;
-  } else {
-    first = 0;
-  }
-
-  mbox->last++;
-
-  if (first) {
-    sys_sem_signal(&mbox->not_empty);
+  rtems_status_code ret;
+
+  ret = rtems_message_queue_create(
+    rtems_build_name('L', 'W', 'I', 'P'),
+    size,
+    SYS_LWIP_MBOX_SIZE,
+    0,
+    &mbox->mailbox
+    );
+  ret |= rtems_semaphore_create(
+    rtems_build_name('L', 'W', 'I', 'P'),
+    size,
+    RTEMS_COUNTING_SEMAPHORE,
+    0,
+    &mbox->sem
+    );
+  if (ret != RTEMS_SUCCESSFUL) {
+    mbox->mailbox = RTEMS_ID_NONE;
+    mbox->sem = RTEMS_ID_NONE;
+    return ret;
   }
-
-  sys_sem_signal(&mbox->mutex);
-
   return ERR_OK;
 }
-/*-----------------------------------------------------------------------------------*/
+
 void
-sys_mbox_post(struct sys_mbox **mb, void *msg)
+sys_mbox_free(sys_mbox_t *mbox)
 {
-  u8_t first;
-  struct sys_mbox *mbox;
-  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
-  mbox = *mb;
-
-  sys_arch_sem_wait(&mbox->mutex, 0);
-
-  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_post: mbox %p msg %p\n", (void *)mbox, (void *)msg));
-
-  while ((mbox->last + 1) >= (mbox->first + SYS_MBOX_SIZE)) {
-    mbox->wait_send++;
-    sys_sem_signal(&mbox->mutex);
-    sys_arch_sem_wait(&mbox->not_full, 0);
-    sys_arch_sem_wait(&mbox->mutex, 0);
-    mbox->wait_send--;
-  }
+  rtems_message_queue_delete(mbox->mailbox);
+  rtems_semaphore_delete(mbox->sem);
+  sys_mbox_set_invalid(mbox);
+}
 
-  mbox->msgs[mbox->last % SYS_MBOX_SIZE] = msg;
+void
+sys_mbox_post(sys_mbox_t *mbox, void *msg)
+{
+  rtems_semaphore_obtain(mbox->sem, RTEMS_WAIT, RTEMS_NO_TIMEOUT);
+  rtems_message_queue_send(mbox->mailbox, &msg, SYS_LWIP_MBOX_SIZE);
+}
+err_t
+sys_mbox_trypost(sys_mbox_t *mbox, void *msg)
+{
+  rtems_status_code status = rtems_semaphore_obtain(mbox->sem,
+						    RTEMS_NO_WAIT, 0);
 
-  if (mbox->last == mbox->first) {
-    first = 1;
+  if (status != RTEMS_SUCCESSFUL) {
+    return ERR_MEM;
   } else {
-    first = 0;
+    rtems_message_queue_send(mbox->mailbox, &msg, SYS_LWIP_MBOX_SIZE);
+    return ERR_OK;
   }
-
-  mbox->last++;
-
-  if (first) {
-    sys_sem_signal(&mbox->not_empty);
-  }
-
-  sys_sem_signal(&mbox->mutex);
 }
-/*-----------------------------------------------------------------------------------*/
+
 u32_t
-sys_arch_mbox_tryfetch(struct sys_mbox **mb, void **msg)
+sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeout)
 {
-  struct sys_mbox *mbox;
-  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
-  mbox = *mb;
-
-  sys_arch_sem_wait(&mbox->mutex, 0);
-
-  if (mbox->first == mbox->last) {
-    sys_sem_signal(&mbox->mutex);
-    return SYS_MBOX_EMPTY;
-  }
-
-  if (msg != NULL) {
-    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_tryfetch: mbox %p msg %p\n", (void *)mbox, *msg));
-    *msg = mbox->msgs[mbox->first % SYS_MBOX_SIZE];
+  rtems_status_code status;
+  rtems_interval tps = rtems_clock_get_ticks_per_second();
+  rtems_interval tick_timeout;
+  uint64_t       start_time;
+  uint64_t       wait_time;
+  size_t         dummy;
+
+  start_time = rtems_clock_get_uptime_nanoseconds();
+  if (timeout == 0) {
+    tick_timeout = RTEMS_NO_TIMEOUT;
+  } else {
+    tick_timeout = (timeout * tps + 999) / 1000;
   }
-  else{
-    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_tryfetch: mbox %p, null msg\n", (void *)mbox));
+  status = rtems_message_queue_receive(mbox->mailbox,
+				       msg,
+				       &dummy,
+				       RTEMS_WAIT,
+				       tick_timeout
+				       );
+  if (status == RTEMS_TIMEOUT) {
+    return SYS_ARCH_TIMEOUT;
   }
-
-  mbox->first++;
-
-  if (mbox->wait_send) {
-    sys_sem_signal(&mbox->not_full);
+  if (status != RTEMS_SUCCESSFUL) {
+    return SYS_ARCH_TIMEOUT;
   }
-
-  sys_sem_signal(&mbox->mutex);
-
-  return 0;
+  wait_time = rtems_clock_get_uptime_nanoseconds() - start_time;
+  rtems_semaphore_release(mbox->sem);
+  return wait_time / (1000 * 1000);
 }
-/*-----------------------------------------------------------------------------------*/
+
 u32_t
-sys_arch_mbox_fetch(struct sys_mbox **mb, void **msg, u32_t timeout)
+sys_arch_mbox_tryfetch(sys_mbox_t *mbox, void **msg)
 {
-  u32_t time_needed = 0;
-  struct sys_mbox *mbox;
-  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
-  mbox = *mb;
-
-  /* The mutex lock is quick so we don't bother with the timeout
-     stuff here. */
-  sys_arch_sem_wait(&mbox->mutex, 0);
-
-  while (mbox->first == mbox->last) {
-    sys_sem_signal(&mbox->mutex);
-
-    /* We block while waiting for a mail to arrive in the mailbox. We
-       must be prepared to timeout. */
-    if (timeout != 0) {
-      time_needed = sys_arch_sem_wait(&mbox->not_empty, timeout);
-
-      if (time_needed == SYS_ARCH_TIMEOUT) {
-        return SYS_ARCH_TIMEOUT;
-      }
-    } else {
-      sys_arch_sem_wait(&mbox->not_empty, 0);
-    }
-
-    sys_arch_sem_wait(&mbox->mutex, 0);
-  }
+  rtems_status_code status;
+  size_t         dummy;
 
-  if (msg != NULL) {
-    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_fetch: mbox %p msg %p\n", (void *)mbox, *msg));
-    *msg = mbox->msgs[mbox->first % SYS_MBOX_SIZE];
-  }
-  else{
-    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_fetch: mbox %p, null msg\n", (void *)mbox));
-  }
-
-  mbox->first++;
-
-  if (mbox->wait_send) {
-    sys_sem_signal(&mbox->not_full);
-  }
-
-  sys_sem_signal(&mbox->mutex);
+  status = rtems_message_queue_receive(mbox->mailbox, msg,
+				       &dummy,
+				       RTEMS_NO_WAIT,
+				       0
+				       );
 
-  return time_needed;
-}
-/*-----------------------------------------------------------------------------------*/
-static struct sys_sem *
-sys_sem_new_internal(u8_t count)
-{
-  struct sys_sem *sem = NULL;
-  int rc;
-
-  sem = (struct sys_sem *)malloc(sizeof(struct sys_sem));
-  if (sem != NULL) {
-    sem->c = count;
-    rc = pthread_cond_init(&(sem->cond), NULL);
-    if(rc != 0) {
-      LWIP_DEBUGF(SYS_DEBUG, ("sys_sem_new_internal: pthread_cond_init error = %d\n", rc));
-      return NULL;
-    }
-    rc = pthread_mutex_init(&(sem->mutex), NULL);
-    if(rc != 0) {
-      LWIP_DEBUGF(SYS_DEBUG, ("sys_sem_new_internal: pthread_mutex_init error = %d\n", rc));
-      SYS_STATS_INC(mutex.err);
-      pthread_cond_destroy(&(sem->cond));
-      return NULL;
-    }
-    SYS_STATS_INC_USED(mutex);
-    SYS_STATS_INC_USED(sem);
+  if (status != RTEMS_SUCCESSFUL) {
+    return SYS_MBOX_EMPTY;
   } else {
-    LWIP_DEBUGF(SYS_DEBUG, ("sys_sem_new_internal: could not create semaphore\n"));
-    SYS_STATS_INC(sem.err);
+    rtems_semaphore_release(mbox->sem);
+    return 0;
   }
-  return sem;
 }
-/*-----------------------------------------------------------------------------------*/
-err_t
-sys_sem_new(struct sys_sem **sem, u8_t count)
+int
+sys_mbox_valid(sys_mbox_t *mbox)
 {
-  *sem = sys_sem_new_internal(count);
-  if (*sem == NULL) {
-    return ERR_MEM;
-  }
-  return ERR_OK;
+  return mbox->mailbox == RTEMS_ID_NONE ? 0 : 1;
 }
-/*-----------------------------------------------------------------------------------*/
-static u32_t
-cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex, u32_t timeout)
+void
+sys_mbox_set_invalid(sys_mbox_t *mbox)
 {
-  time_t tdiff;
-  time_t sec, usec;
-  struct timeval rtime1, rtime2;
-  struct timespec ts;
-  int retval;
-
-  if (timeout > 0) {
-    /* Get a timestamp and add the timeout value. */
-    gettimeofday(&rtime1, NULL);
-    sec = rtime1.tv_sec;
-    usec = rtime1.tv_usec;
-    usec += timeout % 1000 * 1000;
-    sec += (int)(timeout / 1000) + (int)(usec / 1000000);
-    usec = usec % 1000000;
-    ts.tv_nsec = usec * 1000;
-    ts.tv_sec = sec;
-
-    retval = pthread_cond_timedwait(cond, mutex, &ts);
-
-    if (retval == ETIMEDOUT) {
-      return SYS_ARCH_TIMEOUT;
-    } else {
-      /* Calculate for how long we waited for the cond. */
-      gettimeofday(&rtime2, NULL);
-      tdiff = (rtime2.tv_sec - rtime1.tv_sec) * 1000 +
-        (rtime2.tv_usec - rtime1.tv_usec) / 1000;
-
-      if (tdiff <= 0) {
-        return 0;
-      }
-      return (u32_t)tdiff;
-    }
-  } else {
-    pthread_cond_wait(cond, mutex);
-    return 0;
-  }
+  mbox->sem = RTEMS_ID_NONE;
+  mbox->mailbox = RTEMS_ID_NONE;
 }
-/*-----------------------------------------------------------------------------------*/
-u32_t
-sys_arch_sem_wait(struct sys_sem **s, u32_t timeout)
+
+sys_thread_t
+sys_thread_new(const char *name, lwip_thread_fn function, void *arg, int stack_size, int prio)
 {
-  u32_t time_needed = 0;
-  struct sys_sem *sem;
-  LWIP_ASSERT("invalid sem", (s != NULL) && (*s != NULL));
-  sem = *s;
-
-  pthread_mutex_lock(&(sem->mutex));
-  while (sem->c <= 0) {
-    if (timeout > 0) {
-      time_needed = cond_wait(&(sem->cond), &(sem->mutex), timeout);
-
-      if (time_needed == SYS_ARCH_TIMEOUT) {
-        pthread_mutex_unlock(&(sem->mutex));
-        return SYS_ARCH_TIMEOUT;
-      }
-    } else {
-      cond_wait(&(sem->cond), &(sem->mutex), 0);
-    }
+  rtems_id id;
+  rtems_status_code res;
+
+  res = rtems_task_create(
+    rtems_build_name('L', 'W', 'I', 'P'),
+    prio,
+    stack_size,
+    RTEMS_PREEMPT,
+    0,
+    &id
+    );
+
+  if (res != RTEMS_SUCCESSFUL) {
+    return 0;
   }
-  sem->c--;
-  pthread_mutex_unlock(&(sem->mutex));
-  return (u32_t)time_needed;
-}
-/*-----------------------------------------------------------------------------------*/
-void
-sys_sem_signal(struct sys_sem **s)
-{
-  struct sys_sem *sem;
-  LWIP_ASSERT("invalid sem", (s != NULL) && (*s != NULL));
-  sem = *s;
 
-  pthread_mutex_lock(&(sem->mutex));
-  sem->c++;
+  res = rtems_task_start(id, (rtems_task_entry)function, (rtems_task_argument)arg);
 
-  if (sem->c > 1) {
-    sem->c = 1;
+  if (res != RTEMS_SUCCESSFUL) {
+    rtems_task_delete(id);
+    return 0;
   }
-
-  pthread_cond_broadcast(&(sem->cond));
-  pthread_mutex_unlock(&(sem->mutex));
+  return id;
 }
-/*-----------------------------------------------------------------------------------*/
-static void
-sys_sem_free_internal(struct sys_sem *sem)
+
+err_t
+sys_mutex_new(sys_mutex_t *mutex)
 {
-  if(sem != NULL) {
-    pthread_cond_destroy(&(sem->cond));
-    pthread_mutex_destroy(&(sem->mutex));
-    SYS_STATS_DEC(mutex.used);
-    SYS_STATS_DEC(sem.used);
-    free(sem);
+  rtems_status_code ret = rtems_semaphore_create(
+    rtems_build_name('L', 'W', 'I', 'P'),
+    1,
+    RTEMS_PRIORITY|RTEMS_BINARY_SEMAPHORE|RTEMS_INHERIT_PRIORITY|RTEMS_LOCAL,
+    0,
+    &mutex->mutex
+    );
+
+  if (ret != RTEMS_SUCCESSFUL) {
+    mutex->mutex = RTEMS_ID_NONE;
+    return ret;
   }
+  return ERR_OK;
 }
-/*-----------------------------------------------------------------------------------*/
+/** Lock a mutex
+ * @param mutex the mutex to lock */
 void
-sys_sem_free(struct sys_sem **sem)
+sys_mutex_lock(sys_mutex_t *mutex)
 {
-  if ((sem != NULL) && (*sem != SYS_SEM_NULL)) {
-    sys_sem_free_internal(*sem);
-  }
+  rtems_semaphore_obtain(mutex->mutex, RTEMS_WAIT, RTEMS_NO_TIMEOUT);
 }
-#endif /* !NO_SYS */
-/*-----------------------------------------------------------------------------------*/
-u32_t
-sys_now(void)
-{
-  struct timeval tv;
-  u32_t sec, usec, msec;
-  gettimeofday(&tv, NULL);
-
-  sec = (u32_t)(tv.tv_sec - starttime.tv_sec);
-  usec = (u32_t)(tv.tv_usec - starttime.tv_usec);
-  msec = sec * 1000 + usec / 1000;
-
-  return msec;
-}
-/*-----------------------------------------------------------------------------------*/
+/** Unlock a mutex
+ * @param mutex the mutex to unlock */
 void
-sys_init(void)
-{
-  SYS_STATS_INC_USED(mutex);
-  gettimeofday(&starttime, NULL);
-}
-/*-----------------------------------------------------------------------------------*/
-#if SYS_LIGHTWEIGHT_PROT
-/** sys_prot_t sys_arch_protect(void)
-
-This optional function does a "fast" critical region protection and returns
-the previous protection level. This function is only called during very short
-critical regions. An embedded system which supports ISR-based drivers might
-want to implement this function by disabling interrupts. Task-based systems
-might want to implement this by using a mutex or disabling tasking. This
-function should support recursive calls from the same task or interrupt. In
-other words, sys_arch_protect() could be called while already protected. In
-that case the return value indicates that it is already protected.
-
-sys_arch_protect() is only required if your port is supporting an operating
-system.
-*/
-sys_prot_t
-sys_arch_protect(void)
+sys_mutex_unlock(sys_mutex_t *mutex)
 {
-    /* Note that for the UNIX port, we are using a lightweight mutex, and our
-     * own counter (which is locked by the mutex). The return code is not actually
-     * used. */
-    if (lwprot_thread != pthread_self())
-    {
-        /* We are locking the mutex where it has not been locked before *
-        * or is being locked by another thread */
-        pthread_mutex_lock(&lwprot_mutex);
-        lwprot_thread = pthread_self();
-        lwprot_count = 1;
-    }
-    else
-    {
-        /* It is already locked by THIS thread */
-        lwprot_count++;
-    }
-    return 0;
+  rtems_semaphore_release(mutex->mutex);
 }
-/*-----------------------------------------------------------------------------------*/
-/** void sys_arch_unprotect(sys_prot_t pval)
-
-This optional function does a "fast" set of critical region protection to the
-value specified by pval. See the documentation for sys_arch_protect() for
-more information. This function is only required if your port is supporting
-an operating system.
-*/
+/** Delete a semaphore
+ * @param mutex the mutex to delete */
 void
-sys_arch_unprotect(sys_prot_t pval)
+sys_mutex_free(sys_mutex_t *mutex)
 {
-    LWIP_UNUSED_ARG(pval);
-    if (lwprot_thread == pthread_self())
-    {
-        if (--lwprot_count == 0)
-        {
-            lwprot_thread = (pthread_t) 0xDEAD;
-            pthread_mutex_unlock(&lwprot_mutex);
-        }
-    }
+  rtems_semaphore_delete(mutex->mutex);
 }
-#endif /* SYS_LIGHTWEIGHT_PROT */
 
-/*-----------------------------------------------------------------------------------*/
-
-#ifndef MAX_JIFFY_OFFSET
-#define MAX_JIFFY_OFFSET ((~0U >> 1)-1)
-#endif
+void
+sys_arch_delay(unsigned int timeout)
+{
+  rtems_interval tps = rtems_clock_get_ticks_per_second();
+  rtems_interval tick_timeout = (timeout * tps + 999) / 1000;
 
-#ifndef HZ
-#define HZ 100
-#endif
+  rtems_task_wake_after(tick_timeout);
+}
 
-u32_t
+/** Ticks/jiffies since power up. */
+uint32_t
 sys_jiffies(void)
 {
-    struct timeval tv;
-    unsigned long sec;
-    long usec;
-
-    gettimeofday(&tv,NULL);
-    sec = tv.tv_sec - starttime.tv_sec;
-    usec = tv.tv_usec;
-
-    if (sec >= (MAX_JIFFY_OFFSET / HZ))
-      return MAX_JIFFY_OFFSET;
-    usec += 1000000L / HZ - 1;
-    usec /= 1000000L / HZ;
-    return HZ * sec + usec;
+  return rtems_clock_get_ticks_since_boot();
 }
 
-#if PPP_DEBUG
-
-#include <stdarg.h>
-
-void ppp_trace(int level, const char *format, ...)
+int
+sys_request_irq(unsigned int irqnum, sys_irq_handler_t handler,
+		unsigned long flags, const char *name, void *context)
 {
-    va_list args;
+  rtems_status_code res;
 
-    (void)level;
-    va_start(args, format);
-    vprintf(format, args);
-    va_end(args);
+  res = rtems_interrupt_handler_install(irqnum,  name, flags,
+					handler, context);
+  return (res != RTEMS_SUCCESSFUL) ? -1 : 0;
 }
-#endif
diff --git a/rtems.patch b/rtems.patch
deleted file mode 100644
index 1d3b090..0000000
--- a/rtems.patch
+++ /dev/null
@@ -1,7917 +0,0 @@
-From 2d83d4994e578ec339b2b1baef53090bf7a53570 Mon Sep 17 00:00:00 2001
-From: Jay Doyle <jay.doyle@vecna.com>
-Date: Fri, 4 Sep 2015 17:28:55 -0400
-Subject: [PATCH 01/10] rtems changes necessary
-
----
- Makefile                      | 170 +++++++++++
- ports/include/arch/cc.h       | 123 ++++++++
- ports/include/arch/perf.h     |  38 +++
- ports/include/arch/sys_arch.h |  59 ++++
- ports/include/lwipopts.h      | 178 ++++++++++++
- ports/sys_arch.c              | 663 ++++++++++++++++++++++++++++++++++++++++++
- 6 files changed, 1231 insertions(+)
- create mode 100644 Makefile
- create mode 100644 ports/include/arch/cc.h
- create mode 100644 ports/include/arch/perf.h
- create mode 100644 ports/include/arch/sys_arch.h
- create mode 100644 ports/include/lwipopts.h
- create mode 100644 ports/sys_arch.c
-
-diff --git a/Makefile b/Makefile
-new file mode 100644
-index 0000000..0cbae64
---- /dev/null
-+++ b/Makefile
-@@ -0,0 +1,170 @@
-+include $(RTEMS_MAKEFILE_PATH)/Makefile.inc
-+include $(RTEMS_CUSTOM)
-+include $(PROJECT_ROOT)/make/leaf.cfg
-+
-+#### CONFIG ####################################################################
-+#For debugging symbols add -DLWIP_DEBUG
-+# COMPILER/LINKER
-+CFLAGS+=-g -O2   \
-+ -Wall
-+
-+# OUTPUT
-+LWIP_EXEC=lwip
-+
-+#### PATHS #####################################################################
-+
-+# LWIP
-+LWIP_PATH=.
-+LWIP_SRC_PATH=$(LWIP_PATH)/src
-+LWIP_API_PATH=$(LWIP_SRC_PATH)/api
-+LWIP_CORE_PATH=$(LWIP_SRC_PATH)/core
-+LWIP_INCL_PATH=$(LWIP_SRC_PATH)/include
-+LWIP_NETIF_PATH=$(LWIP_SRC_PATH)/netif
-+
-+# ARCH
-+LWIPARCH_PATH=$(LWIP_PATH)/ports
-+LWIPARCH_SRC_PATH=$(LWIPARCH_PATH)
-+LWIPARCH_INCL_PATH=$(LWIPARCH_PATH)/include
-+
-+# DRIVER
-+LWIPDRIVER_PATH=$(LWIP_PATH)/ports
-+LWIPDRIVER_SRC_PATH=$(LWIPDRIVER_PATH)/netif
-+LWIPDRIVER_INCL_PATH=$(LWIPDRIVER_PATH)/include/netif
-+
-+#### SOURCES ###################################################################
-+
-+## CORE
-+CORE_SRC=$(wildcard $(LWIP_CORE_PATH)/*.c)
-+
-+## IPv4
-+IPV4_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv4/*.c)
-+
-+## IPv6
-+IPV6_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv6/*.c)
-+
-+## SNMP
-+SNMP_SRC=$(wildcard $(LWIP_CORE_PATH)/snmp/*.c)
-+
-+## API
-+API_SRC=$(wildcard $(LWIP_API_PATH)/*.c )
-+
-+## NETIF
-+NETIF_SRC=$(wildcard $(LWIP_NETIF_PATH)/*.c) \
-+          $(wildcard $(LWIP_NETIF_PATH)/ppp/*.c) \
-+          $(wildcard $(LWIP_NETIF_PATH)/ppp/polarssl/*.c)
-+
-+
-+ARCH_SRC=$(wildcard $(LWIPARCH_SRC_PATH)/*.c)
-+
-+# DRIVER
-+DRIVER_SRC=$(wildcard $(LWIPDRIVER_SRC_PATH)/*.c ) \
-+           $(wildcard $(LWIPDRIVER_SRC_PATH)/*.S )
-+
-+
-+SOURCES =  $(DRIVER_SRC) $(SNMP_SRC)\
-+           $(CORE_SRC) $(IPV4_SRC) $(API_SRC) $(NETIF_SRC) $(ARCH_SRC)
-+
-+
-+#### HEADERS ###################################################################
-+
-+## CORE
-+CORE_H=$(LWIP_INCL_PATH)
-+
-+## IPv4
-+#IPV4_H=$(LWIP_INCL_PATH)/ipv4
-+
-+## IPv6
-+#IPV6_H=$(LWIP_INCL_PATH)/ipv6
-+
-+## POSIX
-+POSIX_H=$(LWIP_INCL_PATH)/posix
-+
-+##POSIX_SYS
-+POSIX_SYS_H=$(LWIP_INCL_PATH)/posix/sys
-+
-+
-+## NETIF
-+NETIF_H=$(LWIP_INCL_PATH)/netif
-+NETIF_H_PPP=$(LWIP_INCL_PATH)/netif/ppp
-+NETIF_H_PPP_POLARSSL=$(LWIP_INCL_PATH)/netif/ppp/polarssl
-+
-+## ARCH
-+ARCH_H=$(LWIPARCH_INCL_PATH)
-+
-+## DRIVER
-+DRIVER_H=$(LWIPDRIVER_INCL_PATH)
-+
-+# HEADERS
-+HEADERS=-I$(CORE_H) -I$(POSIX_H) -I$(POSIX_SYS_H) -I$(NETIF_H) \
-+        -I$(NETIF_H_PPP) -I$(NETIF_H_PPP_POLARSSL) -I$(ARCH_H) \
-+        -I$(DRIVER_H)
-+
-+
-+################################################################################
-+
-+
-+BIN=${ARCH}/$(LWIP_EXEC).bin
-+LIB=${ARCH}/lib$(LWIP_EXEC).a
-+
-+# optional managers required
-+MANAGERS=all
-+
-+# C source names
-+CSRCS=$(filter %.c ,$(SOURCES))
-+COBJS=$(patsubst %.c,${ARCH}/%.o,$(notdir $(CSRCS)))
-+
-+ASMSRCS=$(filter %.S , $(SOURCES))
-+ASMOBJS=$(patsubst %.S,${ARCH}/%.o,$(notdir $(ASMSRCS)))
-+
-+OBJS=$(COBJS) $(ASMOBJS)
-+
-+all:${ARCH} $(LIB)
-+
-+$(LIB): $(OBJS)
-+	$(AR)  rcs  $@ $^
-+
-+${ARCH}/%.o: $(LWIP_CORE_PATH)/%.c
-+	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
-+
-+${ARCH}/%.o: $(LWIP_CORE_PATH)/ipv4/%.c
-+	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
-+
-+${ARCH}/%.o: $(LWIP_CORE_PATH)/ipv6/%.c
-+	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
-+
-+${ARCH}/%.o: $(LWIP_CORE_PATH)/snmp/%.c
-+	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
-+
-+${ARCH}/%.o: $(LWIP_API_PATH)/%.c
-+	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
-+
-+${ARCH}/%.o: $(LWIP_NETIF_PATH)/%.c
-+	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
-+
-+${ARCH}/%.o: $(LWIP_NETIF_PATH)/ppp/%.c
-+	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
-+
-+${ARCH}/%.o: $(LWIP_NETIF_PATH)/ppp/polarssl/%.c
-+	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
-+
-+${ARCH}/%.o: $(LWIPARCH_SRC_PATH)/%.c
-+	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
-+
-+${ARCH}/%.o: $(LWIPDRIVER_SRC_PATH)/%.S
-+	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
-+
-+${ARCH}/%.o: $(LWIPDRIVER_SRC_PATH)/%.c
-+	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
-+
-+INSTALL_DIR=$(RTEMS_MAKEFILE_PATH)/lwip
-+
-+install:
-+	rm -rf $(INSTALL_DIR)
-+	mkdir -p $(INSTALL_DIR)/include
-+	mkdir -p $(INSTALL_DIR)/lib
-+	cp $(LIB) $(INSTALL_DIR)/lib
-+	cp -r $(CORE_H) $(INSTALL_DIR)
-+	cp $(LWIPARCH_INCL_PATH)/lwipopts.h $(INSTALL_DIR)/include
-+	cp -r $(LWIPARCH_INCL_PATH)/arch $(INSTALL_DIR)/include
-+
-+CPPFLAGS+=$(HEADERS)
-diff --git a/ports/include/arch/cc.h b/ports/include/arch/cc.h
-new file mode 100644
-index 0000000..04ec89f
---- /dev/null
-+++ b/ports/include/arch/cc.h
-@@ -0,0 +1,123 @@
-+/*
-+ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
-+ * All rights reserved.
-+ *
-+ * Redistribution and use in source and binary forms, with or without modification,
-+ * are permitted provided that the following conditions are met:
-+ *
-+ * 1. Redistributions of source code must retain the above copyright notice,
-+ *    this list of conditions and the following disclaimer.
-+ * 2. Redistributions in binary form must reproduce the above copyright notice,
-+ *    this list of conditions and the following disclaimer in the documentation
-+ *    and/or other materials provided with the distribution.
-+ * 3. The name of the author may not be used to endorse or promote products
-+ *    derived from this software without specific prior written permission.
-+ *
-+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
-+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
-+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
-+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
-+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
-+ * OF SUCH DAMAGE.
-+ *
-+ * This file is part of the lwIP TCP/IP stack.
-+ *
-+ * Author: Adam Dunkels <adam@sics.se>
-+ *
-+ */
-+#ifndef __CC_H__
-+#define __CC_H__
-+
-+typedef unsigned    char    u8_t;
-+typedef signed      char    s8_t;
-+typedef unsigned    short   u16_t;
-+typedef signed      short   s16_t;
-+typedef unsigned    int    u32_t;
-+typedef signed      int    s32_t;
-+typedef u32_t           mem_ptr_t;
-+
-+#ifndef BYTE_ORDER
-+#define BYTE_ORDER LITTLE_ENDIAN
-+#endif
-+
-+#if defined(__arm__) && defined(__ARMCC_VERSION)
-+    //
-+    // Setup PACKing macros for KEIL/RVMDK Tools
-+    //
-+    #define PACK_STRUCT_BEGIN __packed
-+    #define PACK_STRUCT_STRUCT
-+    #define PACK_STRUCT_END
-+    #define PACK_STRUCT_FIELD(x) x
-+#elif defined (__IAR_SYSTEMS_ICC__)
-+    //
-+    // Setup PACKing macros for IAR Tools
-+    //
-+    #define PACK_STRUCT_BEGIN
-+    #define PACK_STRUCT_STRUCT
-+    #define PACK_STRUCT_END
-+    #define PACK_STRUCT_FIELD(x) x
-+    #define PACK_STRUCT_USE_INCLUDES
-+#elif defined (__TMS470__)
-+    #define PACK_STRUCT_BEGIN
-+    #define PACK_STRUCT_STRUCT
-+    #define PACK_STRUCT_END
-+    #define PACK_STRUCT_FIELD(x) x
-+#else
-+    //
-+    // Setup PACKing macros for GCC Tools
-+    //
-+    #define PACK_STRUCT_BEGIN
-+    #define PACK_STRUCT_STRUCT __attribute__ ((__packed__))
-+    #define PACK_STRUCT_END
-+    #define PACK_STRUCT_FIELD(x) x
-+#endif
-+
-+#ifdef LWIP_CACHE_ENABLED
-+/**
-+ * Make the PBUF POOL cacheline aligned.
-+ */
-+#ifdef __IAR_SYSTEMS_ICC__
-+#pragma data_alignment=SOC_CACHELINE_SIZE_BYTES
-+extern u8_t memp_memory_PBUF_POOL_base[];
-+#else /*By default, GCC */
-+extern u8_t memp_memory_PBUF_POOL_base[] __attribute__ ((aligned (SOC_CACHELINE_SIZE_BYTES)));
-+#endif
-+#endif
-+
-+extern u8_t memp_memory_PBUF_POOL_base[] __attribute__ ((aligned (SOC_CACHELINE_SIZE_BYTES)));
-+
-+/* Define (sn)printf formatters for these lwIP types */
-+#define X8_F  "02x"
-+#define U16_F "u"
-+#define S16_F "d"
-+#define X16_F "x"
-+#define U32_F "u"
-+#define S32_F "d"
-+#define X32_F "x"
-+
-+#include <stdio.h>
-+#include <stdlib.h>
-+#include <bsp.h>
-+#define LWIP_PLATFORM_DIAG(x)   do { \
-+        printk("[%s - %s - %d] ", __PRETTY_FUNCTION__, __FILE__, __LINE__); \
-+        printk x; \
-+    } while(0)
-+
-+#ifdef LWIP_DEBUG  //DEBUG
-+extern void __error__(char *pcFilename, unsigned long ulLine);
-+#define LWIP_PLATFORM_ASSERT(expr)   printk("[%s - %s - %d] ", expr , __FILE__, __LINE__);
-+//{
-+    //if(!(expr))
-+    //{
-+        //__error__(__FILE__, __LINE__);
-+    //}
-+//}
-+#else
-+#define LWIP_PLATFORM_ASSERT(expr)
-+#endif
-+
-+#endif /* __CC_H__ */
-diff --git a/ports/include/arch/perf.h b/ports/include/arch/perf.h
-new file mode 100644
-index 0000000..d754157
---- /dev/null
-+++ b/ports/include/arch/perf.h
-@@ -0,0 +1,38 @@
-+/*
-+ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
-+ * All rights reserved.
-+ *
-+ * Redistribution and use in source and binary forms, with or without modification,
-+ * are permitted provided that the following conditions are met:
-+ *
-+ * 1. Redistributions of source code must retain the above copyright notice,
-+ *    this list of conditions and the following disclaimer.
-+ * 2. Redistributions in binary form must reproduce the above copyright notice,
-+ *    this list of conditions and the following disclaimer in the documentation
-+ *    and/or other materials provided with the distribution.
-+ * 3. The name of the author may not be used to endorse or promote products
-+ *    derived from this software without specific prior written permission.
-+ *
-+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
-+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
-+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
-+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
-+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
-+ * OF SUCH DAMAGE.
-+ *
-+ * This file is part of the lwIP TCP/IP stack.
-+ *
-+ * Author: Adam Dunkels <adam@sics.se>
-+ *
-+ */
-+#ifndef __PERF_H__
-+#define __PERF_H__
-+
-+#define PERF_START    /* null definition */
-+#define PERF_STOP(x)  /* null definition */
-+
-+#endif /* __PERF_H__ */
-diff --git a/ports/include/arch/sys_arch.h b/ports/include/arch/sys_arch.h
-new file mode 100644
-index 0000000..32f0d99
---- /dev/null
-+++ b/ports/include/arch/sys_arch.h
-@@ -0,0 +1,59 @@
-+/*
-+ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
-+ * All rights reserved.
-+ *
-+ * Redistribution and use in source and binary forms, with or without modification,
-+ * are permitted provided that the following conditions are met:
-+ *
-+ * 1. Redistributions of source code must retain the above copyright notice,
-+ *    this list of conditions and the following disclaimer.
-+ * 2. Redistributions in binary form must reproduce the above copyright notice,
-+ *    this list of conditions and the following disclaimer in the documentation
-+ *    and/or other materials provided with the distribution.
-+ * 3. The name of the author may not be used to endorse or promote products
-+ *    derived from this software without specific prior written permission.
-+ *
-+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
-+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
-+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
-+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
-+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
-+ * OF SUCH DAMAGE.
-+ *
-+ * This file is part of the lwIP TCP/IP stack.
-+ *
-+ * Author: Adam Dunkels <adam@sics.se>
-+ *
-+ */
-+#ifndef LWIP_ARCH_SYS_ARCH_H
-+#define LWIP_ARCH_SYS_ARCH_H
-+
-+#include <errno.h>
-+
-+#define SYS_MBOX_NULL NULL
-+#define SYS_SEM_NULL  NULL
-+
-+typedef u32_t sys_prot_t;
-+
-+struct sys_sem;
-+typedef struct sys_sem * sys_sem_t;
-+#define sys_sem_valid(sem) (((sem) != NULL) && (*(sem) != NULL))
-+#define sys_sem_set_invalid(sem) do { if((sem) != NULL) { *(sem) = NULL; }}while(0)
-+
-+/* let sys.h use binary semaphores for mutexes */
-+#define LWIP_COMPAT_MUTEX 1
-+
-+struct sys_mbox;
-+typedef struct sys_mbox *sys_mbox_t;
-+#define sys_mbox_valid(mbox) ((*(mbox) != NULL))
-+#define sys_mbox_set_invalid(mbox) do { if((mbox) != NULL) { *(mbox) = NULL; }}while(0)
-+
-+struct sys_thread;
-+typedef struct sys_thread * sys_thread_t;
-+
-+#endif /* LWIP_ARCH_SYS_ARCH_H */
-+
-diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
-new file mode 100644
-index 0000000..169ba46
---- /dev/null
-+++ b/ports/include/lwipopts.h
-@@ -0,0 +1,178 @@
-+/**
-+ * \file lwipopts.h - Configuration options for lwIP
-+ *
-+ * Copyright (c) 2010 Texas Instruments Incorporated
-+ */
-+/*
-+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
-+ * All rights reserved.
-+ *
-+ * Redistribution and use in source and binary forms, with or without modification,
-+ * are permitted provided that the following conditions are met:
-+ *
-+ * 1. Redistributions of source code must retain the above copyright notice,
-+ *    this list of conditions and the following disclaimer.
-+ * 2. Redistributions in binary form must reproduce the above copyright notice,
-+ *    this list of conditions and the following disclaimer in the documentation
-+ *    and/or other materials provided with the distribution.
-+ * 3. The name of the author may not be used to endorse or promote products
-+ *    derived from this software without specific prior written permission.
-+ *
-+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
-+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
-+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
-+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
-+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
-+ * OF SUCH DAMAGE.
-+ *
-+ * This file is part of the lwIP TCP/IP stack.
-+ *
-+ * Author: Adam Dunkels <adam@sics.se>
-+ *
-+ */
-+
-+#ifndef __LWIPOPTS_H__
-+#define __LWIPOPTS_H__
-+
-+/*****************************************************************************
-+**                           CONFIGURATIONS
-+*****************************************************************************/
-+
-+/*
-+** The below macro should be defined for using lwIP with cache. For cache
-+** enabling, pbuf pool shall be cache line aligned. This is done by using
-+** separate pool for each memory. The alignment of pbuf pool to cache line
-+** size is done in /ports/cpsw/include/arch/cc.h.
-+*/
-+/*#define LWIP_CACHE_ENABLED*/
-+
-+#define SOC_CACHELINE_SIZE_BYTES        64            /* Number of bytes in
-+                                                         a cache line */
-+/*
-+** The timeout for DHCP completion. lwIP library will wait for DHCP
-+** completion for (LWIP_DHCP_TIMEOUT / 100) seconds.
-+*/
-+#define LWIP_DHCP_TIMEOUT               500
-+
-+/*
-+** The number of times DHCP is attempted. Each time, the library will wait
-+** for (LWIP_DHCP_TIMEOUT / 100) seconds for DHCP completion.
-+*/
-+#define NUM_DHCP_TRIES                  5
-+
-+#define LWIP_ETHERNET                   1
-+#define LWIP_ARP                        1
-+
-+/*****************************************************************************
-+**            lwIP SPECIFIC DEFINITIONS - To be used by lwIP stack
-+*****************************************************************************/
-+#define HOST_TMR_INTERVAL               0
-+#define DYNAMIC_HTTP_HEADERS
-+
-+/*****************************************************************************
-+**                    Platform specific locking
-+*****************************************************************************/
-+#define SYS_LIGHTWEIGHT_PROT            1
-+#define NO_SYS                          0
-+#define NO_SYS_NO_TIMERS                0
-+
-+/*****************************************************************************
-+**                          Memory Options
-+*****************************************************************************/
-+#define MEM_ALIGNMENT                   4
-+#define MEM_SIZE                        (256 * 1024) /* 128K */
-+
-+#define MEMP_NUM_PBUF                   96
-+#define MEMP_NUM_TCP_PCB                32
-+#define MEMP_NUM_TCP_SEG                32
-+#define PBUF_POOL_SIZE                  512
-+
-+#ifdef LWIP_CACHE_ENABLED
-+#define MEMP_SEPARATE_POOLS             1            /* We want the pbuf
-+                                                        pool cache line
-+                                                        aligned*/
-+#endif
-+
-+#define MEMP_NUM_SYS_TIMEOUT (LWIP_TCP + IP_REASSEMBLY + LWIP_ARP + (2*LWIP_DHCP) + LWIP_AUTOIP + LWIP_IGMP + LWIP_DNS + PPP_SUPPORT)
-+
-+/*****************************************************************************
-+**                           IP Options
-+*****************************************************************************/
-+#define IP_REASSEMBLY                   0
-+#define IP_FRAG                         0
-+
-+/*****************************************************************************
-+**                           DHCP Options
-+*****************************************************************************/
-+#define LWIP_DHCP                       1
-+#define DHCP_DOES_ARP_CHECK             0
-+
-+/*****************************************************************************
-+**                           Auto IP  Options
-+*****************************************************************************/
-+#define LWIP_AUTOIP                     1
-+#define LWIP_DHCP_AUTOIP_COOP           ((LWIP_DHCP) && (LWIP_AUTOIP))
-+
-+/*****************************************************************************
-+**                           TCP  Options
-+*****************************************************************************/
-+#define TCP_MSS                         1500
-+#define TCP_WND                         (8 * TCP_MSS)
-+#define TCP_SND_BUF                     (8 * TCP_MSS)
-+#define TCP_OVERSIZE                    TCP_MSS
-+
-+/*****************************************************************************
-+**                           PBUF  Options
-+*****************************************************************************/
-+#define PBUF_LINK_HLEN                  14
-+#define PBUF_POOL_BUFSIZE               1520         /* + size of struct pbuf
-+                                                        shall be cache line
-+                                                        aligned be enabled */
-+#define ETH_PAD_SIZE                    0
-+#define LWIP_NETCONN                    1
-+
-+/*****************************************************************************
-+**                           Socket  Options
-+*****************************************************************************/
-+#define LWIP_SOCKET                     1
-+
-+/*****************************************************************************
-+**                          Debugging options
-+*****************************************************************************/
-+#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_OFF
-+#define LWIP_DBG_TYPES_ON               (LWIP_DBG_ON | LWIP_DBG_TRACE \
-+                                         |LWIP_DBG_STATE | LWIP_DBG_FRESH)
-+#define DHCP_DEBUG                      LWIP_DBG_OFF
-+#define NETIF_DEBUG                     LWIP_DBG_OFF
-+#define IP_DEBUG			LWIP_DBG_OFF
-+#define UDP_DEBUG			LWIP_DBG_OFF
-+#define ETHARP_DEBUG                    LWIP_DBG_OFF
-+#define SYS_DEBUG                       LWIP_DBG_OFF
-+#define RAW_DEBUG                       LWIP_DBG_OFF
-+#define MEM_DEBUG                       LWIP_DBG_OFF
-+#define MEMP_DEBUG                      LWIP_DBG_OFF
-+#define PBUF_DEBUG			LWIP_DBG_OFF
-+#define TCPIP_DEBUG			LWIP_DBG_OFF
-+#define APP_DEBUG			LWIP_DBG_OFF
-+#define SOCKETS_DEBUG		        LWIP_DBG_OFF
-+#define LWIP_STATS                      0
-+#define LWIP_STATS_DISPLAY              0
-+#define LWIP_STATS_POSIX                0
-+
-+
-+
-+/**
-+ * LWIP_COMPAT_SOCKETS==1: Enable BSD-style sockets functions names.
-+ * (only used if you use sockets.c)
-+ */
-+#define LWIP_COMPAT_SOCKETS             0
-+
-+#define LWIP_TIMEVAL_PRIVATE            0
-+
-+ #define LWIP_RAW                       0
-+
-+#endif /* __LWIPOPTS_H__ */
-diff --git a/ports/sys_arch.c b/ports/sys_arch.c
-new file mode 100644
-index 0000000..360a4e2
---- /dev/null
-+++ b/ports/sys_arch.c
-@@ -0,0 +1,663 @@
-+/*
-+ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
-+ * All rights reserved.
-+ *
-+ * Redistribution and use in source and binary forms, with or without modification,
-+ * are permitted provided that the following conditions are met:
-+ *
-+ * 1. Redistributions of source code must retain the above copyright notice,
-+ *    this list of conditions and the following disclaimer.
-+ * 2. Redistributions in binary form must reproduce the above copyright notice,
-+ *    this list of conditions and the following disclaimer in the documentation
-+ *    and/or other materials provided with the distribution.
-+ * 3. The name of the author may not be used to endorse or promote products
-+ *    derived from this software without specific prior written permission.
-+ *
-+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
-+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
-+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
-+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
-+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
-+ * OF SUCH DAMAGE.
-+ *
-+ * This file is part of the lwIP TCP/IP stack.
-+ *
-+ * Author: Adam Dunkels <adam@sics.se>
-+ *
-+ */
-+
-+/*
-+ * Wed Apr 17 16:05:29 EDT 2002 (James Roth)
-+ *
-+ *  - Fixed an unlikely sys_thread_new() race condition.
-+ *
-+ *  - Made current_thread() work with threads which where
-+ *    not created with sys_thread_new().  This includes
-+ *    the main thread and threads made with pthread_create().
-+ *
-+ *  - Catch overflows where more than SYS_MBOX_SIZE messages
-+ *    are waiting to be read.  The sys_mbox_post() routine
-+ *    will block until there is more room instead of just
-+ *    leaking messages.
-+ */
-+
-+#include <string.h>
-+#include <sys/time.h>
-+#include <sys/types.h>
-+#include <stdlib.h>
-+#include <unistd.h>
-+#include <pthread.h>
-+
-+#include "lwip/opt.h"
-+#include "lwip/sys.h"
-+#include "lwip/stats.h"
-+#include "lwip/debug.h"
-+
-+#define UMAX(a, b)      ((a) > (b) ? (a) : (b))
-+
-+static struct timeval starttime;
-+
-+#if !NO_SYS
-+
-+static struct sys_thread *threads = NULL;
-+static pthread_mutex_t threads_mutex = PTHREAD_MUTEX_INITIALIZER;
-+
-+struct sys_mbox_msg {
-+  struct sys_mbox_msg *next;
-+  void *msg;
-+};
-+
-+#define SYS_MBOX_SIZE 128
-+
-+struct sys_mbox {
-+  int first, last;
-+  void *msgs[SYS_MBOX_SIZE];
-+  struct sys_sem *not_empty;
-+  struct sys_sem *not_full;
-+  struct sys_sem *mutex;
-+  int wait_send;
-+};
-+
-+struct sys_sem {
-+  unsigned int c;
-+  pthread_cond_t cond;
-+  pthread_mutex_t mutex;
-+};
-+
-+struct sys_thread {
-+  struct sys_thread *next;
-+  pthread_t pthread;
-+};
-+
-+#if SYS_LIGHTWEIGHT_PROT
-+static pthread_mutex_t lwprot_mutex = PTHREAD_MUTEX_INITIALIZER;
-+static pthread_t lwprot_thread = (pthread_t)0xDEAD;
-+static int lwprot_count = 0;
-+#endif /* SYS_LIGHTWEIGHT_PROT */
-+
-+static struct sys_sem *sys_sem_new_internal(u8_t count);
-+static void sys_sem_free_internal(struct sys_sem *sem);
-+
-+static u32_t cond_wait(pthread_cond_t * cond, pthread_mutex_t * mutex,
-+                       u32_t timeout);
-+
-+/*-----------------------------------------------------------------------------------*/
-+static struct sys_thread *
-+introduce_thread(pthread_t id)
-+{
-+  struct sys_thread *thread = NULL;
-+
-+  thread = (struct sys_thread *)malloc(sizeof(struct sys_thread));
-+
-+  if (thread != NULL) {
-+    pthread_mutex_lock(&threads_mutex);
-+    thread->next = threads;
-+    thread->pthread = id;
-+    threads = thread;
-+    pthread_mutex_unlock(&threads_mutex);
-+  }
-+
-+  return thread;
-+}
-+/*-----------------------------------------------------------------------------------*/
-+sys_thread_t
-+sys_thread_new(const char *name, lwip_thread_fn function, void *arg, int stacksize, int prio)
-+{
-+  int code;
-+  int rc;
-+  pthread_t tmp;
-+  pthread_attr_t attr;
-+  struct sys_thread *st = NULL;
-+  LWIP_UNUSED_ARG(name);
-+  LWIP_UNUSED_ARG(stacksize);
-+  LWIP_UNUSED_ARG(prio);
-+
-+  /* Alloc a new pthread with the specified stack size. */
-+  if(stacksize > 0) {
-+    rc = pthread_attr_init(&attr);
-+    if (rc != 0) {
-+      LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: pthread_attr_init error = %d\n", rc));
-+      return NULL;
-+    }
-+    rc = pthread_attr_setstacksize(&attr, stacksize);
-+    if (rc != 0) {
-+      LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: pthread_attr_setstacksize error = %d\n", rc));
-+      pthread_attr_destroy(&attr);
-+      return NULL;
-+    }
-+    pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);
-+    pthread_attr_setschedpolicy(&attr, SCHED_RR);
-+    code = pthread_create(&tmp, &attr, (void *(*)(void *)) function, arg);
-+    pthread_attr_destroy(&attr);
-+  } else {
-+    code = pthread_create(&tmp, NULL, (void *(*)(void *)) function, arg);
-+  }
-+  LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: thread created [name:%s|stacksize:%d|prio:%d|addr:0x%x]\n",
-+                          name, stacksize, prio, (uint)tmp));
-+
-+  if (0 == code) {
-+    st = introduce_thread(tmp);
-+  }
-+
-+  if (NULL == st) {
-+    LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: failed to introduce %d, st = %p\n",
-+                            code, (void*)st));
-+    abort();
-+  } else {
-+    LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: introduced %d, st = %p\n",
-+                            code, (void*)st));
-+  }
-+
-+  return st;
-+}
-+/*-----------------------------------------------------------------------------------*/
-+void sys_thread_signal(sys_thread_t thread, int signal)
-+{
-+    /* Check received parameters. */
-+    if(thread == NULL) {
-+        LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_signal: could not send signal to thread. thread = NULL\n"));
-+        return;
-+    }
-+
-+    /* Send signal. */
-+    pthread_kill(thread->pthread, signal);
-+}
-+/*-----------------------------------------------------------------------------------*/
-+err_t
-+sys_mbox_new(struct sys_mbox **mb, int size)
-+{
-+  struct sys_mbox *mbox = NULL;
-+  LWIP_UNUSED_ARG(size);
-+
-+  mbox = (struct sys_mbox *)malloc(sizeof(struct sys_mbox));
-+  if (mbox == NULL) {
-+    SYS_STATS_INC(mbox.err);
-+    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_new: could not create mbox\n"));
-+    return ERR_MEM;
-+  }
-+  mbox->first = mbox->last = 0;
-+  mbox->not_empty = sys_sem_new_internal(0);
-+  mbox->not_full = sys_sem_new_internal(0);
-+  mbox->mutex = sys_sem_new_internal(1);
-+  mbox->wait_send = 0;
-+
-+  SYS_STATS_INC_USED(mbox);
-+
-+  if((mbox->not_empty == NULL) || (mbox->not_full == NULL) || (mbox->mutex == NULL)) {
-+    SYS_STATS_INC(mbox.err);
-+    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_new: could not create mbox internals\n"));
-+    sys_mbox_free(&mbox);
-+    return ERR_MEM;
-+  }
-+  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_new: mbox created [not_empty:%X|not_full:%X|mutex:%X] \n",
-+                          mbox->not_empty, mbox->not_full, mbox->mutex));
-+
-+  *mb = mbox;
-+  return ERR_OK;
-+}
-+/*-----------------------------------------------------------------------------------*/
-+void
-+sys_mbox_free(struct sys_mbox **mb)
-+{
-+  if ((mb != NULL) && (*mb != SYS_MBOX_NULL)) {
-+    struct sys_mbox *mbox = *mb;
-+    sys_arch_sem_wait(&mbox->mutex, 0);
-+
-+    sys_sem_free_internal(mbox->not_empty);
-+    sys_sem_free_internal(mbox->not_full);
-+    sys_sem_free_internal(mbox->mutex);
-+    mbox->not_empty = mbox->not_full = mbox->mutex = NULL;
-+    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_free: mbox 0x%lx\n", mbox));
-+    free(mbox);
-+    SYS_STATS_DEC(mbox.used);
-+  }
-+}
-+/*-----------------------------------------------------------------------------------*/
-+err_t
-+sys_mbox_trypost(struct sys_mbox **mb, void *msg)
-+{
-+  u8_t first;
-+  struct sys_mbox *mbox;
-+  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
-+  mbox = *mb;
-+  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_trypost: start"));
-+  sys_arch_sem_wait(&mbox->mutex, 0);
-+
-+  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_trypost: mbox %p msg %p\n",
-+                          (void *)mbox, (void *)msg));
-+
-+  if ((mbox->last + 1) >= (mbox->first + SYS_MBOX_SIZE)) {
-+    sys_sem_signal(&mbox->mutex);
-+    return ERR_MEM;
-+  }
-+
-+  mbox->msgs[mbox->last % SYS_MBOX_SIZE] = msg;
-+
-+  if (mbox->last == mbox->first) {
-+    first = 1;
-+  } else {
-+    first = 0;
-+  }
-+
-+  mbox->last++;
-+
-+  if (first) {
-+    sys_sem_signal(&mbox->not_empty);
-+  }
-+
-+  sys_sem_signal(&mbox->mutex);
-+
-+  return ERR_OK;
-+}
-+/*-----------------------------------------------------------------------------------*/
-+void
-+sys_mbox_post(struct sys_mbox **mb, void *msg)
-+{
-+  u8_t first;
-+  struct sys_mbox *mbox;
-+  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
-+  mbox = *mb;
-+
-+  sys_arch_sem_wait(&mbox->mutex, 0);
-+
-+  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_post: mbox %p msg %p\n", (void *)mbox, (void *)msg));
-+
-+  while ((mbox->last + 1) >= (mbox->first + SYS_MBOX_SIZE)) {
-+    mbox->wait_send++;
-+    sys_sem_signal(&mbox->mutex);
-+    sys_arch_sem_wait(&mbox->not_full, 0);
-+    sys_arch_sem_wait(&mbox->mutex, 0);
-+    mbox->wait_send--;
-+  }
-+
-+  mbox->msgs[mbox->last % SYS_MBOX_SIZE] = msg;
-+
-+  if (mbox->last == mbox->first) {
-+    first = 1;
-+  } else {
-+    first = 0;
-+  }
-+
-+  mbox->last++;
-+
-+  if (first) {
-+    sys_sem_signal(&mbox->not_empty);
-+  }
-+
-+  sys_sem_signal(&mbox->mutex);
-+}
-+/*-----------------------------------------------------------------------------------*/
-+u32_t
-+sys_arch_mbox_tryfetch(struct sys_mbox **mb, void **msg)
-+{
-+  struct sys_mbox *mbox;
-+  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
-+  mbox = *mb;
-+
-+  sys_arch_sem_wait(&mbox->mutex, 0);
-+
-+  if (mbox->first == mbox->last) {
-+    sys_sem_signal(&mbox->mutex);
-+    return SYS_MBOX_EMPTY;
-+  }
-+
-+  if (msg != NULL) {
-+    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_tryfetch: mbox %p msg %p\n", (void *)mbox, *msg));
-+    *msg = mbox->msgs[mbox->first % SYS_MBOX_SIZE];
-+  }
-+  else{
-+    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_tryfetch: mbox %p, null msg\n", (void *)mbox));
-+  }
-+
-+  mbox->first++;
-+
-+  if (mbox->wait_send) {
-+    sys_sem_signal(&mbox->not_full);
-+  }
-+
-+  sys_sem_signal(&mbox->mutex);
-+
-+  return 0;
-+}
-+/*-----------------------------------------------------------------------------------*/
-+u32_t
-+sys_arch_mbox_fetch(struct sys_mbox **mb, void **msg, u32_t timeout)
-+{
-+  u32_t time_needed = 0;
-+  struct sys_mbox *mbox;
-+  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
-+  mbox = *mb;
-+
-+  /* The mutex lock is quick so we don't bother with the timeout
-+     stuff here. */
-+  sys_arch_sem_wait(&mbox->mutex, 0);
-+
-+  while (mbox->first == mbox->last) {
-+    sys_sem_signal(&mbox->mutex);
-+
-+    /* We block while waiting for a mail to arrive in the mailbox. We
-+       must be prepared to timeout. */
-+    if (timeout != 0) {
-+      time_needed = sys_arch_sem_wait(&mbox->not_empty, timeout);
-+
-+      if (time_needed == SYS_ARCH_TIMEOUT) {
-+        return SYS_ARCH_TIMEOUT;
-+      }
-+    } else {
-+      sys_arch_sem_wait(&mbox->not_empty, 0);
-+    }
-+
-+    sys_arch_sem_wait(&mbox->mutex, 0);
-+  }
-+
-+  if (msg != NULL) {
-+    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_fetch: mbox %p msg %p\n", (void *)mbox, *msg));
-+    *msg = mbox->msgs[mbox->first % SYS_MBOX_SIZE];
-+  }
-+  else{
-+    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_fetch: mbox %p, null msg\n", (void *)mbox));
-+  }
-+
-+  mbox->first++;
-+
-+  if (mbox->wait_send) {
-+    sys_sem_signal(&mbox->not_full);
-+  }
-+
-+  sys_sem_signal(&mbox->mutex);
-+
-+  return time_needed;
-+}
-+/*-----------------------------------------------------------------------------------*/
-+static struct sys_sem *
-+sys_sem_new_internal(u8_t count)
-+{
-+  struct sys_sem *sem = NULL;
-+  int rc;
-+
-+  sem = (struct sys_sem *)malloc(sizeof(struct sys_sem));
-+  if (sem != NULL) {
-+    sem->c = count;
-+    rc = pthread_cond_init(&(sem->cond), NULL);
-+    if(rc != 0) {
-+      LWIP_DEBUGF(SYS_DEBUG, ("sys_sem_new_internal: pthread_cond_init error = %d\n", rc));
-+      return NULL;
-+    }
-+    rc = pthread_mutex_init(&(sem->mutex), NULL);
-+    if(rc != 0) {
-+      LWIP_DEBUGF(SYS_DEBUG, ("sys_sem_new_internal: pthread_mutex_init error = %d\n", rc));
-+      SYS_STATS_INC(mutex.err);
-+      pthread_cond_destroy(&(sem->cond));
-+      return NULL;
-+    }
-+    SYS_STATS_INC_USED(mutex);
-+    SYS_STATS_INC_USED(sem);
-+  } else {
-+    LWIP_DEBUGF(SYS_DEBUG, ("sys_sem_new_internal: could not create semaphore\n"));
-+    SYS_STATS_INC(sem.err);
-+  }
-+  return sem;
-+}
-+/*-----------------------------------------------------------------------------------*/
-+err_t
-+sys_sem_new(struct sys_sem **sem, u8_t count)
-+{
-+  *sem = sys_sem_new_internal(count);
-+  if (*sem == NULL) {
-+    return ERR_MEM;
-+  }
-+  return ERR_OK;
-+}
-+/*-----------------------------------------------------------------------------------*/
-+static u32_t
-+cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex, u32_t timeout)
-+{
-+  time_t tdiff;
-+  time_t sec, usec;
-+  struct timeval rtime1, rtime2;
-+  struct timespec ts;
-+  int retval;
-+
-+  if (timeout > 0) {
-+    /* Get a timestamp and add the timeout value. */
-+    gettimeofday(&rtime1, NULL);
-+    sec = rtime1.tv_sec;
-+    usec = rtime1.tv_usec;
-+    usec += timeout % 1000 * 1000;
-+    sec += (int)(timeout / 1000) + (int)(usec / 1000000);
-+    usec = usec % 1000000;
-+    ts.tv_nsec = usec * 1000;
-+    ts.tv_sec = sec;
-+
-+    retval = pthread_cond_timedwait(cond, mutex, &ts);
-+
-+    if (retval == ETIMEDOUT) {
-+      return SYS_ARCH_TIMEOUT;
-+    } else {
-+      /* Calculate for how long we waited for the cond. */
-+      gettimeofday(&rtime2, NULL);
-+      tdiff = (rtime2.tv_sec - rtime1.tv_sec) * 1000 +
-+        (rtime2.tv_usec - rtime1.tv_usec) / 1000;
-+
-+      if (tdiff <= 0) {
-+        return 0;
-+      }
-+      return (u32_t)tdiff;
-+    }
-+  } else {
-+    pthread_cond_wait(cond, mutex);
-+    return 0;
-+  }
-+}
-+/*-----------------------------------------------------------------------------------*/
-+u32_t
-+sys_arch_sem_wait(struct sys_sem **s, u32_t timeout)
-+{
-+  u32_t time_needed = 0;
-+  struct sys_sem *sem;
-+  LWIP_ASSERT("invalid sem", (s != NULL) && (*s != NULL));
-+  sem = *s;
-+
-+  pthread_mutex_lock(&(sem->mutex));
-+  while (sem->c <= 0) {
-+    if (timeout > 0) {
-+      time_needed = cond_wait(&(sem->cond), &(sem->mutex), timeout);
-+
-+      if (time_needed == SYS_ARCH_TIMEOUT) {
-+        pthread_mutex_unlock(&(sem->mutex));
-+        return SYS_ARCH_TIMEOUT;
-+      }
-+    } else {
-+      cond_wait(&(sem->cond), &(sem->mutex), 0);
-+    }
-+  }
-+  sem->c--;
-+  pthread_mutex_unlock(&(sem->mutex));
-+  return (u32_t)time_needed;
-+}
-+/*-----------------------------------------------------------------------------------*/
-+void
-+sys_sem_signal(struct sys_sem **s)
-+{
-+  struct sys_sem *sem;
-+  LWIP_ASSERT("invalid sem", (s != NULL) && (*s != NULL));
-+  sem = *s;
-+
-+  pthread_mutex_lock(&(sem->mutex));
-+  sem->c++;
-+
-+  if (sem->c > 1) {
-+    sem->c = 1;
-+  }
-+
-+  pthread_cond_broadcast(&(sem->cond));
-+  pthread_mutex_unlock(&(sem->mutex));
-+}
-+/*-----------------------------------------------------------------------------------*/
-+static void
-+sys_sem_free_internal(struct sys_sem *sem)
-+{
-+  if(sem != NULL) {
-+    pthread_cond_destroy(&(sem->cond));
-+    pthread_mutex_destroy(&(sem->mutex));
-+    SYS_STATS_DEC(mutex.used);
-+    SYS_STATS_DEC(sem.used);
-+    free(sem);
-+  }
-+}
-+/*-----------------------------------------------------------------------------------*/
-+void
-+sys_sem_free(struct sys_sem **sem)
-+{
-+  if ((sem != NULL) && (*sem != SYS_SEM_NULL)) {
-+    sys_sem_free_internal(*sem);
-+  }
-+}
-+#endif /* !NO_SYS */
-+/*-----------------------------------------------------------------------------------*/
-+u32_t
-+sys_now(void)
-+{
-+  struct timeval tv;
-+  u32_t sec, usec, msec;
-+  gettimeofday(&tv, NULL);
-+
-+  sec = (u32_t)(tv.tv_sec - starttime.tv_sec);
-+  usec = (u32_t)(tv.tv_usec - starttime.tv_usec);
-+  msec = sec * 1000 + usec / 1000;
-+
-+  return msec;
-+}
-+/*-----------------------------------------------------------------------------------*/
-+void
-+sys_init(void)
-+{
-+  SYS_STATS_INC_USED(mutex);
-+  gettimeofday(&starttime, NULL);
-+}
-+/*-----------------------------------------------------------------------------------*/
-+#if SYS_LIGHTWEIGHT_PROT
-+/** sys_prot_t sys_arch_protect(void)
-+
-+This optional function does a "fast" critical region protection and returns
-+the previous protection level. This function is only called during very short
-+critical regions. An embedded system which supports ISR-based drivers might
-+want to implement this function by disabling interrupts. Task-based systems
-+might want to implement this by using a mutex or disabling tasking. This
-+function should support recursive calls from the same task or interrupt. In
-+other words, sys_arch_protect() could be called while already protected. In
-+that case the return value indicates that it is already protected.
-+
-+sys_arch_protect() is only required if your port is supporting an operating
-+system.
-+*/
-+sys_prot_t
-+sys_arch_protect(void)
-+{
-+    /* Note that for the UNIX port, we are using a lightweight mutex, and our
-+     * own counter (which is locked by the mutex). The return code is not actually
-+     * used. */
-+    if (lwprot_thread != pthread_self())
-+    {
-+        /* We are locking the mutex where it has not been locked before *
-+        * or is being locked by another thread */
-+        pthread_mutex_lock(&lwprot_mutex);
-+        lwprot_thread = pthread_self();
-+        lwprot_count = 1;
-+    }
-+    else
-+    {
-+        /* It is already locked by THIS thread */
-+        lwprot_count++;
-+    }
-+    return 0;
-+}
-+/*-----------------------------------------------------------------------------------*/
-+/** void sys_arch_unprotect(sys_prot_t pval)
-+
-+This optional function does a "fast" set of critical region protection to the
-+value specified by pval. See the documentation for sys_arch_protect() for
-+more information. This function is only required if your port is supporting
-+an operating system.
-+*/
-+void
-+sys_arch_unprotect(sys_prot_t pval)
-+{
-+    LWIP_UNUSED_ARG(pval);
-+    if (lwprot_thread == pthread_self())
-+    {
-+        if (--lwprot_count == 0)
-+        {
-+            lwprot_thread = (pthread_t) 0xDEAD;
-+            pthread_mutex_unlock(&lwprot_mutex);
-+        }
-+    }
-+}
-+#endif /* SYS_LIGHTWEIGHT_PROT */
-+
-+/*-----------------------------------------------------------------------------------*/
-+
-+#ifndef MAX_JIFFY_OFFSET
-+#define MAX_JIFFY_OFFSET ((~0U >> 1)-1)
-+#endif
-+
-+#ifndef HZ
-+#define HZ 100
-+#endif
-+
-+u32_t
-+sys_jiffies(void)
-+{
-+    struct timeval tv;
-+    unsigned long sec;
-+    long usec;
-+
-+    gettimeofday(&tv,NULL);
-+    sec = tv.tv_sec - starttime.tv_sec;
-+    usec = tv.tv_usec;
-+
-+    if (sec >= (MAX_JIFFY_OFFSET / HZ))
-+      return MAX_JIFFY_OFFSET;
-+    usec += 1000000L / HZ - 1;
-+    usec /= 1000000L / HZ;
-+    return HZ * sec + usec;
-+}
-+
-+#if PPP_DEBUG
-+
-+#include <stdarg.h>
-+
-+void ppp_trace(int level, const char *format, ...)
-+{
-+    va_list args;
-+
-+    (void)level;
-+    va_start(args, format);
-+    vprintf(format, args);
-+    va_end(args);
-+}
-+#endif
--- 
-1.9.1
-
-
-From d053fa836b445b6736bf82d33a33a59055150aa7 Mon Sep 17 00:00:00 2001
-From: Jay Doyle <jay.doyle@vecna.com>
-Date: Fri, 4 Sep 2015 17:30:37 -0400
-Subject: [PATCH 02/10] changed the compiler options
-
----
- Makefile | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
-diff --git a/Makefile b/Makefile
-index 0cbae64..94fcafc 100644
---- a/Makefile
-+++ b/Makefile
-@@ -5,7 +5,7 @@ include $(PROJECT_ROOT)/make/leaf.cfg
- #### CONFIG ####################################################################
- #For debugging symbols add -DLWIP_DEBUG
- # COMPILER/LINKER
--CFLAGS+=-g -O2   \
-+CFLAGS+=-g -O0   \
-  -Wall
- 
- # OUTPUT
--- 
-1.9.1
-
-
-From 841adb17430bdb9298dcb6d44ac5dad72e82af80 Mon Sep 17 00:00:00 2001
-From: Jay Doyle <jay.doyle@vecna.com>
-Date: Mon, 7 Sep 2015 08:56:58 -0400
-Subject: [PATCH 03/10] disabled any mention of ipv6
-
----
- Makefile | 6 +++---
- 1 file changed, 3 insertions(+), 3 deletions(-)
-
-diff --git a/Makefile b/Makefile
-index 94fcafc..6efa141 100644
---- a/Makefile
-+++ b/Makefile
-@@ -40,7 +40,7 @@ CORE_SRC=$(wildcard $(LWIP_CORE_PATH)/*.c)
- IPV4_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv4/*.c)
- 
- ## IPv6
--IPV6_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv6/*.c)
-+#IPV6_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv6/*.c)
- 
- ## SNMP
- SNMP_SRC=$(wildcard $(LWIP_CORE_PATH)/snmp/*.c)
-@@ -71,7 +71,7 @@ SOURCES =  $(DRIVER_SRC) $(SNMP_SRC)\
- CORE_H=$(LWIP_INCL_PATH)
- 
- ## IPv4
--#IPV4_H=$(LWIP_INCL_PATH)/ipv4
-+IPV4_H=$(LWIP_INCL_PATH)/ipv4
- 
- ## IPv6
- #IPV6_H=$(LWIP_INCL_PATH)/ipv6
-@@ -97,7 +97,7 @@ DRIVER_H=$(LWIPDRIVER_INCL_PATH)
- # HEADERS
- HEADERS=-I$(CORE_H) -I$(POSIX_H) -I$(POSIX_SYS_H) -I$(NETIF_H) \
-         -I$(NETIF_H_PPP) -I$(NETIF_H_PPP_POLARSSL) -I$(ARCH_H) \
--        -I$(DRIVER_H)
-+        -I$(DRIVER_H) -I$(IPV4_H)
- 
- 
- ################################################################################
--- 
-1.9.1
-
-
-From a653d818348fef0130e6e497eecb0c3a35822df4 Mon Sep 17 00:00:00 2001
-From: Jay Doyle <jay.doyle@vecna.com>
-Date: Mon, 7 Sep 2015 09:27:48 -0400
-Subject: [PATCH 04/10] added in stm32f low-level driver
-
----
- src/netif/ethernetif.c | 709 ++++++++++++++++++++++++++++++-------------------
- 1 file changed, 435 insertions(+), 274 deletions(-)
-
-diff --git a/src/netif/ethernetif.c b/src/netif/ethernetif.c
-index 7982d11..82c85ae 100644
---- a/src/netif/ethernetif.c
-+++ b/src/netif/ethernetif.c
-@@ -1,335 +1,496 @@
- /**
-- * @file
-- * Ethernet Interface Skeleton
-- *
-- */
--
--/*
-- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
-- * All rights reserved. 
-- * 
-- * Redistribution and use in source and binary forms, with or without modification, 
-- * are permitted provided that the following conditions are met:
-- *
-- * 1. Redistributions of source code must retain the above copyright notice,
-- *    this list of conditions and the following disclaimer.
-- * 2. Redistributions in binary form must reproduce the above copyright notice,
-- *    this list of conditions and the following disclaimer in the documentation
-- *    and/or other materials provided with the distribution.
-- * 3. The name of the author may not be used to endorse or promote products
-- *    derived from this software without specific prior written permission. 
-- *
-- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
-- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
-- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
-- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
-- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
-- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
-- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
-- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
-- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
-- * OF SUCH DAMAGE.
-- *
-- * This file is part of the lwIP TCP/IP stack.
-- * 
-- * Author: Adam Dunkels <adam@sics.se>
-- *
-- */
--
--/*
-- * This file is a skeleton for developing Ethernet network interface
-- * drivers for lwIP. Add code to the low_level functions and do a
-- * search-and-replace for the word "ethernetif" to replace it with
-- * something that better describes your network interface.
-- */
--
-+  ******************************************************************************
-+  * @file    LwIP/LwIP_HTTP_Server_Netconn_RTOS/Src/ethernetif.c
-+  * @author  MCD Application Team
-+  * @version V1.0.0
-+  * @date    25-June-2015
-+  * @brief   This file implements Ethernet network interface drivers for lwIP
-+  ******************************************************************************
-+  * @attention
-+  *
-+  * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
-+  *
-+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
-+  * You may not use this file except in compliance with the License.
-+  * You may obtain a copy of the License at:
-+  *
-+  *        http://www.st.com/software_license_agreement_liberty_v2
-+  *
-+  * Unless required by applicable law or agreed to in writing, software 
-+  * distributed under the License is distributed on an "AS IS" BASIS, 
-+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-+  * See the License for the specific language governing permissions and
-+  * limitations under the License.
-+  *
-+  ******************************************************************************
-+  */
-+
-+/* Includes ------------------------------------------------------------------*/
-+#include "stm32f7xx_hal.h"
- #include "lwip/opt.h"
--
--#if 0 /* don't build, this is only a skeleton, see previous comment */
--
--#include "lwip/def.h"
--#include "lwip/mem.h"
--#include "lwip/pbuf.h"
--#include "lwip/stats.h"
--#include "lwip/snmp.h"
--#include "lwip/ethip6.h"
-+#include "lwip/lwip_timers.h"
- #include "netif/etharp.h"
--#include "netif/ppp/pppoe.h"
-+#include "hal-ethernetif.h"
-+#include <string.h>
-+
-+/* Private typedef -----------------------------------------------------------*/
-+/* Private define ------------------------------------------------------------*/
-+/* The time to block waiting for input. */
-+#define TIME_WAITING_FOR_INPUT                 ( 100 )
-+/* Stack size of the interface thread */
-+#define INTERFACE_THREAD_STACK_SIZE            ( 350 )
- 
- /* Define those to better describe your network interface. */
- #define IFNAME0 'e'
- #define IFNAME1 'n'
- 
--/**
-- * Helper struct to hold private data used to operate your ethernet interface.
-- * Keeping the ethernet address of the MAC in this struct is not necessary
-- * as it is already kept in the struct netif.
-- * But this is only an example, anyway...
-- */
--struct ethernetif {
--  struct eth_addr *ethaddr;
--  /* Add whatever per-interface state that is needed here. */
--};
--
--/* Forward declarations. */
--static void  ethernetif_input(struct netif *netif);
-+#define LAN8742A_PHY_ADDRESS            0x00
- 
--/**
-- * In this function, the hardware should be initialized.
-- * Called from ethernetif_init().
-- *
-- * @param netif the already initialized lwip network interface structure
-- *        for this ethernetif
-- */
--static void
--low_level_init(struct netif *netif)
--{
--  struct ethernetif *ethernetif = netif->state;
--  
--  /* set MAC hardware address length */
--  netif->hwaddr_len = ETHARP_HWADDR_LEN;
-+/* Private macro -------------------------------------------------------------*/
-+/* Private variables ---------------------------------------------------------*/
- 
--  /* set MAC hardware address */
--  netif->hwaddr[0] = ;
--  ...
--  netif->hwaddr[5] = ;
-+#if defined ( __ICCARM__ ) /*!< IAR Compiler */
- 
--  /* maximum transfer unit */
--  netif->mtu = 1500;
--  
--  /* device capabilities */
--  /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
--  netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
-- 
--#if LWIP_IPV6 && LWIP_IPV6_MLD
--  /*
--   * For hardware/netifs that implement MAC filtering.
--   * All-nodes link-local is handled by default, so we must let the hardware know
--   * to allow multicast packets in.
--   * Should set mld_mac_filter previously. */
--  if (netif->mld_mac_filter != NULL) {
--    ip6_addr_t ip6_allnodes_ll;
--    ip6_addr_set_allnodes_linklocal(&ip6_allnodes_ll);
--    netif->mld_mac_filter(netif, &ip6_allnodes_ll, MLD6_ADD_MAC_FILTER);
--  }
--#endif /* LWIP_IPV6 && LWIP_IPV6_MLD */
-+#pragma location=0x2000E000
-+__no_init ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
-+#pragma location=0x2000E100
-+__no_init ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
-+#elif defined ( __CC_ARM   )
-+ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((at(0x2000E000)));/* Ethernet Rx MA Descriptor */
-+ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((at(0x2000E100)));/* Ethernet Tx DMA Descriptor */
-+#elif defined ( __GNUC__   )
-+//ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".RxDescripSection")));/* Ethernet Rx MA Descriptor */
-+//ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".TxDescripSection")));/* Ethernet Tx DMA Descriptor */
-+ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Rx MA Descriptor */
-+ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Tx DMA Descriptor */
-+
-+
-+#endif
-+#if defined ( __ICCARM__ ) /*!< IAR Compiler */
-+#pragma location=0x2000E200
-+__no_init uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
-+#pragma location=0x2000FFC4
-+__no_init uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
-+#elif defined ( __CC_ARM   )
-+uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((at(0x2000E200)));  /* Ethernet Receive Buffer */
-+uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]  __attribute__((at(0x2000FFC4))); /* Ethernet Transmit Buffer */
-+#elif defined ( __GNUC__   )
-+//uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".RxBUF")));/* Ethernet Receive Buffer */
-+//uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".TxBUF")));/* Ethernet Transmit Buffer */
-+uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Receive Buffer */
-+uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Transmit Buffer */
-+
-+#endif
-+/* Semaphore to signal incoming packets */
-+osSemaphoreId s_xSemaphore = NULL;
- 
--  /* Do whatever else is needed to initialize interface. */  
-+/* Global Ethernet handle*/
-+ETH_HandleTypeDef EthHandle;
-+
-+/* Private function prototypes -----------------------------------------------*/
-+static void ethernetif_input( void const * argument );
-+
-+static void stm32f_ethernet_isr(
-+  void* argData
-+)
-+{
-+  ETH_HandleTypeDef* pEth =
-+    (ETH_HandleTypeDef*) argData;
-+
-+  HAL_ETH_IRQHandler(pEth);
- }
- 
-+/* Private functions ---------------------------------------------------------*/
-+/*******************************************************************************
-+                       Ethernet MSP Routines
-+*******************************************************************************/
- /**
-- * This function should do the actual transmission of the packet. The packet is
-- * contained in the pbuf that is passed to the function. This pbuf
-- * might be chained.
-- *
-- * @param netif the lwip network interface structure for this ethernetif
-- * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
-- * @return ERR_OK if the packet could be sent
-- *         an err_t value if the packet couldn't be sent
-- *
-- * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
-- *       strange results. You might consider waiting for space in the DMA queue
-- *       to become available since the stack doesn't retry to send a packet
-- *       dropped because of memory failure (except for the TCP timers).
-- */
--
--static err_t
--low_level_output(struct netif *netif, struct pbuf *p)
-+  * @brief  Initializes the ETH MSP.
-+  * @param  heth: ETH handle
-+  * @retval None
-+  */
-+void HAL_ETH_MspInit(ETH_HandleTypeDef *heth)
- {
--  struct ethernetif *ethernetif = netif->state;
--  struct pbuf *q;
--
--  initiate transfer();
-+  GPIO_InitTypeDef GPIO_InitStructure;
-   
--#if ETH_PAD_SIZE
--  pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
--#endif
--
--  for(q = p; q != NULL; q = q->next) {
--    /* Send the data from the pbuf to the interface, one pbuf at a
--       time. The size of the data in each pbuf is kept in the ->len
--       variable. */
--    send data from(q->payload, q->len);
--  }
-+  /* Enable GPIOs clocks */
-+  __HAL_RCC_GPIOA_CLK_ENABLE();
-+  __HAL_RCC_GPIOC_CLK_ENABLE();
-+  __HAL_RCC_GPIOG_CLK_ENABLE();
- 
--  signal that packet should be sent();
-+/* Ethernet pins configuration ************************************************/
-+  /*
-+        RMII_REF_CLK ----------------------> PA1
-+        RMII_MDIO -------------------------> PA2
-+        RMII_MDC --------------------------> PC1
-+        RMII_MII_CRS_DV -------------------> PA7
-+        RMII_MII_RXD0 ---------------------> PC4
-+        RMII_MII_RXD1 ---------------------> PC5
-+        RMII_MII_RXER ---------------------> PG2
-+        RMII_MII_TX_EN --------------------> PG11
-+        RMII_MII_TXD0 ---------------------> PG13
-+        RMII_MII_TXD1 ---------------------> PG14
-+  */
-+
-+  /* Configure PA1, PA2 and PA7 */
-+  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
-+  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
-+  GPIO_InitStructure.Pull = GPIO_NOPULL; 
-+  GPIO_InitStructure.Alternate = GPIO_AF11_ETH;
-+  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
-+  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
-+  
-+  /* Configure PC1, PC4 and PC5 */
-+  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;
-+  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
- 
--#if ETH_PAD_SIZE
--  pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
--#endif
-+  /* Configure PG2, PG11, PG13 and PG14 */
-+  GPIO_InitStructure.Pin =  GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14;
-+  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
-   
--  LINK_STATS_INC(link.xmit);
-+  // Install HAL Ethernet ISR
-+  rtems_interrupt_handler_install(
-+    ETH_IRQn,
-+    NULL,
-+    0,
-+    stm32f_ethernet_isr,
-+    heth);
-+  
-+  /* Enable ETHERNET clock  */
-+  __HAL_RCC_ETH_CLK_ENABLE();
-+}
- 
--  return ERR_OK;
-+/**
-+  * @brief  Ethernet Rx Transfer completed callback
-+  * @param  heth: ETH handle
-+  * @retval None
-+  */
-+void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
-+{
-+  osSemaphoreRelease(s_xSemaphore);
- }
- 
- /**
-- * Should allocate a pbuf and transfer the bytes of the incoming
-- * packet from the interface into the pbuf.
-- *
-- * @param netif the lwip network interface structure for this ethernetif
-- * @return a pbuf filled with the received packet (including MAC header)
-- *         NULL on memory error
-- */
--static struct pbuf *
--low_level_input(struct netif *netif)
-+  * @brief  Ethernet IRQ Handler
-+  * @param  None
-+  * @retval None
-+  */
-+void ETHERNET_IRQHandler(void)
- {
--  struct ethernetif *ethernetif = netif->state;
--  struct pbuf *p, *q;
--  u16_t len;
-+  HAL_ETH_IRQHandler(&EthHandle);
-+}
- 
--  /* Obtain the size of the packet and put it into the "len"
--     variable. */
--  len = ;
-+/*******************************************************************************
-+                       LL Driver Interface ( LwIP stack --> ETH) 
-+*******************************************************************************/
-+/**
-+  * @brief In this function, the hardware should be initialized.
-+  * Called from ethernetif_init().
-+  *
-+  * @param netif the already initialized lwip network interface structure
-+  *        for this ethernetif
-+  */
-+static void low_level_init(struct netif *netif)
-+{
-+  uint8_t macaddress[6]= { MAC_ADDR0, MAC_ADDR1, MAC_ADDR2, MAC_ADDR3, MAC_ADDR4, MAC_ADDR5 };
-+  
-+  EthHandle.Instance = ETH;  
-+  EthHandle.Init.MACAddr = macaddress;
-+  EthHandle.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
-+  EthHandle.Init.Speed = ETH_SPEED_100M;
-+  EthHandle.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
-+  EthHandle.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
-+  EthHandle.Init.RxMode = ETH_RXINTERRUPT_MODE;
-+  EthHandle.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
-+  EthHandle.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
-+  
-+  /* configure ethernet peripheral (GPIOs, clocks, MAC, DMA) */
-+  if (HAL_ETH_Init(&EthHandle) == HAL_OK)
-+  {
-+    /* Set netif link flag */
-+    netif->flags |= NETIF_FLAG_LINK_UP;
-+  }
-+  
-+  /* Initialize Tx Descriptors list: Chain Mode */
-+  HAL_ETH_DMATxDescListInit(&EthHandle, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
-+     
-+  /* Initialize Rx Descriptors list: Chain Mode  */
-+  HAL_ETH_DMARxDescListInit(&EthHandle, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
-+  
-+  /* set netif MAC hardware address length */
-+  netif->hwaddr_len = ETHARP_HWADDR_LEN;
- 
--#if ETH_PAD_SIZE
--  len += ETH_PAD_SIZE; /* allow room for Ethernet padding */
--#endif
-+  /* set netif MAC hardware address */
-+  netif->hwaddr[0] =  MAC_ADDR0;
-+  netif->hwaddr[1] =  MAC_ADDR1;
-+  netif->hwaddr[2] =  MAC_ADDR2;
-+  netif->hwaddr[3] =  MAC_ADDR3;
-+  netif->hwaddr[4] =  MAC_ADDR4;
-+  netif->hwaddr[5] =  MAC_ADDR5;
- 
--  /* We allocate a pbuf chain of pbufs from the pool. */
--  p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
--  
--  if (p != NULL) {
-+  /* set netif maximum transfer unit */
-+  netif->mtu = 1500;
- 
--#if ETH_PAD_SIZE
--    pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
--#endif
-+  /* Accept broadcast address and ARP traffic */
-+  netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
- 
--    /* We iterate over the pbuf chain until we have read the entire
--     * packet into the pbuf. */
--    for(q = p; q != NULL; q = q->next) {
--      /* Read enough bytes to fill this pbuf in the chain. The
--       * available data in the pbuf is given by the q->len
--       * variable.
--       * This does not necessarily have to be a memcpy, you can also preallocate
--       * pbufs for a DMA-enabled MAC and after receiving truncate it to the
--       * actually received size. In this case, ensure the tot_len member of the
--       * pbuf is the sum of the chained pbuf len members.
--       */
--      read data into(q->payload, q->len);
--    }
--    acknowledge that packet has been read();
-+  /* create a binary semaphore used for informing ethernetif of frame reception */
-+  osSemaphoreDef(SEM);
-+  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1 );
-+
-+  /* create the task that handles the ETH_MAC */
-+  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
-+  osThreadCreate (osThread(EthIf), netif);
-+
-+  /* Enable MAC and DMA transmission and reception */
-+  HAL_ETH_Start(&EthHandle);
-+}
- 
--#if ETH_PAD_SIZE
--    pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
--#endif
- 
--    LINK_STATS_INC(link.recv);
--  } else {
--    drop packet();
--    LINK_STATS_INC(link.memerr);
--    LINK_STATS_INC(link.drop);
-+/**
-+  * @brief This function should do the actual transmission of the packet. The packet is
-+  * contained in the pbuf that is passed to the function. This pbuf
-+  * might be chained.
-+  *
-+  * @param netif the lwip network interface structure for this ethernetif
-+  * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
-+  * @return ERR_OK if the packet could be sent
-+  *         an err_t value if the packet couldn't be sent
-+  *
-+  * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
-+  *       strange results. You might consider waiting for space in the DMA queue
-+  *       to become available since the stack doesn't retry to send a packet
-+  *       dropped because of memory failure (except for the TCP timers).
-+  */
-+static err_t low_level_output(struct netif *netif, struct pbuf *p)
-+{
-+  err_t errval;
-+  struct pbuf *q;
-+  uint8_t *buffer = (uint8_t *)(EthHandle.TxDesc->Buffer1Addr);
-+  __IO ETH_DMADescTypeDef *DmaTxDesc;
-+  uint32_t framelength = 0;
-+  uint32_t bufferoffset = 0;
-+  uint32_t byteslefttocopy = 0;
-+  uint32_t payloadoffset = 0;
-+
-+  DmaTxDesc = EthHandle.TxDesc;
-+  bufferoffset = 0;
-+  
-+  /* copy frame from pbufs to driver buffers */
-+  for(q = p; q != NULL; q = q->next)
-+  {
-+    /* Is this buffer available? If not, goto error */
-+    if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
-+    {
-+      errval = ERR_USE;
-+      goto error;
-+    }
-+    
-+    /* Get bytes in current lwIP buffer */
-+    byteslefttocopy = q->len;
-+    payloadoffset = 0;
-+    
-+    /* Check if the length of data to copy is bigger than Tx buffer size*/
-+    while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
-+    {
-+      /* Copy data to Tx buffer*/
-+      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
-+      
-+      /* Point to next descriptor */
-+      DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
-+      
-+      /* Check if the buffer is available */
-+      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
-+      {
-+        errval = ERR_USE;
-+        goto error;
-+      }
-+      
-+      buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
-+      
-+      byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
-+      payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
-+      framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
-+      bufferoffset = 0;
-+    }
-+    
-+    /* Copy the remaining bytes */
-+    memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
-+    bufferoffset = bufferoffset + byteslefttocopy;
-+    framelength = framelength + byteslefttocopy;
-+  }
-+  
-+  /* Prepare transmit descriptors to give to DMA */ 
-+  HAL_ETH_TransmitFrame(&EthHandle, framelength);
-+  
-+  errval = ERR_OK;
-+  
-+error:
-+  
-+  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
-+  if ((EthHandle.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
-+  {
-+    /* Clear TUS ETHERNET DMA flag */
-+    EthHandle.Instance->DMASR = ETH_DMASR_TUS;
-+    
-+    /* Resume DMA transmission*/
-+    EthHandle.Instance->DMATPDR = 0;
-   }
-+  return errval;
-+}
- 
--  return p;  
-+/**
-+  * @brief Should allocate a pbuf and transfer the bytes of the incoming
-+  * packet from the interface into the pbuf.
-+  *
-+  * @param netif the lwip network interface structure for this ethernetif
-+  * @return a pbuf filled with the received packet (including MAC header)
-+  *         NULL on memory error
-+  */
-+static struct pbuf * low_level_input(struct netif *netif)
-+{
-+  struct pbuf *p = NULL, *q = NULL;
-+  uint16_t len = 0;
-+  uint8_t *buffer;
-+  __IO ETH_DMADescTypeDef *dmarxdesc;
-+  uint32_t bufferoffset = 0;
-+  uint32_t payloadoffset = 0;
-+  uint32_t byteslefttocopy = 0;
-+  uint32_t i=0;
-+  
-+  /* get received frame */
-+  if(HAL_ETH_GetReceivedFrame_IT(&EthHandle) != HAL_OK)
-+    return NULL;
-+  
-+  /* Obtain the size of the packet and put it into the "len" variable. */
-+  len = EthHandle.RxFrameInfos.length;
-+  buffer = (uint8_t *)EthHandle.RxFrameInfos.buffer;
-+  
-+  if (len > 0)
-+  {
-+    /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
-+    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
-+  }
-+  
-+  if (p != NULL)
-+  {
-+    dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
-+    bufferoffset = 0;
-+    
-+    for(q = p; q != NULL; q = q->next)
-+    {
-+      byteslefttocopy = q->len;
-+      payloadoffset = 0;
-+      
-+      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size */
-+      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
-+      {
-+        /* Copy data to pbuf */
-+        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
-+        
-+        /* Point to next descriptor */
-+        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
-+        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
-+        
-+        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
-+        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
-+        bufferoffset = 0;
-+      }
-+      
-+      /* Copy remaining data in pbuf */
-+      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
-+      bufferoffset = bufferoffset + byteslefttocopy;
-+    }
-+  }
-+    
-+  /* Release descriptors to DMA */
-+  /* Point to first descriptor */
-+  dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
-+  /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
-+  for (i=0; i< EthHandle.RxFrameInfos.SegCount; i++)
-+  {  
-+    dmarxdesc->Status |= ETH_DMARXDESC_OWN;
-+    dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
-+  }
-+    
-+  /* Clear Segment_Count */
-+  EthHandle.RxFrameInfos.SegCount =0;
-+  
-+  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
-+  if ((EthHandle.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
-+  {
-+    /* Clear RBUS ETHERNET DMA flag */
-+    EthHandle.Instance->DMASR = ETH_DMASR_RBUS;
-+    /* Resume DMA reception */
-+    EthHandle.Instance->DMARPDR = 0;
-+  }
-+  return p;
- }
- 
- /**
-- * This function should be called when a packet is ready to be read
-- * from the interface. It uses the function low_level_input() that
-- * should handle the actual reception of bytes from the network
-- * interface. Then the type of the received packet is determined and
-- * the appropriate input function is called.
-- *
-- * @param netif the lwip network interface structure for this ethernetif
-- */
--static void
--ethernetif_input(struct netif *netif)
-+  * @brief This function is the ethernetif_input task, it is processed when a packet 
-+  * is ready to be read from the interface. It uses the function low_level_input() 
-+  * that should handle the actual reception of bytes from the network
-+  * interface. Then the type of the received packet is determined and
-+  * the appropriate input function is called.
-+  *
-+  * @param netif the lwip network interface structure for this ethernetif
-+  */
-+void ethernetif_input( void const * argument )
- {
--  struct ethernetif *ethernetif;
--  struct eth_hdr *ethhdr;
-   struct pbuf *p;
--
--  ethernetif = netif->state;
--
--  /* move received packet into a new pbuf */
--  p = low_level_input(netif);
--  /* no packet could be read, silently ignore this */
--  if (p == NULL) return;
--  /* points to packet payload, which starts with an Ethernet header */
--  ethhdr = p->payload;
--
--  switch (htons(ethhdr->type)) {
--  /* IP or ARP packet? */
--  case ETHTYPE_IP:
--  case ETHTYPE_IPV6:
--  case ETHTYPE_ARP:
--#if PPPOE_SUPPORT
--  /* PPPoE packet? */
--  case ETHTYPE_PPPOEDISC:
--  case ETHTYPE_PPPOE:
--#endif /* PPPOE_SUPPORT */
--    /* full packet send to tcpip_thread to process */
--    if (netif->input(p, netif)!=ERR_OK)
--     { LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
--       pbuf_free(p);
--       p = NULL;
--     }
--    break;
--
--  default:
--    pbuf_free(p);
--    p = NULL;
--    break;
-+  struct netif *netif = (struct netif *) argument;
-+  
-+  for( ;; )
-+  {
-+    if (osSemaphoreWait( s_xSemaphore, TIME_WAITING_FOR_INPUT)==osOK)
-+    {
-+      do
-+      {
-+        p = low_level_input( netif );
-+        if (p != NULL)
-+        {
-+          if (netif->input( p, netif) != ERR_OK )
-+          {
-+            pbuf_free(p);
-+          }
-+        }
-+      }while(p!=NULL);
-+    }
-   }
- }
- 
- /**
-- * Should be called at the beginning of the program to set up the
-- * network interface. It calls the function low_level_init() to do the
-- * actual setup of the hardware.
-- *
-- * This function should be passed as a parameter to netif_add().
-- *
-- * @param netif the lwip network interface structure for this ethernetif
-- * @return ERR_OK if the loopif is initialized
-- *         ERR_MEM if private data couldn't be allocated
-- *         any other err_t on error
-- */
--err_t
--ethernetif_init(struct netif *netif)
-+  * @brief Should be called at the beginning of the program to set up the
-+  * network interface. It calls the function low_level_init() to do the
-+  * actual setup of the hardware.
-+  *
-+  * This function should be passed as a parameter to netif_add().
-+  *
-+  * @param netif the lwip network interface structure for this ethernetif
-+  * @return ERR_OK if the loopif is initialized
-+  *         ERR_MEM if private data couldn't be allocated
-+  *         any other err_t on error
-+  */
-+err_t ethernetif_init(struct netif *netif)
- {
--  struct ethernetif *ethernetif;
--
-   LWIP_ASSERT("netif != NULL", (netif != NULL));
--    
--  ethernetif = mem_malloc(sizeof(struct ethernetif));
--  if (ethernetif == NULL) {
--    LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_init: out of memory\n"));
--    return ERR_MEM;
--  }
- 
- #if LWIP_NETIF_HOSTNAME
-   /* Initialize interface hostname */
-   netif->hostname = "lwip";
- #endif /* LWIP_NETIF_HOSTNAME */
- 
--  /*
--   * Initialize the snmp variables and counters inside the struct netif.
--   * The last argument should be replaced with your link speed, in units
--   * of bits per second.
--   */
--  NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, LINK_SPEED_OF_YOUR_NETIF_IN_BPS);
--
--  netif->state = ethernetif;
-   netif->name[0] = IFNAME0;
-   netif->name[1] = IFNAME1;
--  /* We directly use etharp_output() here to save a function call.
--   * You can instead declare your own function an call etharp_output()
--   * from it if you have to do some checks before sending (e.g. if link
--   * is available...) */
-+
-   netif->output = etharp_output;
--#if LWIP_IPV6
--  netif->output_ip6 = ethip6_output;
--#endif /* LWIP_IPV6 */
-   netif->linkoutput = low_level_output;
--  
--  ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
--  
-+
-   /* initialize the hardware */
-   low_level_init(netif);
- 
-   return ERR_OK;
- }
- 
--#endif /* 0 */
-+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
--- 
-1.9.1
-
-
-From ab97b49d1d41e34fdfdfb457b397c768ee228c9f Mon Sep 17 00:00:00 2001
-From: Jay Doyle <jay.doyle@vecna.com>
-Date: Mon, 7 Sep 2015 09:39:20 -0400
-Subject: [PATCH 05/10] removed ethernetif (it should be in BSP
-
----
- src/netif/ethernetif.c | 496 -------------------------------------------------
- 1 file changed, 496 deletions(-)
- delete mode 100644 src/netif/ethernetif.c
-
-diff --git a/src/netif/ethernetif.c b/src/netif/ethernetif.c
-deleted file mode 100644
-index 82c85ae..0000000
---- a/src/netif/ethernetif.c
-+++ /dev/null
-@@ -1,496 +0,0 @@
--/**
--  ******************************************************************************
--  * @file    LwIP/LwIP_HTTP_Server_Netconn_RTOS/Src/ethernetif.c
--  * @author  MCD Application Team
--  * @version V1.0.0
--  * @date    25-June-2015
--  * @brief   This file implements Ethernet network interface drivers for lwIP
--  ******************************************************************************
--  * @attention
--  *
--  * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
--  *
--  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
--  * You may not use this file except in compliance with the License.
--  * You may obtain a copy of the License at:
--  *
--  *        http://www.st.com/software_license_agreement_liberty_v2
--  *
--  * Unless required by applicable law or agreed to in writing, software 
--  * distributed under the License is distributed on an "AS IS" BASIS, 
--  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
--  * See the License for the specific language governing permissions and
--  * limitations under the License.
--  *
--  ******************************************************************************
--  */
--
--/* Includes ------------------------------------------------------------------*/
--#include "stm32f7xx_hal.h"
--#include "lwip/opt.h"
--#include "lwip/lwip_timers.h"
--#include "netif/etharp.h"
--#include "hal-ethernetif.h"
--#include <string.h>
--
--/* Private typedef -----------------------------------------------------------*/
--/* Private define ------------------------------------------------------------*/
--/* The time to block waiting for input. */
--#define TIME_WAITING_FOR_INPUT                 ( 100 )
--/* Stack size of the interface thread */
--#define INTERFACE_THREAD_STACK_SIZE            ( 350 )
--
--/* Define those to better describe your network interface. */
--#define IFNAME0 'e'
--#define IFNAME1 'n'
--
--#define LAN8742A_PHY_ADDRESS            0x00
--
--/* Private macro -------------------------------------------------------------*/
--/* Private variables ---------------------------------------------------------*/
--
--#if defined ( __ICCARM__ ) /*!< IAR Compiler */
--
--#pragma location=0x2000E000
--__no_init ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
--#pragma location=0x2000E100
--__no_init ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
--#elif defined ( __CC_ARM   )
--ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((at(0x2000E000)));/* Ethernet Rx MA Descriptor */
--ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((at(0x2000E100)));/* Ethernet Tx DMA Descriptor */
--#elif defined ( __GNUC__   )
--//ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".RxDescripSection")));/* Ethernet Rx MA Descriptor */
--//ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".TxDescripSection")));/* Ethernet Tx DMA Descriptor */
--ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Rx MA Descriptor */
--ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Tx DMA Descriptor */
--
--
--#endif
--#if defined ( __ICCARM__ ) /*!< IAR Compiler */
--#pragma location=0x2000E200
--__no_init uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
--#pragma location=0x2000FFC4
--__no_init uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
--#elif defined ( __CC_ARM   )
--uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((at(0x2000E200)));  /* Ethernet Receive Buffer */
--uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]  __attribute__((at(0x2000FFC4))); /* Ethernet Transmit Buffer */
--#elif defined ( __GNUC__   )
--//uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".RxBUF")));/* Ethernet Receive Buffer */
--//uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".TxBUF")));/* Ethernet Transmit Buffer */
--uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Receive Buffer */
--uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Transmit Buffer */
--
--#endif
--/* Semaphore to signal incoming packets */
--osSemaphoreId s_xSemaphore = NULL;
--
--/* Global Ethernet handle*/
--ETH_HandleTypeDef EthHandle;
--
--/* Private function prototypes -----------------------------------------------*/
--static void ethernetif_input( void const * argument );
--
--static void stm32f_ethernet_isr(
--  void* argData
--)
--{
--  ETH_HandleTypeDef* pEth =
--    (ETH_HandleTypeDef*) argData;
--
--  HAL_ETH_IRQHandler(pEth);
--}
--
--/* Private functions ---------------------------------------------------------*/
--/*******************************************************************************
--                       Ethernet MSP Routines
--*******************************************************************************/
--/**
--  * @brief  Initializes the ETH MSP.
--  * @param  heth: ETH handle
--  * @retval None
--  */
--void HAL_ETH_MspInit(ETH_HandleTypeDef *heth)
--{
--  GPIO_InitTypeDef GPIO_InitStructure;
--  
--  /* Enable GPIOs clocks */
--  __HAL_RCC_GPIOA_CLK_ENABLE();
--  __HAL_RCC_GPIOC_CLK_ENABLE();
--  __HAL_RCC_GPIOG_CLK_ENABLE();
--
--/* Ethernet pins configuration ************************************************/
--  /*
--        RMII_REF_CLK ----------------------> PA1
--        RMII_MDIO -------------------------> PA2
--        RMII_MDC --------------------------> PC1
--        RMII_MII_CRS_DV -------------------> PA7
--        RMII_MII_RXD0 ---------------------> PC4
--        RMII_MII_RXD1 ---------------------> PC5
--        RMII_MII_RXER ---------------------> PG2
--        RMII_MII_TX_EN --------------------> PG11
--        RMII_MII_TXD0 ---------------------> PG13
--        RMII_MII_TXD1 ---------------------> PG14
--  */
--
--  /* Configure PA1, PA2 and PA7 */
--  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
--  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
--  GPIO_InitStructure.Pull = GPIO_NOPULL; 
--  GPIO_InitStructure.Alternate = GPIO_AF11_ETH;
--  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
--  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
--  
--  /* Configure PC1, PC4 and PC5 */
--  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;
--  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
--
--  /* Configure PG2, PG11, PG13 and PG14 */
--  GPIO_InitStructure.Pin =  GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14;
--  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
--  
--  // Install HAL Ethernet ISR
--  rtems_interrupt_handler_install(
--    ETH_IRQn,
--    NULL,
--    0,
--    stm32f_ethernet_isr,
--    heth);
--  
--  /* Enable ETHERNET clock  */
--  __HAL_RCC_ETH_CLK_ENABLE();
--}
--
--/**
--  * @brief  Ethernet Rx Transfer completed callback
--  * @param  heth: ETH handle
--  * @retval None
--  */
--void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
--{
--  osSemaphoreRelease(s_xSemaphore);
--}
--
--/**
--  * @brief  Ethernet IRQ Handler
--  * @param  None
--  * @retval None
--  */
--void ETHERNET_IRQHandler(void)
--{
--  HAL_ETH_IRQHandler(&EthHandle);
--}
--
--/*******************************************************************************
--                       LL Driver Interface ( LwIP stack --> ETH) 
--*******************************************************************************/
--/**
--  * @brief In this function, the hardware should be initialized.
--  * Called from ethernetif_init().
--  *
--  * @param netif the already initialized lwip network interface structure
--  *        for this ethernetif
--  */
--static void low_level_init(struct netif *netif)
--{
--  uint8_t macaddress[6]= { MAC_ADDR0, MAC_ADDR1, MAC_ADDR2, MAC_ADDR3, MAC_ADDR4, MAC_ADDR5 };
--  
--  EthHandle.Instance = ETH;  
--  EthHandle.Init.MACAddr = macaddress;
--  EthHandle.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
--  EthHandle.Init.Speed = ETH_SPEED_100M;
--  EthHandle.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
--  EthHandle.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
--  EthHandle.Init.RxMode = ETH_RXINTERRUPT_MODE;
--  EthHandle.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
--  EthHandle.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
--  
--  /* configure ethernet peripheral (GPIOs, clocks, MAC, DMA) */
--  if (HAL_ETH_Init(&EthHandle) == HAL_OK)
--  {
--    /* Set netif link flag */
--    netif->flags |= NETIF_FLAG_LINK_UP;
--  }
--  
--  /* Initialize Tx Descriptors list: Chain Mode */
--  HAL_ETH_DMATxDescListInit(&EthHandle, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
--     
--  /* Initialize Rx Descriptors list: Chain Mode  */
--  HAL_ETH_DMARxDescListInit(&EthHandle, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
--  
--  /* set netif MAC hardware address length */
--  netif->hwaddr_len = ETHARP_HWADDR_LEN;
--
--  /* set netif MAC hardware address */
--  netif->hwaddr[0] =  MAC_ADDR0;
--  netif->hwaddr[1] =  MAC_ADDR1;
--  netif->hwaddr[2] =  MAC_ADDR2;
--  netif->hwaddr[3] =  MAC_ADDR3;
--  netif->hwaddr[4] =  MAC_ADDR4;
--  netif->hwaddr[5] =  MAC_ADDR5;
--
--  /* set netif maximum transfer unit */
--  netif->mtu = 1500;
--
--  /* Accept broadcast address and ARP traffic */
--  netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
--
--  /* create a binary semaphore used for informing ethernetif of frame reception */
--  osSemaphoreDef(SEM);
--  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1 );
--
--  /* create the task that handles the ETH_MAC */
--  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
--  osThreadCreate (osThread(EthIf), netif);
--
--  /* Enable MAC and DMA transmission and reception */
--  HAL_ETH_Start(&EthHandle);
--}
--
--
--/**
--  * @brief This function should do the actual transmission of the packet. The packet is
--  * contained in the pbuf that is passed to the function. This pbuf
--  * might be chained.
--  *
--  * @param netif the lwip network interface structure for this ethernetif
--  * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
--  * @return ERR_OK if the packet could be sent
--  *         an err_t value if the packet couldn't be sent
--  *
--  * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
--  *       strange results. You might consider waiting for space in the DMA queue
--  *       to become available since the stack doesn't retry to send a packet
--  *       dropped because of memory failure (except for the TCP timers).
--  */
--static err_t low_level_output(struct netif *netif, struct pbuf *p)
--{
--  err_t errval;
--  struct pbuf *q;
--  uint8_t *buffer = (uint8_t *)(EthHandle.TxDesc->Buffer1Addr);
--  __IO ETH_DMADescTypeDef *DmaTxDesc;
--  uint32_t framelength = 0;
--  uint32_t bufferoffset = 0;
--  uint32_t byteslefttocopy = 0;
--  uint32_t payloadoffset = 0;
--
--  DmaTxDesc = EthHandle.TxDesc;
--  bufferoffset = 0;
--  
--  /* copy frame from pbufs to driver buffers */
--  for(q = p; q != NULL; q = q->next)
--  {
--    /* Is this buffer available? If not, goto error */
--    if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
--    {
--      errval = ERR_USE;
--      goto error;
--    }
--    
--    /* Get bytes in current lwIP buffer */
--    byteslefttocopy = q->len;
--    payloadoffset = 0;
--    
--    /* Check if the length of data to copy is bigger than Tx buffer size*/
--    while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
--    {
--      /* Copy data to Tx buffer*/
--      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
--      
--      /* Point to next descriptor */
--      DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
--      
--      /* Check if the buffer is available */
--      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
--      {
--        errval = ERR_USE;
--        goto error;
--      }
--      
--      buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
--      
--      byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
--      payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
--      framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
--      bufferoffset = 0;
--    }
--    
--    /* Copy the remaining bytes */
--    memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
--    bufferoffset = bufferoffset + byteslefttocopy;
--    framelength = framelength + byteslefttocopy;
--  }
--  
--  /* Prepare transmit descriptors to give to DMA */ 
--  HAL_ETH_TransmitFrame(&EthHandle, framelength);
--  
--  errval = ERR_OK;
--  
--error:
--  
--  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
--  if ((EthHandle.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
--  {
--    /* Clear TUS ETHERNET DMA flag */
--    EthHandle.Instance->DMASR = ETH_DMASR_TUS;
--    
--    /* Resume DMA transmission*/
--    EthHandle.Instance->DMATPDR = 0;
--  }
--  return errval;
--}
--
--/**
--  * @brief Should allocate a pbuf and transfer the bytes of the incoming
--  * packet from the interface into the pbuf.
--  *
--  * @param netif the lwip network interface structure for this ethernetif
--  * @return a pbuf filled with the received packet (including MAC header)
--  *         NULL on memory error
--  */
--static struct pbuf * low_level_input(struct netif *netif)
--{
--  struct pbuf *p = NULL, *q = NULL;
--  uint16_t len = 0;
--  uint8_t *buffer;
--  __IO ETH_DMADescTypeDef *dmarxdesc;
--  uint32_t bufferoffset = 0;
--  uint32_t payloadoffset = 0;
--  uint32_t byteslefttocopy = 0;
--  uint32_t i=0;
--  
--  /* get received frame */
--  if(HAL_ETH_GetReceivedFrame_IT(&EthHandle) != HAL_OK)
--    return NULL;
--  
--  /* Obtain the size of the packet and put it into the "len" variable. */
--  len = EthHandle.RxFrameInfos.length;
--  buffer = (uint8_t *)EthHandle.RxFrameInfos.buffer;
--  
--  if (len > 0)
--  {
--    /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
--    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
--  }
--  
--  if (p != NULL)
--  {
--    dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
--    bufferoffset = 0;
--    
--    for(q = p; q != NULL; q = q->next)
--    {
--      byteslefttocopy = q->len;
--      payloadoffset = 0;
--      
--      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size */
--      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
--      {
--        /* Copy data to pbuf */
--        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
--        
--        /* Point to next descriptor */
--        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
--        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
--        
--        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
--        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
--        bufferoffset = 0;
--      }
--      
--      /* Copy remaining data in pbuf */
--      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
--      bufferoffset = bufferoffset + byteslefttocopy;
--    }
--  }
--    
--  /* Release descriptors to DMA */
--  /* Point to first descriptor */
--  dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
--  /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
--  for (i=0; i< EthHandle.RxFrameInfos.SegCount; i++)
--  {  
--    dmarxdesc->Status |= ETH_DMARXDESC_OWN;
--    dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
--  }
--    
--  /* Clear Segment_Count */
--  EthHandle.RxFrameInfos.SegCount =0;
--  
--  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
--  if ((EthHandle.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
--  {
--    /* Clear RBUS ETHERNET DMA flag */
--    EthHandle.Instance->DMASR = ETH_DMASR_RBUS;
--    /* Resume DMA reception */
--    EthHandle.Instance->DMARPDR = 0;
--  }
--  return p;
--}
--
--/**
--  * @brief This function is the ethernetif_input task, it is processed when a packet 
--  * is ready to be read from the interface. It uses the function low_level_input() 
--  * that should handle the actual reception of bytes from the network
--  * interface. Then the type of the received packet is determined and
--  * the appropriate input function is called.
--  *
--  * @param netif the lwip network interface structure for this ethernetif
--  */
--void ethernetif_input( void const * argument )
--{
--  struct pbuf *p;
--  struct netif *netif = (struct netif *) argument;
--  
--  for( ;; )
--  {
--    if (osSemaphoreWait( s_xSemaphore, TIME_WAITING_FOR_INPUT)==osOK)
--    {
--      do
--      {
--        p = low_level_input( netif );
--        if (p != NULL)
--        {
--          if (netif->input( p, netif) != ERR_OK )
--          {
--            pbuf_free(p);
--          }
--        }
--      }while(p!=NULL);
--    }
--  }
--}
--
--/**
--  * @brief Should be called at the beginning of the program to set up the
--  * network interface. It calls the function low_level_init() to do the
--  * actual setup of the hardware.
--  *
--  * This function should be passed as a parameter to netif_add().
--  *
--  * @param netif the lwip network interface structure for this ethernetif
--  * @return ERR_OK if the loopif is initialized
--  *         ERR_MEM if private data couldn't be allocated
--  *         any other err_t on error
--  */
--err_t ethernetif_init(struct netif *netif)
--{
--  LWIP_ASSERT("netif != NULL", (netif != NULL));
--
--#if LWIP_NETIF_HOSTNAME
--  /* Initialize interface hostname */
--  netif->hostname = "lwip";
--#endif /* LWIP_NETIF_HOSTNAME */
--
--  netif->name[0] = IFNAME0;
--  netif->name[1] = IFNAME1;
--
--  netif->output = etharp_output;
--  netif->linkoutput = low_level_output;
--
--  /* initialize the hardware */
--  low_level_init(netif);
--
--  return ERR_OK;
--}
--
--/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
--- 
-1.9.1
-
-
-From 31d34fab26b1e3fde99fe7288786725fe5e51b95 Mon Sep 17 00:00:00 2001
-From: Jay Doyle <jay.doyle@vecna.com>
-Date: Mon, 7 Sep 2015 10:17:32 -0400
-Subject: [PATCH 06/10] add low level driver back
-
----
- src/netif/ethernetif.c | 496 +++++++++++++++++++++++++++++++++++++++++++++++++
- 1 file changed, 496 insertions(+)
- create mode 100644 src/netif/ethernetif.c
-
-diff --git a/src/netif/ethernetif.c b/src/netif/ethernetif.c
-new file mode 100644
-index 0000000..bc429e9
---- /dev/null
-+++ b/src/netif/ethernetif.c
-@@ -0,0 +1,496 @@
-+/**
-+  ******************************************************************************
-+  * @file    LwIP/LwIP_HTTP_Server_Netconn_RTOS/Src/ethernetif.c
-+  * @author  MCD Application Team
-+  * @version V1.0.0
-+  * @date    25-June-2015
-+  * @brief   This file implements Ethernet network interface drivers for lwIP
-+  ******************************************************************************
-+  * @attention
-+  *
-+  * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
-+  *
-+  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
-+  * You may not use this file except in compliance with the License.
-+  * You may obtain a copy of the License at:
-+  *
-+  *        http://www.st.com/software_license_agreement_liberty_v2
-+  *
-+  * Unless required by applicable law or agreed to in writing, software 
-+  * distributed under the License is distributed on an "AS IS" BASIS, 
-+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-+  * See the License for the specific language governing permissions and
-+  * limitations under the License.
-+  *
-+  ******************************************************************************
-+  */
-+
-+/* Includes ------------------------------------------------------------------*/
-+#include <stm32f7xx_hal.h>
-+#include <lwip/opt.h>
-+#include <lwip/lwip_timers.h>
-+#include <netif/etharp.h>
-+#include <hal-ethernetif.h>
-+#include <string.h>
-+
-+/* Private typedef -----------------------------------------------------------*/
-+/* Private define ------------------------------------------------------------*/
-+/* The time to block waiting for input. */
-+#define TIME_WAITING_FOR_INPUT                 ( 100 )
-+/* Stack size of the interface thread */
-+#define INTERFACE_THREAD_STACK_SIZE            ( 350 )
-+
-+/* Define those to better describe your network interface. */
-+#define IFNAME0 'e'
-+#define IFNAME1 'n'
-+
-+#define LAN8742A_PHY_ADDRESS            0x00
-+
-+/* Private macro -------------------------------------------------------------*/
-+/* Private variables ---------------------------------------------------------*/
-+
-+#if defined ( __ICCARM__ ) /*!< IAR Compiler */
-+
-+#pragma location=0x2000E000
-+__no_init ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
-+#pragma location=0x2000E100
-+__no_init ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
-+#elif defined ( __CC_ARM   )
-+ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((at(0x2000E000)));/* Ethernet Rx MA Descriptor */
-+ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((at(0x2000E100)));/* Ethernet Tx DMA Descriptor */
-+#elif defined ( __GNUC__   )
-+//ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".RxDescripSection")));/* Ethernet Rx MA Descriptor */
-+//ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".TxDescripSection")));/* Ethernet Tx DMA Descriptor */
-+ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Rx MA Descriptor */
-+ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Tx DMA Descriptor */
-+
-+
-+#endif
-+#if defined ( __ICCARM__ ) /*!< IAR Compiler */
-+#pragma location=0x2000E200
-+__no_init uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
-+#pragma location=0x2000FFC4
-+__no_init uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
-+#elif defined ( __CC_ARM   )
-+uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((at(0x2000E200)));  /* Ethernet Receive Buffer */
-+uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]  __attribute__((at(0x2000FFC4))); /* Ethernet Transmit Buffer */
-+#elif defined ( __GNUC__   )
-+//uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".RxBUF")));/* Ethernet Receive Buffer */
-+//uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".TxBUF")));/* Ethernet Transmit Buffer */
-+uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Receive Buffer */
-+uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Transmit Buffer */
-+
-+#endif
-+/* Semaphore to signal incoming packets */
-+osSemaphoreId s_xSemaphore = NULL;
-+
-+/* Global Ethernet handle*/
-+ETH_HandleTypeDef EthHandle;
-+
-+/* Private function prototypes -----------------------------------------------*/
-+static void ethernetif_input( void const * argument );
-+
-+static void stm32f_ethernet_isr(
-+  void* argData
-+)
-+{
-+  ETH_HandleTypeDef* pEth =
-+    (ETH_HandleTypeDef*) argData;
-+
-+  HAL_ETH_IRQHandler(pEth);
-+}
-+
-+/* Private functions ---------------------------------------------------------*/
-+/*******************************************************************************
-+                       Ethernet MSP Routines
-+*******************************************************************************/
-+/**
-+  * @brief  Initializes the ETH MSP.
-+  * @param  heth: ETH handle
-+  * @retval None
-+  */
-+void HAL_ETH_MspInit(ETH_HandleTypeDef *heth)
-+{
-+  GPIO_InitTypeDef GPIO_InitStructure;
-+  
-+  /* Enable GPIOs clocks */
-+  __HAL_RCC_GPIOA_CLK_ENABLE();
-+  __HAL_RCC_GPIOC_CLK_ENABLE();
-+  __HAL_RCC_GPIOG_CLK_ENABLE();
-+
-+/* Ethernet pins configuration ************************************************/
-+  /*
-+        RMII_REF_CLK ----------------------> PA1
-+        RMII_MDIO -------------------------> PA2
-+        RMII_MDC --------------------------> PC1
-+        RMII_MII_CRS_DV -------------------> PA7
-+        RMII_MII_RXD0 ---------------------> PC4
-+        RMII_MII_RXD1 ---------------------> PC5
-+        RMII_MII_RXER ---------------------> PG2
-+        RMII_MII_TX_EN --------------------> PG11
-+        RMII_MII_TXD0 ---------------------> PG13
-+        RMII_MII_TXD1 ---------------------> PG14
-+  */
-+
-+  /* Configure PA1, PA2 and PA7 */
-+  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
-+  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
-+  GPIO_InitStructure.Pull = GPIO_NOPULL; 
-+  GPIO_InitStructure.Alternate = GPIO_AF11_ETH;
-+  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
-+  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
-+  
-+  /* Configure PC1, PC4 and PC5 */
-+  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;
-+  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
-+
-+  /* Configure PG2, PG11, PG13 and PG14 */
-+  GPIO_InitStructure.Pin =  GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14;
-+  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
-+  
-+  // Install HAL Ethernet ISR
-+  rtems_interrupt_handler_install(
-+    ETH_IRQn,
-+    NULL,
-+    0,
-+    stm32f_ethernet_isr,
-+    heth);
-+  
-+  /* Enable ETHERNET clock  */
-+  __HAL_RCC_ETH_CLK_ENABLE();
-+}
-+
-+/**
-+  * @brief  Ethernet Rx Transfer completed callback
-+  * @param  heth: ETH handle
-+  * @retval None
-+  */
-+void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
-+{
-+  osSemaphoreRelease(s_xSemaphore);
-+}
-+
-+/**
-+  * @brief  Ethernet IRQ Handler
-+  * @param  None
-+  * @retval None
-+  */
-+void ETHERNET_IRQHandler(void)
-+{
-+  HAL_ETH_IRQHandler(&EthHandle);
-+}
-+
-+/*******************************************************************************
-+                       LL Driver Interface ( LwIP stack --> ETH) 
-+*******************************************************************************/
-+/**
-+  * @brief In this function, the hardware should be initialized.
-+  * Called from ethernetif_init().
-+  *
-+  * @param netif the already initialized lwip network interface structure
-+  *        for this ethernetif
-+  */
-+static void low_level_init(struct netif *netif)
-+{
-+  uint8_t macaddress[6]= { MAC_ADDR0, MAC_ADDR1, MAC_ADDR2, MAC_ADDR3, MAC_ADDR4, MAC_ADDR5 };
-+  
-+  EthHandle.Instance = ETH;  
-+  EthHandle.Init.MACAddr = macaddress;
-+  EthHandle.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
-+  EthHandle.Init.Speed = ETH_SPEED_100M;
-+  EthHandle.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
-+  EthHandle.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
-+  EthHandle.Init.RxMode = ETH_RXINTERRUPT_MODE;
-+  EthHandle.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
-+  EthHandle.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
-+  
-+  /* configure ethernet peripheral (GPIOs, clocks, MAC, DMA) */
-+  if (HAL_ETH_Init(&EthHandle) == HAL_OK)
-+  {
-+    /* Set netif link flag */
-+    netif->flags |= NETIF_FLAG_LINK_UP;
-+  }
-+  
-+  /* Initialize Tx Descriptors list: Chain Mode */
-+  HAL_ETH_DMATxDescListInit(&EthHandle, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
-+     
-+  /* Initialize Rx Descriptors list: Chain Mode  */
-+  HAL_ETH_DMARxDescListInit(&EthHandle, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
-+  
-+  /* set netif MAC hardware address length */
-+  netif->hwaddr_len = ETHARP_HWADDR_LEN;
-+
-+  /* set netif MAC hardware address */
-+  netif->hwaddr[0] =  MAC_ADDR0;
-+  netif->hwaddr[1] =  MAC_ADDR1;
-+  netif->hwaddr[2] =  MAC_ADDR2;
-+  netif->hwaddr[3] =  MAC_ADDR3;
-+  netif->hwaddr[4] =  MAC_ADDR4;
-+  netif->hwaddr[5] =  MAC_ADDR5;
-+
-+  /* set netif maximum transfer unit */
-+  netif->mtu = 1500;
-+
-+  /* Accept broadcast address and ARP traffic */
-+  netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
-+
-+  /* create a binary semaphore used for informing ethernetif of frame reception */
-+  osSemaphoreDef(SEM);
-+  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1 );
-+
-+  /* create the task that handles the ETH_MAC */
-+  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
-+  osThreadCreate (osThread(EthIf), netif);
-+
-+  /* Enable MAC and DMA transmission and reception */
-+  HAL_ETH_Start(&EthHandle);
-+}
-+
-+
-+/**
-+  * @brief This function should do the actual transmission of the packet. The packet is
-+  * contained in the pbuf that is passed to the function. This pbuf
-+  * might be chained.
-+  *
-+  * @param netif the lwip network interface structure for this ethernetif
-+  * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
-+  * @return ERR_OK if the packet could be sent
-+  *         an err_t value if the packet couldn't be sent
-+  *
-+  * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
-+  *       strange results. You might consider waiting for space in the DMA queue
-+  *       to become available since the stack doesn't retry to send a packet
-+  *       dropped because of memory failure (except for the TCP timers).
-+  */
-+static err_t low_level_output(struct netif *netif, struct pbuf *p)
-+{
-+  err_t errval;
-+  struct pbuf *q;
-+  uint8_t *buffer = (uint8_t *)(EthHandle.TxDesc->Buffer1Addr);
-+  __IO ETH_DMADescTypeDef *DmaTxDesc;
-+  uint32_t framelength = 0;
-+  uint32_t bufferoffset = 0;
-+  uint32_t byteslefttocopy = 0;
-+  uint32_t payloadoffset = 0;
-+
-+  DmaTxDesc = EthHandle.TxDesc;
-+  bufferoffset = 0;
-+  
-+  /* copy frame from pbufs to driver buffers */
-+  for(q = p; q != NULL; q = q->next)
-+  {
-+    /* Is this buffer available? If not, goto error */
-+    if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
-+    {
-+      errval = ERR_USE;
-+      goto error;
-+    }
-+    
-+    /* Get bytes in current lwIP buffer */
-+    byteslefttocopy = q->len;
-+    payloadoffset = 0;
-+    
-+    /* Check if the length of data to copy is bigger than Tx buffer size*/
-+    while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
-+    {
-+      /* Copy data to Tx buffer*/
-+      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
-+      
-+      /* Point to next descriptor */
-+      DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
-+      
-+      /* Check if the buffer is available */
-+      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
-+      {
-+        errval = ERR_USE;
-+        goto error;
-+      }
-+      
-+      buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
-+      
-+      byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
-+      payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
-+      framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
-+      bufferoffset = 0;
-+    }
-+    
-+    /* Copy the remaining bytes */
-+    memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
-+    bufferoffset = bufferoffset + byteslefttocopy;
-+    framelength = framelength + byteslefttocopy;
-+  }
-+  
-+  /* Prepare transmit descriptors to give to DMA */ 
-+  HAL_ETH_TransmitFrame(&EthHandle, framelength);
-+  
-+  errval = ERR_OK;
-+  
-+error:
-+  
-+  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
-+  if ((EthHandle.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
-+  {
-+    /* Clear TUS ETHERNET DMA flag */
-+    EthHandle.Instance->DMASR = ETH_DMASR_TUS;
-+    
-+    /* Resume DMA transmission*/
-+    EthHandle.Instance->DMATPDR = 0;
-+  }
-+  return errval;
-+}
-+
-+/**
-+  * @brief Should allocate a pbuf and transfer the bytes of the incoming
-+  * packet from the interface into the pbuf.
-+  *
-+  * @param netif the lwip network interface structure for this ethernetif
-+  * @return a pbuf filled with the received packet (including MAC header)
-+  *         NULL on memory error
-+  */
-+static struct pbuf * low_level_input(struct netif *netif)
-+{
-+  struct pbuf *p = NULL, *q = NULL;
-+  uint16_t len = 0;
-+  uint8_t *buffer;
-+  __IO ETH_DMADescTypeDef *dmarxdesc;
-+  uint32_t bufferoffset = 0;
-+  uint32_t payloadoffset = 0;
-+  uint32_t byteslefttocopy = 0;
-+  uint32_t i=0;
-+  
-+  /* get received frame */
-+  if(HAL_ETH_GetReceivedFrame_IT(&EthHandle) != HAL_OK)
-+    return NULL;
-+  
-+  /* Obtain the size of the packet and put it into the "len" variable. */
-+  len = EthHandle.RxFrameInfos.length;
-+  buffer = (uint8_t *)EthHandle.RxFrameInfos.buffer;
-+  
-+  if (len > 0)
-+  {
-+    /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
-+    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
-+  }
-+  
-+  if (p != NULL)
-+  {
-+    dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
-+    bufferoffset = 0;
-+    
-+    for(q = p; q != NULL; q = q->next)
-+    {
-+      byteslefttocopy = q->len;
-+      payloadoffset = 0;
-+      
-+      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size */
-+      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
-+      {
-+        /* Copy data to pbuf */
-+        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
-+        
-+        /* Point to next descriptor */
-+        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
-+        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
-+        
-+        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
-+        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
-+        bufferoffset = 0;
-+      }
-+      
-+      /* Copy remaining data in pbuf */
-+      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
-+      bufferoffset = bufferoffset + byteslefttocopy;
-+    }
-+  }
-+    
-+  /* Release descriptors to DMA */
-+  /* Point to first descriptor */
-+  dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
-+  /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
-+  for (i=0; i< EthHandle.RxFrameInfos.SegCount; i++)
-+  {  
-+    dmarxdesc->Status |= ETH_DMARXDESC_OWN;
-+    dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
-+  }
-+    
-+  /* Clear Segment_Count */
-+  EthHandle.RxFrameInfos.SegCount =0;
-+  
-+  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
-+  if ((EthHandle.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
-+  {
-+    /* Clear RBUS ETHERNET DMA flag */
-+    EthHandle.Instance->DMASR = ETH_DMASR_RBUS;
-+    /* Resume DMA reception */
-+    EthHandle.Instance->DMARPDR = 0;
-+  }
-+  return p;
-+}
-+
-+/**
-+  * @brief This function is the ethernetif_input task, it is processed when a packet 
-+  * is ready to be read from the interface. It uses the function low_level_input() 
-+  * that should handle the actual reception of bytes from the network
-+  * interface. Then the type of the received packet is determined and
-+  * the appropriate input function is called.
-+  *
-+  * @param netif the lwip network interface structure for this ethernetif
-+  */
-+void ethernetif_input( void const * argument )
-+{
-+  struct pbuf *p;
-+  struct netif *netif = (struct netif *) argument;
-+  
-+  for( ;; )
-+  {
-+    if (osSemaphoreWait( s_xSemaphore, TIME_WAITING_FOR_INPUT)==osOK)
-+    {
-+      do
-+      {
-+        p = low_level_input( netif );
-+        if (p != NULL)
-+        {
-+          if (netif->input( p, netif) != ERR_OK )
-+          {
-+            pbuf_free(p);
-+          }
-+        }
-+      }while(p!=NULL);
-+    }
-+  }
-+}
-+
-+/**
-+  * @brief Should be called at the beginning of the program to set up the
-+  * network interface. It calls the function low_level_init() to do the
-+  * actual setup of the hardware.
-+  *
-+  * This function should be passed as a parameter to netif_add().
-+  *
-+  * @param netif the lwip network interface structure for this ethernetif
-+  * @return ERR_OK if the loopif is initialized
-+  *         ERR_MEM if private data couldn't be allocated
-+  *         any other err_t on error
-+  */
-+err_t ethernetif_init(struct netif *netif)
-+{
-+  LWIP_ASSERT("netif != NULL", (netif != NULL));
-+
-+#if LWIP_NETIF_HOSTNAME
-+  /* Initialize interface hostname */
-+  netif->hostname = "lwip";
-+#endif /* LWIP_NETIF_HOSTNAME */
-+
-+  netif->name[0] = IFNAME0;
-+  netif->name[1] = IFNAME1;
-+
-+  netif->output = etharp_output;
-+  netif->linkoutput = low_level_output;
-+
-+  /* initialize the hardware */
-+  low_level_init(netif);
-+
-+  return ERR_OK;
-+}
-+
-+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
--- 
-1.9.1
-
-
-From 81eded01bb2bc35a9b627e5cf35b2021efb5972c Mon Sep 17 00:00:00 2001
-From: Jay Doyle <jay.doyle@vecna.com>
-Date: Mon, 7 Sep 2015 10:22:57 -0400
-Subject: [PATCH 07/10] Added bsp path
-
----
- Makefile | 4 +++-
- 1 file changed, 3 insertions(+), 1 deletion(-)
-
-diff --git a/Makefile b/Makefile
-index 6efa141..a855d9f 100644
---- a/Makefile
-+++ b/Makefile
-@@ -13,6 +13,8 @@ LWIP_EXEC=lwip
- 
- #### PATHS #####################################################################
- 
-+BSP_PATH=/opt/rtems-4.11/arm-rtems4.11/stm32f7x/lib/include/bsp
-+
- # LWIP
- LWIP_PATH=.
- LWIP_SRC_PATH=$(LWIP_PATH)/src
-@@ -97,7 +99,7 @@ DRIVER_H=$(LWIPDRIVER_INCL_PATH)
- # HEADERS
- HEADERS=-I$(CORE_H) -I$(POSIX_H) -I$(POSIX_SYS_H) -I$(NETIF_H) \
-         -I$(NETIF_H_PPP) -I$(NETIF_H_PPP_POLARSSL) -I$(ARCH_H) \
--        -I$(DRIVER_H) -I$(IPV4_H)
-+        -I$(DRIVER_H) -I$(IPV4_H) -I$(BSP_PATH)
- 
- 
- ################################################################################
--- 
-1.9.1
-
-
-From f114529d5af1e2a83b49b67d631b10c02648e8d8 Mon Sep 17 00:00:00 2001
-From: Jay Doyle <jay.doyle@vecna.com>
-Date: Mon, 7 Sep 2015 10:54:26 -0400
-Subject: [PATCH 08/10] removed ethernetif.c
-
----
- src/netif/ethernetif.c | 496 -------------------------------------------------
- 1 file changed, 496 deletions(-)
- delete mode 100644 src/netif/ethernetif.c
-
-diff --git a/src/netif/ethernetif.c b/src/netif/ethernetif.c
-deleted file mode 100644
-index bc429e9..0000000
---- a/src/netif/ethernetif.c
-+++ /dev/null
-@@ -1,496 +0,0 @@
--/**
--  ******************************************************************************
--  * @file    LwIP/LwIP_HTTP_Server_Netconn_RTOS/Src/ethernetif.c
--  * @author  MCD Application Team
--  * @version V1.0.0
--  * @date    25-June-2015
--  * @brief   This file implements Ethernet network interface drivers for lwIP
--  ******************************************************************************
--  * @attention
--  *
--  * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
--  *
--  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
--  * You may not use this file except in compliance with the License.
--  * You may obtain a copy of the License at:
--  *
--  *        http://www.st.com/software_license_agreement_liberty_v2
--  *
--  * Unless required by applicable law or agreed to in writing, software 
--  * distributed under the License is distributed on an "AS IS" BASIS, 
--  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
--  * See the License for the specific language governing permissions and
--  * limitations under the License.
--  *
--  ******************************************************************************
--  */
--
--/* Includes ------------------------------------------------------------------*/
--#include <stm32f7xx_hal.h>
--#include <lwip/opt.h>
--#include <lwip/lwip_timers.h>
--#include <netif/etharp.h>
--#include <hal-ethernetif.h>
--#include <string.h>
--
--/* Private typedef -----------------------------------------------------------*/
--/* Private define ------------------------------------------------------------*/
--/* The time to block waiting for input. */
--#define TIME_WAITING_FOR_INPUT                 ( 100 )
--/* Stack size of the interface thread */
--#define INTERFACE_THREAD_STACK_SIZE            ( 350 )
--
--/* Define those to better describe your network interface. */
--#define IFNAME0 'e'
--#define IFNAME1 'n'
--
--#define LAN8742A_PHY_ADDRESS            0x00
--
--/* Private macro -------------------------------------------------------------*/
--/* Private variables ---------------------------------------------------------*/
--
--#if defined ( __ICCARM__ ) /*!< IAR Compiler */
--
--#pragma location=0x2000E000
--__no_init ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
--#pragma location=0x2000E100
--__no_init ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
--#elif defined ( __CC_ARM   )
--ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((at(0x2000E000)));/* Ethernet Rx MA Descriptor */
--ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((at(0x2000E100)));/* Ethernet Tx DMA Descriptor */
--#elif defined ( __GNUC__   )
--//ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".RxDescripSection")));/* Ethernet Rx MA Descriptor */
--//ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".TxDescripSection")));/* Ethernet Tx DMA Descriptor */
--ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Rx MA Descriptor */
--ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Tx DMA Descriptor */
--
--
--#endif
--#if defined ( __ICCARM__ ) /*!< IAR Compiler */
--#pragma location=0x2000E200
--__no_init uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
--#pragma location=0x2000FFC4
--__no_init uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
--#elif defined ( __CC_ARM   )
--uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((at(0x2000E200)));  /* Ethernet Receive Buffer */
--uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]  __attribute__((at(0x2000FFC4))); /* Ethernet Transmit Buffer */
--#elif defined ( __GNUC__   )
--//uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".RxBUF")));/* Ethernet Receive Buffer */
--//uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".TxBUF")));/* Ethernet Transmit Buffer */
--uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Receive Buffer */
--uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Transmit Buffer */
--
--#endif
--/* Semaphore to signal incoming packets */
--osSemaphoreId s_xSemaphore = NULL;
--
--/* Global Ethernet handle*/
--ETH_HandleTypeDef EthHandle;
--
--/* Private function prototypes -----------------------------------------------*/
--static void ethernetif_input( void const * argument );
--
--static void stm32f_ethernet_isr(
--  void* argData
--)
--{
--  ETH_HandleTypeDef* pEth =
--    (ETH_HandleTypeDef*) argData;
--
--  HAL_ETH_IRQHandler(pEth);
--}
--
--/* Private functions ---------------------------------------------------------*/
--/*******************************************************************************
--                       Ethernet MSP Routines
--*******************************************************************************/
--/**
--  * @brief  Initializes the ETH MSP.
--  * @param  heth: ETH handle
--  * @retval None
--  */
--void HAL_ETH_MspInit(ETH_HandleTypeDef *heth)
--{
--  GPIO_InitTypeDef GPIO_InitStructure;
--  
--  /* Enable GPIOs clocks */
--  __HAL_RCC_GPIOA_CLK_ENABLE();
--  __HAL_RCC_GPIOC_CLK_ENABLE();
--  __HAL_RCC_GPIOG_CLK_ENABLE();
--
--/* Ethernet pins configuration ************************************************/
--  /*
--        RMII_REF_CLK ----------------------> PA1
--        RMII_MDIO -------------------------> PA2
--        RMII_MDC --------------------------> PC1
--        RMII_MII_CRS_DV -------------------> PA7
--        RMII_MII_RXD0 ---------------------> PC4
--        RMII_MII_RXD1 ---------------------> PC5
--        RMII_MII_RXER ---------------------> PG2
--        RMII_MII_TX_EN --------------------> PG11
--        RMII_MII_TXD0 ---------------------> PG13
--        RMII_MII_TXD1 ---------------------> PG14
--  */
--
--  /* Configure PA1, PA2 and PA7 */
--  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
--  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
--  GPIO_InitStructure.Pull = GPIO_NOPULL; 
--  GPIO_InitStructure.Alternate = GPIO_AF11_ETH;
--  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
--  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
--  
--  /* Configure PC1, PC4 and PC5 */
--  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;
--  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
--
--  /* Configure PG2, PG11, PG13 and PG14 */
--  GPIO_InitStructure.Pin =  GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14;
--  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
--  
--  // Install HAL Ethernet ISR
--  rtems_interrupt_handler_install(
--    ETH_IRQn,
--    NULL,
--    0,
--    stm32f_ethernet_isr,
--    heth);
--  
--  /* Enable ETHERNET clock  */
--  __HAL_RCC_ETH_CLK_ENABLE();
--}
--
--/**
--  * @brief  Ethernet Rx Transfer completed callback
--  * @param  heth: ETH handle
--  * @retval None
--  */
--void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
--{
--  osSemaphoreRelease(s_xSemaphore);
--}
--
--/**
--  * @brief  Ethernet IRQ Handler
--  * @param  None
--  * @retval None
--  */
--void ETHERNET_IRQHandler(void)
--{
--  HAL_ETH_IRQHandler(&EthHandle);
--}
--
--/*******************************************************************************
--                       LL Driver Interface ( LwIP stack --> ETH) 
--*******************************************************************************/
--/**
--  * @brief In this function, the hardware should be initialized.
--  * Called from ethernetif_init().
--  *
--  * @param netif the already initialized lwip network interface structure
--  *        for this ethernetif
--  */
--static void low_level_init(struct netif *netif)
--{
--  uint8_t macaddress[6]= { MAC_ADDR0, MAC_ADDR1, MAC_ADDR2, MAC_ADDR3, MAC_ADDR4, MAC_ADDR5 };
--  
--  EthHandle.Instance = ETH;  
--  EthHandle.Init.MACAddr = macaddress;
--  EthHandle.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
--  EthHandle.Init.Speed = ETH_SPEED_100M;
--  EthHandle.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
--  EthHandle.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
--  EthHandle.Init.RxMode = ETH_RXINTERRUPT_MODE;
--  EthHandle.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
--  EthHandle.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
--  
--  /* configure ethernet peripheral (GPIOs, clocks, MAC, DMA) */
--  if (HAL_ETH_Init(&EthHandle) == HAL_OK)
--  {
--    /* Set netif link flag */
--    netif->flags |= NETIF_FLAG_LINK_UP;
--  }
--  
--  /* Initialize Tx Descriptors list: Chain Mode */
--  HAL_ETH_DMATxDescListInit(&EthHandle, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
--     
--  /* Initialize Rx Descriptors list: Chain Mode  */
--  HAL_ETH_DMARxDescListInit(&EthHandle, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
--  
--  /* set netif MAC hardware address length */
--  netif->hwaddr_len = ETHARP_HWADDR_LEN;
--
--  /* set netif MAC hardware address */
--  netif->hwaddr[0] =  MAC_ADDR0;
--  netif->hwaddr[1] =  MAC_ADDR1;
--  netif->hwaddr[2] =  MAC_ADDR2;
--  netif->hwaddr[3] =  MAC_ADDR3;
--  netif->hwaddr[4] =  MAC_ADDR4;
--  netif->hwaddr[5] =  MAC_ADDR5;
--
--  /* set netif maximum transfer unit */
--  netif->mtu = 1500;
--
--  /* Accept broadcast address and ARP traffic */
--  netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
--
--  /* create a binary semaphore used for informing ethernetif of frame reception */
--  osSemaphoreDef(SEM);
--  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1 );
--
--  /* create the task that handles the ETH_MAC */
--  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
--  osThreadCreate (osThread(EthIf), netif);
--
--  /* Enable MAC and DMA transmission and reception */
--  HAL_ETH_Start(&EthHandle);
--}
--
--
--/**
--  * @brief This function should do the actual transmission of the packet. The packet is
--  * contained in the pbuf that is passed to the function. This pbuf
--  * might be chained.
--  *
--  * @param netif the lwip network interface structure for this ethernetif
--  * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
--  * @return ERR_OK if the packet could be sent
--  *         an err_t value if the packet couldn't be sent
--  *
--  * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
--  *       strange results. You might consider waiting for space in the DMA queue
--  *       to become available since the stack doesn't retry to send a packet
--  *       dropped because of memory failure (except for the TCP timers).
--  */
--static err_t low_level_output(struct netif *netif, struct pbuf *p)
--{
--  err_t errval;
--  struct pbuf *q;
--  uint8_t *buffer = (uint8_t *)(EthHandle.TxDesc->Buffer1Addr);
--  __IO ETH_DMADescTypeDef *DmaTxDesc;
--  uint32_t framelength = 0;
--  uint32_t bufferoffset = 0;
--  uint32_t byteslefttocopy = 0;
--  uint32_t payloadoffset = 0;
--
--  DmaTxDesc = EthHandle.TxDesc;
--  bufferoffset = 0;
--  
--  /* copy frame from pbufs to driver buffers */
--  for(q = p; q != NULL; q = q->next)
--  {
--    /* Is this buffer available? If not, goto error */
--    if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
--    {
--      errval = ERR_USE;
--      goto error;
--    }
--    
--    /* Get bytes in current lwIP buffer */
--    byteslefttocopy = q->len;
--    payloadoffset = 0;
--    
--    /* Check if the length of data to copy is bigger than Tx buffer size*/
--    while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
--    {
--      /* Copy data to Tx buffer*/
--      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
--      
--      /* Point to next descriptor */
--      DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
--      
--      /* Check if the buffer is available */
--      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
--      {
--        errval = ERR_USE;
--        goto error;
--      }
--      
--      buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
--      
--      byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
--      payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
--      framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
--      bufferoffset = 0;
--    }
--    
--    /* Copy the remaining bytes */
--    memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
--    bufferoffset = bufferoffset + byteslefttocopy;
--    framelength = framelength + byteslefttocopy;
--  }
--  
--  /* Prepare transmit descriptors to give to DMA */ 
--  HAL_ETH_TransmitFrame(&EthHandle, framelength);
--  
--  errval = ERR_OK;
--  
--error:
--  
--  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
--  if ((EthHandle.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
--  {
--    /* Clear TUS ETHERNET DMA flag */
--    EthHandle.Instance->DMASR = ETH_DMASR_TUS;
--    
--    /* Resume DMA transmission*/
--    EthHandle.Instance->DMATPDR = 0;
--  }
--  return errval;
--}
--
--/**
--  * @brief Should allocate a pbuf and transfer the bytes of the incoming
--  * packet from the interface into the pbuf.
--  *
--  * @param netif the lwip network interface structure for this ethernetif
--  * @return a pbuf filled with the received packet (including MAC header)
--  *         NULL on memory error
--  */
--static struct pbuf * low_level_input(struct netif *netif)
--{
--  struct pbuf *p = NULL, *q = NULL;
--  uint16_t len = 0;
--  uint8_t *buffer;
--  __IO ETH_DMADescTypeDef *dmarxdesc;
--  uint32_t bufferoffset = 0;
--  uint32_t payloadoffset = 0;
--  uint32_t byteslefttocopy = 0;
--  uint32_t i=0;
--  
--  /* get received frame */
--  if(HAL_ETH_GetReceivedFrame_IT(&EthHandle) != HAL_OK)
--    return NULL;
--  
--  /* Obtain the size of the packet and put it into the "len" variable. */
--  len = EthHandle.RxFrameInfos.length;
--  buffer = (uint8_t *)EthHandle.RxFrameInfos.buffer;
--  
--  if (len > 0)
--  {
--    /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
--    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
--  }
--  
--  if (p != NULL)
--  {
--    dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
--    bufferoffset = 0;
--    
--    for(q = p; q != NULL; q = q->next)
--    {
--      byteslefttocopy = q->len;
--      payloadoffset = 0;
--      
--      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size */
--      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
--      {
--        /* Copy data to pbuf */
--        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
--        
--        /* Point to next descriptor */
--        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
--        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
--        
--        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
--        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
--        bufferoffset = 0;
--      }
--      
--      /* Copy remaining data in pbuf */
--      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
--      bufferoffset = bufferoffset + byteslefttocopy;
--    }
--  }
--    
--  /* Release descriptors to DMA */
--  /* Point to first descriptor */
--  dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
--  /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
--  for (i=0; i< EthHandle.RxFrameInfos.SegCount; i++)
--  {  
--    dmarxdesc->Status |= ETH_DMARXDESC_OWN;
--    dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
--  }
--    
--  /* Clear Segment_Count */
--  EthHandle.RxFrameInfos.SegCount =0;
--  
--  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
--  if ((EthHandle.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
--  {
--    /* Clear RBUS ETHERNET DMA flag */
--    EthHandle.Instance->DMASR = ETH_DMASR_RBUS;
--    /* Resume DMA reception */
--    EthHandle.Instance->DMARPDR = 0;
--  }
--  return p;
--}
--
--/**
--  * @brief This function is the ethernetif_input task, it is processed when a packet 
--  * is ready to be read from the interface. It uses the function low_level_input() 
--  * that should handle the actual reception of bytes from the network
--  * interface. Then the type of the received packet is determined and
--  * the appropriate input function is called.
--  *
--  * @param netif the lwip network interface structure for this ethernetif
--  */
--void ethernetif_input( void const * argument )
--{
--  struct pbuf *p;
--  struct netif *netif = (struct netif *) argument;
--  
--  for( ;; )
--  {
--    if (osSemaphoreWait( s_xSemaphore, TIME_WAITING_FOR_INPUT)==osOK)
--    {
--      do
--      {
--        p = low_level_input( netif );
--        if (p != NULL)
--        {
--          if (netif->input( p, netif) != ERR_OK )
--          {
--            pbuf_free(p);
--          }
--        }
--      }while(p!=NULL);
--    }
--  }
--}
--
--/**
--  * @brief Should be called at the beginning of the program to set up the
--  * network interface. It calls the function low_level_init() to do the
--  * actual setup of the hardware.
--  *
--  * This function should be passed as a parameter to netif_add().
--  *
--  * @param netif the lwip network interface structure for this ethernetif
--  * @return ERR_OK if the loopif is initialized
--  *         ERR_MEM if private data couldn't be allocated
--  *         any other err_t on error
--  */
--err_t ethernetif_init(struct netif *netif)
--{
--  LWIP_ASSERT("netif != NULL", (netif != NULL));
--
--#if LWIP_NETIF_HOSTNAME
--  /* Initialize interface hostname */
--  netif->hostname = "lwip";
--#endif /* LWIP_NETIF_HOSTNAME */
--
--  netif->name[0] = IFNAME0;
--  netif->name[1] = IFNAME1;
--
--  netif->output = etharp_output;
--  netif->linkoutput = low_level_output;
--
--  /* initialize the hardware */
--  low_level_init(netif);
--
--  return ERR_OK;
--}
--
--/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
--- 
-1.9.1
-
-
-From 8f652ac0f1be0f2abc1493981763fc4c402bbfed Mon Sep 17 00:00:00 2001
-From: Jay Doyle <jay.doyle@vecna.com>
-Date: Wed, 16 Sep 2015 09:29:27 -0400
-Subject: [PATCH 09/13] using options from sample project
-
----
- ports/include/lwipopts.h | 207 +++++++++++++++++++++++++++++++++++++++++++++++
- 1 file changed, 207 insertions(+)
-
-diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
-index 169ba46..68d799b 100644
---- a/ports/include/lwipopts.h
-+++ b/ports/include/lwipopts.h
-@@ -38,6 +38,9 @@
- #ifndef __LWIPOPTS_H__
- #define __LWIPOPTS_H__
- 
-+
-+#if ORIGINAL_CONFIG_OPTIONS
-+
- /*****************************************************************************
- **                           CONFIGURATIONS
- *****************************************************************************/
-@@ -175,4 +178,208 @@
- 
-  #define LWIP_RAW                       0
- 
-+#else
-+
-+/**
-+ * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
-+ * critical regions during buffer allocation, deallocation and memory
-+ * allocation and deallocation.
-+ */
-+#define SYS_LIGHTWEIGHT_PROT    0
-+
-+#define ETHARP_TRUST_IP_MAC     0
-+#define IP_REASSEMBLY           0
-+#define IP_FRAG                 0
-+#define ARP_QUEUEING            0
-+#define TCP_LISTEN_BACKLOG      1
-+
-+/**
-+ * NO_SYS==1: Provides VERY minimal functionality. Otherwise,
-+ * use lwIP facilities.
-+ */
-+#define NO_SYS                  0
-+
-+/* ---------- Memory options ---------- */
-+/* MEM_ALIGNMENT: should be set to the alignment of the CPU for which
-+   lwIP is compiled. 4 byte alignment -> define MEM_ALIGNMENT to 4, 2
-+   byte alignment -> define MEM_ALIGNMENT to 2. */
-+#define MEM_ALIGNMENT           4
-+
-+/* MEM_SIZE: the size of the heap memory. If the application will send
-+a lot of data that needs to be copied, this should be set high. */
-+#define MEM_SIZE                (10*1024)
-+
-+/* MEMP_NUM_PBUF: the number of memp struct pbufs. If the application
-+   sends a lot of data out of ROM (or other static memory), this
-+   should be set high. */
-+#define MEMP_NUM_PBUF           50
-+/* MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks. One
-+   per active UDP "connection". */
-+#define MEMP_NUM_UDP_PCB        6
-+/* MEMP_NUM_TCP_PCB: the number of simulatenously active TCP
-+   connections. */
-+#define MEMP_NUM_TCP_PCB        10
-+/* MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP
-+   connections. */
-+#define MEMP_NUM_TCP_PCB_LISTEN 5
-+/* MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP
-+   segments. */
-+#define MEMP_NUM_TCP_SEG        12
-+/* MEMP_NUM_SYS_TIMEOUT: the number of simulateously active
-+   timeouts. */
-+#define MEMP_NUM_SYS_TIMEOUT    10
-+
-+
-+/* ---------- Pbuf options ---------- */
-+/* PBUF_POOL_SIZE: the number of buffers in the pbuf pool. */
-+#define PBUF_POOL_SIZE          10
-+
-+/* PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. */
-+#define PBUF_POOL_BUFSIZE       1524
-+
-+
-+/* ---------- TCP options ---------- */
-+#define LWIP_TCP                1
-+#define TCP_TTL                 255
-+
-+/* Controls if TCP should queue segments that arrive out of
-+   order. Define to 0 if your device is low on memory. */
-+#define TCP_QUEUE_OOSEQ         0
-+
-+/* TCP Maximum segment size. */
-+#define TCP_MSS                 (1500 - 40)   /* TCP_MSS = (Ethernet MTU - IP header size - TCP header size) */
-+
-+/* TCP sender buffer space (bytes). */
-+#define TCP_SND_BUF             (4*TCP_MSS)
-+
-+/*  TCP_SND_QUEUELEN: TCP sender buffer space (pbufs). This must be at least
-+  as much as (2 * TCP_SND_BUF/TCP_MSS) for things to work. */
-+
-+#define TCP_SND_QUEUELEN        (2* TCP_SND_BUF/TCP_MSS)
-+
-+/* TCP receive window. */
-+#define TCP_WND                 (2*TCP_MSS)
-+
-+
-+/* ---------- ICMP options ---------- */
-+#define LWIP_ICMP                       1
-+
-+
-+/* ---------- DHCP options ---------- */
-+/* Define LWIP_DHCP to 1 if you want DHCP configuration of
-+   interfaces. DHCP is not implemented in lwIP 0.5.1, however, so
-+   turning this on does currently not work. */
-+#define LWIP_DHCP               1
-+
-+
-+/* ---------- UDP options ---------- */
-+#define LWIP_UDP                1
-+#define UDP_TTL                 255
-+
-+
-+/* ---------- Statistics options ---------- */
-+#define LWIP_STATS 0
-+#define LWIP_PROVIDE_ERRNO 1
-+
-+/* ---------- link callback options ---------- */
-+/* LWIP_NETIF_LINK_CALLBACK==1: Support a callback function from an interface
-+ * whenever the link changes (i.e., link down)
-+ */
-+#define LWIP_NETIF_LINK_CALLBACK        1
-+
-+/*
-+   --------------------------------------
-+   ---------- Checksum options ----------
-+   --------------------------------------
-+*/
-+
-+/*
-+The STM32F4x7 allows computing and verifying the IP, UDP, TCP and ICMP checksums by hardware:
-+ - To use this feature let the following define uncommented.
-+ - To disable it and process by CPU comment the  the checksum.
-+*/
-+#define CHECKSUM_BY_HARDWARE
-+
-+
-+#ifdef CHECKSUM_BY_HARDWARE
-+  /* CHECKSUM_GEN_IP==0: Generate checksums by hardware for outgoing IP packets.*/
-+  #define CHECKSUM_GEN_IP                 0
-+  /* CHECKSUM_GEN_UDP==0: Generate checksums by hardware for outgoing UDP packets.*/
-+  #define CHECKSUM_GEN_UDP                0
-+  /* CHECKSUM_GEN_TCP==0: Generate checksums by hardware for outgoing TCP packets.*/
-+  #define CHECKSUM_GEN_TCP                0
-+  /* CHECKSUM_CHECK_IP==0: Check checksums by hardware for incoming IP packets.*/
-+  #define CHECKSUM_CHECK_IP               0
-+  /* CHECKSUM_CHECK_UDP==0: Check checksums by hardware for incoming UDP packets.*/
-+  #define CHECKSUM_CHECK_UDP              0
-+  /* CHECKSUM_CHECK_TCP==0: Check checksums by hardware for incoming TCP packets.*/
-+  #define CHECKSUM_CHECK_TCP              0
-+  /* CHECKSUM_CHECK_ICMP==0: Check checksums by hardware for incoming ICMP packets.*/
-+  #define CHECKSUM_GEN_ICMP               0
-+#else
-+  /* CHECKSUM_GEN_IP==1: Generate checksums in software for outgoing IP packets.*/
-+  #define CHECKSUM_GEN_IP                 1
-+  /* CHECKSUM_GEN_UDP==1: Generate checksums in software for outgoing UDP packets.*/
-+  #define CHECKSUM_GEN_UDP                1
-+  /* CHECKSUM_GEN_TCP==1: Generate checksums in software for outgoing TCP packets.*/
-+  #define CHECKSUM_GEN_TCP                1
-+  /* CHECKSUM_CHECK_IP==1: Check checksums in software for incoming IP packets.*/
-+  #define CHECKSUM_CHECK_IP               1
-+  /* CHECKSUM_CHECK_UDP==1: Check checksums in software for incoming UDP packets.*/
-+  #define CHECKSUM_CHECK_UDP              1
-+  /* CHECKSUM_CHECK_TCP==1: Check checksums in software for incoming TCP packets.*/
-+  #define CHECKSUM_CHECK_TCP              1
-+  /* CHECKSUM_CHECK_ICMP==1: Check checksums by hardware for incoming ICMP packets.*/
-+  #define CHECKSUM_GEN_ICMP               1
-+#endif
-+
-+
-+/*
-+   ----------------------------------------------
-+   ---------- Sequential layer options ----------
-+   ----------------------------------------------
-+*/
-+/**
-+ * LWIP_NETCONN==1: Enable Netconn API (require to use api_lib.c)
-+ */
-+#define LWIP_NETCONN                    1
-+
-+/*
-+   ------------------------------------
-+   ---------- Socket options ----------
-+   ------------------------------------
-+*/
-+/**
-+ * LWIP_SOCKET==1: Enable Socket API (require to use sockets.c)
-+ */
-+#define LWIP_SOCKET                     1
-+
-+/*
-+   -----------------------------------
-+   ---------- DEBUG options ----------
-+   -----------------------------------
-+*/
-+
-+#define LWIP_DEBUG                      0
-+
-+
-+/*
-+   ---------------------------------
-+   ---------- OS options ----------
-+   ---------------------------------
-+*/
-+
-+#define TCPIP_THREAD_NAME              "TCP/IP"
-+#define TCPIP_THREAD_STACKSIZE          1000
-+#define TCPIP_MBOX_SIZE                 5
-+#define DEFAULT_UDP_RECVMBOX_SIZE       2000
-+#define DEFAULT_TCP_RECVMBOX_SIZE       2000
-+#define DEFAULT_ACCEPTMBOX_SIZE         2000
-+#define DEFAULT_THREAD_STACKSIZE        500
-+#define TCPIP_THREAD_PRIO               (configMAX_PRIORITIES - 2)
-+#define LWIP_COMPAT_MUTEX               1
-+
-+
-+#endif
-+
- #endif /* __LWIPOPTS_H__ */
--- 
-1.9.1
-
-
-From c5a4114e1f21fe408301a2e5a8ae3a3f22fdea0f Mon Sep 17 00:00:00 2001
-From: Jay Doyle <jay.doyle@vecna.com>
-Date: Mon, 28 Sep 2015 13:47:22 -0400
-Subject: [PATCH 09/10] enable BSD sockets naming
-
----
- ports/include/lwipopts.h | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
-diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
-index 68d799b..40170c3 100644
---- a/ports/include/lwipopts.h
-+++ b/ports/include/lwipopts.h
-@@ -172,7 +172,7 @@
-  * LWIP_COMPAT_SOCKETS==1: Enable BSD-style sockets functions names.
-  * (only used if you use sockets.c)
-  */
--#define LWIP_COMPAT_SOCKETS             0
-+#define LWIP_COMPAT_SOCKETS             1
- 
- #define LWIP_TIMEVAL_PRIVATE            0
- 
--- 
-1.9.1
-
-
-From db7b9a1f9d9d2cba75a14e49e393c88e199ead20 Mon Sep 17 00:00:00 2001
-Subject: [PATCH 10/10] corrected cache line size
-index 9149c29..7b44db3 100644
-@@ -50,7 +50,7 @@
--- 
-1.9.1
-
-
-From 35d7bb6c5d762616e71c785143ac2fb3c7c3ae86 Mon Sep 17 00:00:00 2001
-From: Jay Doyle <jay.doyle@vecna.com>
-Date: Mon, 28 Sep 2015 16:21:35 -0400
-Subject: [PATCH 12/13] patch file update
-
----
- rtems.patch | 3809 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-
- 1 file changed, 3800 insertions(+), 9 deletions(-)
-
-diff --git a/rtems.patch b/rtems.patch
-index c088510..3ec5fb0 100644
---- a/rtems.patch
-+++ b/rtems.patch
-@@ -1,7 +1,7 @@
- From 2d83d4994e578ec339b2b1baef53090bf7a53570 Mon Sep 17 00:00:00 2001
- From: Jay Doyle <jay.doyle@vecna.com>
- Date: Fri, 4 Sep 2015 17:28:55 -0400
--Subject: [PATCH 1/9] rtems changes necessary
-+Subject: [PATCH 01/10] rtems changes necessary
- 
- ---
-  Makefile                      | 170 +++++++++++
-@@ -1292,7 +1292,7 @@ index 0000000..360a4e2
- From d053fa836b445b6736bf82d33a33a59055150aa7 Mon Sep 17 00:00:00 2001
- From: Jay Doyle <jay.doyle@vecna.com>
- Date: Fri, 4 Sep 2015 17:30:37 -0400
--Subject: [PATCH 2/9] changed the compiler options
-+Subject: [PATCH 02/10] changed the compiler options
- 
- ---
-  Makefile | 2 +-
-@@ -1318,7 +1318,7 @@ index 0cbae64..94fcafc 100644
- From 841adb17430bdb9298dcb6d44ac5dad72e82af80 Mon Sep 17 00:00:00 2001
- From: Jay Doyle <jay.doyle@vecna.com>
- Date: Mon, 7 Sep 2015 08:56:58 -0400
--Subject: [PATCH 3/9] disabled any mention of ipv6
-+Subject: [PATCH 03/10] disabled any mention of ipv6
- 
- ---
-  Makefile | 6 +++---
-@@ -1362,7 +1362,7 @@ index 94fcafc..6efa141 100644
- From a653d818348fef0130e6e497eecb0c3a35822df4 Mon Sep 17 00:00:00 2001
- From: Jay Doyle <jay.doyle@vecna.com>
- Date: Mon, 7 Sep 2015 09:27:48 -0400
--Subject: [PATCH 4/9] added in stm32f low-level driver
-+Subject: [PATCH 04/10] added in stm32f low-level driver
- 
- ---
-  src/netif/ethernetif.c | 709 ++++++++++++++++++++++++++++++-------------------
-@@ -2150,7 +2150,7 @@ index 7982d11..82c85ae 100644
- From ab97b49d1d41e34fdfdfb457b397c768ee228c9f Mon Sep 17 00:00:00 2001
- From: Jay Doyle <jay.doyle@vecna.com>
- Date: Mon, 7 Sep 2015 09:39:20 -0400
--Subject: [PATCH 5/9] removed ethernetif (it should be in BSP
-+Subject: [PATCH 05/10] removed ethernetif (it should be in BSP
- 
- ---
-  src/netif/ethernetif.c | 496 -------------------------------------------------
-@@ -2666,7 +2666,7 @@ index 82c85ae..0000000
- From 31d34fab26b1e3fde99fe7288786725fe5e51b95 Mon Sep 17 00:00:00 2001
- From: Jay Doyle <jay.doyle@vecna.com>
- Date: Mon, 7 Sep 2015 10:17:32 -0400
--Subject: [PATCH 6/9] add low level driver back
-+Subject: [PATCH 06/10] add low level driver back
- 
- ---
-  src/netif/ethernetif.c | 496 +++++++++++++++++++++++++++++++++++++++++++++++++
-@@ -3182,7 +3182,7 @@ index 0000000..bc429e9
- From 81eded01bb2bc35a9b627e5cf35b2021efb5972c Mon Sep 17 00:00:00 2001
- From: Jay Doyle <jay.doyle@vecna.com>
- Date: Mon, 7 Sep 2015 10:22:57 -0400
--Subject: [PATCH 7/9] Added bsp path
-+Subject: [PATCH 07/10] Added bsp path
- 
- ---
-  Makefile | 4 +++-
-@@ -3217,7 +3217,7 @@ index 6efa141..a855d9f 100644
- From f114529d5af1e2a83b49b67d631b10c02648e8d8 Mon Sep 17 00:00:00 2001
- From: Jay Doyle <jay.doyle@vecna.com>
- Date: Mon, 7 Sep 2015 10:54:26 -0400
--Subject: [PATCH 8/9] removed ethernetif.c
-+Subject: [PATCH 08/10] removed ethernetif.c
- 
- ---
-  src/netif/ethernetif.c | 496 -------------------------------------------------
-@@ -3733,7 +3733,7 @@ index bc429e9..0000000
- From badcd5771d8fa3046a2cd7aa07536c6dcb703891 Mon Sep 17 00:00:00 2001
- From: Jay Doyle <jay.doyle@vecna.com>
- Date: Mon, 28 Sep 2015 13:47:22 -0400
--Subject: [PATCH 9/9] enable BSD sockets naming
-+Subject: [PATCH 09/10] enable BSD sockets naming
- 
- ---
-  ports/include/lwipopts.h | 2 +-
-@@ -3755,3 +3755,3794 @@ index 169ba46..9149c29 100644
- -- 
- 1.9.1
- 
-+
-+From db7b9a1f9d9d2cba75a14e49e393c88e199ead20 Mon Sep 17 00:00:00 2001
-+From: Jay Doyle <jay.doyle@vecna.com>
-+Date: Mon, 28 Sep 2015 15:28:28 -0400
-+Subject: [PATCH 10/10] corrected cache line size
-+
-+---
-+ ports/include/lwipopts.h |    2 +-
-+ rtems.patch              | 3757 ++++++++++++++++++++++++++++++++++++++++++++++
-+ 2 files changed, 3758 insertions(+), 1 deletion(-)
-+ create mode 100644 rtems.patch
-+
-+diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
-+index 9149c29..7b44db3 100644
-+--- a/ports/include/lwipopts.h
-++++ b/ports/include/lwipopts.h
-+@@ -50,7 +50,7 @@
-+ */
-+ /*#define LWIP_CACHE_ENABLED*/
-+ 
-+-#define SOC_CACHELINE_SIZE_BYTES        64            /* Number of bytes in
-++#define SOC_CACHELINE_SIZE_BYTES        32            /* Number of bytes in
-+                                                          a cache line */
-+ /*
-+ ** The timeout for DHCP completion. lwIP library will wait for DHCP
-+diff --git a/rtems.patch b/rtems.patch
-+new file mode 100644
-+index 0000000..c088510
-+--- /dev/null
-++++ b/rtems.patch
-+@@ -0,0 +1,3757 @@
-++From 2d83d4994e578ec339b2b1baef53090bf7a53570 Mon Sep 17 00:00:00 2001
-++From: Jay Doyle <jay.doyle@vecna.com>
-++Date: Fri, 4 Sep 2015 17:28:55 -0400
-++Subject: [PATCH 1/9] rtems changes necessary
-++
-++---
-++ Makefile                      | 170 +++++++++++
-++ ports/include/arch/cc.h       | 123 ++++++++
-++ ports/include/arch/perf.h     |  38 +++
-++ ports/include/arch/sys_arch.h |  59 ++++
-++ ports/include/lwipopts.h      | 178 ++++++++++++
-++ ports/sys_arch.c              | 663 ++++++++++++++++++++++++++++++++++++++++++
-++ 6 files changed, 1231 insertions(+)
-++ create mode 100644 Makefile
-++ create mode 100644 ports/include/arch/cc.h
-++ create mode 100644 ports/include/arch/perf.h
-++ create mode 100644 ports/include/arch/sys_arch.h
-++ create mode 100644 ports/include/lwipopts.h
-++ create mode 100644 ports/sys_arch.c
-++
-++diff --git a/Makefile b/Makefile
-++new file mode 100644
-++index 0000000..0cbae64
-++--- /dev/null
-+++++ b/Makefile
-++@@ -0,0 +1,170 @@
-+++include $(RTEMS_MAKEFILE_PATH)/Makefile.inc
-+++include $(RTEMS_CUSTOM)
-+++include $(PROJECT_ROOT)/make/leaf.cfg
-+++
-+++#### CONFIG ####################################################################
-+++#For debugging symbols add -DLWIP_DEBUG
-+++# COMPILER/LINKER
-+++CFLAGS+=-g -O2   \
-+++ -Wall
-+++
-+++# OUTPUT
-+++LWIP_EXEC=lwip
-+++
-+++#### PATHS #####################################################################
-+++
-+++# LWIP
-+++LWIP_PATH=.
-+++LWIP_SRC_PATH=$(LWIP_PATH)/src
-+++LWIP_API_PATH=$(LWIP_SRC_PATH)/api
-+++LWIP_CORE_PATH=$(LWIP_SRC_PATH)/core
-+++LWIP_INCL_PATH=$(LWIP_SRC_PATH)/include
-+++LWIP_NETIF_PATH=$(LWIP_SRC_PATH)/netif
-+++
-+++# ARCH
-+++LWIPARCH_PATH=$(LWIP_PATH)/ports
-+++LWIPARCH_SRC_PATH=$(LWIPARCH_PATH)
-+++LWIPARCH_INCL_PATH=$(LWIPARCH_PATH)/include
-+++
-+++# DRIVER
-+++LWIPDRIVER_PATH=$(LWIP_PATH)/ports
-+++LWIPDRIVER_SRC_PATH=$(LWIPDRIVER_PATH)/netif
-+++LWIPDRIVER_INCL_PATH=$(LWIPDRIVER_PATH)/include/netif
-+++
-+++#### SOURCES ###################################################################
-+++
-+++## CORE
-+++CORE_SRC=$(wildcard $(LWIP_CORE_PATH)/*.c)
-+++
-+++## IPv4
-+++IPV4_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv4/*.c)
-+++
-+++## IPv6
-+++IPV6_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv6/*.c)
-+++
-+++## SNMP
-+++SNMP_SRC=$(wildcard $(LWIP_CORE_PATH)/snmp/*.c)
-+++
-+++## API
-+++API_SRC=$(wildcard $(LWIP_API_PATH)/*.c )
-+++
-+++## NETIF
-+++NETIF_SRC=$(wildcard $(LWIP_NETIF_PATH)/*.c) \
-+++          $(wildcard $(LWIP_NETIF_PATH)/ppp/*.c) \
-+++          $(wildcard $(LWIP_NETIF_PATH)/ppp/polarssl/*.c)
-+++
-+++
-+++ARCH_SRC=$(wildcard $(LWIPARCH_SRC_PATH)/*.c)
-+++
-+++# DRIVER
-+++DRIVER_SRC=$(wildcard $(LWIPDRIVER_SRC_PATH)/*.c ) \
-+++           $(wildcard $(LWIPDRIVER_SRC_PATH)/*.S )
-+++
-+++
-+++SOURCES =  $(DRIVER_SRC) $(SNMP_SRC)\
-+++           $(CORE_SRC) $(IPV4_SRC) $(API_SRC) $(NETIF_SRC) $(ARCH_SRC)
-+++
-+++
-+++#### HEADERS ###################################################################
-+++
-+++## CORE
-+++CORE_H=$(LWIP_INCL_PATH)
-+++
-+++## IPv4
-+++#IPV4_H=$(LWIP_INCL_PATH)/ipv4
-+++
-+++## IPv6
-+++#IPV6_H=$(LWIP_INCL_PATH)/ipv6
-+++
-+++## POSIX
-+++POSIX_H=$(LWIP_INCL_PATH)/posix
-+++
-+++##POSIX_SYS
-+++POSIX_SYS_H=$(LWIP_INCL_PATH)/posix/sys
-+++
-+++
-+++## NETIF
-+++NETIF_H=$(LWIP_INCL_PATH)/netif
-+++NETIF_H_PPP=$(LWIP_INCL_PATH)/netif/ppp
-+++NETIF_H_PPP_POLARSSL=$(LWIP_INCL_PATH)/netif/ppp/polarssl
-+++
-+++## ARCH
-+++ARCH_H=$(LWIPARCH_INCL_PATH)
-+++
-+++## DRIVER
-+++DRIVER_H=$(LWIPDRIVER_INCL_PATH)
-+++
-+++# HEADERS
-+++HEADERS=-I$(CORE_H) -I$(POSIX_H) -I$(POSIX_SYS_H) -I$(NETIF_H) \
-+++        -I$(NETIF_H_PPP) -I$(NETIF_H_PPP_POLARSSL) -I$(ARCH_H) \
-+++        -I$(DRIVER_H)
-+++
-+++
-+++################################################################################
-+++
-+++
-+++BIN=${ARCH}/$(LWIP_EXEC).bin
-+++LIB=${ARCH}/lib$(LWIP_EXEC).a
-+++
-+++# optional managers required
-+++MANAGERS=all
-+++
-+++# C source names
-+++CSRCS=$(filter %.c ,$(SOURCES))
-+++COBJS=$(patsubst %.c,${ARCH}/%.o,$(notdir $(CSRCS)))
-+++
-+++ASMSRCS=$(filter %.S , $(SOURCES))
-+++ASMOBJS=$(patsubst %.S,${ARCH}/%.o,$(notdir $(ASMSRCS)))
-+++
-+++OBJS=$(COBJS) $(ASMOBJS)
-+++
-+++all:${ARCH} $(LIB)
-+++
-+++$(LIB): $(OBJS)
-+++	$(AR)  rcs  $@ $^
-+++
-+++${ARCH}/%.o: $(LWIP_CORE_PATH)/%.c
-+++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
-+++
-+++${ARCH}/%.o: $(LWIP_CORE_PATH)/ipv4/%.c
-+++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
-+++
-+++${ARCH}/%.o: $(LWIP_CORE_PATH)/ipv6/%.c
-+++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
-+++
-+++${ARCH}/%.o: $(LWIP_CORE_PATH)/snmp/%.c
-+++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
-+++
-+++${ARCH}/%.o: $(LWIP_API_PATH)/%.c
-+++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
-+++
-+++${ARCH}/%.o: $(LWIP_NETIF_PATH)/%.c
-+++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
-+++
-+++${ARCH}/%.o: $(LWIP_NETIF_PATH)/ppp/%.c
-+++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
-+++
-+++${ARCH}/%.o: $(LWIP_NETIF_PATH)/ppp/polarssl/%.c
-+++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
-+++
-+++${ARCH}/%.o: $(LWIPARCH_SRC_PATH)/%.c
-+++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
-+++
-+++${ARCH}/%.o: $(LWIPDRIVER_SRC_PATH)/%.S
-+++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
-+++
-+++${ARCH}/%.o: $(LWIPDRIVER_SRC_PATH)/%.c
-+++	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
-+++
-+++INSTALL_DIR=$(RTEMS_MAKEFILE_PATH)/lwip
-+++
-+++install:
-+++	rm -rf $(INSTALL_DIR)
-+++	mkdir -p $(INSTALL_DIR)/include
-+++	mkdir -p $(INSTALL_DIR)/lib
-+++	cp $(LIB) $(INSTALL_DIR)/lib
-+++	cp -r $(CORE_H) $(INSTALL_DIR)
-+++	cp $(LWIPARCH_INCL_PATH)/lwipopts.h $(INSTALL_DIR)/include
-+++	cp -r $(LWIPARCH_INCL_PATH)/arch $(INSTALL_DIR)/include
-+++
-+++CPPFLAGS+=$(HEADERS)
-++diff --git a/ports/include/arch/cc.h b/ports/include/arch/cc.h
-++new file mode 100644
-++index 0000000..04ec89f
-++--- /dev/null
-+++++ b/ports/include/arch/cc.h
-++@@ -0,0 +1,123 @@
-+++/*
-+++ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
-+++ * All rights reserved.
-+++ *
-+++ * Redistribution and use in source and binary forms, with or without modification,
-+++ * are permitted provided that the following conditions are met:
-+++ *
-+++ * 1. Redistributions of source code must retain the above copyright notice,
-+++ *    this list of conditions and the following disclaimer.
-+++ * 2. Redistributions in binary form must reproduce the above copyright notice,
-+++ *    this list of conditions and the following disclaimer in the documentation
-+++ *    and/or other materials provided with the distribution.
-+++ * 3. The name of the author may not be used to endorse or promote products
-+++ *    derived from this software without specific prior written permission.
-+++ *
-+++ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
-+++ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-+++ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
-+++ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-+++ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
-+++ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-+++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-+++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
-+++ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
-+++ * OF SUCH DAMAGE.
-+++ *
-+++ * This file is part of the lwIP TCP/IP stack.
-+++ *
-+++ * Author: Adam Dunkels <adam@sics.se>
-+++ *
-+++ */
-+++#ifndef __CC_H__
-+++#define __CC_H__
-+++
-+++typedef unsigned    char    u8_t;
-+++typedef signed      char    s8_t;
-+++typedef unsigned    short   u16_t;
-+++typedef signed      short   s16_t;
-+++typedef unsigned    int    u32_t;
-+++typedef signed      int    s32_t;
-+++typedef u32_t           mem_ptr_t;
-+++
-+++#ifndef BYTE_ORDER
-+++#define BYTE_ORDER LITTLE_ENDIAN
-+++#endif
-+++
-+++#if defined(__arm__) && defined(__ARMCC_VERSION)
-+++    //
-+++    // Setup PACKing macros for KEIL/RVMDK Tools
-+++    //
-+++    #define PACK_STRUCT_BEGIN __packed
-+++    #define PACK_STRUCT_STRUCT
-+++    #define PACK_STRUCT_END
-+++    #define PACK_STRUCT_FIELD(x) x
-+++#elif defined (__IAR_SYSTEMS_ICC__)
-+++    //
-+++    // Setup PACKing macros for IAR Tools
-+++    //
-+++    #define PACK_STRUCT_BEGIN
-+++    #define PACK_STRUCT_STRUCT
-+++    #define PACK_STRUCT_END
-+++    #define PACK_STRUCT_FIELD(x) x
-+++    #define PACK_STRUCT_USE_INCLUDES
-+++#elif defined (__TMS470__)
-+++    #define PACK_STRUCT_BEGIN
-+++    #define PACK_STRUCT_STRUCT
-+++    #define PACK_STRUCT_END
-+++    #define PACK_STRUCT_FIELD(x) x
-+++#else
-+++    //
-+++    // Setup PACKing macros for GCC Tools
-+++    //
-+++    #define PACK_STRUCT_BEGIN
-+++    #define PACK_STRUCT_STRUCT __attribute__ ((__packed__))
-+++    #define PACK_STRUCT_END
-+++    #define PACK_STRUCT_FIELD(x) x
-+++#endif
-+++
-+++#ifdef LWIP_CACHE_ENABLED
-+++/**
-+++ * Make the PBUF POOL cacheline aligned.
-+++ */
-+++#ifdef __IAR_SYSTEMS_ICC__
-+++#pragma data_alignment=SOC_CACHELINE_SIZE_BYTES
-+++extern u8_t memp_memory_PBUF_POOL_base[];
-+++#else /*By default, GCC */
-+++extern u8_t memp_memory_PBUF_POOL_base[] __attribute__ ((aligned (SOC_CACHELINE_SIZE_BYTES)));
-+++#endif
-+++#endif
-+++
-+++extern u8_t memp_memory_PBUF_POOL_base[] __attribute__ ((aligned (SOC_CACHELINE_SIZE_BYTES)));
-+++
-+++/* Define (sn)printf formatters for these lwIP types */
-+++#define X8_F  "02x"
-+++#define U16_F "u"
-+++#define S16_F "d"
-+++#define X16_F "x"
-+++#define U32_F "u"
-+++#define S32_F "d"
-+++#define X32_F "x"
-+++
-+++#include <stdio.h>
-+++#include <stdlib.h>
-+++#include <bsp.h>
-+++#define LWIP_PLATFORM_DIAG(x)   do { \
-+++        printk("[%s - %s - %d] ", __PRETTY_FUNCTION__, __FILE__, __LINE__); \
-+++        printk x; \
-+++    } while(0)
-+++
-+++#ifdef LWIP_DEBUG  //DEBUG
-+++extern void __error__(char *pcFilename, unsigned long ulLine);
-+++#define LWIP_PLATFORM_ASSERT(expr)   printk("[%s - %s - %d] ", expr , __FILE__, __LINE__);
-+++//{
-+++    //if(!(expr))
-+++    //{
-+++        //__error__(__FILE__, __LINE__);
-+++    //}
-+++//}
-+++#else
-+++#define LWIP_PLATFORM_ASSERT(expr)
-+++#endif
-+++
-+++#endif /* __CC_H__ */
-++diff --git a/ports/include/arch/perf.h b/ports/include/arch/perf.h
-++new file mode 100644
-++index 0000000..d754157
-++--- /dev/null
-+++++ b/ports/include/arch/perf.h
-++@@ -0,0 +1,38 @@
-+++/*
-+++ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
-+++ * All rights reserved.
-+++ *
-+++ * Redistribution and use in source and binary forms, with or without modification,
-+++ * are permitted provided that the following conditions are met:
-+++ *
-+++ * 1. Redistributions of source code must retain the above copyright notice,
-+++ *    this list of conditions and the following disclaimer.
-+++ * 2. Redistributions in binary form must reproduce the above copyright notice,
-+++ *    this list of conditions and the following disclaimer in the documentation
-+++ *    and/or other materials provided with the distribution.
-+++ * 3. The name of the author may not be used to endorse or promote products
-+++ *    derived from this software without specific prior written permission.
-+++ *
-+++ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
-+++ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-+++ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
-+++ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-+++ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
-+++ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-+++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-+++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
-+++ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
-+++ * OF SUCH DAMAGE.
-+++ *
-+++ * This file is part of the lwIP TCP/IP stack.
-+++ *
-+++ * Author: Adam Dunkels <adam@sics.se>
-+++ *
-+++ */
-+++#ifndef __PERF_H__
-+++#define __PERF_H__
-+++
-+++#define PERF_START    /* null definition */
-+++#define PERF_STOP(x)  /* null definition */
-+++
-+++#endif /* __PERF_H__ */
-++diff --git a/ports/include/arch/sys_arch.h b/ports/include/arch/sys_arch.h
-++new file mode 100644
-++index 0000000..32f0d99
-++--- /dev/null
-+++++ b/ports/include/arch/sys_arch.h
-++@@ -0,0 +1,59 @@
-+++/*
-+++ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
-+++ * All rights reserved.
-+++ *
-+++ * Redistribution and use in source and binary forms, with or without modification,
-+++ * are permitted provided that the following conditions are met:
-+++ *
-+++ * 1. Redistributions of source code must retain the above copyright notice,
-+++ *    this list of conditions and the following disclaimer.
-+++ * 2. Redistributions in binary form must reproduce the above copyright notice,
-+++ *    this list of conditions and the following disclaimer in the documentation
-+++ *    and/or other materials provided with the distribution.
-+++ * 3. The name of the author may not be used to endorse or promote products
-+++ *    derived from this software without specific prior written permission.
-+++ *
-+++ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
-+++ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-+++ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
-+++ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-+++ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
-+++ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-+++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-+++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
-+++ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
-+++ * OF SUCH DAMAGE.
-+++ *
-+++ * This file is part of the lwIP TCP/IP stack.
-+++ *
-+++ * Author: Adam Dunkels <adam@sics.se>
-+++ *
-+++ */
-+++#ifndef LWIP_ARCH_SYS_ARCH_H
-+++#define LWIP_ARCH_SYS_ARCH_H
-+++
-+++#include <errno.h>
-+++
-+++#define SYS_MBOX_NULL NULL
-+++#define SYS_SEM_NULL  NULL
-+++
-+++typedef u32_t sys_prot_t;
-+++
-+++struct sys_sem;
-+++typedef struct sys_sem * sys_sem_t;
-+++#define sys_sem_valid(sem) (((sem) != NULL) && (*(sem) != NULL))
-+++#define sys_sem_set_invalid(sem) do { if((sem) != NULL) { *(sem) = NULL; }}while(0)
-+++
-+++/* let sys.h use binary semaphores for mutexes */
-+++#define LWIP_COMPAT_MUTEX 1
-+++
-+++struct sys_mbox;
-+++typedef struct sys_mbox *sys_mbox_t;
-+++#define sys_mbox_valid(mbox) ((*(mbox) != NULL))
-+++#define sys_mbox_set_invalid(mbox) do { if((mbox) != NULL) { *(mbox) = NULL; }}while(0)
-+++
-+++struct sys_thread;
-+++typedef struct sys_thread * sys_thread_t;
-+++
-+++#endif /* LWIP_ARCH_SYS_ARCH_H */
-+++
-++diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
-++new file mode 100644
-++index 0000000..169ba46
-++--- /dev/null
-+++++ b/ports/include/lwipopts.h
-++@@ -0,0 +1,178 @@
-+++/**
-+++ * \file lwipopts.h - Configuration options for lwIP
-+++ *
-+++ * Copyright (c) 2010 Texas Instruments Incorporated
-+++ */
-+++/*
-+++ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
-+++ * All rights reserved.
-+++ *
-+++ * Redistribution and use in source and binary forms, with or without modification,
-+++ * are permitted provided that the following conditions are met:
-+++ *
-+++ * 1. Redistributions of source code must retain the above copyright notice,
-+++ *    this list of conditions and the following disclaimer.
-+++ * 2. Redistributions in binary form must reproduce the above copyright notice,
-+++ *    this list of conditions and the following disclaimer in the documentation
-+++ *    and/or other materials provided with the distribution.
-+++ * 3. The name of the author may not be used to endorse or promote products
-+++ *    derived from this software without specific prior written permission.
-+++ *
-+++ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
-+++ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-+++ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
-+++ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-+++ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
-+++ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-+++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-+++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
-+++ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
-+++ * OF SUCH DAMAGE.
-+++ *
-+++ * This file is part of the lwIP TCP/IP stack.
-+++ *
-+++ * Author: Adam Dunkels <adam@sics.se>
-+++ *
-+++ */
-+++
-+++#ifndef __LWIPOPTS_H__
-+++#define __LWIPOPTS_H__
-+++
-+++/*****************************************************************************
-+++**                           CONFIGURATIONS
-+++*****************************************************************************/
-+++
-+++/*
-+++** The below macro should be defined for using lwIP with cache. For cache
-+++** enabling, pbuf pool shall be cache line aligned. This is done by using
-+++** separate pool for each memory. The alignment of pbuf pool to cache line
-+++** size is done in /ports/cpsw/include/arch/cc.h.
-+++*/
-+++/*#define LWIP_CACHE_ENABLED*/
-+++
-+++#define SOC_CACHELINE_SIZE_BYTES        64            /* Number of bytes in
-+++                                                         a cache line */
-+++/*
-+++** The timeout for DHCP completion. lwIP library will wait for DHCP
-+++** completion for (LWIP_DHCP_TIMEOUT / 100) seconds.
-+++*/
-+++#define LWIP_DHCP_TIMEOUT               500
-+++
-+++/*
-+++** The number of times DHCP is attempted. Each time, the library will wait
-+++** for (LWIP_DHCP_TIMEOUT / 100) seconds for DHCP completion.
-+++*/
-+++#define NUM_DHCP_TRIES                  5
-+++
-+++#define LWIP_ETHERNET                   1
-+++#define LWIP_ARP                        1
-+++
-+++/*****************************************************************************
-+++**            lwIP SPECIFIC DEFINITIONS - To be used by lwIP stack
-+++*****************************************************************************/
-+++#define HOST_TMR_INTERVAL               0
-+++#define DYNAMIC_HTTP_HEADERS
-+++
-+++/*****************************************************************************
-+++**                    Platform specific locking
-+++*****************************************************************************/
-+++#define SYS_LIGHTWEIGHT_PROT            1
-+++#define NO_SYS                          0
-+++#define NO_SYS_NO_TIMERS                0
-+++
-+++/*****************************************************************************
-+++**                          Memory Options
-+++*****************************************************************************/
-+++#define MEM_ALIGNMENT                   4
-+++#define MEM_SIZE                        (256 * 1024) /* 128K */
-+++
-+++#define MEMP_NUM_PBUF                   96
-+++#define MEMP_NUM_TCP_PCB                32
-+++#define MEMP_NUM_TCP_SEG                32
-+++#define PBUF_POOL_SIZE                  512
-+++
-+++#ifdef LWIP_CACHE_ENABLED
-+++#define MEMP_SEPARATE_POOLS             1            /* We want the pbuf
-+++                                                        pool cache line
-+++                                                        aligned*/
-+++#endif
-+++
-+++#define MEMP_NUM_SYS_TIMEOUT (LWIP_TCP + IP_REASSEMBLY + LWIP_ARP + (2*LWIP_DHCP) + LWIP_AUTOIP + LWIP_IGMP + LWIP_DNS + PPP_SUPPORT)
-+++
-+++/*****************************************************************************
-+++**                           IP Options
-+++*****************************************************************************/
-+++#define IP_REASSEMBLY                   0
-+++#define IP_FRAG                         0
-+++
-+++/*****************************************************************************
-+++**                           DHCP Options
-+++*****************************************************************************/
-+++#define LWIP_DHCP                       1
-+++#define DHCP_DOES_ARP_CHECK             0
-+++
-+++/*****************************************************************************
-+++**                           Auto IP  Options
-+++*****************************************************************************/
-+++#define LWIP_AUTOIP                     1
-+++#define LWIP_DHCP_AUTOIP_COOP           ((LWIP_DHCP) && (LWIP_AUTOIP))
-+++
-+++/*****************************************************************************
-+++**                           TCP  Options
-+++*****************************************************************************/
-+++#define TCP_MSS                         1500
-+++#define TCP_WND                         (8 * TCP_MSS)
-+++#define TCP_SND_BUF                     (8 * TCP_MSS)
-+++#define TCP_OVERSIZE                    TCP_MSS
-+++
-+++/*****************************************************************************
-+++**                           PBUF  Options
-+++*****************************************************************************/
-+++#define PBUF_LINK_HLEN                  14
-+++#define PBUF_POOL_BUFSIZE               1520         /* + size of struct pbuf
-+++                                                        shall be cache line
-+++                                                        aligned be enabled */
-+++#define ETH_PAD_SIZE                    0
-+++#define LWIP_NETCONN                    1
-+++
-+++/*****************************************************************************
-+++**                           Socket  Options
-+++*****************************************************************************/
-+++#define LWIP_SOCKET                     1
-+++
-+++/*****************************************************************************
-+++**                          Debugging options
-+++*****************************************************************************/
-+++#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_OFF
-+++#define LWIP_DBG_TYPES_ON               (LWIP_DBG_ON | LWIP_DBG_TRACE \
-+++                                         |LWIP_DBG_STATE | LWIP_DBG_FRESH)
-+++#define DHCP_DEBUG                      LWIP_DBG_OFF
-+++#define NETIF_DEBUG                     LWIP_DBG_OFF
-+++#define IP_DEBUG			LWIP_DBG_OFF
-+++#define UDP_DEBUG			LWIP_DBG_OFF
-+++#define ETHARP_DEBUG                    LWIP_DBG_OFF
-+++#define SYS_DEBUG                       LWIP_DBG_OFF
-+++#define RAW_DEBUG                       LWIP_DBG_OFF
-+++#define MEM_DEBUG                       LWIP_DBG_OFF
-+++#define MEMP_DEBUG                      LWIP_DBG_OFF
-+++#define PBUF_DEBUG			LWIP_DBG_OFF
-+++#define TCPIP_DEBUG			LWIP_DBG_OFF
-+++#define APP_DEBUG			LWIP_DBG_OFF
-+++#define SOCKETS_DEBUG		        LWIP_DBG_OFF
-+++#define LWIP_STATS                      0
-+++#define LWIP_STATS_DISPLAY              0
-+++#define LWIP_STATS_POSIX                0
-+++
-+++
-+++
-+++/**
-+++ * LWIP_COMPAT_SOCKETS==1: Enable BSD-style sockets functions names.
-+++ * (only used if you use sockets.c)
-+++ */
-+++#define LWIP_COMPAT_SOCKETS             0
-+++
-+++#define LWIP_TIMEVAL_PRIVATE            0
-+++
-+++ #define LWIP_RAW                       0
-+++
-+++#endif /* __LWIPOPTS_H__ */
-++diff --git a/ports/sys_arch.c b/ports/sys_arch.c
-++new file mode 100644
-++index 0000000..360a4e2
-++--- /dev/null
-+++++ b/ports/sys_arch.c
-++@@ -0,0 +1,663 @@
-+++/*
-+++ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
-+++ * All rights reserved.
-+++ *
-+++ * Redistribution and use in source and binary forms, with or without modification,
-+++ * are permitted provided that the following conditions are met:
-+++ *
-+++ * 1. Redistributions of source code must retain the above copyright notice,
-+++ *    this list of conditions and the following disclaimer.
-+++ * 2. Redistributions in binary form must reproduce the above copyright notice,
-+++ *    this list of conditions and the following disclaimer in the documentation
-+++ *    and/or other materials provided with the distribution.
-+++ * 3. The name of the author may not be used to endorse or promote products
-+++ *    derived from this software without specific prior written permission.
-+++ *
-+++ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
-+++ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-+++ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
-+++ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-+++ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
-+++ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-+++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-+++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
-+++ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
-+++ * OF SUCH DAMAGE.
-+++ *
-+++ * This file is part of the lwIP TCP/IP stack.
-+++ *
-+++ * Author: Adam Dunkels <adam@sics.se>
-+++ *
-+++ */
-+++
-+++/*
-+++ * Wed Apr 17 16:05:29 EDT 2002 (James Roth)
-+++ *
-+++ *  - Fixed an unlikely sys_thread_new() race condition.
-+++ *
-+++ *  - Made current_thread() work with threads which where
-+++ *    not created with sys_thread_new().  This includes
-+++ *    the main thread and threads made with pthread_create().
-+++ *
-+++ *  - Catch overflows where more than SYS_MBOX_SIZE messages
-+++ *    are waiting to be read.  The sys_mbox_post() routine
-+++ *    will block until there is more room instead of just
-+++ *    leaking messages.
-+++ */
-+++
-+++#include <string.h>
-+++#include <sys/time.h>
-+++#include <sys/types.h>
-+++#include <stdlib.h>
-+++#include <unistd.h>
-+++#include <pthread.h>
-+++
-+++#include "lwip/opt.h"
-+++#include "lwip/sys.h"
-+++#include "lwip/stats.h"
-+++#include "lwip/debug.h"
-+++
-+++#define UMAX(a, b)      ((a) > (b) ? (a) : (b))
-+++
-+++static struct timeval starttime;
-+++
-+++#if !NO_SYS
-+++
-+++static struct sys_thread *threads = NULL;
-+++static pthread_mutex_t threads_mutex = PTHREAD_MUTEX_INITIALIZER;
-+++
-+++struct sys_mbox_msg {
-+++  struct sys_mbox_msg *next;
-+++  void *msg;
-+++};
-+++
-+++#define SYS_MBOX_SIZE 128
-+++
-+++struct sys_mbox {
-+++  int first, last;
-+++  void *msgs[SYS_MBOX_SIZE];
-+++  struct sys_sem *not_empty;
-+++  struct sys_sem *not_full;
-+++  struct sys_sem *mutex;
-+++  int wait_send;
-+++};
-+++
-+++struct sys_sem {
-+++  unsigned int c;
-+++  pthread_cond_t cond;
-+++  pthread_mutex_t mutex;
-+++};
-+++
-+++struct sys_thread {
-+++  struct sys_thread *next;
-+++  pthread_t pthread;
-+++};
-+++
-+++#if SYS_LIGHTWEIGHT_PROT
-+++static pthread_mutex_t lwprot_mutex = PTHREAD_MUTEX_INITIALIZER;
-+++static pthread_t lwprot_thread = (pthread_t)0xDEAD;
-+++static int lwprot_count = 0;
-+++#endif /* SYS_LIGHTWEIGHT_PROT */
-+++
-+++static struct sys_sem *sys_sem_new_internal(u8_t count);
-+++static void sys_sem_free_internal(struct sys_sem *sem);
-+++
-+++static u32_t cond_wait(pthread_cond_t * cond, pthread_mutex_t * mutex,
-+++                       u32_t timeout);
-+++
-+++/*-----------------------------------------------------------------------------------*/
-+++static struct sys_thread *
-+++introduce_thread(pthread_t id)
-+++{
-+++  struct sys_thread *thread = NULL;
-+++
-+++  thread = (struct sys_thread *)malloc(sizeof(struct sys_thread));
-+++
-+++  if (thread != NULL) {
-+++    pthread_mutex_lock(&threads_mutex);
-+++    thread->next = threads;
-+++    thread->pthread = id;
-+++    threads = thread;
-+++    pthread_mutex_unlock(&threads_mutex);
-+++  }
-+++
-+++  return thread;
-+++}
-+++/*-----------------------------------------------------------------------------------*/
-+++sys_thread_t
-+++sys_thread_new(const char *name, lwip_thread_fn function, void *arg, int stacksize, int prio)
-+++{
-+++  int code;
-+++  int rc;
-+++  pthread_t tmp;
-+++  pthread_attr_t attr;
-+++  struct sys_thread *st = NULL;
-+++  LWIP_UNUSED_ARG(name);
-+++  LWIP_UNUSED_ARG(stacksize);
-+++  LWIP_UNUSED_ARG(prio);
-+++
-+++  /* Alloc a new pthread with the specified stack size. */
-+++  if(stacksize > 0) {
-+++    rc = pthread_attr_init(&attr);
-+++    if (rc != 0) {
-+++      LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: pthread_attr_init error = %d\n", rc));
-+++      return NULL;
-+++    }
-+++    rc = pthread_attr_setstacksize(&attr, stacksize);
-+++    if (rc != 0) {
-+++      LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: pthread_attr_setstacksize error = %d\n", rc));
-+++      pthread_attr_destroy(&attr);
-+++      return NULL;
-+++    }
-+++    pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);
-+++    pthread_attr_setschedpolicy(&attr, SCHED_RR);
-+++    code = pthread_create(&tmp, &attr, (void *(*)(void *)) function, arg);
-+++    pthread_attr_destroy(&attr);
-+++  } else {
-+++    code = pthread_create(&tmp, NULL, (void *(*)(void *)) function, arg);
-+++  }
-+++  LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: thread created [name:%s|stacksize:%d|prio:%d|addr:0x%x]\n",
-+++                          name, stacksize, prio, (uint)tmp));
-+++
-+++  if (0 == code) {
-+++    st = introduce_thread(tmp);
-+++  }
-+++
-+++  if (NULL == st) {
-+++    LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: failed to introduce %d, st = %p\n",
-+++                            code, (void*)st));
-+++    abort();
-+++  } else {
-+++    LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: introduced %d, st = %p\n",
-+++                            code, (void*)st));
-+++  }
-+++
-+++  return st;
-+++}
-+++/*-----------------------------------------------------------------------------------*/
-+++void sys_thread_signal(sys_thread_t thread, int signal)
-+++{
-+++    /* Check received parameters. */
-+++    if(thread == NULL) {
-+++        LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_signal: could not send signal to thread. thread = NULL\n"));
-+++        return;
-+++    }
-+++
-+++    /* Send signal. */
-+++    pthread_kill(thread->pthread, signal);
-+++}
-+++/*-----------------------------------------------------------------------------------*/
-+++err_t
-+++sys_mbox_new(struct sys_mbox **mb, int size)
-+++{
-+++  struct sys_mbox *mbox = NULL;
-+++  LWIP_UNUSED_ARG(size);
-+++
-+++  mbox = (struct sys_mbox *)malloc(sizeof(struct sys_mbox));
-+++  if (mbox == NULL) {
-+++    SYS_STATS_INC(mbox.err);
-+++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_new: could not create mbox\n"));
-+++    return ERR_MEM;
-+++  }
-+++  mbox->first = mbox->last = 0;
-+++  mbox->not_empty = sys_sem_new_internal(0);
-+++  mbox->not_full = sys_sem_new_internal(0);
-+++  mbox->mutex = sys_sem_new_internal(1);
-+++  mbox->wait_send = 0;
-+++
-+++  SYS_STATS_INC_USED(mbox);
-+++
-+++  if((mbox->not_empty == NULL) || (mbox->not_full == NULL) || (mbox->mutex == NULL)) {
-+++    SYS_STATS_INC(mbox.err);
-+++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_new: could not create mbox internals\n"));
-+++    sys_mbox_free(&mbox);
-+++    return ERR_MEM;
-+++  }
-+++  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_new: mbox created [not_empty:%X|not_full:%X|mutex:%X] \n",
-+++                          mbox->not_empty, mbox->not_full, mbox->mutex));
-+++
-+++  *mb = mbox;
-+++  return ERR_OK;
-+++}
-+++/*-----------------------------------------------------------------------------------*/
-+++void
-+++sys_mbox_free(struct sys_mbox **mb)
-+++{
-+++  if ((mb != NULL) && (*mb != SYS_MBOX_NULL)) {
-+++    struct sys_mbox *mbox = *mb;
-+++    sys_arch_sem_wait(&mbox->mutex, 0);
-+++
-+++    sys_sem_free_internal(mbox->not_empty);
-+++    sys_sem_free_internal(mbox->not_full);
-+++    sys_sem_free_internal(mbox->mutex);
-+++    mbox->not_empty = mbox->not_full = mbox->mutex = NULL;
-+++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_free: mbox 0x%lx\n", mbox));
-+++    free(mbox);
-+++    SYS_STATS_DEC(mbox.used);
-+++  }
-+++}
-+++/*-----------------------------------------------------------------------------------*/
-+++err_t
-+++sys_mbox_trypost(struct sys_mbox **mb, void *msg)
-+++{
-+++  u8_t first;
-+++  struct sys_mbox *mbox;
-+++  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
-+++  mbox = *mb;
-+++  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_trypost: start"));
-+++  sys_arch_sem_wait(&mbox->mutex, 0);
-+++
-+++  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_trypost: mbox %p msg %p\n",
-+++                          (void *)mbox, (void *)msg));
-+++
-+++  if ((mbox->last + 1) >= (mbox->first + SYS_MBOX_SIZE)) {
-+++    sys_sem_signal(&mbox->mutex);
-+++    return ERR_MEM;
-+++  }
-+++
-+++  mbox->msgs[mbox->last % SYS_MBOX_SIZE] = msg;
-+++
-+++  if (mbox->last == mbox->first) {
-+++    first = 1;
-+++  } else {
-+++    first = 0;
-+++  }
-+++
-+++  mbox->last++;
-+++
-+++  if (first) {
-+++    sys_sem_signal(&mbox->not_empty);
-+++  }
-+++
-+++  sys_sem_signal(&mbox->mutex);
-+++
-+++  return ERR_OK;
-+++}
-+++/*-----------------------------------------------------------------------------------*/
-+++void
-+++sys_mbox_post(struct sys_mbox **mb, void *msg)
-+++{
-+++  u8_t first;
-+++  struct sys_mbox *mbox;
-+++  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
-+++  mbox = *mb;
-+++
-+++  sys_arch_sem_wait(&mbox->mutex, 0);
-+++
-+++  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_post: mbox %p msg %p\n", (void *)mbox, (void *)msg));
-+++
-+++  while ((mbox->last + 1) >= (mbox->first + SYS_MBOX_SIZE)) {
-+++    mbox->wait_send++;
-+++    sys_sem_signal(&mbox->mutex);
-+++    sys_arch_sem_wait(&mbox->not_full, 0);
-+++    sys_arch_sem_wait(&mbox->mutex, 0);
-+++    mbox->wait_send--;
-+++  }
-+++
-+++  mbox->msgs[mbox->last % SYS_MBOX_SIZE] = msg;
-+++
-+++  if (mbox->last == mbox->first) {
-+++    first = 1;
-+++  } else {
-+++    first = 0;
-+++  }
-+++
-+++  mbox->last++;
-+++
-+++  if (first) {
-+++    sys_sem_signal(&mbox->not_empty);
-+++  }
-+++
-+++  sys_sem_signal(&mbox->mutex);
-+++}
-+++/*-----------------------------------------------------------------------------------*/
-+++u32_t
-+++sys_arch_mbox_tryfetch(struct sys_mbox **mb, void **msg)
-+++{
-+++  struct sys_mbox *mbox;
-+++  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
-+++  mbox = *mb;
-+++
-+++  sys_arch_sem_wait(&mbox->mutex, 0);
-+++
-+++  if (mbox->first == mbox->last) {
-+++    sys_sem_signal(&mbox->mutex);
-+++    return SYS_MBOX_EMPTY;
-+++  }
-+++
-+++  if (msg != NULL) {
-+++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_tryfetch: mbox %p msg %p\n", (void *)mbox, *msg));
-+++    *msg = mbox->msgs[mbox->first % SYS_MBOX_SIZE];
-+++  }
-+++  else{
-+++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_tryfetch: mbox %p, null msg\n", (void *)mbox));
-+++  }
-+++
-+++  mbox->first++;
-+++
-+++  if (mbox->wait_send) {
-+++    sys_sem_signal(&mbox->not_full);
-+++  }
-+++
-+++  sys_sem_signal(&mbox->mutex);
-+++
-+++  return 0;
-+++}
-+++/*-----------------------------------------------------------------------------------*/
-+++u32_t
-+++sys_arch_mbox_fetch(struct sys_mbox **mb, void **msg, u32_t timeout)
-+++{
-+++  u32_t time_needed = 0;
-+++  struct sys_mbox *mbox;
-+++  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
-+++  mbox = *mb;
-+++
-+++  /* The mutex lock is quick so we don't bother with the timeout
-+++     stuff here. */
-+++  sys_arch_sem_wait(&mbox->mutex, 0);
-+++
-+++  while (mbox->first == mbox->last) {
-+++    sys_sem_signal(&mbox->mutex);
-+++
-+++    /* We block while waiting for a mail to arrive in the mailbox. We
-+++       must be prepared to timeout. */
-+++    if (timeout != 0) {
-+++      time_needed = sys_arch_sem_wait(&mbox->not_empty, timeout);
-+++
-+++      if (time_needed == SYS_ARCH_TIMEOUT) {
-+++        return SYS_ARCH_TIMEOUT;
-+++      }
-+++    } else {
-+++      sys_arch_sem_wait(&mbox->not_empty, 0);
-+++    }
-+++
-+++    sys_arch_sem_wait(&mbox->mutex, 0);
-+++  }
-+++
-+++  if (msg != NULL) {
-+++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_fetch: mbox %p msg %p\n", (void *)mbox, *msg));
-+++    *msg = mbox->msgs[mbox->first % SYS_MBOX_SIZE];
-+++  }
-+++  else{
-+++    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_fetch: mbox %p, null msg\n", (void *)mbox));
-+++  }
-+++
-+++  mbox->first++;
-+++
-+++  if (mbox->wait_send) {
-+++    sys_sem_signal(&mbox->not_full);
-+++  }
-+++
-+++  sys_sem_signal(&mbox->mutex);
-+++
-+++  return time_needed;
-+++}
-+++/*-----------------------------------------------------------------------------------*/
-+++static struct sys_sem *
-+++sys_sem_new_internal(u8_t count)
-+++{
-+++  struct sys_sem *sem = NULL;
-+++  int rc;
-+++
-+++  sem = (struct sys_sem *)malloc(sizeof(struct sys_sem));
-+++  if (sem != NULL) {
-+++    sem->c = count;
-+++    rc = pthread_cond_init(&(sem->cond), NULL);
-+++    if(rc != 0) {
-+++      LWIP_DEBUGF(SYS_DEBUG, ("sys_sem_new_internal: pthread_cond_init error = %d\n", rc));
-+++      return NULL;
-+++    }
-+++    rc = pthread_mutex_init(&(sem->mutex), NULL);
-+++    if(rc != 0) {
-+++      LWIP_DEBUGF(SYS_DEBUG, ("sys_sem_new_internal: pthread_mutex_init error = %d\n", rc));
-+++      SYS_STATS_INC(mutex.err);
-+++      pthread_cond_destroy(&(sem->cond));
-+++      return NULL;
-+++    }
-+++    SYS_STATS_INC_USED(mutex);
-+++    SYS_STATS_INC_USED(sem);
-+++  } else {
-+++    LWIP_DEBUGF(SYS_DEBUG, ("sys_sem_new_internal: could not create semaphore\n"));
-+++    SYS_STATS_INC(sem.err);
-+++  }
-+++  return sem;
-+++}
-+++/*-----------------------------------------------------------------------------------*/
-+++err_t
-+++sys_sem_new(struct sys_sem **sem, u8_t count)
-+++{
-+++  *sem = sys_sem_new_internal(count);
-+++  if (*sem == NULL) {
-+++    return ERR_MEM;
-+++  }
-+++  return ERR_OK;
-+++}
-+++/*-----------------------------------------------------------------------------------*/
-+++static u32_t
-+++cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex, u32_t timeout)
-+++{
-+++  time_t tdiff;
-+++  time_t sec, usec;
-+++  struct timeval rtime1, rtime2;
-+++  struct timespec ts;
-+++  int retval;
-+++
-+++  if (timeout > 0) {
-+++    /* Get a timestamp and add the timeout value. */
-+++    gettimeofday(&rtime1, NULL);
-+++    sec = rtime1.tv_sec;
-+++    usec = rtime1.tv_usec;
-+++    usec += timeout % 1000 * 1000;
-+++    sec += (int)(timeout / 1000) + (int)(usec / 1000000);
-+++    usec = usec % 1000000;
-+++    ts.tv_nsec = usec * 1000;
-+++    ts.tv_sec = sec;
-+++
-+++    retval = pthread_cond_timedwait(cond, mutex, &ts);
-+++
-+++    if (retval == ETIMEDOUT) {
-+++      return SYS_ARCH_TIMEOUT;
-+++    } else {
-+++      /* Calculate for how long we waited for the cond. */
-+++      gettimeofday(&rtime2, NULL);
-+++      tdiff = (rtime2.tv_sec - rtime1.tv_sec) * 1000 +
-+++        (rtime2.tv_usec - rtime1.tv_usec) / 1000;
-+++
-+++      if (tdiff <= 0) {
-+++        return 0;
-+++      }
-+++      return (u32_t)tdiff;
-+++    }
-+++  } else {
-+++    pthread_cond_wait(cond, mutex);
-+++    return 0;
-+++  }
-+++}
-+++/*-----------------------------------------------------------------------------------*/
-+++u32_t
-+++sys_arch_sem_wait(struct sys_sem **s, u32_t timeout)
-+++{
-+++  u32_t time_needed = 0;
-+++  struct sys_sem *sem;
-+++  LWIP_ASSERT("invalid sem", (s != NULL) && (*s != NULL));
-+++  sem = *s;
-+++
-+++  pthread_mutex_lock(&(sem->mutex));
-+++  while (sem->c <= 0) {
-+++    if (timeout > 0) {
-+++      time_needed = cond_wait(&(sem->cond), &(sem->mutex), timeout);
-+++
-+++      if (time_needed == SYS_ARCH_TIMEOUT) {
-+++        pthread_mutex_unlock(&(sem->mutex));
-+++        return SYS_ARCH_TIMEOUT;
-+++      }
-+++    } else {
-+++      cond_wait(&(sem->cond), &(sem->mutex), 0);
-+++    }
-+++  }
-+++  sem->c--;
-+++  pthread_mutex_unlock(&(sem->mutex));
-+++  return (u32_t)time_needed;
-+++}
-+++/*-----------------------------------------------------------------------------------*/
-+++void
-+++sys_sem_signal(struct sys_sem **s)
-+++{
-+++  struct sys_sem *sem;
-+++  LWIP_ASSERT("invalid sem", (s != NULL) && (*s != NULL));
-+++  sem = *s;
-+++
-+++  pthread_mutex_lock(&(sem->mutex));
-+++  sem->c++;
-+++
-+++  if (sem->c > 1) {
-+++    sem->c = 1;
-+++  }
-+++
-+++  pthread_cond_broadcast(&(sem->cond));
-+++  pthread_mutex_unlock(&(sem->mutex));
-+++}
-+++/*-----------------------------------------------------------------------------------*/
-+++static void
-+++sys_sem_free_internal(struct sys_sem *sem)
-+++{
-+++  if(sem != NULL) {
-+++    pthread_cond_destroy(&(sem->cond));
-+++    pthread_mutex_destroy(&(sem->mutex));
-+++    SYS_STATS_DEC(mutex.used);
-+++    SYS_STATS_DEC(sem.used);
-+++    free(sem);
-+++  }
-+++}
-+++/*-----------------------------------------------------------------------------------*/
-+++void
-+++sys_sem_free(struct sys_sem **sem)
-+++{
-+++  if ((sem != NULL) && (*sem != SYS_SEM_NULL)) {
-+++    sys_sem_free_internal(*sem);
-+++  }
-+++}
-+++#endif /* !NO_SYS */
-+++/*-----------------------------------------------------------------------------------*/
-+++u32_t
-+++sys_now(void)
-+++{
-+++  struct timeval tv;
-+++  u32_t sec, usec, msec;
-+++  gettimeofday(&tv, NULL);
-+++
-+++  sec = (u32_t)(tv.tv_sec - starttime.tv_sec);
-+++  usec = (u32_t)(tv.tv_usec - starttime.tv_usec);
-+++  msec = sec * 1000 + usec / 1000;
-+++
-+++  return msec;
-+++}
-+++/*-----------------------------------------------------------------------------------*/
-+++void
-+++sys_init(void)
-+++{
-+++  SYS_STATS_INC_USED(mutex);
-+++  gettimeofday(&starttime, NULL);
-+++}
-+++/*-----------------------------------------------------------------------------------*/
-+++#if SYS_LIGHTWEIGHT_PROT
-+++/** sys_prot_t sys_arch_protect(void)
-+++
-+++This optional function does a "fast" critical region protection and returns
-+++the previous protection level. This function is only called during very short
-+++critical regions. An embedded system which supports ISR-based drivers might
-+++want to implement this function by disabling interrupts. Task-based systems
-+++might want to implement this by using a mutex or disabling tasking. This
-+++function should support recursive calls from the same task or interrupt. In
-+++other words, sys_arch_protect() could be called while already protected. In
-+++that case the return value indicates that it is already protected.
-+++
-+++sys_arch_protect() is only required if your port is supporting an operating
-+++system.
-+++*/
-+++sys_prot_t
-+++sys_arch_protect(void)
-+++{
-+++    /* Note that for the UNIX port, we are using a lightweight mutex, and our
-+++     * own counter (which is locked by the mutex). The return code is not actually
-+++     * used. */
-+++    if (lwprot_thread != pthread_self())
-+++    {
-+++        /* We are locking the mutex where it has not been locked before *
-+++        * or is being locked by another thread */
-+++        pthread_mutex_lock(&lwprot_mutex);
-+++        lwprot_thread = pthread_self();
-+++        lwprot_count = 1;
-+++    }
-+++    else
-+++    {
-+++        /* It is already locked by THIS thread */
-+++        lwprot_count++;
-+++    }
-+++    return 0;
-+++}
-+++/*-----------------------------------------------------------------------------------*/
-+++/** void sys_arch_unprotect(sys_prot_t pval)
-+++
-+++This optional function does a "fast" set of critical region protection to the
-+++value specified by pval. See the documentation for sys_arch_protect() for
-+++more information. This function is only required if your port is supporting
-+++an operating system.
-+++*/
-+++void
-+++sys_arch_unprotect(sys_prot_t pval)
-+++{
-+++    LWIP_UNUSED_ARG(pval);
-+++    if (lwprot_thread == pthread_self())
-+++    {
-+++        if (--lwprot_count == 0)
-+++        {
-+++            lwprot_thread = (pthread_t) 0xDEAD;
-+++            pthread_mutex_unlock(&lwprot_mutex);
-+++        }
-+++    }
-+++}
-+++#endif /* SYS_LIGHTWEIGHT_PROT */
-+++
-+++/*-----------------------------------------------------------------------------------*/
-+++
-+++#ifndef MAX_JIFFY_OFFSET
-+++#define MAX_JIFFY_OFFSET ((~0U >> 1)-1)
-+++#endif
-+++
-+++#ifndef HZ
-+++#define HZ 100
-+++#endif
-+++
-+++u32_t
-+++sys_jiffies(void)
-+++{
-+++    struct timeval tv;
-+++    unsigned long sec;
-+++    long usec;
-+++
-+++    gettimeofday(&tv,NULL);
-+++    sec = tv.tv_sec - starttime.tv_sec;
-+++    usec = tv.tv_usec;
-+++
-+++    if (sec >= (MAX_JIFFY_OFFSET / HZ))
-+++      return MAX_JIFFY_OFFSET;
-+++    usec += 1000000L / HZ - 1;
-+++    usec /= 1000000L / HZ;
-+++    return HZ * sec + usec;
-+++}
-+++
-+++#if PPP_DEBUG
-+++
-+++#include <stdarg.h>
-+++
-+++void ppp_trace(int level, const char *format, ...)
-+++{
-+++    va_list args;
-+++
-+++    (void)level;
-+++    va_start(args, format);
-+++    vprintf(format, args);
-+++    va_end(args);
-+++}
-+++#endif
-++-- 
-++1.9.1
-++
-++
-++From d053fa836b445b6736bf82d33a33a59055150aa7 Mon Sep 17 00:00:00 2001
-++From: Jay Doyle <jay.doyle@vecna.com>
-++Date: Fri, 4 Sep 2015 17:30:37 -0400
-++Subject: [PATCH 2/9] changed the compiler options
-++
-++---
-++ Makefile | 2 +-
-++ 1 file changed, 1 insertion(+), 1 deletion(-)
-++
-++diff --git a/Makefile b/Makefile
-++index 0cbae64..94fcafc 100644
-++--- a/Makefile
-+++++ b/Makefile
-++@@ -5,7 +5,7 @@ include $(PROJECT_ROOT)/make/leaf.cfg
-++ #### CONFIG ####################################################################
-++ #For debugging symbols add -DLWIP_DEBUG
-++ # COMPILER/LINKER
-++-CFLAGS+=-g -O2   \
-+++CFLAGS+=-g -O0   \
-++  -Wall
-++ 
-++ # OUTPUT
-++-- 
-++1.9.1
-++
-++
-++From 841adb17430bdb9298dcb6d44ac5dad72e82af80 Mon Sep 17 00:00:00 2001
-++From: Jay Doyle <jay.doyle@vecna.com>
-++Date: Mon, 7 Sep 2015 08:56:58 -0400
-++Subject: [PATCH 3/9] disabled any mention of ipv6
-++
-++---
-++ Makefile | 6 +++---
-++ 1 file changed, 3 insertions(+), 3 deletions(-)
-++
-++diff --git a/Makefile b/Makefile
-++index 94fcafc..6efa141 100644
-++--- a/Makefile
-+++++ b/Makefile
-++@@ -40,7 +40,7 @@ CORE_SRC=$(wildcard $(LWIP_CORE_PATH)/*.c)
-++ IPV4_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv4/*.c)
-++ 
-++ ## IPv6
-++-IPV6_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv6/*.c)
-+++#IPV6_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv6/*.c)
-++ 
-++ ## SNMP
-++ SNMP_SRC=$(wildcard $(LWIP_CORE_PATH)/snmp/*.c)
-++@@ -71,7 +71,7 @@ SOURCES =  $(DRIVER_SRC) $(SNMP_SRC)\
-++ CORE_H=$(LWIP_INCL_PATH)
-++ 
-++ ## IPv4
-++-#IPV4_H=$(LWIP_INCL_PATH)/ipv4
-+++IPV4_H=$(LWIP_INCL_PATH)/ipv4
-++ 
-++ ## IPv6
-++ #IPV6_H=$(LWIP_INCL_PATH)/ipv6
-++@@ -97,7 +97,7 @@ DRIVER_H=$(LWIPDRIVER_INCL_PATH)
-++ # HEADERS
-++ HEADERS=-I$(CORE_H) -I$(POSIX_H) -I$(POSIX_SYS_H) -I$(NETIF_H) \
-++         -I$(NETIF_H_PPP) -I$(NETIF_H_PPP_POLARSSL) -I$(ARCH_H) \
-++-        -I$(DRIVER_H)
-+++        -I$(DRIVER_H) -I$(IPV4_H)
-++ 
-++ 
-++ ################################################################################
-++-- 
-++1.9.1
-++
-++
-++From a653d818348fef0130e6e497eecb0c3a35822df4 Mon Sep 17 00:00:00 2001
-++From: Jay Doyle <jay.doyle@vecna.com>
-++Date: Mon, 7 Sep 2015 09:27:48 -0400
-++Subject: [PATCH 4/9] added in stm32f low-level driver
-++
-++---
-++ src/netif/ethernetif.c | 709 ++++++++++++++++++++++++++++++-------------------
-++ 1 file changed, 435 insertions(+), 274 deletions(-)
-++
-++diff --git a/src/netif/ethernetif.c b/src/netif/ethernetif.c
-++index 7982d11..82c85ae 100644
-++--- a/src/netif/ethernetif.c
-+++++ b/src/netif/ethernetif.c
-++@@ -1,335 +1,496 @@
-++ /**
-++- * @file
-++- * Ethernet Interface Skeleton
-++- *
-++- */
-++-
-++-/*
-++- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
-++- * All rights reserved. 
-++- * 
-++- * Redistribution and use in source and binary forms, with or without modification, 
-++- * are permitted provided that the following conditions are met:
-++- *
-++- * 1. Redistributions of source code must retain the above copyright notice,
-++- *    this list of conditions and the following disclaimer.
-++- * 2. Redistributions in binary form must reproduce the above copyright notice,
-++- *    this list of conditions and the following disclaimer in the documentation
-++- *    and/or other materials provided with the distribution.
-++- * 3. The name of the author may not be used to endorse or promote products
-++- *    derived from this software without specific prior written permission. 
-++- *
-++- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
-++- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
-++- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
-++- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
-++- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
-++- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
-++- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
-++- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
-++- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
-++- * OF SUCH DAMAGE.
-++- *
-++- * This file is part of the lwIP TCP/IP stack.
-++- * 
-++- * Author: Adam Dunkels <adam@sics.se>
-++- *
-++- */
-++-
-++-/*
-++- * This file is a skeleton for developing Ethernet network interface
-++- * drivers for lwIP. Add code to the low_level functions and do a
-++- * search-and-replace for the word "ethernetif" to replace it with
-++- * something that better describes your network interface.
-++- */
-++-
-+++  ******************************************************************************
-+++  * @file    LwIP/LwIP_HTTP_Server_Netconn_RTOS/Src/ethernetif.c
-+++  * @author  MCD Application Team
-+++  * @version V1.0.0
-+++  * @date    25-June-2015
-+++  * @brief   This file implements Ethernet network interface drivers for lwIP
-+++  ******************************************************************************
-+++  * @attention
-+++  *
-+++  * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
-+++  *
-+++  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
-+++  * You may not use this file except in compliance with the License.
-+++  * You may obtain a copy of the License at:
-+++  *
-+++  *        http://www.st.com/software_license_agreement_liberty_v2
-+++  *
-+++  * Unless required by applicable law or agreed to in writing, software 
-+++  * distributed under the License is distributed on an "AS IS" BASIS, 
-+++  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-+++  * See the License for the specific language governing permissions and
-+++  * limitations under the License.
-+++  *
-+++  ******************************************************************************
-+++  */
-+++
-+++/* Includes ------------------------------------------------------------------*/
-+++#include "stm32f7xx_hal.h"
-++ #include "lwip/opt.h"
-++-
-++-#if 0 /* don't build, this is only a skeleton, see previous comment */
-++-
-++-#include "lwip/def.h"
-++-#include "lwip/mem.h"
-++-#include "lwip/pbuf.h"
-++-#include "lwip/stats.h"
-++-#include "lwip/snmp.h"
-++-#include "lwip/ethip6.h"
-+++#include "lwip/lwip_timers.h"
-++ #include "netif/etharp.h"
-++-#include "netif/ppp/pppoe.h"
-+++#include "hal-ethernetif.h"
-+++#include <string.h>
-+++
-+++/* Private typedef -----------------------------------------------------------*/
-+++/* Private define ------------------------------------------------------------*/
-+++/* The time to block waiting for input. */
-+++#define TIME_WAITING_FOR_INPUT                 ( 100 )
-+++/* Stack size of the interface thread */
-+++#define INTERFACE_THREAD_STACK_SIZE            ( 350 )
-++ 
-++ /* Define those to better describe your network interface. */
-++ #define IFNAME0 'e'
-++ #define IFNAME1 'n'
-++ 
-++-/**
-++- * Helper struct to hold private data used to operate your ethernet interface.
-++- * Keeping the ethernet address of the MAC in this struct is not necessary
-++- * as it is already kept in the struct netif.
-++- * But this is only an example, anyway...
-++- */
-++-struct ethernetif {
-++-  struct eth_addr *ethaddr;
-++-  /* Add whatever per-interface state that is needed here. */
-++-};
-++-
-++-/* Forward declarations. */
-++-static void  ethernetif_input(struct netif *netif);
-+++#define LAN8742A_PHY_ADDRESS            0x00
-++ 
-++-/**
-++- * In this function, the hardware should be initialized.
-++- * Called from ethernetif_init().
-++- *
-++- * @param netif the already initialized lwip network interface structure
-++- *        for this ethernetif
-++- */
-++-static void
-++-low_level_init(struct netif *netif)
-++-{
-++-  struct ethernetif *ethernetif = netif->state;
-++-  
-++-  /* set MAC hardware address length */
-++-  netif->hwaddr_len = ETHARP_HWADDR_LEN;
-+++/* Private macro -------------------------------------------------------------*/
-+++/* Private variables ---------------------------------------------------------*/
-++ 
-++-  /* set MAC hardware address */
-++-  netif->hwaddr[0] = ;
-++-  ...
-++-  netif->hwaddr[5] = ;
-+++#if defined ( __ICCARM__ ) /*!< IAR Compiler */
-++ 
-++-  /* maximum transfer unit */
-++-  netif->mtu = 1500;
-++-  
-++-  /* device capabilities */
-++-  /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
-++-  netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
-++- 
-++-#if LWIP_IPV6 && LWIP_IPV6_MLD
-++-  /*
-++-   * For hardware/netifs that implement MAC filtering.
-++-   * All-nodes link-local is handled by default, so we must let the hardware know
-++-   * to allow multicast packets in.
-++-   * Should set mld_mac_filter previously. */
-++-  if (netif->mld_mac_filter != NULL) {
-++-    ip6_addr_t ip6_allnodes_ll;
-++-    ip6_addr_set_allnodes_linklocal(&ip6_allnodes_ll);
-++-    netif->mld_mac_filter(netif, &ip6_allnodes_ll, MLD6_ADD_MAC_FILTER);
-++-  }
-++-#endif /* LWIP_IPV6 && LWIP_IPV6_MLD */
-+++#pragma location=0x2000E000
-+++__no_init ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
-+++#pragma location=0x2000E100
-+++__no_init ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
-+++#elif defined ( __CC_ARM   )
-+++ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((at(0x2000E000)));/* Ethernet Rx MA Descriptor */
-+++ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((at(0x2000E100)));/* Ethernet Tx DMA Descriptor */
-+++#elif defined ( __GNUC__   )
-+++//ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".RxDescripSection")));/* Ethernet Rx MA Descriptor */
-+++//ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".TxDescripSection")));/* Ethernet Tx DMA Descriptor */
-+++ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Rx MA Descriptor */
-+++ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Tx DMA Descriptor */
-+++
-+++
-+++#endif
-+++#if defined ( __ICCARM__ ) /*!< IAR Compiler */
-+++#pragma location=0x2000E200
-+++__no_init uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
-+++#pragma location=0x2000FFC4
-+++__no_init uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
-+++#elif defined ( __CC_ARM   )
-+++uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((at(0x2000E200)));  /* Ethernet Receive Buffer */
-+++uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]  __attribute__((at(0x2000FFC4))); /* Ethernet Transmit Buffer */
-+++#elif defined ( __GNUC__   )
-+++//uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".RxBUF")));/* Ethernet Receive Buffer */
-+++//uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".TxBUF")));/* Ethernet Transmit Buffer */
-+++uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Receive Buffer */
-+++uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Transmit Buffer */
-+++
-+++#endif
-+++/* Semaphore to signal incoming packets */
-+++osSemaphoreId s_xSemaphore = NULL;
-++ 
-++-  /* Do whatever else is needed to initialize interface. */  
-+++/* Global Ethernet handle*/
-+++ETH_HandleTypeDef EthHandle;
-+++
-+++/* Private function prototypes -----------------------------------------------*/
-+++static void ethernetif_input( void const * argument );
-+++
-+++static void stm32f_ethernet_isr(
-+++  void* argData
-+++)
-+++{
-+++  ETH_HandleTypeDef* pEth =
-+++    (ETH_HandleTypeDef*) argData;
-+++
-+++  HAL_ETH_IRQHandler(pEth);
-++ }
-++ 
-+++/* Private functions ---------------------------------------------------------*/
-+++/*******************************************************************************
-+++                       Ethernet MSP Routines
-+++*******************************************************************************/
-++ /**
-++- * This function should do the actual transmission of the packet. The packet is
-++- * contained in the pbuf that is passed to the function. This pbuf
-++- * might be chained.
-++- *
-++- * @param netif the lwip network interface structure for this ethernetif
-++- * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
-++- * @return ERR_OK if the packet could be sent
-++- *         an err_t value if the packet couldn't be sent
-++- *
-++- * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
-++- *       strange results. You might consider waiting for space in the DMA queue
-++- *       to become available since the stack doesn't retry to send a packet
-++- *       dropped because of memory failure (except for the TCP timers).
-++- */
-++-
-++-static err_t
-++-low_level_output(struct netif *netif, struct pbuf *p)
-+++  * @brief  Initializes the ETH MSP.
-+++  * @param  heth: ETH handle
-+++  * @retval None
-+++  */
-+++void HAL_ETH_MspInit(ETH_HandleTypeDef *heth)
-++ {
-++-  struct ethernetif *ethernetif = netif->state;
-++-  struct pbuf *q;
-++-
-++-  initiate transfer();
-+++  GPIO_InitTypeDef GPIO_InitStructure;
-++   
-++-#if ETH_PAD_SIZE
-++-  pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
-++-#endif
-++-
-++-  for(q = p; q != NULL; q = q->next) {
-++-    /* Send the data from the pbuf to the interface, one pbuf at a
-++-       time. The size of the data in each pbuf is kept in the ->len
-++-       variable. */
-++-    send data from(q->payload, q->len);
-++-  }
-+++  /* Enable GPIOs clocks */
-+++  __HAL_RCC_GPIOA_CLK_ENABLE();
-+++  __HAL_RCC_GPIOC_CLK_ENABLE();
-+++  __HAL_RCC_GPIOG_CLK_ENABLE();
-++ 
-++-  signal that packet should be sent();
-+++/* Ethernet pins configuration ************************************************/
-+++  /*
-+++        RMII_REF_CLK ----------------------> PA1
-+++        RMII_MDIO -------------------------> PA2
-+++        RMII_MDC --------------------------> PC1
-+++        RMII_MII_CRS_DV -------------------> PA7
-+++        RMII_MII_RXD0 ---------------------> PC4
-+++        RMII_MII_RXD1 ---------------------> PC5
-+++        RMII_MII_RXER ---------------------> PG2
-+++        RMII_MII_TX_EN --------------------> PG11
-+++        RMII_MII_TXD0 ---------------------> PG13
-+++        RMII_MII_TXD1 ---------------------> PG14
-+++  */
-+++
-+++  /* Configure PA1, PA2 and PA7 */
-+++  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
-+++  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
-+++  GPIO_InitStructure.Pull = GPIO_NOPULL; 
-+++  GPIO_InitStructure.Alternate = GPIO_AF11_ETH;
-+++  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
-+++  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
-+++  
-+++  /* Configure PC1, PC4 and PC5 */
-+++  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;
-+++  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
-++ 
-++-#if ETH_PAD_SIZE
-++-  pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
-++-#endif
-+++  /* Configure PG2, PG11, PG13 and PG14 */
-+++  GPIO_InitStructure.Pin =  GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14;
-+++  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
-++   
-++-  LINK_STATS_INC(link.xmit);
-+++  // Install HAL Ethernet ISR
-+++  rtems_interrupt_handler_install(
-+++    ETH_IRQn,
-+++    NULL,
-+++    0,
-+++    stm32f_ethernet_isr,
-+++    heth);
-+++  
-+++  /* Enable ETHERNET clock  */
-+++  __HAL_RCC_ETH_CLK_ENABLE();
-+++}
-++ 
-++-  return ERR_OK;
-+++/**
-+++  * @brief  Ethernet Rx Transfer completed callback
-+++  * @param  heth: ETH handle
-+++  * @retval None
-+++  */
-+++void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
-+++{
-+++  osSemaphoreRelease(s_xSemaphore);
-++ }
-++ 
-++ /**
-++- * Should allocate a pbuf and transfer the bytes of the incoming
-++- * packet from the interface into the pbuf.
-++- *
-++- * @param netif the lwip network interface structure for this ethernetif
-++- * @return a pbuf filled with the received packet (including MAC header)
-++- *         NULL on memory error
-++- */
-++-static struct pbuf *
-++-low_level_input(struct netif *netif)
-+++  * @brief  Ethernet IRQ Handler
-+++  * @param  None
-+++  * @retval None
-+++  */
-+++void ETHERNET_IRQHandler(void)
-++ {
-++-  struct ethernetif *ethernetif = netif->state;
-++-  struct pbuf *p, *q;
-++-  u16_t len;
-+++  HAL_ETH_IRQHandler(&EthHandle);
-+++}
-++ 
-++-  /* Obtain the size of the packet and put it into the "len"
-++-     variable. */
-++-  len = ;
-+++/*******************************************************************************
-+++                       LL Driver Interface ( LwIP stack --> ETH) 
-+++*******************************************************************************/
-+++/**
-+++  * @brief In this function, the hardware should be initialized.
-+++  * Called from ethernetif_init().
-+++  *
-+++  * @param netif the already initialized lwip network interface structure
-+++  *        for this ethernetif
-+++  */
-+++static void low_level_init(struct netif *netif)
-+++{
-+++  uint8_t macaddress[6]= { MAC_ADDR0, MAC_ADDR1, MAC_ADDR2, MAC_ADDR3, MAC_ADDR4, MAC_ADDR5 };
-+++  
-+++  EthHandle.Instance = ETH;  
-+++  EthHandle.Init.MACAddr = macaddress;
-+++  EthHandle.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
-+++  EthHandle.Init.Speed = ETH_SPEED_100M;
-+++  EthHandle.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
-+++  EthHandle.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
-+++  EthHandle.Init.RxMode = ETH_RXINTERRUPT_MODE;
-+++  EthHandle.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
-+++  EthHandle.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
-+++  
-+++  /* configure ethernet peripheral (GPIOs, clocks, MAC, DMA) */
-+++  if (HAL_ETH_Init(&EthHandle) == HAL_OK)
-+++  {
-+++    /* Set netif link flag */
-+++    netif->flags |= NETIF_FLAG_LINK_UP;
-+++  }
-+++  
-+++  /* Initialize Tx Descriptors list: Chain Mode */
-+++  HAL_ETH_DMATxDescListInit(&EthHandle, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
-+++     
-+++  /* Initialize Rx Descriptors list: Chain Mode  */
-+++  HAL_ETH_DMARxDescListInit(&EthHandle, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
-+++  
-+++  /* set netif MAC hardware address length */
-+++  netif->hwaddr_len = ETHARP_HWADDR_LEN;
-++ 
-++-#if ETH_PAD_SIZE
-++-  len += ETH_PAD_SIZE; /* allow room for Ethernet padding */
-++-#endif
-+++  /* set netif MAC hardware address */
-+++  netif->hwaddr[0] =  MAC_ADDR0;
-+++  netif->hwaddr[1] =  MAC_ADDR1;
-+++  netif->hwaddr[2] =  MAC_ADDR2;
-+++  netif->hwaddr[3] =  MAC_ADDR3;
-+++  netif->hwaddr[4] =  MAC_ADDR4;
-+++  netif->hwaddr[5] =  MAC_ADDR5;
-++ 
-++-  /* We allocate a pbuf chain of pbufs from the pool. */
-++-  p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
-++-  
-++-  if (p != NULL) {
-+++  /* set netif maximum transfer unit */
-+++  netif->mtu = 1500;
-++ 
-++-#if ETH_PAD_SIZE
-++-    pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
-++-#endif
-+++  /* Accept broadcast address and ARP traffic */
-+++  netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
-++ 
-++-    /* We iterate over the pbuf chain until we have read the entire
-++-     * packet into the pbuf. */
-++-    for(q = p; q != NULL; q = q->next) {
-++-      /* Read enough bytes to fill this pbuf in the chain. The
-++-       * available data in the pbuf is given by the q->len
-++-       * variable.
-++-       * This does not necessarily have to be a memcpy, you can also preallocate
-++-       * pbufs for a DMA-enabled MAC and after receiving truncate it to the
-++-       * actually received size. In this case, ensure the tot_len member of the
-++-       * pbuf is the sum of the chained pbuf len members.
-++-       */
-++-      read data into(q->payload, q->len);
-++-    }
-++-    acknowledge that packet has been read();
-+++  /* create a binary semaphore used for informing ethernetif of frame reception */
-+++  osSemaphoreDef(SEM);
-+++  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1 );
-+++
-+++  /* create the task that handles the ETH_MAC */
-+++  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
-+++  osThreadCreate (osThread(EthIf), netif);
-+++
-+++  /* Enable MAC and DMA transmission and reception */
-+++  HAL_ETH_Start(&EthHandle);
-+++}
-++ 
-++-#if ETH_PAD_SIZE
-++-    pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
-++-#endif
-++ 
-++-    LINK_STATS_INC(link.recv);
-++-  } else {
-++-    drop packet();
-++-    LINK_STATS_INC(link.memerr);
-++-    LINK_STATS_INC(link.drop);
-+++/**
-+++  * @brief This function should do the actual transmission of the packet. The packet is
-+++  * contained in the pbuf that is passed to the function. This pbuf
-+++  * might be chained.
-+++  *
-+++  * @param netif the lwip network interface structure for this ethernetif
-+++  * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
-+++  * @return ERR_OK if the packet could be sent
-+++  *         an err_t value if the packet couldn't be sent
-+++  *
-+++  * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
-+++  *       strange results. You might consider waiting for space in the DMA queue
-+++  *       to become available since the stack doesn't retry to send a packet
-+++  *       dropped because of memory failure (except for the TCP timers).
-+++  */
-+++static err_t low_level_output(struct netif *netif, struct pbuf *p)
-+++{
-+++  err_t errval;
-+++  struct pbuf *q;
-+++  uint8_t *buffer = (uint8_t *)(EthHandle.TxDesc->Buffer1Addr);
-+++  __IO ETH_DMADescTypeDef *DmaTxDesc;
-+++  uint32_t framelength = 0;
-+++  uint32_t bufferoffset = 0;
-+++  uint32_t byteslefttocopy = 0;
-+++  uint32_t payloadoffset = 0;
-+++
-+++  DmaTxDesc = EthHandle.TxDesc;
-+++  bufferoffset = 0;
-+++  
-+++  /* copy frame from pbufs to driver buffers */
-+++  for(q = p; q != NULL; q = q->next)
-+++  {
-+++    /* Is this buffer available? If not, goto error */
-+++    if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
-+++    {
-+++      errval = ERR_USE;
-+++      goto error;
-+++    }
-+++    
-+++    /* Get bytes in current lwIP buffer */
-+++    byteslefttocopy = q->len;
-+++    payloadoffset = 0;
-+++    
-+++    /* Check if the length of data to copy is bigger than Tx buffer size*/
-+++    while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
-+++    {
-+++      /* Copy data to Tx buffer*/
-+++      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
-+++      
-+++      /* Point to next descriptor */
-+++      DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
-+++      
-+++      /* Check if the buffer is available */
-+++      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
-+++      {
-+++        errval = ERR_USE;
-+++        goto error;
-+++      }
-+++      
-+++      buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
-+++      
-+++      byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
-+++      payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
-+++      framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
-+++      bufferoffset = 0;
-+++    }
-+++    
-+++    /* Copy the remaining bytes */
-+++    memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
-+++    bufferoffset = bufferoffset + byteslefttocopy;
-+++    framelength = framelength + byteslefttocopy;
-+++  }
-+++  
-+++  /* Prepare transmit descriptors to give to DMA */ 
-+++  HAL_ETH_TransmitFrame(&EthHandle, framelength);
-+++  
-+++  errval = ERR_OK;
-+++  
-+++error:
-+++  
-+++  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
-+++  if ((EthHandle.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
-+++  {
-+++    /* Clear TUS ETHERNET DMA flag */
-+++    EthHandle.Instance->DMASR = ETH_DMASR_TUS;
-+++    
-+++    /* Resume DMA transmission*/
-+++    EthHandle.Instance->DMATPDR = 0;
-++   }
-+++  return errval;
-+++}
-++ 
-++-  return p;  
-+++/**
-+++  * @brief Should allocate a pbuf and transfer the bytes of the incoming
-+++  * packet from the interface into the pbuf.
-+++  *
-+++  * @param netif the lwip network interface structure for this ethernetif
-+++  * @return a pbuf filled with the received packet (including MAC header)
-+++  *         NULL on memory error
-+++  */
-+++static struct pbuf * low_level_input(struct netif *netif)
-+++{
-+++  struct pbuf *p = NULL, *q = NULL;
-+++  uint16_t len = 0;
-+++  uint8_t *buffer;
-+++  __IO ETH_DMADescTypeDef *dmarxdesc;
-+++  uint32_t bufferoffset = 0;
-+++  uint32_t payloadoffset = 0;
-+++  uint32_t byteslefttocopy = 0;
-+++  uint32_t i=0;
-+++  
-+++  /* get received frame */
-+++  if(HAL_ETH_GetReceivedFrame_IT(&EthHandle) != HAL_OK)
-+++    return NULL;
-+++  
-+++  /* Obtain the size of the packet and put it into the "len" variable. */
-+++  len = EthHandle.RxFrameInfos.length;
-+++  buffer = (uint8_t *)EthHandle.RxFrameInfos.buffer;
-+++  
-+++  if (len > 0)
-+++  {
-+++    /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
-+++    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
-+++  }
-+++  
-+++  if (p != NULL)
-+++  {
-+++    dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
-+++    bufferoffset = 0;
-+++    
-+++    for(q = p; q != NULL; q = q->next)
-+++    {
-+++      byteslefttocopy = q->len;
-+++      payloadoffset = 0;
-+++      
-+++      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size */
-+++      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
-+++      {
-+++        /* Copy data to pbuf */
-+++        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
-+++        
-+++        /* Point to next descriptor */
-+++        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
-+++        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
-+++        
-+++        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
-+++        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
-+++        bufferoffset = 0;
-+++      }
-+++      
-+++      /* Copy remaining data in pbuf */
-+++      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
-+++      bufferoffset = bufferoffset + byteslefttocopy;
-+++    }
-+++  }
-+++    
-+++  /* Release descriptors to DMA */
-+++  /* Point to first descriptor */
-+++  dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
-+++  /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
-+++  for (i=0; i< EthHandle.RxFrameInfos.SegCount; i++)
-+++  {  
-+++    dmarxdesc->Status |= ETH_DMARXDESC_OWN;
-+++    dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
-+++  }
-+++    
-+++  /* Clear Segment_Count */
-+++  EthHandle.RxFrameInfos.SegCount =0;
-+++  
-+++  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
-+++  if ((EthHandle.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
-+++  {
-+++    /* Clear RBUS ETHERNET DMA flag */
-+++    EthHandle.Instance->DMASR = ETH_DMASR_RBUS;
-+++    /* Resume DMA reception */
-+++    EthHandle.Instance->DMARPDR = 0;
-+++  }
-+++  return p;
-++ }
-++ 
-++ /**
-++- * This function should be called when a packet is ready to be read
-++- * from the interface. It uses the function low_level_input() that
-++- * should handle the actual reception of bytes from the network
-++- * interface. Then the type of the received packet is determined and
-++- * the appropriate input function is called.
-++- *
-++- * @param netif the lwip network interface structure for this ethernetif
-++- */
-++-static void
-++-ethernetif_input(struct netif *netif)
-+++  * @brief This function is the ethernetif_input task, it is processed when a packet 
-+++  * is ready to be read from the interface. It uses the function low_level_input() 
-+++  * that should handle the actual reception of bytes from the network
-+++  * interface. Then the type of the received packet is determined and
-+++  * the appropriate input function is called.
-+++  *
-+++  * @param netif the lwip network interface structure for this ethernetif
-+++  */
-+++void ethernetif_input( void const * argument )
-++ {
-++-  struct ethernetif *ethernetif;
-++-  struct eth_hdr *ethhdr;
-++   struct pbuf *p;
-++-
-++-  ethernetif = netif->state;
-++-
-++-  /* move received packet into a new pbuf */
-++-  p = low_level_input(netif);
-++-  /* no packet could be read, silently ignore this */
-++-  if (p == NULL) return;
-++-  /* points to packet payload, which starts with an Ethernet header */
-++-  ethhdr = p->payload;
-++-
-++-  switch (htons(ethhdr->type)) {
-++-  /* IP or ARP packet? */
-++-  case ETHTYPE_IP:
-++-  case ETHTYPE_IPV6:
-++-  case ETHTYPE_ARP:
-++-#if PPPOE_SUPPORT
-++-  /* PPPoE packet? */
-++-  case ETHTYPE_PPPOEDISC:
-++-  case ETHTYPE_PPPOE:
-++-#endif /* PPPOE_SUPPORT */
-++-    /* full packet send to tcpip_thread to process */
-++-    if (netif->input(p, netif)!=ERR_OK)
-++-     { LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
-++-       pbuf_free(p);
-++-       p = NULL;
-++-     }
-++-    break;
-++-
-++-  default:
-++-    pbuf_free(p);
-++-    p = NULL;
-++-    break;
-+++  struct netif *netif = (struct netif *) argument;
-+++  
-+++  for( ;; )
-+++  {
-+++    if (osSemaphoreWait( s_xSemaphore, TIME_WAITING_FOR_INPUT)==osOK)
-+++    {
-+++      do
-+++      {
-+++        p = low_level_input( netif );
-+++        if (p != NULL)
-+++        {
-+++          if (netif->input( p, netif) != ERR_OK )
-+++          {
-+++            pbuf_free(p);
-+++          }
-+++        }
-+++      }while(p!=NULL);
-+++    }
-++   }
-++ }
-++ 
-++ /**
-++- * Should be called at the beginning of the program to set up the
-++- * network interface. It calls the function low_level_init() to do the
-++- * actual setup of the hardware.
-++- *
-++- * This function should be passed as a parameter to netif_add().
-++- *
-++- * @param netif the lwip network interface structure for this ethernetif
-++- * @return ERR_OK if the loopif is initialized
-++- *         ERR_MEM if private data couldn't be allocated
-++- *         any other err_t on error
-++- */
-++-err_t
-++-ethernetif_init(struct netif *netif)
-+++  * @brief Should be called at the beginning of the program to set up the
-+++  * network interface. It calls the function low_level_init() to do the
-+++  * actual setup of the hardware.
-+++  *
-+++  * This function should be passed as a parameter to netif_add().
-+++  *
-+++  * @param netif the lwip network interface structure for this ethernetif
-+++  * @return ERR_OK if the loopif is initialized
-+++  *         ERR_MEM if private data couldn't be allocated
-+++  *         any other err_t on error
-+++  */
-+++err_t ethernetif_init(struct netif *netif)
-++ {
-++-  struct ethernetif *ethernetif;
-++-
-++   LWIP_ASSERT("netif != NULL", (netif != NULL));
-++-    
-++-  ethernetif = mem_malloc(sizeof(struct ethernetif));
-++-  if (ethernetif == NULL) {
-++-    LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_init: out of memory\n"));
-++-    return ERR_MEM;
-++-  }
-++ 
-++ #if LWIP_NETIF_HOSTNAME
-++   /* Initialize interface hostname */
-++   netif->hostname = "lwip";
-++ #endif /* LWIP_NETIF_HOSTNAME */
-++ 
-++-  /*
-++-   * Initialize the snmp variables and counters inside the struct netif.
-++-   * The last argument should be replaced with your link speed, in units
-++-   * of bits per second.
-++-   */
-++-  NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, LINK_SPEED_OF_YOUR_NETIF_IN_BPS);
-++-
-++-  netif->state = ethernetif;
-++   netif->name[0] = IFNAME0;
-++   netif->name[1] = IFNAME1;
-++-  /* We directly use etharp_output() here to save a function call.
-++-   * You can instead declare your own function an call etharp_output()
-++-   * from it if you have to do some checks before sending (e.g. if link
-++-   * is available...) */
-+++
-++   netif->output = etharp_output;
-++-#if LWIP_IPV6
-++-  netif->output_ip6 = ethip6_output;
-++-#endif /* LWIP_IPV6 */
-++   netif->linkoutput = low_level_output;
-++-  
-++-  ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
-++-  
-+++
-++   /* initialize the hardware */
-++   low_level_init(netif);
-++ 
-++   return ERR_OK;
-++ }
-++ 
-++-#endif /* 0 */
-+++/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
-++-- 
-++1.9.1
-++
-++
-++From ab97b49d1d41e34fdfdfb457b397c768ee228c9f Mon Sep 17 00:00:00 2001
-++From: Jay Doyle <jay.doyle@vecna.com>
-++Date: Mon, 7 Sep 2015 09:39:20 -0400
-++Subject: [PATCH 5/9] removed ethernetif (it should be in BSP
-++
-++---
-++ src/netif/ethernetif.c | 496 -------------------------------------------------
-++ 1 file changed, 496 deletions(-)
-++ delete mode 100644 src/netif/ethernetif.c
-++
-++diff --git a/src/netif/ethernetif.c b/src/netif/ethernetif.c
-++deleted file mode 100644
-++index 82c85ae..0000000
-++--- a/src/netif/ethernetif.c
-+++++ /dev/null
-++@@ -1,496 +0,0 @@
-++-/**
-++-  ******************************************************************************
-++-  * @file    LwIP/LwIP_HTTP_Server_Netconn_RTOS/Src/ethernetif.c
-++-  * @author  MCD Application Team
-++-  * @version V1.0.0
-++-  * @date    25-June-2015
-++-  * @brief   This file implements Ethernet network interface drivers for lwIP
-++-  ******************************************************************************
-++-  * @attention
-++-  *
-++-  * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
-++-  *
-++-  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
-++-  * You may not use this file except in compliance with the License.
-++-  * You may obtain a copy of the License at:
-++-  *
-++-  *        http://www.st.com/software_license_agreement_liberty_v2
-++-  *
-++-  * Unless required by applicable law or agreed to in writing, software 
-++-  * distributed under the License is distributed on an "AS IS" BASIS, 
-++-  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-++-  * See the License for the specific language governing permissions and
-++-  * limitations under the License.
-++-  *
-++-  ******************************************************************************
-++-  */
-++-
-++-/* Includes ------------------------------------------------------------------*/
-++-#include "stm32f7xx_hal.h"
-++-#include "lwip/opt.h"
-++-#include "lwip/lwip_timers.h"
-++-#include "netif/etharp.h"
-++-#include "hal-ethernetif.h"
-++-#include <string.h>
-++-
-++-/* Private typedef -----------------------------------------------------------*/
-++-/* Private define ------------------------------------------------------------*/
-++-/* The time to block waiting for input. */
-++-#define TIME_WAITING_FOR_INPUT                 ( 100 )
-++-/* Stack size of the interface thread */
-++-#define INTERFACE_THREAD_STACK_SIZE            ( 350 )
-++-
-++-/* Define those to better describe your network interface. */
-++-#define IFNAME0 'e'
-++-#define IFNAME1 'n'
-++-
-++-#define LAN8742A_PHY_ADDRESS            0x00
-++-
-++-/* Private macro -------------------------------------------------------------*/
-++-/* Private variables ---------------------------------------------------------*/
-++-
-++-#if defined ( __ICCARM__ ) /*!< IAR Compiler */
-++-
-++-#pragma location=0x2000E000
-++-__no_init ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
-++-#pragma location=0x2000E100
-++-__no_init ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
-++-#elif defined ( __CC_ARM   )
-++-ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((at(0x2000E000)));/* Ethernet Rx MA Descriptor */
-++-ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((at(0x2000E100)));/* Ethernet Tx DMA Descriptor */
-++-#elif defined ( __GNUC__   )
-++-//ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".RxDescripSection")));/* Ethernet Rx MA Descriptor */
-++-//ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".TxDescripSection")));/* Ethernet Tx DMA Descriptor */
-++-ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Rx MA Descriptor */
-++-ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Tx DMA Descriptor */
-++-
-++-
-++-#endif
-++-#if defined ( __ICCARM__ ) /*!< IAR Compiler */
-++-#pragma location=0x2000E200
-++-__no_init uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
-++-#pragma location=0x2000FFC4
-++-__no_init uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
-++-#elif defined ( __CC_ARM   )
-++-uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((at(0x2000E200)));  /* Ethernet Receive Buffer */
-++-uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]  __attribute__((at(0x2000FFC4))); /* Ethernet Transmit Buffer */
-++-#elif defined ( __GNUC__   )
-++-//uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".RxBUF")));/* Ethernet Receive Buffer */
-++-//uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".TxBUF")));/* Ethernet Transmit Buffer */
-++-uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Receive Buffer */
-++-uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Transmit Buffer */
-++-
-++-#endif
-++-/* Semaphore to signal incoming packets */
-++-osSemaphoreId s_xSemaphore = NULL;
-++-
-++-/* Global Ethernet handle*/
-++-ETH_HandleTypeDef EthHandle;
-++-
-++-/* Private function prototypes -----------------------------------------------*/
-++-static void ethernetif_input( void const * argument );
-++-
-++-static void stm32f_ethernet_isr(
-++-  void* argData
-++-)
-++-{
-++-  ETH_HandleTypeDef* pEth =
-++-    (ETH_HandleTypeDef*) argData;
-++-
-++-  HAL_ETH_IRQHandler(pEth);
-++-}
-++-
-++-/* Private functions ---------------------------------------------------------*/
-++-/*******************************************************************************
-++-                       Ethernet MSP Routines
-++-*******************************************************************************/
-++-/**
-++-  * @brief  Initializes the ETH MSP.
-++-  * @param  heth: ETH handle
-++-  * @retval None
-++-  */
-++-void HAL_ETH_MspInit(ETH_HandleTypeDef *heth)
-++-{
-++-  GPIO_InitTypeDef GPIO_InitStructure;
-++-  
-++-  /* Enable GPIOs clocks */
-++-  __HAL_RCC_GPIOA_CLK_ENABLE();
-++-  __HAL_RCC_GPIOC_CLK_ENABLE();
-++-  __HAL_RCC_GPIOG_CLK_ENABLE();
-++-
-++-/* Ethernet pins configuration ************************************************/
-++-  /*
-++-        RMII_REF_CLK ----------------------> PA1
-++-        RMII_MDIO -------------------------> PA2
-++-        RMII_MDC --------------------------> PC1
-++-        RMII_MII_CRS_DV -------------------> PA7
-++-        RMII_MII_RXD0 ---------------------> PC4
-++-        RMII_MII_RXD1 ---------------------> PC5
-++-        RMII_MII_RXER ---------------------> PG2
-++-        RMII_MII_TX_EN --------------------> PG11
-++-        RMII_MII_TXD0 ---------------------> PG13
-++-        RMII_MII_TXD1 ---------------------> PG14
-++-  */
-++-
-++-  /* Configure PA1, PA2 and PA7 */
-++-  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
-++-  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
-++-  GPIO_InitStructure.Pull = GPIO_NOPULL; 
-++-  GPIO_InitStructure.Alternate = GPIO_AF11_ETH;
-++-  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
-++-  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
-++-  
-++-  /* Configure PC1, PC4 and PC5 */
-++-  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;
-++-  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
-++-
-++-  /* Configure PG2, PG11, PG13 and PG14 */
-++-  GPIO_InitStructure.Pin =  GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14;
-++-  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
-++-  
-++-  // Install HAL Ethernet ISR
-++-  rtems_interrupt_handler_install(
-++-    ETH_IRQn,
-++-    NULL,
-++-    0,
-++-    stm32f_ethernet_isr,
-++-    heth);
-++-  
-++-  /* Enable ETHERNET clock  */
-++-  __HAL_RCC_ETH_CLK_ENABLE();
-++-}
-++-
-++-/**
-++-  * @brief  Ethernet Rx Transfer completed callback
-++-  * @param  heth: ETH handle
-++-  * @retval None
-++-  */
-++-void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
-++-{
-++-  osSemaphoreRelease(s_xSemaphore);
-++-}
-++-
-++-/**
-++-  * @brief  Ethernet IRQ Handler
-++-  * @param  None
-++-  * @retval None
-++-  */
-++-void ETHERNET_IRQHandler(void)
-++-{
-++-  HAL_ETH_IRQHandler(&EthHandle);
-++-}
-++-
-++-/*******************************************************************************
-++-                       LL Driver Interface ( LwIP stack --> ETH) 
-++-*******************************************************************************/
-++-/**
-++-  * @brief In this function, the hardware should be initialized.
-++-  * Called from ethernetif_init().
-++-  *
-++-  * @param netif the already initialized lwip network interface structure
-++-  *        for this ethernetif
-++-  */
-++-static void low_level_init(struct netif *netif)
-++-{
-++-  uint8_t macaddress[6]= { MAC_ADDR0, MAC_ADDR1, MAC_ADDR2, MAC_ADDR3, MAC_ADDR4, MAC_ADDR5 };
-++-  
-++-  EthHandle.Instance = ETH;  
-++-  EthHandle.Init.MACAddr = macaddress;
-++-  EthHandle.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
-++-  EthHandle.Init.Speed = ETH_SPEED_100M;
-++-  EthHandle.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
-++-  EthHandle.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
-++-  EthHandle.Init.RxMode = ETH_RXINTERRUPT_MODE;
-++-  EthHandle.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
-++-  EthHandle.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
-++-  
-++-  /* configure ethernet peripheral (GPIOs, clocks, MAC, DMA) */
-++-  if (HAL_ETH_Init(&EthHandle) == HAL_OK)
-++-  {
-++-    /* Set netif link flag */
-++-    netif->flags |= NETIF_FLAG_LINK_UP;
-++-  }
-++-  
-++-  /* Initialize Tx Descriptors list: Chain Mode */
-++-  HAL_ETH_DMATxDescListInit(&EthHandle, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
-++-     
-++-  /* Initialize Rx Descriptors list: Chain Mode  */
-++-  HAL_ETH_DMARxDescListInit(&EthHandle, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
-++-  
-++-  /* set netif MAC hardware address length */
-++-  netif->hwaddr_len = ETHARP_HWADDR_LEN;
-++-
-++-  /* set netif MAC hardware address */
-++-  netif->hwaddr[0] =  MAC_ADDR0;
-++-  netif->hwaddr[1] =  MAC_ADDR1;
-++-  netif->hwaddr[2] =  MAC_ADDR2;
-++-  netif->hwaddr[3] =  MAC_ADDR3;
-++-  netif->hwaddr[4] =  MAC_ADDR4;
-++-  netif->hwaddr[5] =  MAC_ADDR5;
-++-
-++-  /* set netif maximum transfer unit */
-++-  netif->mtu = 1500;
-++-
-++-  /* Accept broadcast address and ARP traffic */
-++-  netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
-++-
-++-  /* create a binary semaphore used for informing ethernetif of frame reception */
-++-  osSemaphoreDef(SEM);
-++-  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1 );
-++-
-++-  /* create the task that handles the ETH_MAC */
-++-  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
-++-  osThreadCreate (osThread(EthIf), netif);
-++-
-++-  /* Enable MAC and DMA transmission and reception */
-++-  HAL_ETH_Start(&EthHandle);
-++-}
-++-
-++-
-++-/**
-++-  * @brief This function should do the actual transmission of the packet. The packet is
-++-  * contained in the pbuf that is passed to the function. This pbuf
-++-  * might be chained.
-++-  *
-++-  * @param netif the lwip network interface structure for this ethernetif
-++-  * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
-++-  * @return ERR_OK if the packet could be sent
-++-  *         an err_t value if the packet couldn't be sent
-++-  *
-++-  * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
-++-  *       strange results. You might consider waiting for space in the DMA queue
-++-  *       to become available since the stack doesn't retry to send a packet
-++-  *       dropped because of memory failure (except for the TCP timers).
-++-  */
-++-static err_t low_level_output(struct netif *netif, struct pbuf *p)
-++-{
-++-  err_t errval;
-++-  struct pbuf *q;
-++-  uint8_t *buffer = (uint8_t *)(EthHandle.TxDesc->Buffer1Addr);
-++-  __IO ETH_DMADescTypeDef *DmaTxDesc;
-++-  uint32_t framelength = 0;
-++-  uint32_t bufferoffset = 0;
-++-  uint32_t byteslefttocopy = 0;
-++-  uint32_t payloadoffset = 0;
-++-
-++-  DmaTxDesc = EthHandle.TxDesc;
-++-  bufferoffset = 0;
-++-  
-++-  /* copy frame from pbufs to driver buffers */
-++-  for(q = p; q != NULL; q = q->next)
-++-  {
-++-    /* Is this buffer available? If not, goto error */
-++-    if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
-++-    {
-++-      errval = ERR_USE;
-++-      goto error;
-++-    }
-++-    
-++-    /* Get bytes in current lwIP buffer */
-++-    byteslefttocopy = q->len;
-++-    payloadoffset = 0;
-++-    
-++-    /* Check if the length of data to copy is bigger than Tx buffer size*/
-++-    while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
-++-    {
-++-      /* Copy data to Tx buffer*/
-++-      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
-++-      
-++-      /* Point to next descriptor */
-++-      DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
-++-      
-++-      /* Check if the buffer is available */
-++-      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
-++-      {
-++-        errval = ERR_USE;
-++-        goto error;
-++-      }
-++-      
-++-      buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
-++-      
-++-      byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
-++-      payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
-++-      framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
-++-      bufferoffset = 0;
-++-    }
-++-    
-++-    /* Copy the remaining bytes */
-++-    memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
-++-    bufferoffset = bufferoffset + byteslefttocopy;
-++-    framelength = framelength + byteslefttocopy;
-++-  }
-++-  
-++-  /* Prepare transmit descriptors to give to DMA */ 
-++-  HAL_ETH_TransmitFrame(&EthHandle, framelength);
-++-  
-++-  errval = ERR_OK;
-++-  
-++-error:
-++-  
-++-  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
-++-  if ((EthHandle.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
-++-  {
-++-    /* Clear TUS ETHERNET DMA flag */
-++-    EthHandle.Instance->DMASR = ETH_DMASR_TUS;
-++-    
-++-    /* Resume DMA transmission*/
-++-    EthHandle.Instance->DMATPDR = 0;
-++-  }
-++-  return errval;
-++-}
-++-
-++-/**
-++-  * @brief Should allocate a pbuf and transfer the bytes of the incoming
-++-  * packet from the interface into the pbuf.
-++-  *
-++-  * @param netif the lwip network interface structure for this ethernetif
-++-  * @return a pbuf filled with the received packet (including MAC header)
-++-  *         NULL on memory error
-++-  */
-++-static struct pbuf * low_level_input(struct netif *netif)
-++-{
-++-  struct pbuf *p = NULL, *q = NULL;
-++-  uint16_t len = 0;
-++-  uint8_t *buffer;
-++-  __IO ETH_DMADescTypeDef *dmarxdesc;
-++-  uint32_t bufferoffset = 0;
-++-  uint32_t payloadoffset = 0;
-++-  uint32_t byteslefttocopy = 0;
-++-  uint32_t i=0;
-++-  
-++-  /* get received frame */
-++-  if(HAL_ETH_GetReceivedFrame_IT(&EthHandle) != HAL_OK)
-++-    return NULL;
-++-  
-++-  /* Obtain the size of the packet and put it into the "len" variable. */
-++-  len = EthHandle.RxFrameInfos.length;
-++-  buffer = (uint8_t *)EthHandle.RxFrameInfos.buffer;
-++-  
-++-  if (len > 0)
-++-  {
-++-    /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
-++-    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
-++-  }
-++-  
-++-  if (p != NULL)
-++-  {
-++-    dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
-++-    bufferoffset = 0;
-++-    
-++-    for(q = p; q != NULL; q = q->next)
-++-    {
-++-      byteslefttocopy = q->len;
-++-      payloadoffset = 0;
-++-      
-++-      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size */
-++-      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
-++-      {
-++-        /* Copy data to pbuf */
-++-        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
-++-        
-++-        /* Point to next descriptor */
-++-        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
-++-        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
-++-        
-++-        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
-++-        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
-++-        bufferoffset = 0;
-++-      }
-++-      
-++-      /* Copy remaining data in pbuf */
-++-      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
-++-      bufferoffset = bufferoffset + byteslefttocopy;
-++-    }
-++-  }
-++-    
-++-  /* Release descriptors to DMA */
-++-  /* Point to first descriptor */
-++-  dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
-++-  /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
-++-  for (i=0; i< EthHandle.RxFrameInfos.SegCount; i++)
-++-  {  
-++-    dmarxdesc->Status |= ETH_DMARXDESC_OWN;
-++-    dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
-++-  }
-++-    
-++-  /* Clear Segment_Count */
-++-  EthHandle.RxFrameInfos.SegCount =0;
-++-  
-++-  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
-++-  if ((EthHandle.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
-++-  {
-++-    /* Clear RBUS ETHERNET DMA flag */
-++-    EthHandle.Instance->DMASR = ETH_DMASR_RBUS;
-++-    /* Resume DMA reception */
-++-    EthHandle.Instance->DMARPDR = 0;
-++-  }
-++-  return p;
-++-}
-++-
-++-/**
-++-  * @brief This function is the ethernetif_input task, it is processed when a packet 
-++-  * is ready to be read from the interface. It uses the function low_level_input() 
-++-  * that should handle the actual reception of bytes from the network
-++-  * interface. Then the type of the received packet is determined and
-++-  * the appropriate input function is called.
-++-  *
-++-  * @param netif the lwip network interface structure for this ethernetif
-++-  */
-++-void ethernetif_input( void const * argument )
-++-{
-++-  struct pbuf *p;
-++-  struct netif *netif = (struct netif *) argument;
-++-  
-++-  for( ;; )
-++-  {
-++-    if (osSemaphoreWait( s_xSemaphore, TIME_WAITING_FOR_INPUT)==osOK)
-++-    {
-++-      do
-++-      {
-++-        p = low_level_input( netif );
-++-        if (p != NULL)
-++-        {
-++-          if (netif->input( p, netif) != ERR_OK )
-++-          {
-++-            pbuf_free(p);
-++-          }
-++-        }
-++-      }while(p!=NULL);
-++-    }
-++-  }
-++-}
-++-
-++-/**
-++-  * @brief Should be called at the beginning of the program to set up the
-++-  * network interface. It calls the function low_level_init() to do the
-++-  * actual setup of the hardware.
-++-  *
-++-  * This function should be passed as a parameter to netif_add().
-++-  *
-++-  * @param netif the lwip network interface structure for this ethernetif
-++-  * @return ERR_OK if the loopif is initialized
-++-  *         ERR_MEM if private data couldn't be allocated
-++-  *         any other err_t on error
-++-  */
-++-err_t ethernetif_init(struct netif *netif)
-++-{
-++-  LWIP_ASSERT("netif != NULL", (netif != NULL));
-++-
-++-#if LWIP_NETIF_HOSTNAME
-++-  /* Initialize interface hostname */
-++-  netif->hostname = "lwip";
-++-#endif /* LWIP_NETIF_HOSTNAME */
-++-
-++-  netif->name[0] = IFNAME0;
-++-  netif->name[1] = IFNAME1;
-++-
-++-  netif->output = etharp_output;
-++-  netif->linkoutput = low_level_output;
-++-
-++-  /* initialize the hardware */
-++-  low_level_init(netif);
-++-
-++-  return ERR_OK;
-++-}
-++-
-++-/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
-++-- 
-++1.9.1
-++
-++
-++From 31d34fab26b1e3fde99fe7288786725fe5e51b95 Mon Sep 17 00:00:00 2001
-++From: Jay Doyle <jay.doyle@vecna.com>
-++Date: Mon, 7 Sep 2015 10:17:32 -0400
-++Subject: [PATCH 6/9] add low level driver back
-++
-++---
-++ src/netif/ethernetif.c | 496 +++++++++++++++++++++++++++++++++++++++++++++++++
-++ 1 file changed, 496 insertions(+)
-++ create mode 100644 src/netif/ethernetif.c
-++
-++diff --git a/src/netif/ethernetif.c b/src/netif/ethernetif.c
-++new file mode 100644
-++index 0000000..bc429e9
-++--- /dev/null
-+++++ b/src/netif/ethernetif.c
-++@@ -0,0 +1,496 @@
-+++/**
-+++  ******************************************************************************
-+++  * @file    LwIP/LwIP_HTTP_Server_Netconn_RTOS/Src/ethernetif.c
-+++  * @author  MCD Application Team
-+++  * @version V1.0.0
-+++  * @date    25-June-2015
-+++  * @brief   This file implements Ethernet network interface drivers for lwIP
-+++  ******************************************************************************
-+++  * @attention
-+++  *
-+++  * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
-+++  *
-+++  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
-+++  * You may not use this file except in compliance with the License.
-+++  * You may obtain a copy of the License at:
-+++  *
-+++  *        http://www.st.com/software_license_agreement_liberty_v2
-+++  *
-+++  * Unless required by applicable law or agreed to in writing, software 
-+++  * distributed under the License is distributed on an "AS IS" BASIS, 
-+++  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-+++  * See the License for the specific language governing permissions and
-+++  * limitations under the License.
-+++  *
-+++  ******************************************************************************
-+++  */
-+++
-+++/* Includes ------------------------------------------------------------------*/
-+++#include <stm32f7xx_hal.h>
-+++#include <lwip/opt.h>
-+++#include <lwip/lwip_timers.h>
-+++#include <netif/etharp.h>
-+++#include <hal-ethernetif.h>
-+++#include <string.h>
-+++
-+++/* Private typedef -----------------------------------------------------------*/
-+++/* Private define ------------------------------------------------------------*/
-+++/* The time to block waiting for input. */
-+++#define TIME_WAITING_FOR_INPUT                 ( 100 )
-+++/* Stack size of the interface thread */
-+++#define INTERFACE_THREAD_STACK_SIZE            ( 350 )
-+++
-+++/* Define those to better describe your network interface. */
-+++#define IFNAME0 'e'
-+++#define IFNAME1 'n'
-+++
-+++#define LAN8742A_PHY_ADDRESS            0x00
-+++
-+++/* Private macro -------------------------------------------------------------*/
-+++/* Private variables ---------------------------------------------------------*/
-+++
-+++#if defined ( __ICCARM__ ) /*!< IAR Compiler */
-+++
-+++#pragma location=0x2000E000
-+++__no_init ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
-+++#pragma location=0x2000E100
-+++__no_init ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
-+++#elif defined ( __CC_ARM   )
-+++ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((at(0x2000E000)));/* Ethernet Rx MA Descriptor */
-+++ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((at(0x2000E100)));/* Ethernet Tx DMA Descriptor */
-+++#elif defined ( __GNUC__   )
-+++//ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".RxDescripSection")));/* Ethernet Rx MA Descriptor */
-+++//ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".TxDescripSection")));/* Ethernet Tx DMA Descriptor */
-+++ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Rx MA Descriptor */
-+++ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Tx DMA Descriptor */
-+++
-+++
-+++#endif
-+++#if defined ( __ICCARM__ ) /*!< IAR Compiler */
-+++#pragma location=0x2000E200
-+++__no_init uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
-+++#pragma location=0x2000FFC4
-+++__no_init uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
-+++#elif defined ( __CC_ARM   )
-+++uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((at(0x2000E200)));  /* Ethernet Receive Buffer */
-+++uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]  __attribute__((at(0x2000FFC4))); /* Ethernet Transmit Buffer */
-+++#elif defined ( __GNUC__   )
-+++//uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".RxBUF")));/* Ethernet Receive Buffer */
-+++//uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".TxBUF")));/* Ethernet Transmit Buffer */
-+++uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Receive Buffer */
-+++uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Transmit Buffer */
-+++
-+++#endif
-+++/* Semaphore to signal incoming packets */
-+++osSemaphoreId s_xSemaphore = NULL;
-+++
-+++/* Global Ethernet handle*/
-+++ETH_HandleTypeDef EthHandle;
-+++
-+++/* Private function prototypes -----------------------------------------------*/
-+++static void ethernetif_input( void const * argument );
-+++
-+++static void stm32f_ethernet_isr(
-+++  void* argData
-+++)
-+++{
-+++  ETH_HandleTypeDef* pEth =
-+++    (ETH_HandleTypeDef*) argData;
-+++
-+++  HAL_ETH_IRQHandler(pEth);
-+++}
-+++
-+++/* Private functions ---------------------------------------------------------*/
-+++/*******************************************************************************
-+++                       Ethernet MSP Routines
-+++*******************************************************************************/
-+++/**
-+++  * @brief  Initializes the ETH MSP.
-+++  * @param  heth: ETH handle
-+++  * @retval None
-+++  */
-+++void HAL_ETH_MspInit(ETH_HandleTypeDef *heth)
-+++{
-+++  GPIO_InitTypeDef GPIO_InitStructure;
-+++  
-+++  /* Enable GPIOs clocks */
-+++  __HAL_RCC_GPIOA_CLK_ENABLE();
-+++  __HAL_RCC_GPIOC_CLK_ENABLE();
-+++  __HAL_RCC_GPIOG_CLK_ENABLE();
-+++
-+++/* Ethernet pins configuration ************************************************/
-+++  /*
-+++        RMII_REF_CLK ----------------------> PA1
-+++        RMII_MDIO -------------------------> PA2
-+++        RMII_MDC --------------------------> PC1
-+++        RMII_MII_CRS_DV -------------------> PA7
-+++        RMII_MII_RXD0 ---------------------> PC4
-+++        RMII_MII_RXD1 ---------------------> PC5
-+++        RMII_MII_RXER ---------------------> PG2
-+++        RMII_MII_TX_EN --------------------> PG11
-+++        RMII_MII_TXD0 ---------------------> PG13
-+++        RMII_MII_TXD1 ---------------------> PG14
-+++  */
-+++
-+++  /* Configure PA1, PA2 and PA7 */
-+++  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
-+++  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
-+++  GPIO_InitStructure.Pull = GPIO_NOPULL; 
-+++  GPIO_InitStructure.Alternate = GPIO_AF11_ETH;
-+++  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
-+++  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
-+++  
-+++  /* Configure PC1, PC4 and PC5 */
-+++  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;
-+++  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
-+++
-+++  /* Configure PG2, PG11, PG13 and PG14 */
-+++  GPIO_InitStructure.Pin =  GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14;
-+++  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
-+++  
-+++  // Install HAL Ethernet ISR
-+++  rtems_interrupt_handler_install(
-+++    ETH_IRQn,
-+++    NULL,
-+++    0,
-+++    stm32f_ethernet_isr,
-+++    heth);
-+++  
-+++  /* Enable ETHERNET clock  */
-+++  __HAL_RCC_ETH_CLK_ENABLE();
-+++}
-+++
-+++/**
-+++  * @brief  Ethernet Rx Transfer completed callback
-+++  * @param  heth: ETH handle
-+++  * @retval None
-+++  */
-+++void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
-+++{
-+++  osSemaphoreRelease(s_xSemaphore);
-+++}
-+++
-+++/**
-+++  * @brief  Ethernet IRQ Handler
-+++  * @param  None
-+++  * @retval None
-+++  */
-+++void ETHERNET_IRQHandler(void)
-+++{
-+++  HAL_ETH_IRQHandler(&EthHandle);
-+++}
-+++
-+++/*******************************************************************************
-+++                       LL Driver Interface ( LwIP stack --> ETH) 
-+++*******************************************************************************/
-+++/**
-+++  * @brief In this function, the hardware should be initialized.
-+++  * Called from ethernetif_init().
-+++  *
-+++  * @param netif the already initialized lwip network interface structure
-+++  *        for this ethernetif
-+++  */
-+++static void low_level_init(struct netif *netif)
-+++{
-+++  uint8_t macaddress[6]= { MAC_ADDR0, MAC_ADDR1, MAC_ADDR2, MAC_ADDR3, MAC_ADDR4, MAC_ADDR5 };
-+++  
-+++  EthHandle.Instance = ETH;  
-+++  EthHandle.Init.MACAddr = macaddress;
-+++  EthHandle.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
-+++  EthHandle.Init.Speed = ETH_SPEED_100M;
-+++  EthHandle.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
-+++  EthHandle.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
-+++  EthHandle.Init.RxMode = ETH_RXINTERRUPT_MODE;
-+++  EthHandle.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
-+++  EthHandle.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
-+++  
-+++  /* configure ethernet peripheral (GPIOs, clocks, MAC, DMA) */
-+++  if (HAL_ETH_Init(&EthHandle) == HAL_OK)
-+++  {
-+++    /* Set netif link flag */
-+++    netif->flags |= NETIF_FLAG_LINK_UP;
-+++  }
-+++  
-+++  /* Initialize Tx Descriptors list: Chain Mode */
-+++  HAL_ETH_DMATxDescListInit(&EthHandle, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
-+++     
-+++  /* Initialize Rx Descriptors list: Chain Mode  */
-+++  HAL_ETH_DMARxDescListInit(&EthHandle, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
-+++  
-+++  /* set netif MAC hardware address length */
-+++  netif->hwaddr_len = ETHARP_HWADDR_LEN;
-+++
-+++  /* set netif MAC hardware address */
-+++  netif->hwaddr[0] =  MAC_ADDR0;
-+++  netif->hwaddr[1] =  MAC_ADDR1;
-+++  netif->hwaddr[2] =  MAC_ADDR2;
-+++  netif->hwaddr[3] =  MAC_ADDR3;
-+++  netif->hwaddr[4] =  MAC_ADDR4;
-+++  netif->hwaddr[5] =  MAC_ADDR5;
-+++
-+++  /* set netif maximum transfer unit */
-+++  netif->mtu = 1500;
-+++
-+++  /* Accept broadcast address and ARP traffic */
-+++  netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
-+++
-+++  /* create a binary semaphore used for informing ethernetif of frame reception */
-+++  osSemaphoreDef(SEM);
-+++  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1 );
-+++
-+++  /* create the task that handles the ETH_MAC */
-+++  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
-+++  osThreadCreate (osThread(EthIf), netif);
-+++
-+++  /* Enable MAC and DMA transmission and reception */
-+++  HAL_ETH_Start(&EthHandle);
-+++}
-+++
-+++
-+++/**
-+++  * @brief This function should do the actual transmission of the packet. The packet is
-+++  * contained in the pbuf that is passed to the function. This pbuf
-+++  * might be chained.
-+++  *
-+++  * @param netif the lwip network interface structure for this ethernetif
-+++  * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
-+++  * @return ERR_OK if the packet could be sent
-+++  *         an err_t value if the packet couldn't be sent
-+++  *
-+++  * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
-+++  *       strange results. You might consider waiting for space in the DMA queue
-+++  *       to become available since the stack doesn't retry to send a packet
-+++  *       dropped because of memory failure (except for the TCP timers).
-+++  */
-+++static err_t low_level_output(struct netif *netif, struct pbuf *p)
-+++{
-+++  err_t errval;
-+++  struct pbuf *q;
-+++  uint8_t *buffer = (uint8_t *)(EthHandle.TxDesc->Buffer1Addr);
-+++  __IO ETH_DMADescTypeDef *DmaTxDesc;
-+++  uint32_t framelength = 0;
-+++  uint32_t bufferoffset = 0;
-+++  uint32_t byteslefttocopy = 0;
-+++  uint32_t payloadoffset = 0;
-+++
-+++  DmaTxDesc = EthHandle.TxDesc;
-+++  bufferoffset = 0;
-+++  
-+++  /* copy frame from pbufs to driver buffers */
-+++  for(q = p; q != NULL; q = q->next)
-+++  {
-+++    /* Is this buffer available? If not, goto error */
-+++    if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
-+++    {
-+++      errval = ERR_USE;
-+++      goto error;
-+++    }
-+++    
-+++    /* Get bytes in current lwIP buffer */
-+++    byteslefttocopy = q->len;
-+++    payloadoffset = 0;
-+++    
-+++    /* Check if the length of data to copy is bigger than Tx buffer size*/
-+++    while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
-+++    {
-+++      /* Copy data to Tx buffer*/
-+++      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
-+++      
-+++      /* Point to next descriptor */
-+++      DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
-+++      
-+++      /* Check if the buffer is available */
-+++      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
-+++      {
-+++        errval = ERR_USE;
-+++        goto error;
-+++      }
-+++      
-+++      buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
-+++      
-+++      byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
-+++      payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
-+++      framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
-+++      bufferoffset = 0;
-+++    }
-+++    
-+++    /* Copy the remaining bytes */
-+++    memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
-+++    bufferoffset = bufferoffset + byteslefttocopy;
-+++    framelength = framelength + byteslefttocopy;
-+++  }
-+++  
-+++  /* Prepare transmit descriptors to give to DMA */ 
-+++  HAL_ETH_TransmitFrame(&EthHandle, framelength);
-+++  
-+++  errval = ERR_OK;
-+++  
-+++error:
-+++  
-+++  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
-+++  if ((EthHandle.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
-+++  {
-+++    /* Clear TUS ETHERNET DMA flag */
-+++    EthHandle.Instance->DMASR = ETH_DMASR_TUS;
-+++    
-+++    /* Resume DMA transmission*/
-+++    EthHandle.Instance->DMATPDR = 0;
-+++  }
-+++  return errval;
-+++}
-+++
-+++/**
-+++  * @brief Should allocate a pbuf and transfer the bytes of the incoming
-+++  * packet from the interface into the pbuf.
-+++  *
-+++  * @param netif the lwip network interface structure for this ethernetif
-+++  * @return a pbuf filled with the received packet (including MAC header)
-+++  *         NULL on memory error
-+++  */
-+++static struct pbuf * low_level_input(struct netif *netif)
-+++{
-+++  struct pbuf *p = NULL, *q = NULL;
-+++  uint16_t len = 0;
-+++  uint8_t *buffer;
-+++  __IO ETH_DMADescTypeDef *dmarxdesc;
-+++  uint32_t bufferoffset = 0;
-+++  uint32_t payloadoffset = 0;
-+++  uint32_t byteslefttocopy = 0;
-+++  uint32_t i=0;
-+++  
-+++  /* get received frame */
-+++  if(HAL_ETH_GetReceivedFrame_IT(&EthHandle) != HAL_OK)
-+++    return NULL;
-+++  
-+++  /* Obtain the size of the packet and put it into the "len" variable. */
-+++  len = EthHandle.RxFrameInfos.length;
-+++  buffer = (uint8_t *)EthHandle.RxFrameInfos.buffer;
-+++  
-+++  if (len > 0)
-+++  {
-+++    /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
-+++    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
-+++  }
-+++  
-+++  if (p != NULL)
-+++  {
-+++    dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
-+++    bufferoffset = 0;
-+++    
-+++    for(q = p; q != NULL; q = q->next)
-+++    {
-+++      byteslefttocopy = q->len;
-+++      payloadoffset = 0;
-+++      
-+++      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size */
-+++      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
-+++      {
-+++        /* Copy data to pbuf */
-+++        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
-+++        
-+++        /* Point to next descriptor */
-+++        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
-+++        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
-+++        
-+++        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
-+++        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
-+++        bufferoffset = 0;
-+++      }
-+++      
-+++      /* Copy remaining data in pbuf */
-+++      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
-+++      bufferoffset = bufferoffset + byteslefttocopy;
-+++    }
-+++  }
-+++    
-+++  /* Release descriptors to DMA */
-+++  /* Point to first descriptor */
-+++  dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
-+++  /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
-+++  for (i=0; i< EthHandle.RxFrameInfos.SegCount; i++)
-+++  {  
-+++    dmarxdesc->Status |= ETH_DMARXDESC_OWN;
-+++    dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
-+++  }
-+++    
-+++  /* Clear Segment_Count */
-+++  EthHandle.RxFrameInfos.SegCount =0;
-+++  
-+++  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
-+++  if ((EthHandle.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
-+++  {
-+++    /* Clear RBUS ETHERNET DMA flag */
-+++    EthHandle.Instance->DMASR = ETH_DMASR_RBUS;
-+++    /* Resume DMA reception */
-+++    EthHandle.Instance->DMARPDR = 0;
-+++  }
-+++  return p;
-+++}
-+++
-+++/**
-+++  * @brief This function is the ethernetif_input task, it is processed when a packet 
-+++  * is ready to be read from the interface. It uses the function low_level_input() 
-+++  * that should handle the actual reception of bytes from the network
-+++  * interface. Then the type of the received packet is determined and
-+++  * the appropriate input function is called.
-+++  *
-+++  * @param netif the lwip network interface structure for this ethernetif
-+++  */
-+++void ethernetif_input( void const * argument )
-+++{
-+++  struct pbuf *p;
-+++  struct netif *netif = (struct netif *) argument;
-+++  
-+++  for( ;; )
-+++  {
-+++    if (osSemaphoreWait( s_xSemaphore, TIME_WAITING_FOR_INPUT)==osOK)
-+++    {
-+++      do
-+++      {
-+++        p = low_level_input( netif );
-+++        if (p != NULL)
-+++        {
-+++          if (netif->input( p, netif) != ERR_OK )
-+++          {
-+++            pbuf_free(p);
-+++          }
-+++        }
-+++      }while(p!=NULL);
-+++    }
-+++  }
-+++}
-+++
-+++/**
-+++  * @brief Should be called at the beginning of the program to set up the
-+++  * network interface. It calls the function low_level_init() to do the
-+++  * actual setup of the hardware.
-+++  *
-+++  * This function should be passed as a parameter to netif_add().
-+++  *
-+++  * @param netif the lwip network interface structure for this ethernetif
-+++  * @return ERR_OK if the loopif is initialized
-+++  *         ERR_MEM if private data couldn't be allocated
-+++  *         any other err_t on error
-+++  */
-+++err_t ethernetif_init(struct netif *netif)
-+++{
-+++  LWIP_ASSERT("netif != NULL", (netif != NULL));
-+++
-+++#if LWIP_NETIF_HOSTNAME
-+++  /* Initialize interface hostname */
-+++  netif->hostname = "lwip";
-+++#endif /* LWIP_NETIF_HOSTNAME */
-+++
-+++  netif->name[0] = IFNAME0;
-+++  netif->name[1] = IFNAME1;
-+++
-+++  netif->output = etharp_output;
-+++  netif->linkoutput = low_level_output;
-+++
-+++  /* initialize the hardware */
-+++  low_level_init(netif);
-+++
-+++  return ERR_OK;
-+++}
-+++
-+++/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
-++-- 
-++1.9.1
-++
-++
-++From 81eded01bb2bc35a9b627e5cf35b2021efb5972c Mon Sep 17 00:00:00 2001
-++From: Jay Doyle <jay.doyle@vecna.com>
-++Date: Mon, 7 Sep 2015 10:22:57 -0400
-++Subject: [PATCH 7/9] Added bsp path
-++
-++---
-++ Makefile | 4 +++-
-++ 1 file changed, 3 insertions(+), 1 deletion(-)
-++
-++diff --git a/Makefile b/Makefile
-++index 6efa141..a855d9f 100644
-++--- a/Makefile
-+++++ b/Makefile
-++@@ -13,6 +13,8 @@ LWIP_EXEC=lwip
-++ 
-++ #### PATHS #####################################################################
-++ 
-+++BSP_PATH=/opt/rtems-4.11/arm-rtems4.11/stm32f7x/lib/include/bsp
-+++
-++ # LWIP
-++ LWIP_PATH=.
-++ LWIP_SRC_PATH=$(LWIP_PATH)/src
-++@@ -97,7 +99,7 @@ DRIVER_H=$(LWIPDRIVER_INCL_PATH)
-++ # HEADERS
-++ HEADERS=-I$(CORE_H) -I$(POSIX_H) -I$(POSIX_SYS_H) -I$(NETIF_H) \
-++         -I$(NETIF_H_PPP) -I$(NETIF_H_PPP_POLARSSL) -I$(ARCH_H) \
-++-        -I$(DRIVER_H) -I$(IPV4_H)
-+++        -I$(DRIVER_H) -I$(IPV4_H) -I$(BSP_PATH)
-++ 
-++ 
-++ ################################################################################
-++-- 
-++1.9.1
-++
-++
-++From f114529d5af1e2a83b49b67d631b10c02648e8d8 Mon Sep 17 00:00:00 2001
-++From: Jay Doyle <jay.doyle@vecna.com>
-++Date: Mon, 7 Sep 2015 10:54:26 -0400
-++Subject: [PATCH 8/9] removed ethernetif.c
-++
-++---
-++ src/netif/ethernetif.c | 496 -------------------------------------------------
-++ 1 file changed, 496 deletions(-)
-++ delete mode 100644 src/netif/ethernetif.c
-++
-++diff --git a/src/netif/ethernetif.c b/src/netif/ethernetif.c
-++deleted file mode 100644
-++index bc429e9..0000000
-++--- a/src/netif/ethernetif.c
-+++++ /dev/null
-++@@ -1,496 +0,0 @@
-++-/**
-++-  ******************************************************************************
-++-  * @file    LwIP/LwIP_HTTP_Server_Netconn_RTOS/Src/ethernetif.c
-++-  * @author  MCD Application Team
-++-  * @version V1.0.0
-++-  * @date    25-June-2015
-++-  * @brief   This file implements Ethernet network interface drivers for lwIP
-++-  ******************************************************************************
-++-  * @attention
-++-  *
-++-  * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
-++-  *
-++-  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
-++-  * You may not use this file except in compliance with the License.
-++-  * You may obtain a copy of the License at:
-++-  *
-++-  *        http://www.st.com/software_license_agreement_liberty_v2
-++-  *
-++-  * Unless required by applicable law or agreed to in writing, software 
-++-  * distributed under the License is distributed on an "AS IS" BASIS, 
-++-  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-++-  * See the License for the specific language governing permissions and
-++-  * limitations under the License.
-++-  *
-++-  ******************************************************************************
-++-  */
-++-
-++-/* Includes ------------------------------------------------------------------*/
-++-#include <stm32f7xx_hal.h>
-++-#include <lwip/opt.h>
-++-#include <lwip/lwip_timers.h>
-++-#include <netif/etharp.h>
-++-#include <hal-ethernetif.h>
-++-#include <string.h>
-++-
-++-/* Private typedef -----------------------------------------------------------*/
-++-/* Private define ------------------------------------------------------------*/
-++-/* The time to block waiting for input. */
-++-#define TIME_WAITING_FOR_INPUT                 ( 100 )
-++-/* Stack size of the interface thread */
-++-#define INTERFACE_THREAD_STACK_SIZE            ( 350 )
-++-
-++-/* Define those to better describe your network interface. */
-++-#define IFNAME0 'e'
-++-#define IFNAME1 'n'
-++-
-++-#define LAN8742A_PHY_ADDRESS            0x00
-++-
-++-/* Private macro -------------------------------------------------------------*/
-++-/* Private variables ---------------------------------------------------------*/
-++-
-++-#if defined ( __ICCARM__ ) /*!< IAR Compiler */
-++-
-++-#pragma location=0x2000E000
-++-__no_init ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB];/* Ethernet Rx MA Descriptor */
-++-#pragma location=0x2000E100
-++-__no_init ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB];/* Ethernet Tx DMA Descriptor */
-++-#elif defined ( __CC_ARM   )
-++-ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((at(0x2000E000)));/* Ethernet Rx MA Descriptor */
-++-ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((at(0x2000E100)));/* Ethernet Tx DMA Descriptor */
-++-#elif defined ( __GNUC__   )
-++-//ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".RxDescripSection")));/* Ethernet Rx MA Descriptor */
-++-//ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".TxDescripSection")));/* Ethernet Tx DMA Descriptor */
-++-ETH_DMADescTypeDef  DMARxDscrTab[ETH_RXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Rx MA Descriptor */
-++-ETH_DMADescTypeDef  DMATxDscrTab[ETH_TXBUFNB] __attribute__((section(".bsp_fast_data")));/* Ethernet Tx DMA Descriptor */
-++-
-++-
-++-#endif
-++-#if defined ( __ICCARM__ ) /*!< IAR Compiler */
-++-#pragma location=0x2000E200
-++-__no_init uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE]; /* Ethernet Receive Buffer */
-++-#pragma location=0x2000FFC4
-++-__no_init uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]; /* Ethernet Transmit Buffer */
-++-#elif defined ( __CC_ARM   )
-++-uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((at(0x2000E200)));  /* Ethernet Receive Buffer */
-++-uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE]  __attribute__((at(0x2000FFC4))); /* Ethernet Transmit Buffer */
-++-#elif defined ( __GNUC__   )
-++-//uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".RxBUF")));/* Ethernet Receive Buffer */
-++-//uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".TxBUF")));/* Ethernet Transmit Buffer */
-++-uint8_t Rx_Buff[ETH_RXBUFNB][ETH_RX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Receive Buffer */
-++-uint8_t Tx_Buff[ETH_TXBUFNB][ETH_TX_BUF_SIZE] __attribute__((section(".bsp_fast_data")));/* Ethernet Transmit Buffer */
-++-
-++-#endif
-++-/* Semaphore to signal incoming packets */
-++-osSemaphoreId s_xSemaphore = NULL;
-++-
-++-/* Global Ethernet handle*/
-++-ETH_HandleTypeDef EthHandle;
-++-
-++-/* Private function prototypes -----------------------------------------------*/
-++-static void ethernetif_input( void const * argument );
-++-
-++-static void stm32f_ethernet_isr(
-++-  void* argData
-++-)
-++-{
-++-  ETH_HandleTypeDef* pEth =
-++-    (ETH_HandleTypeDef*) argData;
-++-
-++-  HAL_ETH_IRQHandler(pEth);
-++-}
-++-
-++-/* Private functions ---------------------------------------------------------*/
-++-/*******************************************************************************
-++-                       Ethernet MSP Routines
-++-*******************************************************************************/
-++-/**
-++-  * @brief  Initializes the ETH MSP.
-++-  * @param  heth: ETH handle
-++-  * @retval None
-++-  */
-++-void HAL_ETH_MspInit(ETH_HandleTypeDef *heth)
-++-{
-++-  GPIO_InitTypeDef GPIO_InitStructure;
-++-  
-++-  /* Enable GPIOs clocks */
-++-  __HAL_RCC_GPIOA_CLK_ENABLE();
-++-  __HAL_RCC_GPIOC_CLK_ENABLE();
-++-  __HAL_RCC_GPIOG_CLK_ENABLE();
-++-
-++-/* Ethernet pins configuration ************************************************/
-++-  /*
-++-        RMII_REF_CLK ----------------------> PA1
-++-        RMII_MDIO -------------------------> PA2
-++-        RMII_MDC --------------------------> PC1
-++-        RMII_MII_CRS_DV -------------------> PA7
-++-        RMII_MII_RXD0 ---------------------> PC4
-++-        RMII_MII_RXD1 ---------------------> PC5
-++-        RMII_MII_RXER ---------------------> PG2
-++-        RMII_MII_TX_EN --------------------> PG11
-++-        RMII_MII_TXD0 ---------------------> PG13
-++-        RMII_MII_TXD1 ---------------------> PG14
-++-  */
-++-
-++-  /* Configure PA1, PA2 and PA7 */
-++-  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
-++-  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
-++-  GPIO_InitStructure.Pull = GPIO_NOPULL; 
-++-  GPIO_InitStructure.Alternate = GPIO_AF11_ETH;
-++-  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
-++-  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
-++-  
-++-  /* Configure PC1, PC4 and PC5 */
-++-  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;
-++-  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
-++-
-++-  /* Configure PG2, PG11, PG13 and PG14 */
-++-  GPIO_InitStructure.Pin =  GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14;
-++-  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
-++-  
-++-  // Install HAL Ethernet ISR
-++-  rtems_interrupt_handler_install(
-++-    ETH_IRQn,
-++-    NULL,
-++-    0,
-++-    stm32f_ethernet_isr,
-++-    heth);
-++-  
-++-  /* Enable ETHERNET clock  */
-++-  __HAL_RCC_ETH_CLK_ENABLE();
-++-}
-++-
-++-/**
-++-  * @brief  Ethernet Rx Transfer completed callback
-++-  * @param  heth: ETH handle
-++-  * @retval None
-++-  */
-++-void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
-++-{
-++-  osSemaphoreRelease(s_xSemaphore);
-++-}
-++-
-++-/**
-++-  * @brief  Ethernet IRQ Handler
-++-  * @param  None
-++-  * @retval None
-++-  */
-++-void ETHERNET_IRQHandler(void)
-++-{
-++-  HAL_ETH_IRQHandler(&EthHandle);
-++-}
-++-
-++-/*******************************************************************************
-++-                       LL Driver Interface ( LwIP stack --> ETH) 
-++-*******************************************************************************/
-++-/**
-++-  * @brief In this function, the hardware should be initialized.
-++-  * Called from ethernetif_init().
-++-  *
-++-  * @param netif the already initialized lwip network interface structure
-++-  *        for this ethernetif
-++-  */
-++-static void low_level_init(struct netif *netif)
-++-{
-++-  uint8_t macaddress[6]= { MAC_ADDR0, MAC_ADDR1, MAC_ADDR2, MAC_ADDR3, MAC_ADDR4, MAC_ADDR5 };
-++-  
-++-  EthHandle.Instance = ETH;  
-++-  EthHandle.Init.MACAddr = macaddress;
-++-  EthHandle.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
-++-  EthHandle.Init.Speed = ETH_SPEED_100M;
-++-  EthHandle.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
-++-  EthHandle.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
-++-  EthHandle.Init.RxMode = ETH_RXINTERRUPT_MODE;
-++-  EthHandle.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
-++-  EthHandle.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
-++-  
-++-  /* configure ethernet peripheral (GPIOs, clocks, MAC, DMA) */
-++-  if (HAL_ETH_Init(&EthHandle) == HAL_OK)
-++-  {
-++-    /* Set netif link flag */
-++-    netif->flags |= NETIF_FLAG_LINK_UP;
-++-  }
-++-  
-++-  /* Initialize Tx Descriptors list: Chain Mode */
-++-  HAL_ETH_DMATxDescListInit(&EthHandle, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
-++-     
-++-  /* Initialize Rx Descriptors list: Chain Mode  */
-++-  HAL_ETH_DMARxDescListInit(&EthHandle, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
-++-  
-++-  /* set netif MAC hardware address length */
-++-  netif->hwaddr_len = ETHARP_HWADDR_LEN;
-++-
-++-  /* set netif MAC hardware address */
-++-  netif->hwaddr[0] =  MAC_ADDR0;
-++-  netif->hwaddr[1] =  MAC_ADDR1;
-++-  netif->hwaddr[2] =  MAC_ADDR2;
-++-  netif->hwaddr[3] =  MAC_ADDR3;
-++-  netif->hwaddr[4] =  MAC_ADDR4;
-++-  netif->hwaddr[5] =  MAC_ADDR5;
-++-
-++-  /* set netif maximum transfer unit */
-++-  netif->mtu = 1500;
-++-
-++-  /* Accept broadcast address and ARP traffic */
-++-  netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
-++-
-++-  /* create a binary semaphore used for informing ethernetif of frame reception */
-++-  osSemaphoreDef(SEM);
-++-  s_xSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1 );
-++-
-++-  /* create the task that handles the ETH_MAC */
-++-  osThreadDef(EthIf, ethernetif_input, osPriorityRealtime, 0, INTERFACE_THREAD_STACK_SIZE);
-++-  osThreadCreate (osThread(EthIf), netif);
-++-
-++-  /* Enable MAC and DMA transmission and reception */
-++-  HAL_ETH_Start(&EthHandle);
-++-}
-++-
-++-
-++-/**
-++-  * @brief This function should do the actual transmission of the packet. The packet is
-++-  * contained in the pbuf that is passed to the function. This pbuf
-++-  * might be chained.
-++-  *
-++-  * @param netif the lwip network interface structure for this ethernetif
-++-  * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
-++-  * @return ERR_OK if the packet could be sent
-++-  *         an err_t value if the packet couldn't be sent
-++-  *
-++-  * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
-++-  *       strange results. You might consider waiting for space in the DMA queue
-++-  *       to become available since the stack doesn't retry to send a packet
-++-  *       dropped because of memory failure (except for the TCP timers).
-++-  */
-++-static err_t low_level_output(struct netif *netif, struct pbuf *p)
-++-{
-++-  err_t errval;
-++-  struct pbuf *q;
-++-  uint8_t *buffer = (uint8_t *)(EthHandle.TxDesc->Buffer1Addr);
-++-  __IO ETH_DMADescTypeDef *DmaTxDesc;
-++-  uint32_t framelength = 0;
-++-  uint32_t bufferoffset = 0;
-++-  uint32_t byteslefttocopy = 0;
-++-  uint32_t payloadoffset = 0;
-++-
-++-  DmaTxDesc = EthHandle.TxDesc;
-++-  bufferoffset = 0;
-++-  
-++-  /* copy frame from pbufs to driver buffers */
-++-  for(q = p; q != NULL; q = q->next)
-++-  {
-++-    /* Is this buffer available? If not, goto error */
-++-    if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
-++-    {
-++-      errval = ERR_USE;
-++-      goto error;
-++-    }
-++-    
-++-    /* Get bytes in current lwIP buffer */
-++-    byteslefttocopy = q->len;
-++-    payloadoffset = 0;
-++-    
-++-    /* Check if the length of data to copy is bigger than Tx buffer size*/
-++-    while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
-++-    {
-++-      /* Copy data to Tx buffer*/
-++-      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
-++-      
-++-      /* Point to next descriptor */
-++-      DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
-++-      
-++-      /* Check if the buffer is available */
-++-      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
-++-      {
-++-        errval = ERR_USE;
-++-        goto error;
-++-      }
-++-      
-++-      buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
-++-      
-++-      byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
-++-      payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
-++-      framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
-++-      bufferoffset = 0;
-++-    }
-++-    
-++-    /* Copy the remaining bytes */
-++-    memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
-++-    bufferoffset = bufferoffset + byteslefttocopy;
-++-    framelength = framelength + byteslefttocopy;
-++-  }
-++-  
-++-  /* Prepare transmit descriptors to give to DMA */ 
-++-  HAL_ETH_TransmitFrame(&EthHandle, framelength);
-++-  
-++-  errval = ERR_OK;
-++-  
-++-error:
-++-  
-++-  /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
-++-  if ((EthHandle.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
-++-  {
-++-    /* Clear TUS ETHERNET DMA flag */
-++-    EthHandle.Instance->DMASR = ETH_DMASR_TUS;
-++-    
-++-    /* Resume DMA transmission*/
-++-    EthHandle.Instance->DMATPDR = 0;
-++-  }
-++-  return errval;
-++-}
-++-
-++-/**
-++-  * @brief Should allocate a pbuf and transfer the bytes of the incoming
-++-  * packet from the interface into the pbuf.
-++-  *
-++-  * @param netif the lwip network interface structure for this ethernetif
-++-  * @return a pbuf filled with the received packet (including MAC header)
-++-  *         NULL on memory error
-++-  */
-++-static struct pbuf * low_level_input(struct netif *netif)
-++-{
-++-  struct pbuf *p = NULL, *q = NULL;
-++-  uint16_t len = 0;
-++-  uint8_t *buffer;
-++-  __IO ETH_DMADescTypeDef *dmarxdesc;
-++-  uint32_t bufferoffset = 0;
-++-  uint32_t payloadoffset = 0;
-++-  uint32_t byteslefttocopy = 0;
-++-  uint32_t i=0;
-++-  
-++-  /* get received frame */
-++-  if(HAL_ETH_GetReceivedFrame_IT(&EthHandle) != HAL_OK)
-++-    return NULL;
-++-  
-++-  /* Obtain the size of the packet and put it into the "len" variable. */
-++-  len = EthHandle.RxFrameInfos.length;
-++-  buffer = (uint8_t *)EthHandle.RxFrameInfos.buffer;
-++-  
-++-  if (len > 0)
-++-  {
-++-    /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
-++-    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
-++-  }
-++-  
-++-  if (p != NULL)
-++-  {
-++-    dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
-++-    bufferoffset = 0;
-++-    
-++-    for(q = p; q != NULL; q = q->next)
-++-    {
-++-      byteslefttocopy = q->len;
-++-      payloadoffset = 0;
-++-      
-++-      /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size */
-++-      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
-++-      {
-++-        /* Copy data to pbuf */
-++-        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
-++-        
-++-        /* Point to next descriptor */
-++-        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
-++-        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
-++-        
-++-        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
-++-        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
-++-        bufferoffset = 0;
-++-      }
-++-      
-++-      /* Copy remaining data in pbuf */
-++-      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
-++-      bufferoffset = bufferoffset + byteslefttocopy;
-++-    }
-++-  }
-++-    
-++-  /* Release descriptors to DMA */
-++-  /* Point to first descriptor */
-++-  dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
-++-  /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
-++-  for (i=0; i< EthHandle.RxFrameInfos.SegCount; i++)
-++-  {  
-++-    dmarxdesc->Status |= ETH_DMARXDESC_OWN;
-++-    dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
-++-  }
-++-    
-++-  /* Clear Segment_Count */
-++-  EthHandle.RxFrameInfos.SegCount =0;
-++-  
-++-  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
-++-  if ((EthHandle.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
-++-  {
-++-    /* Clear RBUS ETHERNET DMA flag */
-++-    EthHandle.Instance->DMASR = ETH_DMASR_RBUS;
-++-    /* Resume DMA reception */
-++-    EthHandle.Instance->DMARPDR = 0;
-++-  }
-++-  return p;
-++-}
-++-
-++-/**
-++-  * @brief This function is the ethernetif_input task, it is processed when a packet 
-++-  * is ready to be read from the interface. It uses the function low_level_input() 
-++-  * that should handle the actual reception of bytes from the network
-++-  * interface. Then the type of the received packet is determined and
-++-  * the appropriate input function is called.
-++-  *
-++-  * @param netif the lwip network interface structure for this ethernetif
-++-  */
-++-void ethernetif_input( void const * argument )
-++-{
-++-  struct pbuf *p;
-++-  struct netif *netif = (struct netif *) argument;
-++-  
-++-  for( ;; )
-++-  {
-++-    if (osSemaphoreWait( s_xSemaphore, TIME_WAITING_FOR_INPUT)==osOK)
-++-    {
-++-      do
-++-      {
-++-        p = low_level_input( netif );
-++-        if (p != NULL)
-++-        {
-++-          if (netif->input( p, netif) != ERR_OK )
-++-          {
-++-            pbuf_free(p);
-++-          }
-++-        }
-++-      }while(p!=NULL);
-++-    }
-++-  }
-++-}
-++-
-++-/**
-++-  * @brief Should be called at the beginning of the program to set up the
-++-  * network interface. It calls the function low_level_init() to do the
-++-  * actual setup of the hardware.
-++-  *
-++-  * This function should be passed as a parameter to netif_add().
-++-  *
-++-  * @param netif the lwip network interface structure for this ethernetif
-++-  * @return ERR_OK if the loopif is initialized
-++-  *         ERR_MEM if private data couldn't be allocated
-++-  *         any other err_t on error
-++-  */
-++-err_t ethernetif_init(struct netif *netif)
-++-{
-++-  LWIP_ASSERT("netif != NULL", (netif != NULL));
-++-
-++-#if LWIP_NETIF_HOSTNAME
-++-  /* Initialize interface hostname */
-++-  netif->hostname = "lwip";
-++-#endif /* LWIP_NETIF_HOSTNAME */
-++-
-++-  netif->name[0] = IFNAME0;
-++-  netif->name[1] = IFNAME1;
-++-
-++-  netif->output = etharp_output;
-++-  netif->linkoutput = low_level_output;
-++-
-++-  /* initialize the hardware */
-++-  low_level_init(netif);
-++-
-++-  return ERR_OK;
-++-}
-++-
-++-/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
-++-- 
-++1.9.1
-++
-++
-++From badcd5771d8fa3046a2cd7aa07536c6dcb703891 Mon Sep 17 00:00:00 2001
-++From: Jay Doyle <jay.doyle@vecna.com>
-++Date: Mon, 28 Sep 2015 13:47:22 -0400
-++Subject: [PATCH 9/9] enable BSD sockets naming
-++
-++---
-++ ports/include/lwipopts.h | 2 +-
-++ 1 file changed, 1 insertion(+), 1 deletion(-)
-++
-++diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
-++index 169ba46..9149c29 100644
-++--- a/ports/include/lwipopts.h
-+++++ b/ports/include/lwipopts.h
-++@@ -169,7 +169,7 @@
-++  * LWIP_COMPAT_SOCKETS==1: Enable BSD-style sockets functions names.
-++  * (only used if you use sockets.c)
-++  */
-++-#define LWIP_COMPAT_SOCKETS             0
-+++#define LWIP_COMPAT_SOCKETS             1
-++ 
-++ #define LWIP_TIMEVAL_PRIVATE            0
-++ 
-++-- 
-++1.9.1
-++
-+-- 
-+1.9.1
-+
--- 
-1.9.1
-
-
-From 6e898ad87870ca775a3c9a38a05437d02b6f6ba5 Mon Sep 17 00:00:00 2001
-From: Jay Doyle <jay.doyle@vecna.com>
-Date: Mon, 28 Sep 2015 16:33:04 -0400
-Subject: [PATCH 13/13] defined cache line size
-
----
- ports/include/lwipopts.h | 2 ++
- 1 file changed, 2 insertions(+)
-
-diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
-index 4c23d97..41b67a1 100644
---- a/ports/include/lwipopts.h
-+++ b/ports/include/lwipopts.h
-@@ -180,6 +180,8 @@
- 
- #else
- 
-+#define SOC_CACHELINE_SIZE_BYTES        32            /* Number of bytes in
-+                                                         a cache line */
- /**
-  * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
-  * critical regions during buffer allocation, deallocation and memory
\ No newline at end of file
-- 
1.9.1


From 5c4cbd34b3ea817a125ec81d2159a77463ae5441 Mon Sep 17 00:00:00 2001
From: Jay Doyle <jay.doyle@vecna.com>
Date: Mon, 12 Oct 2015 09:13:49 -0400
Subject: [PATCH 28/33] fix?

---
 src/api/sockets.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/api/sockets.c b/src/api/sockets.c
index d601911..11e15e1 100644
--- a/src/api/sockets.c
+++ b/src/api/sockets.c
@@ -42,6 +42,7 @@
 
 #if LWIP_SOCKET /* don't build if not configured for use in lwipopts.h */
 
+#include "lwip/arch.h"
 #include "lwip/sockets.h"
 #include "lwip/api.h"
 #include "lwip/sys.h"
-- 
1.9.1


From 40939890bf52c21dbedd9ee1f2cca5ff6671b7bb Mon Sep 17 00:00:00 2001
From: Jay Doyle <jay.doyle@vecna.com>
Date: Mon, 12 Oct 2015 09:16:05 -0400
Subject: [PATCH 29/33] fix

---
 ports/include/lwipopts.h | 1 +
 1 file changed, 1 insertion(+)

diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
index 5922306..e6257f8 100644
--- a/ports/include/lwipopts.h
+++ b/ports/include/lwipopts.h
@@ -143,6 +143,7 @@
 **                           Socket  Options
 *****************************************************************************/
 #define LWIP_SOCKET                     1
+#define LWIP_PROVIDE_ERRNO              1
 
 /*****************************************************************************
 **                          Debugging options
-- 
1.9.1


From b6c5cf5b5a1ad61ac19a4c4fa66ed8f95acc9787 Mon Sep 17 00:00:00 2001
From: Jay Doyle <jay.doyle@vecna.com>
Date: Mon, 12 Oct 2015 09:27:41 -0400
Subject: [PATCH 30/33] fix

---
 ports/include/arch/cc.h  | 3 ++-
 ports/include/lwipopts.h | 1 -
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/ports/include/arch/cc.h b/ports/include/arch/cc.h
index 5964091..9b57c2f 100644
--- a/ports/include/arch/cc.h
+++ b/ports/include/arch/cc.h
@@ -47,7 +47,8 @@
 /* This file must either include a system-local <errno.h> which defines
    the standard *nix error codes, or it should #define LWIP_PROVIDE_ERRNO
    to make lwip/arch.h define the codes which are used throughout. */
-#undef LWIP_PROVIDE_ERRNO
+//#undef LWIP_PROVIDE_ERRNO
+#define LWIP_PROVIDE_ERRNO              1
 
 /* type definitions */
 typedef uint8_t             u8_t;
diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
index e6257f8..5922306 100644
--- a/ports/include/lwipopts.h
+++ b/ports/include/lwipopts.h
@@ -143,7 +143,6 @@
 **                           Socket  Options
 *****************************************************************************/
 #define LWIP_SOCKET                     1
-#define LWIP_PROVIDE_ERRNO              1
 
 /*****************************************************************************
 **                          Debugging options
-- 
1.9.1


From fa2a753944bc9c423f130209dcbde34fe4b5ec0e Mon Sep 17 00:00:00 2001
From: Jay Doyle <jay.doyle@vecna.com>
Date: Mon, 12 Oct 2015 09:29:38 -0400
Subject: [PATCH 31/33] fix

---
 ports/sys_arch.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/ports/sys_arch.c b/ports/sys_arch.c
index 24d1133..2bfeb9e 100644
--- a/ports/sys_arch.c
+++ b/ports/sys_arch.c
@@ -42,7 +42,7 @@
 #include <rtems/rtems/clock.h>
 #include <rtems/rtems/sem.h>
 #include <rtems.h>
-#include "sys_arch.h"
+#include "arch/sys_arch.h"
 #include "lwip/err.h"
 #include "lwip/tcpip.h"
 #include "lwipopts.h"
-- 
1.9.1


From fdf1f59bd97d0fceaca92b1ab44ded7d329ef06a Mon Sep 17 00:00:00 2001
From: Jay Doyle <jay.doyle@vecna.com>
Date: Mon, 12 Oct 2015 09:39:53 -0400
Subject: [PATCH 32/33] various

---
 ports/include/arch/cc.h               | 145 ++++----
 ports/include/arch/perf.h             |  46 ++-
 ports/include/arch/sys_arch.h         |   1 +
 ports/include/lwipopts.h              |  19 +-
 ports/sys_arch.c                      |  10 +-
 src/api/api_msg.c                     |  13 +-
 src/api/netdb.c                       |   4 +-
 src/api/pppapi.c                      |   8 +-
 src/api/sockets.c                     |   1 -
 src/api/tcpip.c                       |   4 +
 src/core/dns.c                        |  18 +-
 src/core/ipv4/icmp.c                  |  17 +-
 src/core/ipv4/ip4.c                   |  43 ++-
 src/core/ipv4/ip_frag.c               |  11 +-
 src/core/netif.c                      |  57 ++--
 src/core/snmp/mib2.c                  | 620 +++++++---------------------------
 src/core/snmp/msg_in.c                |  72 ++--
 src/core/snmp/msg_out.c               |  25 +-
 src/core/tcp.c                        |  11 +-
 src/core/tcp_in.c                     |   9 +-
 src/core/tcp_out.c                    |   8 +-
 src/core/udp.c                        |  18 +-
 src/include/lwip/api.h                |   2 +-
 src/include/lwip/dns.h                |  14 +-
 src/include/lwip/netif.h              |  26 +-
 src/include/lwip/opt.h                |  30 +-
 src/include/lwip/pppapi.h             |   7 +-
 src/include/lwip/snmp.h               | 303 +----------------
 src/include/lwip/snmp_mib2.h          | 185 ++++++++++
 src/include/lwip/snmp_structs.h       |  31 ++
 src/include/lwip/stats.h              |  76 +++++
 src/include/netif/ppp/chap-new.h      |   2 +-
 src/include/netif/ppp/fsm.h           |   2 +-
 src/include/netif/ppp/mppe.h          |   2 +-
 src/include/netif/ppp/polarssl/des.h  |   2 +-
 src/include/netif/ppp/polarssl/md4.h  |   2 +-
 src/include/netif/ppp/polarssl/md5.h  |   2 +-
 src/include/netif/ppp/polarssl/sha1.h |   2 +-
 src/include/netif/ppp/ppp_impl.h      |  10 +-
 src/include/netif/ppp/pppos.h         |   7 +-
 src/netif/etharp.c                    |   6 +-
 src/netif/ppp/ccp.c                   |   6 +-
 src/netif/ppp/chap-md5.c              |   6 +-
 src/netif/ppp/chap-new.c              |   4 +-
 src/netif/ppp/chap_ms.c               | 100 +++---
 src/netif/ppp/eap.c                   |   6 +-
 src/netif/ppp/ecp.c                   |   4 +-
 src/netif/ppp/fsm.c                   |   6 +-
 src/netif/ppp/ipcp.c                  |   6 +-
 src/netif/ppp/ipv6cp.c                |   6 +-
 src/netif/ppp/lcp.c                   |   6 +-
 src/netif/ppp/mppe.c                  |   6 +-
 src/netif/ppp/polarssl/des.c          |   2 +-
 src/netif/ppp/polarssl/md4.c          |  10 +-
 src/netif/ppp/polarssl/md5.c          |  10 +-
 src/netif/ppp/polarssl/sha1.c         |  10 +-
 src/netif/ppp/ppp.c                   |  27 +-
 src/netif/ppp/pppoe.c                 |  55 ++-
 src/netif/ppp/pppol2tp.c              |  54 ++-
 src/netif/ppp/pppos.c                 |  65 ++--
 src/netif/ppp/upap.c                  |   6 +-
 src/netif/ppp/utils.c                 |  10 +-
 src/netif/slipif.c                    |   4 +-
 63 files changed, 935 insertions(+), 1345 deletions(-)
 create mode 100644 src/include/lwip/snmp_mib2.h

diff --git a/ports/include/arch/cc.h b/ports/include/arch/cc.h
index 9b57c2f..8eefd64 100644
--- a/ports/include/arch/cc.h
+++ b/ports/include/arch/cc.h
@@ -24,63 +24,38 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
  * OF SUCH DAMAGE.
  *
- * This file is system adaptation of the lwIP TCP/IP stack
- * by Adam Dunkels <adam@sics.se> for RTEMS system.
+ * This file is part of the lwIP TCP/IP stack.
  *
- * Author: Premysl Houdek <houdepre@fel.cvut.cz>
- * Mentor: Pavel Pisa <pisa@cmp.felk.cvut.cz>
- * Industrial Informatics Group, FEE, Czech Technical University in Prague
+ * Author: Adam Dunkels <adam@sics.se>
  *
  */
-/*
- * settings to adapt lwIP for compiler and machine architecture for RTEMS/GCC
- * DETAILS: ./lwip/doc/sys_arch.txt
- */
 #ifndef __CC_H__
 #define __CC_H__
 
-#include <stdio.h>
-#include <rtems/malloc.h>  /*printk*/
-#include <inttypes.h>
-#include <malloc.h>
-
-/* This file must either include a system-local <errno.h> which defines
-   the standard *nix error codes, or it should #define LWIP_PROVIDE_ERRNO
-   to make lwip/arch.h define the codes which are used throughout. */
-//#undef LWIP_PROVIDE_ERRNO
-#define LWIP_PROVIDE_ERRNO              1
-
-/* type definitions */
-typedef uint8_t             u8_t;
-typedef int8_t              s8_t;
-typedef uint16_t            u16_t;
-typedef int16_t             s16_t;
-typedef uint32_t            u32_t;
-typedef int32_t             s32_t;
-typedef u32_t               mem_ptr_t;
+typedef unsigned    char    u8_t;
+typedef signed      char    s8_t;
+typedef unsigned    short   u16_t;
+typedef signed      short   s16_t;
+typedef unsigned    int    u32_t;
+typedef signed      int    s32_t;
+typedef u32_t           mem_ptr_t;
 
-#define BYTE_ORDER BIG_ENDIAN
-
-/* Define (sn)printf formatters for these lwIP types */
-#define U16_F PRIu16
-#define S16_F PRId16
-#define X16_F PRIx16
-#define U32_F PRIu32
-#define S32_F PRId32
-#define X32_F PRIx32
+#ifndef BYTE_ORDER
+#define BYTE_ORDER LITTLE_ENDIAN
+#endif
 
 #if defined(__arm__) && defined(__ARMCC_VERSION)
-//
-// Setup PACKing macros for KEIL/RVMDK Tools
-//
+    //
+    // Setup PACKing macros for KEIL/RVMDK Tools
+    //
     #define PACK_STRUCT_BEGIN __packed
     #define PACK_STRUCT_STRUCT
     #define PACK_STRUCT_END
     #define PACK_STRUCT_FIELD(x) x
 #elif defined (__IAR_SYSTEMS_ICC__)
-//
-// Setup PACKing macros for IAR Tools
-//
+    //
+    // Setup PACKing macros for IAR Tools
+    //
     #define PACK_STRUCT_BEGIN
     #define PACK_STRUCT_STRUCT
     #define PACK_STRUCT_END
@@ -92,61 +67,59 @@ typedef u32_t               mem_ptr_t;
     #define PACK_STRUCT_END
     #define PACK_STRUCT_FIELD(x) x
 #else
-//
-// Setup PACKing macros for GCC Tools
-//
+    //
+    // Setup PACKing macros for GCC Tools
+    //
     #define PACK_STRUCT_BEGIN
     #define PACK_STRUCT_STRUCT __attribute__ ((__packed__))
     #define PACK_STRUCT_END
     #define PACK_STRUCT_FIELD(x) x
 #endif
 
-/*
- *     1 - load byte by byte, construct 16 bits word and add: not efficient for most platforms
- *     2 - load first byte if odd address, loop processing 16 bits words, add last byte.
- *     3 - load first byte and word if not 4 byte aligned, loop processing 32 bits words, add last word/byte.
- *
- *     see inet_chksum.c
+#ifdef LWIP_CACHE_ENABLED
+/**
+ * Make the PBUF POOL cacheline aligned.
  */
-#ifndef LWIP_CHKSUM_ALGORITHM
-#define LWIP_CHKSUM_ALGORITHM 2
+#ifdef __IAR_SYSTEMS_ICC__
+#pragma data_alignment=SOC_CACHELINE_SIZE_BYTES
+extern u8_t memp_memory_PBUF_POOL_base[];
+#else /*By default, GCC */
+extern u8_t memp_memory_PBUF_POOL_base[] __attribute__ ((aligned (SOC_CACHELINE_SIZE_BYTES)));
+#endif
 #endif
 
-/* this is used for 1) displaying statistics and 2) lwip debugging (set appropriate debugging level in lwipopts.h) */
-//#ifdef LWIP_DEBUG
-
-
-#define LWIP_PLATFORM_DIAG(expr)        printk expr
-
-//#else
-//#define LWIP_PLATFORM_DIAG(expr)
-//#endif
-
-//#define DEBUG
-#ifdef DEBUG
+extern u8_t memp_memory_PBUF_POOL_base[] __attribute__ ((aligned (SOC_CACHELINE_SIZE_BYTES)));
 
-/* for passing arguments to print function */
-#define CC_ASSERT(message, assertion) do { if (!(assertion)) \
-					     LWIP_PLATFORM_DIAG(message); } while (0)
+/* Define (sn)printf formatters for these lwIP types */
+#define X8_F  "02x"
+#define U16_F "u"
+#define S16_F "d"
+#define X16_F "x"
+#define U32_F "u"
+#define S32_F "d"
+#define X32_F "x"
 
-//extern void __error__(char *pcFilename, unsigned long ulLine);
-#define LWIP_PLATFORM_ASSERT(expr)      printk((const char *)expr)
-/*
-{                                       \
-    if(!(expr))                         \
-    {                                   \
-        __error__(__FILE__, __LINE__);  \
-    }                                   \
-}
-*/
+#include <stdio.h>
+#include <stdlib.h>
+#include <bsp.h>
+//#include <sys/time.h>
+
+#define LWIP_PLATFORM_DIAG(x)   do { \
+        printk("[%s - %s - %d] ", __PRETTY_FUNCTION__, __FILE__, __LINE__); \
+        printk x; \
+    } while(0)
+
+#ifdef LWIP_DEBUG  //DEBUG
+extern void __error__(char *pcFilename, unsigned long ulLine);
+#define LWIP_PLATFORM_ASSERT(expr)   printk("[%s - %s - %d] ", expr , __FILE__, __LINE__);
+//{
+    //if(!(expr))
+    //{
+        //__error__(__FILE__, __LINE__);
+    //}
+//}
 #else
 #define LWIP_PLATFORM_ASSERT(expr)
-#define CC_ASSERT(message, assertion)
-#endif /* DEBUG */
-
-/* "lightweight" synchronization mechanisms */
-/* #define SYS_ARCH_DECL_PROTECT(x) */ /* declare a protection state variable */
-/* #define SYS_ARCH_PROTECT(x) */ /* enter protection mode */
-/* #define SYS_ARCH_UNPROTECT(x) */ /* leave protection mode */
+#endif
 
 #endif /* __CC_H__ */
diff --git a/ports/include/arch/perf.h b/ports/include/arch/perf.h
index 1f799b3..d754157 100644
--- a/ports/include/arch/perf.h
+++ b/ports/include/arch/perf.h
@@ -1,12 +1,38 @@
-#ifndef _LWIP_ARCH_PERF_H_
-#define _LWIP_ARCH_PERF_H_
+/*
+ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __PERF_H__
+#define __PERF_H__
 
-//perf.h     - Architecture specific performance measurement.
-//Measurement calls made throughout lwip, these can be defined to nothing.
+#define PERF_START    /* null definition */
+#define PERF_STOP(x)  /* null definition */
 
-#define PERF_START
-
-#define PERF_STOP(x)
-
-
-#endif /* _LWIP_ARCH_PERF_H_ */
+#endif /* __PERF_H__ */
diff --git a/ports/include/arch/sys_arch.h b/ports/include/arch/sys_arch.h
index 087892b..29d8202 100644
--- a/ports/include/arch/sys_arch.h
+++ b/ports/include/arch/sys_arch.h
@@ -39,6 +39,7 @@
 #ifndef __ARCH_SYS_ARCH_H__
 #define __ARCH_SYS_ARCH_H__
 
+#include <errno.h>
 #include <rtems/rtems/sem.h>
 #include <rtems/rtems/intr.h>
 #include <bsp/irq-generic.h>
diff --git a/ports/include/lwipopts.h b/ports/include/lwipopts.h
index 5922306..f4ea9ec 100644
--- a/ports/include/lwipopts.h
+++ b/ports/include/lwipopts.h
@@ -131,7 +131,7 @@
 *****************************************************************************/
 #define PBUF_LINK_HLEN                  14
 /* PBUF_POOL_SIZE: the number of buffers in the pbuf pool. */
-#define PBUF_POOL_SIZE                  512
+#define PBUF_POOL_SIZE                  96
 
 /* PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. */
 #define PBUF_POOL_BUFSIZE               1524
@@ -152,17 +152,17 @@
                                          |LWIP_DBG_STATE | LWIP_DBG_FRESH)
 #define DHCP_DEBUG                      LWIP_DBG_OFF
 #define NETIF_DEBUG                     LWIP_DBG_OFF
-#define IP_DEBUG			LWIP_DBG_OFF
-#define UDP_DEBUG			LWIP_DBG_OFF
+#define IP_DEBUG                        LWIP_DBG_OFF
+#define UDP_DEBUG                       LWIP_DBG_OFF
 #define ETHARP_DEBUG                    LWIP_DBG_OFF
 #define SYS_DEBUG                       LWIP_DBG_OFF
 #define RAW_DEBUG                       LWIP_DBG_OFF
 #define MEM_DEBUG                       LWIP_DBG_OFF
 #define MEMP_DEBUG                      LWIP_DBG_OFF
-#define PBUF_DEBUG			LWIP_DBG_OFF
-#define TCPIP_DEBUG			LWIP_DBG_OFF
-#define APP_DEBUG			LWIP_DBG_OFF
-#define SOCKETS_DEBUG		        LWIP_DBG_OFF
+#define PBUF_DEBUG                      LWIP_DBG_OFF
+#define TCPIP_DEBUG                     LWIP_DBG_OFF
+#define APP_DEBUG                       LWIP_DBG_OFF
+#define SOCKETS_DEBUG                   LWIP_DBG_OFF
 #define LWIP_STATS                      0
 #define LWIP_STATS_DISPLAY              0
 #define LWIP_STATS_POSIX                0
@@ -177,6 +177,9 @@
 #define LWIP_RAW                        0
 
 #define configMAX_PRIORITIES            100
-#define TCPIP_THREAD_PRIO               200
+#define TCPIP_THREAD_PRIO               20
+#define TCPIP_THREAD_STACKSIZE          8192
+#define TCPIP_MBOX_SIZE                 10
+#define SYS_LWIP_MBOX_SIZE              1500
 
 #endif /* __LWIPOPTS_H__ */
diff --git a/ports/sys_arch.c b/ports/sys_arch.c
index 2bfeb9e..f01a047 100644
--- a/ports/sys_arch.c
+++ b/ports/sys_arch.c
@@ -38,18 +38,20 @@
  */
 
 #include <stdint.h>
-#include <arch/cc.h>
 #include <rtems/rtems/clock.h>
 #include <rtems/rtems/sem.h>
 #include <rtems.h>
+#include "lwipopts.h"
 #include "arch/sys_arch.h"
 #include "lwip/err.h"
 #include "lwip/tcpip.h"
-#include "lwipopts.h"
+#include <arch/cc.h>
+
+int errno;
 
 #define SYS_LWIP_MBOX_SIZE (sizeof(void *))
 
-uint32_t
+u32_t
 sys_now()
 {
   uint64_t temp = rtems_clock_get_uptime_nanoseconds() / (1000 * 1000);
@@ -339,7 +341,7 @@ sys_arch_delay(unsigned int timeout)
 }
 
 /** Ticks/jiffies since power up. */
-uint32_t
+u32_t
 sys_jiffies(void)
 {
   return rtems_clock_get_ticks_since_boot();
diff --git a/src/api/api_msg.c b/src/api/api_msg.c
index 2764342..ad3d78e 100644
--- a/src/api/api_msg.c
+++ b/src/api/api_msg.c
@@ -1840,12 +1840,15 @@ void
 lwip_netconn_do_gethostbyname(void *arg)
 {
   struct dns_api_msg *msg = (struct dns_api_msg*)arg;
-
-  API_EXPR_DEREF(msg->err) = dns_gethostbyname_addrtype(msg->name, API_EXPR_REF(msg->addr), lwip_netconn_do_dns_found, msg
+  u8_t addrtype =
 #if LWIP_IPV4 && LWIP_IPV6
-    , msg->dns_addrtype
-#endif /* LWIP_IPV4 && LWIP_IPV6 */
-    );
+    msg->dns_addrtype;
+#else
+    LWIP_DNS_ADDRTYPE_DEFAULT;
+#endif
+
+  API_EXPR_DEREF(msg->err) = dns_gethostbyname_addrtype(msg->name,
+    API_EXPR_REF(msg->addr), lwip_netconn_do_dns_found, msg, addrtype);
   if (API_EXPR_DEREF(msg->err) != ERR_INPROGRESS) {
     /* on error or immediate success, wake up the application
      * task waiting in netconn_gethostbyname */
diff --git a/src/api/netdb.c b/src/api/netdb.c
index c25e71b..4d85dba 100644
--- a/src/api/netdb.c
+++ b/src/api/netdb.c
@@ -290,9 +290,9 @@ lwip_getaddrinfo(const char *nodename, const char *servname,
 #if LWIP_IPV4
       && (ai_family != AF_INET)
 #endif /* LWIP_IPV4 */
-#if LWIP_IPV4
+#if LWIP_IPV6
       && (ai_family != AF_INET6)
-#endif /* LWIP_IPV4 */
+#endif /* LWIP_IPV6 */
       ) {
       return EAI_FAMILY;
     }
diff --git a/src/api/pppapi.c b/src/api/pppapi.c
index 5b7940d..e1122d7 100644
--- a/src/api/pppapi.c
+++ b/src/api/pppapi.c
@@ -127,7 +127,7 @@ pppapi_set_notify_phase_callback(ppp_pcb *pcb, ppp_notify_phase_cb_fn notify_pha
 static void
 pppapi_do_pppos_create(struct pppapi_msg_msg *msg)
 {
-  msg->ppp = pppos_create(msg->msg.serialcreate.pppif, msg->msg.serialcreate.fd,
+  msg->ppp = pppos_create(msg->msg.serialcreate.pppif, msg->msg.serialcreate.output_cb,
     msg->msg.serialcreate.link_status_cb, msg->msg.serialcreate.ctx_cb);
   TCPIP_PPPAPI_ACK(msg);
 }
@@ -137,13 +137,13 @@ pppapi_do_pppos_create(struct pppapi_msg_msg *msg)
  * tcpip_thread context.
  */
 ppp_pcb*
-pppapi_pppos_create(struct netif *pppif, sio_fd_t fd, ppp_link_status_cb_fn link_status_cb,
-                          void *ctx_cb)
+pppapi_pppos_create(struct netif *pppif, pppos_output_cb_fn output_cb,
+               ppp_link_status_cb_fn link_status_cb, void *ctx_cb)
 {
   struct pppapi_msg msg;
   msg.function = pppapi_do_pppos_create;
   msg.msg.msg.serialcreate.pppif = pppif;
-  msg.msg.msg.serialcreate.fd = fd;
+  msg.msg.msg.serialcreate.output_cb = output_cb;
   msg.msg.msg.serialcreate.link_status_cb = link_status_cb;
   msg.msg.msg.serialcreate.ctx_cb = ctx_cb;
   TCPIP_PPPAPI(&msg);
diff --git a/src/api/sockets.c b/src/api/sockets.c
index 11e15e1..d601911 100644
--- a/src/api/sockets.c
+++ b/src/api/sockets.c
@@ -42,7 +42,6 @@
 
 #if LWIP_SOCKET /* don't build if not configured for use in lwipopts.h */
 
-#include "lwip/arch.h"
 #include "lwip/sockets.h"
 #include "lwip/api.h"
 #include "lwip/sys.h"
diff --git a/src/api/tcpip.c b/src/api/tcpip.c
index 34ec501..63adb66 100644
--- a/src/api/tcpip.c
+++ b/src/api/tcpip.c
@@ -555,6 +555,10 @@ tcpip_trycallback(struct tcpip_callback_msg* msg)
 void
 tcpip_init(tcpip_init_done_fn initfunc, void *arg)
 {
+#if (TCPIP_MBOX_SIZE == 0)
+#error "TCPIP_MBOX_SIZE  is zero"
+#endif
+
   lwip_init();
 
   tcpip_init_done = initfunc;
diff --git a/src/core/dns.c b/src/core/dns.c
index 967fca4..c9b7d01 100644
--- a/src/core/dns.c
+++ b/src/core/dns.c
@@ -1423,7 +1423,7 @@ dns_gethostbyname(const char *hostname, ip_addr_t *addr, dns_found_callback foun
                   void *callback_arg)
 {
 #if LWIP_IPV4 && LWIP_IPV6
-  return dns_gethostbyname_addrtype(hostname, addr, found, callback_arg, LWIP_DNS_ADDRTYPE_IPV4_IPV6);
+  return dns_gethostbyname_addrtype(hostname, addr, found, callback_arg, LWIP_DNS_ADDRTYPE_DEFAULT);
 }
 
 /** Like dns_gethostbyname, but returned address type can be controlled:
@@ -1468,7 +1468,7 @@ dns_gethostbyname_addrtype(const char *hostname, ip_addr_t *addr, dns_found_call
 #if LWIP_IPV4 && LWIP_IPV6
     if ((IP_IS_V6(addr) && (dns_addrtype != LWIP_DNS_ADDRTYPE_IPV4)) ||
        !(IP_IS_V6(addr) && (dns_addrtype != LWIP_DNS_ADDRTYPE_IPV6)))
-#endif LWIP_IPV4 && LWIP_IPV6
+#endif /* LWIP_IPV4 && LWIP_IPV6 */
     {
       return ERR_OK;
     }
@@ -1478,7 +1478,7 @@ dns_gethostbyname_addrtype(const char *hostname, ip_addr_t *addr, dns_found_call
     return ERR_OK;
   }
 #if LWIP_IPV4 && LWIP_IPV6
-  if ((dns_addrtype == LWIP_DNS_ADDRTYPE_IPV4_IPV6) || (dns_addrtype == LWIP_DNS_ADDRTYPE_IPV4_IPV6)) {
+  if ((dns_addrtype == LWIP_DNS_ADDRTYPE_IPV4_IPV6) || (dns_addrtype == LWIP_DNS_ADDRTYPE_IPV6_IPV4)) {
     /* fallback to 2nd IP type and try again to lookup */
     u8_t fallback;
     if (dns_addrtype == LWIP_DNS_ADDRTYPE_IPV4_IPV6) {
@@ -1486,7 +1486,7 @@ dns_gethostbyname_addrtype(const char *hostname, ip_addr_t *addr, dns_found_call
     } else {
       fallback = LWIP_DNS_ADDRTYPE_IPV4;
     }
-    if(dns_lookup(hostname, addr LWIP_DNS_ADDRTYPE_ARG(dns_addrtype)) == ERR_OK) {
+    if(dns_lookup(hostname, addr LWIP_DNS_ADDRTYPE_ARG(fallback)) == ERR_OK) {
       return ERR_OK;
     }
   }
@@ -1496,4 +1496,14 @@ dns_gethostbyname_addrtype(const char *hostname, ip_addr_t *addr, dns_found_call
   return dns_enqueue(hostname, hostnamelen, found, callback_arg LWIP_DNS_ADDRTYPE_ARG(dns_addrtype));
 }
 
+#if !LWIP_IPV4 || !LWIP_IPV6
+err_t
+dns_gethostbyname_addrtype(const char *hostname, ip_addr_t *addr, dns_found_callback found,
+                           void *callback_arg, u8_t dns_addrtype)
+{
+  LWIP_UNUSED_ARG(dns_addrtype);
+  return dns_gethostbyname(hostname, addr, found, callback_arg);
+}
+#endif /* LWIP_IPV4 && LWIP_IPV6 */
+
 #endif /* LWIP_DNS */
diff --git a/src/core/ipv4/icmp.c b/src/core/ipv4/icmp.c
index 0d66960..a9cf3b6 100644
--- a/src/core/ipv4/icmp.c
+++ b/src/core/ipv4/icmp.c
@@ -48,7 +48,6 @@
 #include "lwip/ip.h"
 #include "lwip/def.h"
 #include "lwip/stats.h"
-#include "lwip/snmp.h"
 
 #include <string.h>
 
@@ -87,7 +86,7 @@ icmp_input(struct pbuf *p, struct netif *inp)
   ip4_addr_t* src;
 
   ICMP_STATS_INC(icmp.recv);
-  snmp_inc_icmpinmsgs();
+  MIB2_STATS_INC(mib2.icmpinmsgs);
 
   iphdr_in = ip4_current_header();
   hlen = IPH_HL(iphdr_in) * 4;
@@ -138,7 +137,7 @@ icmp_input(struct pbuf *p, struct netif *inp)
         LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
         pbuf_free(p);
         ICMP_STATS_INC(icmp.chkerr);
-        snmp_inc_icmpinerrors();
+        MIB2_STATS_INC(mib2.icmpinerrors);
         return;
       }
     }
@@ -223,9 +222,9 @@ icmp_input(struct pbuf *p, struct netif *inp)
 
       ICMP_STATS_INC(icmp.xmit);
       /* increase number of messages attempted to send */
-      snmp_inc_icmpoutmsgs();
+      MIB2_STATS_INC(mib2.icmpoutmsgs);
       /* increase number of echo replies attempted to send */
-      snmp_inc_icmpoutechoreps();
+      MIB2_STATS_INC(mib2.icmpoutechoreps);
 
       /* send an ICMP packet */
       ret = ip4_output_if(p, src, IP_HDRINCL,
@@ -246,13 +245,13 @@ icmp_input(struct pbuf *p, struct netif *inp)
 lenerr:
   pbuf_free(p);
   ICMP_STATS_INC(icmp.lenerr);
-  snmp_inc_icmpinerrors();
+  MIB2_STATS_INC(mib2.icmpinerrors);
   return;
 #if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN || !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
 icmperr:
   pbuf_free(p);
   ICMP_STATS_INC(icmp.err);
-  snmp_inc_icmpinerrors();
+  MIB2_STATS_INC(mib2.icmpinerrors);
   return;
 #endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN || !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
 }
@@ -344,9 +343,9 @@ icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
 #endif
     ICMP_STATS_INC(icmp.xmit);
     /* increase number of messages attempted to send */
-    snmp_inc_icmpoutmsgs();
+    MIB2_STATS_INC(mib2.icmpoutmsgs);
     /* increase number of destination unreachable messages attempted to send */
-    snmp_inc_icmpouttimeexcds();
+    MIB2_STATS_INC(mib2.icmpouttimeexcds);
     ip4_addr_copy(iphdr_src, iphdr->src);
     ip4_output_if(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP, netif);
   }
diff --git a/src/core/ipv4/ip4.c b/src/core/ipv4/ip4.c
index c4ca61c..8778cca 100644
--- a/src/core/ipv4/ip4.c
+++ b/src/core/ipv4/ip4.c
@@ -53,7 +53,6 @@
 #include "lwip/raw.h"
 #include "lwip/udp.h"
 #include "lwip/tcp_impl.h"
-#include "lwip/snmp.h"
 #include "lwip/dhcp.h"
 #include "lwip/autoip.h"
 #include "lwip/stats.h"
@@ -188,7 +187,7 @@ ip4_route(const ip4_addr_t *dest)
     LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_route: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
       ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
     IP_STATS_INC(ip.rterr);
-    snmp_inc_ipoutnoroutes();
+    MIB2_STATS_INC(mib2.ipoutnoroutes);
     return NULL;
   }
 
@@ -302,7 +301,7 @@ ip4_forward(struct pbuf *p, struct ip_hdr *iphdr, struct netif *inp)
   IPH_TTL_SET(iphdr, IPH_TTL(iphdr) - 1);
   /* send ICMP if TTL == 0 */
   if (IPH_TTL(iphdr) == 0) {
-    snmp_inc_ipinhdrerrors();
+    MIB2_STATS_INC(mib2.ipinhdrerrors);
 #if LWIP_ICMP
     /* Don't send ICMP messages in response to ICMP messages */
     if (IPH_PROTO(iphdr) != IP_PROTO_ICMP) {
@@ -324,8 +323,8 @@ ip4_forward(struct pbuf *p, struct ip_hdr *iphdr, struct netif *inp)
     ip4_addr3_16(ip4_current_dest_addr()), ip4_addr4_16(ip4_current_dest_addr())));
 
   IP_STATS_INC(ip.fw);
+  MIB2_STATS_INC(mib2.ipforwdatagrams);
   IP_STATS_INC(ip.xmit);
-  snmp_inc_ipforwdatagrams();
 
   PERF_STOP("ip_forward");
   /* don't fragment if interface has mtu set to 0 [loopif] */
@@ -346,7 +345,7 @@ ip4_forward(struct pbuf *p, struct ip_hdr *iphdr, struct netif *inp)
   netif->output(netif, p, ip4_current_dest_addr());
   return;
 return_noroute:
-  snmp_inc_ipoutnoroutes();
+  MIB2_STATS_INC(mib2.ipoutnoroutes);
 }
 #endif /* IP_FORWARD */
 
@@ -393,7 +392,7 @@ ip4_input(struct pbuf *p, struct netif *inp)
 #endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING || LWIP_IGMP */
 
   IP_STATS_INC(ip.recv);
-  snmp_inc_ipinreceives();
+  MIB2_STATS_INC(mib2.ipinreceives);
 
   /* identify the IP header */
   iphdr = (struct ip_hdr *)p->payload;
@@ -403,7 +402,7 @@ ip4_input(struct pbuf *p, struct netif *inp)
     pbuf_free(p);
     IP_STATS_INC(ip.err);
     IP_STATS_INC(ip.drop);
-    snmp_inc_ipinhdrerrors();
+    MIB2_STATS_INC(mib2.ipinhdrerrors);
     return ERR_OK;
   }
 
@@ -442,7 +441,7 @@ ip4_input(struct pbuf *p, struct netif *inp)
     pbuf_free(p);
     IP_STATS_INC(ip.lenerr);
     IP_STATS_INC(ip.drop);
-    snmp_inc_ipindiscards();
+    MIB2_STATS_INC(mib2.ipindiscards);
     return ERR_OK;
   }
 
@@ -457,7 +456,7 @@ ip4_input(struct pbuf *p, struct netif *inp)
       pbuf_free(p);
       IP_STATS_INC(ip.chkerr);
       IP_STATS_INC(ip.drop);
-      snmp_inc_ipinhdrerrors();
+      MIB2_STATS_INC(mib2.ipinhdrerrors);
       return ERR_OK;
     }
   }
@@ -577,8 +576,8 @@ ip4_input(struct pbuf *p, struct netif *inp)
       /* free (drop) packet pbufs */
       pbuf_free(p);
       IP_STATS_INC(ip.drop);
-      snmp_inc_ipinaddrerrors();
-      snmp_inc_ipindiscards();
+      MIB2_STATS_INC(mib2.ipinaddrerrors);
+      MIB2_STATS_INC(mib2.ipindiscards);
       return ERR_OK;
     }
   }
@@ -595,8 +594,8 @@ ip4_input(struct pbuf *p, struct netif *inp)
     } else
 #endif /* IP_FORWARD */
     {
-      snmp_inc_ipinaddrerrors();
-      snmp_inc_ipindiscards();
+      MIB2_STATS_INC(mib2.ipinaddrerrors);
+      MIB2_STATS_INC(mib2.ipindiscards);
     }
     pbuf_free(p);
     return ERR_OK;
@@ -620,7 +619,7 @@ ip4_input(struct pbuf *p, struct netif *inp)
     IP_STATS_INC(ip.opterr);
     IP_STATS_INC(ip.drop);
     /* unsupported protocol feature */
-    snmp_inc_ipinunknownprotos();
+    MIB2_STATS_INC(mib2.ipinunknownprotos);
     return ERR_OK;
 #endif /* IP_REASSEMBLY */
   }
@@ -638,7 +637,7 @@ ip4_input(struct pbuf *p, struct netif *inp)
     IP_STATS_INC(ip.opterr);
     IP_STATS_INC(ip.drop);
     /* unsupported protocol feature */
-    snmp_inc_ipinunknownprotos();
+    MIB2_STATS_INC(mib2.ipinunknownprotos);
     return ERR_OK;
   }
 #endif /* IP_OPTIONS_ALLOWED == 0 */
@@ -666,19 +665,19 @@ ip4_input(struct pbuf *p, struct netif *inp)
 #if LWIP_UDPLITE
     case IP_PROTO_UDPLITE:
 #endif /* LWIP_UDPLITE */
-      snmp_inc_ipindelivers();
+      MIB2_STATS_INC(mib2.ipindelivers);
       udp_input(p, inp);
       break;
 #endif /* LWIP_UDP */
 #if LWIP_TCP
     case IP_PROTO_TCP:
-      snmp_inc_ipindelivers();
+      MIB2_STATS_INC(mib2.ipindelivers);
       tcp_input(p, inp);
       break;
 #endif /* LWIP_TCP */
 #if LWIP_ICMP
     case IP_PROTO_ICMP:
-      snmp_inc_ipindelivers();
+      MIB2_STATS_INC(mib2.ipindelivers);
       icmp_input(p, inp);
       break;
 #endif /* LWIP_ICMP */
@@ -703,7 +702,7 @@ ip4_input(struct pbuf *p, struct netif *inp)
 
       IP_STATS_INC(ip.proterr);
       IP_STATS_INC(ip.drop);
-      snmp_inc_ipinunknownprotos();
+      MIB2_STATS_INC(mib2.ipinunknownprotos);
     }
   }
 
@@ -808,7 +807,7 @@ err_t ip4_output_if_opt_src(struct pbuf *p, const ip4_addr_t *src, const ip4_add
 
   LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
 
-  snmp_inc_ipoutrequests();
+  MIB2_STATS_INC(mib2.ipoutrequests);
 
   /* Should the IP header be generated or is it already included in p? */
   if (dest != IP_HDRINCL) {
@@ -826,7 +825,7 @@ err_t ip4_output_if_opt_src(struct pbuf *p, const ip4_addr_t *src, const ip4_add
       if (pbuf_header(p, optlen_aligned)) {
         LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_output_if_opt: not enough room for IP options in pbuf\n"));
         IP_STATS_INC(ip.err);
-        snmp_inc_ipoutdiscards();
+        MIB2_STATS_INC(mib2.ipoutdiscards);
         return ERR_BUF;
       }
       MEMCPY(p->payload, ip_options, optlen);
@@ -846,7 +845,7 @@ err_t ip4_output_if_opt_src(struct pbuf *p, const ip4_addr_t *src, const ip4_add
       LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_output: not enough room for IP header in pbuf\n"));
 
       IP_STATS_INC(ip.err);
-      snmp_inc_ipoutdiscards();
+      MIB2_STATS_INC(mib2.ipoutdiscards);
       return ERR_BUF;
     }
 
diff --git a/src/core/ipv4/ip_frag.c b/src/core/ipv4/ip_frag.c
index 7e933ac..e239ba2 100644
--- a/src/core/ipv4/ip_frag.c
+++ b/src/core/ipv4/ip_frag.c
@@ -46,7 +46,6 @@
 #include "lwip/def.h"
 #include "lwip/inet_chksum.h"
 #include "lwip/netif.h"
-#include "lwip/snmp.h"
 #include "lwip/stats.h"
 #include "lwip/icmp.h"
 
@@ -170,7 +169,7 @@ ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *p
     LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
   }
 
-  snmp_inc_ipreasmfails();
+  MIB2_STATS_INC(mib2.ipreasmfails);
 #if LWIP_ICMP
   iprh = (struct ip_reass_helper *)ipr->p->payload;
   if (iprh->start == 0) {
@@ -489,8 +488,8 @@ ip4_reass(struct pbuf *p)
   u8_t clen;
 
   IPFRAG_STATS_INC(ip_frag.recv);
-  snmp_inc_ipreasmreqds();
-
+  MIB2_STATS_INC(mib2.ipreasmreqds);
+  
   fraghdr = (struct ip_hdr*)p->payload;
 
   if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
@@ -853,7 +852,7 @@ ip4_frag(struct pbuf *p, struct netif *netif, const ip4_addr_t *dest)
       pbuf_chain(header, rambuf);
       netif->output(netif, header, dest);
       IPFRAG_STATS_INC(ip_frag.xmit);
-      snmp_inc_ipfragcreates();
+      MIB2_STATS_INC(mib2.ipfragcreates);
       pbuf_free(header);
     } else {
       LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
@@ -882,7 +881,7 @@ ip4_frag(struct pbuf *p, struct netif *netif, const ip4_addr_t *dest)
 #if IP_FRAG_USES_STATIC_BUF
   pbuf_free(rambuf);
 #endif /* IP_FRAG_USES_STATIC_BUF */
-  snmp_inc_ipfragoks();
+  MIB2_STATS_INC(mib2.ipfragoks);
   return ERR_OK;
 }
 #endif /* IP_FRAG */
diff --git a/src/core/netif.c b/src/core/netif.c
index 668196f..4b9f00a 100644
--- a/src/core/netif.c
+++ b/src/core/netif.c
@@ -44,10 +44,11 @@
 #include "lwip/netif.h"
 #include "lwip/tcp_impl.h"
 #include "lwip/udp.h"
-#include "lwip/snmp.h"
+#include "lwip/snmp_mib2.h"
 #include "lwip/igmp.h"
 #include "netif/etharp.h"
 #include "lwip/stats.h"
+#include "lwip/sys.h"
 #if ENABLE_LOOPBACK
 #include "lwip/sys.h"
 #if LWIP_NETIF_LOOPBACK_MULTITHREADING
@@ -117,7 +118,7 @@ netif_loopif_init(struct netif *netif)
   /* initialize the snmp variables and counters inside the struct netif
    * ifSpeed: no assumption can be made!
    */
-  NETIF_INIT_SNMP(netif, snmp_ifType_softwareLoopback, 0);
+  MIB2_INIT_NETIF(netif, snmp_ifType_softwareLoopback, 0);
 
   netif->name[0] = 'l';
   netif->name[1] = 'o';
@@ -264,7 +265,7 @@ netif_add(struct netif *netif,
   /* add this netif to the list */
   netif->next = netif_list;
   netif_list = netif;
-  snmp_inc_iflist();
+  mib2_netif_added(netif);
 
 #if LWIP_IGMP
   /* start IGMP processing */
@@ -345,7 +346,7 @@ netif_remove(struct netif *netif)
     netif_set_down(netif);
   }
 
-  snmp_delete_ipaddridx_tree(netif);
+  mib2_remove_ip4(netif);
 
   /* this netif is default? */
   if (netif_default == netif) {
@@ -368,7 +369,7 @@ netif_remove(struct netif *netif)
       return; /* netif is not on the list */
     }
   }
-  snmp_dec_iflist();
+  mib2_netif_removed(netif);
 #if LWIP_NETIF_REMOVE_CALLBACK
   if (netif->remove_callback) {
     netif->remove_callback(netif);
@@ -431,12 +432,12 @@ netif_set_ipaddr(struct netif *netif, const ip4_addr_t *ipaddr)
     udp_netif_ipv4_addr_changed(netif_ip4_addr(netif), ipaddr);
 #endif /* LWIP_UDP */
 
-    snmp_delete_ipaddridx_tree(netif);
-    snmp_delete_iprteidx_tree(0, netif);
+    mib2_remove_ip4(netif);
+    mib2_remove_route_ip4(0, netif);
     /* set new IP address to netif */
     ip4_addr_set(netif_ip4_addr(netif), ipaddr);
-    snmp_insert_ipaddridx_tree(netif);
-    snmp_insert_iprteidx_tree(0, netif);
+    mib2_add_ip4(netif);
+    mib2_add_route_ip4(0, netif);
 
     netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4);
 
@@ -483,10 +484,10 @@ netif_set_gw(struct netif *netif, const ip4_addr_t *gw)
 void
 netif_set_netmask(struct netif *netif, const ip4_addr_t *netmask)
 {
-  snmp_delete_iprteidx_tree(0, netif);
+  mib2_remove_route_ip4(0, netif);
   /* set new netmask to netif */
   ip4_addr_set(netif_ip4_netmask(netif), netmask);
-  snmp_insert_iprteidx_tree(0, netif);
+  mib2_add_route_ip4(0, netif);
   LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("netif: netmask of interface %c%c set to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
     netif->name[0], netif->name[1],
     ip4_addr1_16(netif_ip4_netmask(netif)),
@@ -507,10 +508,10 @@ netif_set_default(struct netif *netif)
 {
   if (netif == NULL) {
     /* remove default route */
-    snmp_delete_iprteidx_tree(1, netif);
+    mib2_remove_route_ip4(1, netif);
   } else {
     /* install default route */
-    snmp_insert_iprteidx_tree(1, netif);
+    mib2_add_route_ip4(1, netif);
   }
   netif_default = netif;
   LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
@@ -531,9 +532,7 @@ void netif_set_up(struct netif *netif)
   if (!(netif->flags & NETIF_FLAG_UP)) {
     netif->flags |= NETIF_FLAG_UP;
 
-#if LWIP_SNMP
-    snmp_get_sysuptime(&netif->ts);
-#endif /* LWIP_SNMP */
+    MIB2_COPY_SYSUPTIME_TO(&netif->ts);
 
     NETIF_STATUS_CALLBACK(netif);
 
@@ -593,9 +592,7 @@ void netif_set_down(struct netif *netif)
 {
   if (netif->flags & NETIF_FLAG_UP) {
     netif->flags &= ~NETIF_FLAG_UP;
-#if LWIP_SNMP
-    snmp_get_sysuptime(&netif->ts);
-#endif
+    MIB2_COPY_SYSUPTIME_TO(&netif->ts);
 
 #if LWIP_IPV4 && LWIP_ARP
     if (netif->flags & NETIF_FLAG_ETHARP) {
@@ -706,13 +703,13 @@ netif_loop_output(struct netif *netif, struct pbuf *p)
 #endif /* LWIP_LOOPBACK_MAX_PBUFS */
   /* If we have a loopif, SNMP counters are adjusted for it,
    * if not they are adjusted for 'netif'. */
-#if LWIP_SNMP
+#if MIB2_STATS
 #if LWIP_HAVE_LOOPIF
   struct netif *stats_if = &loop_netif;
 #else /* LWIP_HAVE_LOOPIF */
   struct netif *stats_if = netif;
 #endif /* LWIP_HAVE_LOOPIF */
-#endif /* LWIP_SNMP */
+#endif /* MIB2_STATS */
   SYS_ARCH_DECL_PROTECT(lev);
 
   /* Allocate a new pbuf */
@@ -720,7 +717,7 @@ netif_loop_output(struct netif *netif, struct pbuf *p)
   if (r == NULL) {
     LINK_STATS_INC(link.memerr);
     LINK_STATS_INC(link.drop);
-    snmp_inc_ifoutdiscards(stats_if);
+    MIB2_STATS_NETIF_INC(stats_if, ifoutdiscards);
     return ERR_MEM;
   }
 #if LWIP_LOOPBACK_MAX_PBUFS
@@ -731,7 +728,7 @@ netif_loop_output(struct netif *netif, struct pbuf *p)
     pbuf_free(r);
     LINK_STATS_INC(link.memerr);
     LINK_STATS_INC(link.drop);
-    snmp_inc_ifoutdiscards(stats_if);
+    MIB2_STATS_NETIF_INC(stats_if, ifoutdiscards);
     return ERR_MEM;
   }
   netif->loop_cnt_current += clen;
@@ -742,7 +739,7 @@ netif_loop_output(struct netif *netif, struct pbuf *p)
     pbuf_free(r);
     LINK_STATS_INC(link.memerr);
     LINK_STATS_INC(link.drop);
-    snmp_inc_ifoutdiscards(stats_if);
+    MIB2_STATS_NETIF_INC(stats_if, ifoutdiscards);
     return err;
   }
 
@@ -764,8 +761,8 @@ netif_loop_output(struct netif *netif, struct pbuf *p)
   SYS_ARCH_UNPROTECT(lev);
 
   LINK_STATS_INC(link.xmit);
-  snmp_add_ifoutoctets(stats_if, p->tot_len);
-  snmp_inc_ifoutucastpkts(stats_if);
+  MIB2_STATS_NETIF_ADD(stats_if, ifoutoctets, p->tot_len);
+  MIB2_STATS_NETIF_INC(stats_if, ifoutucastpkts);
 
 #if LWIP_NETIF_LOOPBACK_MULTITHREADING
   /* For multithreading environment, schedule a call to netif_poll */
@@ -806,13 +803,13 @@ netif_poll(struct netif *netif)
   struct pbuf *in;
   /* If we have a loopif, SNMP counters are adjusted for it,
    * if not they are adjusted for 'netif'. */
-#if LWIP_SNMP
+#if MIB2_STATS
 #if LWIP_HAVE_LOOPIF
   struct netif *stats_if = &loop_netif;
 #else /* LWIP_HAVE_LOOPIF */
   struct netif *stats_if = netif;
 #endif /* LWIP_HAVE_LOOPIF */
-#endif /* LWIP_SNMP */
+#endif /* MIB2_STATS */
   SYS_ARCH_DECL_PROTECT(lev);
 
   do {
@@ -854,8 +851,8 @@ netif_poll(struct netif *netif)
 
     if (in != NULL) {
       LINK_STATS_INC(link.recv);
-      snmp_add_ifinoctets(stats_if, in->tot_len);
-      snmp_inc_ifinucastpkts(stats_if);
+      MIB2_STATS_NETIF_ADD(stats_if, ifinoctets, in->tot_len);
+      MIB2_STATS_NETIF_INC(stats_if, ifinucastpkts);
       /* loopback packets are always IP packets! */
       if (ip_input(in, netif) != ERR_OK) {
         pbuf_free(in);
diff --git a/src/core/snmp/mib2.c b/src/core/snmp/mib2.c
index 5e2ea4f..438d014 100644
--- a/src/core/snmp/mib2.c
+++ b/src/core/snmp/mib2.c
@@ -40,6 +40,18 @@
 #if LWIP_SNMP /* don't build if not configured for use in lwipopts.h */
 
 #include "lwip/snmp.h"
+#include "lwip/snmp_mib2.h"
+
+#if !LWIP_MIB2_CALLBACKS
+#error LWIP_SNMP MIB2 needs LWIP_MIB2_CALLBACKS (for MIB2)
+#endif
+#if !LWIP_STATS
+#error LWIP_SNMP MIB2 needs LWIP_STATS (for MIB2)
+#endif
+#if !MIB2_STATS
+#error LWIP_SNMP MIB2 needs MIB2_STATS (for MIB2)
+#endif
+
 #include "lwip/netif.h"
 #include "lwip/ip.h"
 #include "lwip/ip_frag.h"
@@ -50,6 +62,7 @@
 #include "lwip/snmp_structs.h"
 #include "lwip/sys.h"
 #include "netif/etharp.h"
+#include "lwip/stats.h"
 
 #include <string.h>
 
@@ -74,10 +87,6 @@
 #define SNMP_SYSSERVICES ((1 << 6) | (1 << 3) | ((IP_FORWARD) << 2))
 #endif
 
-#ifndef SNMP_GET_SYSUPTIME
-#define SNMP_GET_SYSUPTIME(sysuptime)  (sysuptime = (sys_now() / 10))
-#endif
-
 static void system_get_object_def(u8_t ident_len, s32_t *ident, struct obj_def *od);
 static void system_get_value(struct obj_def *od, u16_t len, void *value);
 static u8_t system_set_test(struct obj_def *od, u16_t len, void *value);
@@ -805,70 +814,6 @@ static const struct snmp_obj_id ifspecific = {2, {0, 0}};
 static const struct snmp_obj_id iprouteinfo = {2, {0, 0}};
 
 
-
-/* mib-2.system counter(s) */
-static u32_t sysuptime = 0;
-
-/* mib-2.ip counter(s) */
-static u32_t ipinreceives = 0,
-             ipinhdrerrors = 0,
-             ipinaddrerrors = 0,
-             ipforwdatagrams = 0,
-             ipinunknownprotos = 0,
-             ipindiscards = 0,
-             ipindelivers = 0,
-             ipoutrequests = 0,
-             ipoutdiscards = 0,
-             ipoutnoroutes = 0,
-             ipreasmreqds = 0,
-             ipreasmoks = 0,
-             ipreasmfails = 0,
-             ipfragoks = 0,
-             ipfragfails = 0,
-             ipfragcreates = 0,
-             iproutingdiscards = 0;
-/* mib-2.icmp counter(s) */
-static u32_t icmpinmsgs = 0,
-             icmpinerrors = 0,
-             icmpindestunreachs = 0,
-             icmpintimeexcds = 0,
-             icmpinparmprobs = 0,
-             icmpinsrcquenchs = 0,
-             icmpinredirects = 0,
-             icmpinechos = 0,
-             icmpinechoreps = 0,
-             icmpintimestamps = 0,
-             icmpintimestampreps = 0,
-             icmpinaddrmasks = 0,
-             icmpinaddrmaskreps = 0,
-             icmpoutmsgs = 0,
-             icmpouterrors = 0,
-             icmpoutdestunreachs = 0,
-             icmpouttimeexcds = 0,
-             icmpoutparmprobs = 0,
-             icmpoutsrcquenchs = 0,
-             icmpoutredirects = 0,
-             icmpoutechos = 0,
-             icmpoutechoreps = 0,
-             icmpouttimestamps = 0,
-             icmpouttimestampreps = 0,
-             icmpoutaddrmasks = 0,
-             icmpoutaddrmaskreps = 0;
-/* mib-2.tcp counter(s) */
-static u32_t tcpactiveopens = 0,
-             tcppassiveopens = 0,
-             tcpattemptfails = 0,
-             tcpestabresets = 0,
-             tcpinsegs = 0,
-             tcpoutsegs = 0,
-             tcpretranssegs = 0,
-             tcpinerrs = 0,
-             tcpoutrsts = 0;
-/* mib-2.udp counter(s) */
-static u32_t udpindatagrams = 0,
-             udpnoports = 0,
-             udpinerrors = 0,
-             udpoutdatagrams = 0;
 /* mib-2.snmp counter(s) */
 static u32_t snmpinpkts = 0,
              snmpoutpkts = 0,
@@ -930,26 +875,6 @@ void snmp_set_sysobjid(const struct snmp_obj_id *oid)
 }
 
 /**
- * Must be called at regular 10 msec interval from a timer interrupt
- * or signal handler depending on your runtime environment.
- */
-void snmp_inc_sysuptime(void)
-{
-  sysuptime++;
-}
-
-void snmp_add_sysuptime(u32_t value)
-{
-  sysuptime+=value;
-}
-
-void snmp_get_sysuptime(u32_t *value)
-{
-  SNMP_GET_SYSUPTIME(sysuptime);
-  *value = sysuptime;
-}
-
-/**
  * Initializes sysContact pointers,
  * e.g. ptrs to non-volatile memory external to lwIP.
  *
@@ -1006,58 +931,21 @@ void snmp_set_syslocation(u8_t *ocstr, u8_t *ocstrlen, u8_t bufsize)
   }
 }
 
-
-void snmp_add_ifinoctets(struct netif *ni, u32_t value)
-{
-  ni->ifinoctets += value;
-}
-
-void snmp_inc_ifinucastpkts(struct netif *ni)
-{
-  (ni->ifinucastpkts)++;
-}
-
-void snmp_inc_ifinnucastpkts(struct netif *ni)
-{
-  (ni->ifinnucastpkts)++;
-}
-
-void snmp_inc_ifindiscards(struct netif *ni)
-{
-  (ni->ifindiscards)++;
-}
-
-void snmp_add_ifoutoctets(struct netif *ni, u32_t value)
-{
-  ni->ifoutoctets += value;
-}
-
-void snmp_inc_ifoutucastpkts(struct netif *ni)
-{
-  (ni->ifoutucastpkts)++;
-}
-
-void snmp_inc_ifoutnucastpkts(struct netif *ni)
-{
-  (ni->ifoutnucastpkts)++;
-}
-
-void snmp_inc_ifoutdiscards(struct netif *ni)
-{
-  (ni->ifoutdiscards)++;
-}
-
-void snmp_inc_iflist(void)
+void mib2_netif_added(struct netif *ni)
 {
   struct mib_list_node *if_node = NULL;
 
+  LWIP_UNUSED_ARG(ni);
+
   snmp_mib_node_insert(&iflist_root, iflist_root.count + 1, &if_node);
   /* enable getnext traversal on filled table */
   iftable.maxlength = 1;
 }
 
-void snmp_dec_iflist(void)
+void mib2_netif_removed(struct netif *ni)
 {
+  LWIP_UNUSED_ARG(ni);
+
   snmp_mib_node_delete(&iflist_root, iflist_root.tail);
   /* disable getnext traversal on empty table */
   if(iflist_root.count == 0) iftable.maxlength = 0;
@@ -1067,7 +955,7 @@ void snmp_dec_iflist(void)
  * Inserts ARP table indexes (.xIfIndex.xNetAddress)
  * into arp table index trees (both atTable and ipNetToMediaTable).
  */
-void snmp_insert_arpidx_tree(struct netif *ni, ip4_addr_t *ip)
+void mib2_add_arp_entry(struct netif *ni, ip4_addr_t *ip)
 {
   struct mib_list_rootnode *at_rn;
   struct mib_list_node *at_node;
@@ -1139,7 +1027,7 @@ void snmp_insert_arpidx_tree(struct netif *ni, ip4_addr_t *ip)
  * Removes ARP table indexes (.xIfIndex.xNetAddress)
  * from arp table index trees.
  */
-void snmp_delete_arpidx_tree(struct netif *ni, ip4_addr_t *ip)
+void mib2_remove_arp_entry(struct netif *ni, ip4_addr_t *ip)
 {
   struct mib_list_rootnode *at_rn, *next, *del_rn[5];
   struct mib_list_node *at_n, *del_n[5];
@@ -1207,96 +1095,11 @@ void snmp_delete_arpidx_tree(struct netif *ni, ip4_addr_t *ip)
   if(ipntomtree_root.count == 0) ipntomtable.maxlength = 0;
 }
 
-void snmp_inc_ipinreceives(void)
-{
-  ipinreceives++;
-}
-
-void snmp_inc_ipinhdrerrors(void)
-{
-  ipinhdrerrors++;
-}
-
-void snmp_inc_ipinaddrerrors(void)
-{
-  ipinaddrerrors++;
-}
-
-void snmp_inc_ipforwdatagrams(void)
-{
-  ipforwdatagrams++;
-}
-
-void snmp_inc_ipinunknownprotos(void)
-{
-  ipinunknownprotos++;
-}
-
-void snmp_inc_ipindiscards(void)
-{
-  ipindiscards++;
-}
-
-void snmp_inc_ipindelivers(void)
-{
-  ipindelivers++;
-}
-
-void snmp_inc_ipoutrequests(void)
-{
-  ipoutrequests++;
-}
-
-void snmp_inc_ipoutdiscards(void)
-{
-  ipoutdiscards++;
-}
-
-void snmp_inc_ipoutnoroutes(void)
-{
-  ipoutnoroutes++;
-}
-
-void snmp_inc_ipreasmreqds(void)
-{
-  ipreasmreqds++;
-}
-
-void snmp_inc_ipreasmoks(void)
-{
-  ipreasmoks++;
-}
-
-void snmp_inc_ipreasmfails(void)
-{
-  ipreasmfails++;
-}
-
-void snmp_inc_ipfragoks(void)
-{
-  ipfragoks++;
-}
-
-void snmp_inc_ipfragfails(void)
-{
-  ipfragfails++;
-}
-
-void snmp_inc_ipfragcreates(void)
-{
-  ipfragcreates++;
-}
-
-void snmp_inc_iproutingdiscards(void)
-{
-  iproutingdiscards++;
-}
-
 /**
  * Inserts ipAddrTable indexes (.ipAdEntAddr)
  * into index tree.
  */
-void snmp_insert_ipaddridx_tree(struct netif *ni)
+void mib2_add_ip4(struct netif *ni)
 {
   struct mib_list_rootnode *ipa_rn;
   struct mib_list_node *ipa_node;
@@ -1350,7 +1153,7 @@ void snmp_insert_ipaddridx_tree(struct netif *ni)
  * Removes ipAddrTable indexes (.ipAdEntAddr)
  * from index tree.
  */
-void snmp_delete_ipaddridx_tree(struct netif *ni)
+void mib2_remove_ip4(struct netif *ni)
 {
   struct mib_list_rootnode *ipa_rn, *next, *del_rn[4];
   struct mib_list_node *ipa_n, *del_n[4];
@@ -1417,7 +1220,7 @@ void snmp_delete_ipaddridx_tree(struct netif *ni)
  * @todo record sysuptime for _this_ route when it is installed
  *   (needed for ipRouteAge) in the netif.
  */
-void snmp_insert_iprteidx_tree(u8_t dflt, struct netif *ni)
+void mib2_add_route_ip4(u8_t dflt, struct netif *ni)
 {
   u8_t insert = 0;
   ip4_addr_t dst;
@@ -1494,7 +1297,7 @@ void snmp_insert_iprteidx_tree(u8_t dflt, struct netif *ni)
  * @param ni points to network interface for this rte or NULL
  *   for default route to be removed.
  */
-void snmp_delete_iprteidx_tree(u8_t dflt, struct netif *ni)
+void mib2_remove_route_ip4(u8_t dflt, struct netif *ni)
 {
   u8_t del = 0;
   ip4_addr_t dst;
@@ -1571,206 +1374,11 @@ void snmp_delete_iprteidx_tree(u8_t dflt, struct netif *ni)
 }
 
 
-void snmp_inc_icmpinmsgs(void)
-{
-  icmpinmsgs++;
-}
-
-void snmp_inc_icmpinerrors(void)
-{
-  icmpinerrors++;
-}
-
-void snmp_inc_icmpindestunreachs(void)
-{
-  icmpindestunreachs++;
-}
-
-void snmp_inc_icmpintimeexcds(void)
-{
-  icmpintimeexcds++;
-}
-
-void snmp_inc_icmpinparmprobs(void)
-{
-  icmpinparmprobs++;
-}
-
-void snmp_inc_icmpinsrcquenchs(void)
-{
-  icmpinsrcquenchs++;
-}
-
-void snmp_inc_icmpinredirects(void)
-{
-  icmpinredirects++;
-}
-
-void snmp_inc_icmpinechos(void)
-{
-  icmpinechos++;
-}
-
-void snmp_inc_icmpinechoreps(void)
-{
-  icmpinechoreps++;
-}
-
-void snmp_inc_icmpintimestamps(void)
-{
-  icmpintimestamps++;
-}
-
-void snmp_inc_icmpintimestampreps(void)
-{
-  icmpintimestampreps++;
-}
-
-void snmp_inc_icmpinaddrmasks(void)
-{
-  icmpinaddrmasks++;
-}
-
-void snmp_inc_icmpinaddrmaskreps(void)
-{
-  icmpinaddrmaskreps++;
-}
-
-void snmp_inc_icmpoutmsgs(void)
-{
-  icmpoutmsgs++;
-}
-
-void snmp_inc_icmpouterrors(void)
-{
-  icmpouterrors++;
-}
-
-void snmp_inc_icmpoutdestunreachs(void)
-{
-  icmpoutdestunreachs++;
-}
-
-void snmp_inc_icmpouttimeexcds(void)
-{
-  icmpouttimeexcds++;
-}
-
-void snmp_inc_icmpoutparmprobs(void)
-{
-  icmpoutparmprobs++;
-}
-
-void snmp_inc_icmpoutsrcquenchs(void)
-{
-  icmpoutsrcquenchs++;
-}
-
-void snmp_inc_icmpoutredirects(void)
-{
-  icmpoutredirects++;
-}
-
-void snmp_inc_icmpoutechos(void)
-{
-  icmpoutechos++;
-}
-
-void snmp_inc_icmpoutechoreps(void)
-{
-  icmpoutechoreps++;
-}
-
-void snmp_inc_icmpouttimestamps(void)
-{
-  icmpouttimestamps++;
-}
-
-void snmp_inc_icmpouttimestampreps(void)
-{
-  icmpouttimestampreps++;
-}
-
-void snmp_inc_icmpoutaddrmasks(void)
-{
-  icmpoutaddrmasks++;
-}
-
-void snmp_inc_icmpoutaddrmaskreps(void)
-{
-  icmpoutaddrmaskreps++;
-}
-
-void snmp_inc_tcpactiveopens(void)
-{
-  tcpactiveopens++;
-}
-
-void snmp_inc_tcppassiveopens(void)
-{
-  tcppassiveopens++;
-}
-
-void snmp_inc_tcpattemptfails(void)
-{
-  tcpattemptfails++;
-}
-
-void snmp_inc_tcpestabresets(void)
-{
-  tcpestabresets++;
-}
-
-void snmp_inc_tcpinsegs(void)
-{
-  tcpinsegs++;
-}
-
-void snmp_inc_tcpoutsegs(void)
-{
-  tcpoutsegs++;
-}
-
-void snmp_inc_tcpretranssegs(void)
-{
-  tcpretranssegs++;
-}
-
-void snmp_inc_tcpinerrs(void)
-{
-  tcpinerrs++;
-}
-
-void snmp_inc_tcpoutrsts(void)
-{
-  tcpoutrsts++;
-}
-
-void snmp_inc_udpindatagrams(void)
-{
-  udpindatagrams++;
-}
-
-void snmp_inc_udpnoports(void)
-{
-  udpnoports++;
-}
-
-void snmp_inc_udpinerrors(void)
-{
-  udpinerrors++;
-}
-
-void snmp_inc_udpoutdatagrams(void)
-{
-  udpoutdatagrams++;
-}
-
 /**
  * Inserts udpTable indexes (.udpLocalAddress.udpLocalPort)
  * into index tree.
  */
-void snmp_insert_udpidx_tree(struct udp_pcb *pcb)
+void mib2_udp_bind(struct udp_pcb *pcb)
 {
   struct mib_list_rootnode *udp_rn;
   struct mib_list_node *udp_node;
@@ -1826,7 +1434,7 @@ void snmp_insert_udpidx_tree(struct udp_pcb *pcb)
  * Removes udpTable indexes (.udpLocalAddress.udpLocalPort)
  * from index tree.
  */
-void snmp_delete_udpidx_tree(struct udp_pcb *pcb)
+void mib2_udp_unbind(struct udp_pcb *pcb)
 {
   struct udp_pcb *npcb;
   struct mib_list_rootnode *udp_rn, *next, *del_rn[5];
@@ -1907,142 +1515,142 @@ void snmp_delete_udpidx_tree(struct udp_pcb *pcb)
 }
 
 
-void snmp_inc_snmpinpkts(void)
+void mib2_inc_snmpinpkts(void)
 {
   snmpinpkts++;
 }
 
-void snmp_inc_snmpoutpkts(void)
+void mib2_inc_snmpoutpkts(void)
 {
   snmpoutpkts++;
 }
 
-void snmp_inc_snmpinbadversions(void)
+void mib2_inc_snmpinbadversions(void)
 {
   snmpinbadversions++;
 }
 
-void snmp_inc_snmpinbadcommunitynames(void)
+void mib2_inc_snmpinbadcommunitynames(void)
 {
   snmpinbadcommunitynames++;
 }
 
-void snmp_inc_snmpinbadcommunityuses(void)
+void mib2_inc_snmpinbadcommunityuses(void)
 {
   snmpinbadcommunityuses++;
 }
 
-void snmp_inc_snmpinasnparseerrs(void)
+void mib2_inc_snmpinasnparseerrs(void)
 {
   snmpinasnparseerrs++;
 }
 
-void snmp_inc_snmpintoobigs(void)
+void mib2_inc_snmpintoobigs(void)
 {
   snmpintoobigs++;
 }
 
-void snmp_inc_snmpinnosuchnames(void)
+void mib2_inc_snmpinnosuchnames(void)
 {
   snmpinnosuchnames++;
 }
 
-void snmp_inc_snmpinbadvalues(void)
+void mib2_inc_snmpinbadvalues(void)
 {
   snmpinbadvalues++;
 }
 
-void snmp_inc_snmpinreadonlys(void)
+void mib2_inc_snmpinreadonlys(void)
 {
   snmpinreadonlys++;
 }
 
-void snmp_inc_snmpingenerrs(void)
+void mib2_inc_snmpingenerrs(void)
 {
   snmpingenerrs++;
 }
 
-void snmp_add_snmpintotalreqvars(u8_t value)
+void mib2_add_snmpintotalreqvars(u8_t value)
 {
   snmpintotalreqvars += value;
 }
 
-void snmp_add_snmpintotalsetvars(u8_t value)
+void mib2_add_snmpintotalsetvars(u8_t value)
 {
   snmpintotalsetvars += value;
 }
 
-void snmp_inc_snmpingetrequests(void)
+void mib2_inc_snmpingetrequests(void)
 {
   snmpingetrequests++;
 }
 
-void snmp_inc_snmpingetnexts(void)
+void mib2_inc_snmpingetnexts(void)
 {
   snmpingetnexts++;
 }
 
-void snmp_inc_snmpinsetrequests(void)
+void mib2_inc_snmpinsetrequests(void)
 {
   snmpinsetrequests++;
 }
 
-void snmp_inc_snmpingetresponses(void)
+void mib2_inc_snmpingetresponses(void)
 {
   snmpingetresponses++;
 }
 
-void snmp_inc_snmpintraps(void)
+void mib2_inc_snmpintraps(void)
 {
   snmpintraps++;
 }
 
-void snmp_inc_snmpouttoobigs(void)
+void mib2_inc_snmpouttoobigs(void)
 {
   snmpouttoobigs++;
 }
 
-void snmp_inc_snmpoutnosuchnames(void)
+void mib2_inc_snmpoutnosuchnames(void)
 {
   snmpoutnosuchnames++;
 }
 
-void snmp_inc_snmpoutbadvalues(void)
+void mib2_inc_snmpoutbadvalues(void)
 {
   snmpoutbadvalues++;
 }
 
-void snmp_inc_snmpoutgenerrs(void)
+void mib2_inc_snmpoutgenerrs(void)
 {
   snmpoutgenerrs++;
 }
 
-void snmp_inc_snmpoutgetrequests(void)
+void mib2_inc_snmpoutgetrequests(void)
 {
   snmpoutgetrequests++;
 }
 
-void snmp_inc_snmpoutgetnexts(void)
+void mib2_inc_snmpoutgetnexts(void)
 {
   snmpoutgetnexts++;
 }
 
-void snmp_inc_snmpoutsetrequests(void)
+void mib2_inc_snmpoutsetrequests(void)
 {
   snmpoutsetrequests++;
 }
 
-void snmp_inc_snmpoutgetresponses(void)
+void mib2_inc_snmpoutgetresponses(void)
 {
   snmpoutgetresponses++;
 }
 
-void snmp_inc_snmpouttraps(void)
+void mib2_inc_snmpouttraps(void)
 {
   snmpouttraps++;
 }
 
-void snmp_get_snmpgrpid_ptr(const struct snmp_obj_id **oid)
+void mib2_get_snmpgrpid_ptr(const struct snmp_obj_id **oid)
 {
   *oid = &snmpgrp_id;
 }
@@ -2055,7 +1663,7 @@ void snmp_set_snmpenableauthentraps(u8_t *value)
   }
 }
 
-void snmp_get_snmpenableauthentraps(u8_t *value)
+void mib2_get_snmpenableauthentraps(u8_t *value)
 {
   *value = *snmpenableauthentraps_ptr;
 }
@@ -2199,9 +1807,7 @@ system_get_value(struct obj_def *od, u16_t len, void *value)
       MEMCPY(value, sysobjid_ptr->id, len);
       break;
     case 3: /* sysUpTime */
-      {
-        snmp_get_sysuptime((u32_t*)value);
-      }
+      MIB2_COPY_SYSUPTIME_TO((u32_t*)value);
       break;
     case 4: /* sysContact */
       MEMCPY(value, syscontact_ptr, len);
@@ -2864,61 +2470,61 @@ ip_get_value(struct obj_def *od, u16_t len, void *value)
     case 3: /* ipInReceives */
       {
         u32_t *uint_ptr = (u32_t*)value;
-        *uint_ptr = ipinreceives;
+        *uint_ptr = STATS_GET(mib2.ipinreceives);
       }
       break;
     case 4: /* ipInHdrErrors */
       {
         u32_t *uint_ptr = (u32_t*)value;
-        *uint_ptr = ipinhdrerrors;
+        *uint_ptr = STATS_GET(mib2.ipinhdrerrors);
       }
       break;
     case 5: /* ipInAddrErrors */
       {
         u32_t *uint_ptr = (u32_t*)value;
-        *uint_ptr = ipinaddrerrors;
+        *uint_ptr = STATS_GET(mib2.ipinaddrerrors);
       }
       break;
     case 6: /* ipForwDatagrams */
       {
         u32_t *uint_ptr = (u32_t*)value;
-        *uint_ptr = ipforwdatagrams;
+        *uint_ptr = STATS_GET(mib2.ipforwdatagrams);
       }
       break;
     case 7: /* ipInUnknownProtos */
       {
         u32_t *uint_ptr = (u32_t*)value;
-        *uint_ptr = ipinunknownprotos;
+        *uint_ptr = STATS_GET(mib2.ipinunknownprotos);
       }
       break;
     case 8: /* ipInDiscards */
       {
         u32_t *uint_ptr = (u32_t*)value;
-        *uint_ptr = ipindiscards;
+        *uint_ptr = STATS_GET(mib2.ipindiscards);
       }
       break;
     case 9: /* ipInDelivers */
       {
         u32_t *uint_ptr = (u32_t*)value;
-        *uint_ptr = ipindelivers;
+        *uint_ptr = STATS_GET(mib2.ipindelivers);
       }
       break;
     case 10: /* ipOutRequests */
       {
         u32_t *uint_ptr = (u32_t*)value;
-        *uint_ptr = ipoutrequests;
+        *uint_ptr = STATS_GET(mib2.ipoutrequests);
       }
       break;
     case 11: /* ipOutDiscards */
       {
         u32_t *uint_ptr = (u32_t*)value;
-        *uint_ptr = ipoutdiscards;
+        *uint_ptr = STATS_GET(mib2.ipoutdiscards);
       }
       break;
     case 12: /* ipOutNoRoutes */
       {
         u32_t *uint_ptr = (u32_t*)value;
-        *uint_ptr = ipoutnoroutes;
+        *uint_ptr = STATS_GET(mib2.ipoutnoroutes);
       }
       break;
     case 13: /* ipReasmTimeout */
@@ -2934,44 +2540,44 @@ ip_get_value(struct obj_def *od, u16_t len, void *value)
     case 14: /* ipReasmReqds */
       {
         u32_t *uint_ptr = (u32_t*)value;
-        *uint_ptr = ipreasmreqds;
+        *uint_ptr = STATS_GET(mib2.ipreasmreqds);
       }
       break;
     case 15: /* ipReasmOKs */
       {
         u32_t *uint_ptr = (u32_t*)value;
-        *uint_ptr = ipreasmoks;
+        *uint_ptr = STATS_GET(mib2.ipreasmoks);
       }
       break;
     case 16: /* ipReasmFails */
       {
         u32_t *uint_ptr = (u32_t*)value;
-        *uint_ptr = ipreasmfails;
+        *uint_ptr = STATS_GET(mib2.ipreasmfails);
       }
       break;
     case 17: /* ipFragOKs */
       {
         u32_t *uint_ptr = (u32_t*)value;
-        *uint_ptr = ipfragoks;
+        *uint_ptr = STATS_GET(mib2.ipfragoks);
       }
       break;
     case 18: /* ipFragFails */
       {
         u32_t *uint_ptr = (u32_t*)value;
-        *uint_ptr = ipfragfails;
+        *uint_ptr = STATS_GET(mib2.ipfragfails);
       }
       break;
     case 19: /* ipFragCreates */
       {
         u32_t *uint_ptr = (u32_t*)value;
-        *uint_ptr = ipfragcreates;
+        *uint_ptr = STATS_GET(mib2.ipfragcreates);
       }
       break;
     case 23: /* ipRoutingDiscards */
       /** @todo can lwIP discard routes at all?? hardwire this to 0?? */
       {
         u32_t *uint_ptr = (u32_t*)value;
-        *uint_ptr = iproutingdiscards;
+        *uint_ptr = STATS_GET(mib2.iproutingdiscards);
       }
       break;
     default:
@@ -3516,82 +3122,82 @@ icmp_get_value(struct obj_def *od, u16_t len, void *value)
   switch (id)
   {
     case 1: /* icmpInMsgs */
-      *uint_ptr = icmpinmsgs;
+      *uint_ptr = STATS_GET(mib2.icmpinmsgs);
       break;
     case 2: /* icmpInErrors */
-      *uint_ptr = icmpinerrors;
+      *uint_ptr = STATS_GET(mib2.icmpinerrors);
       break;
     case 3: /* icmpInDestUnreachs */
-      *uint_ptr = icmpindestunreachs;
+      *uint_ptr = STATS_GET(mib2.icmpindestunreachs);
       break;
     case 4: /* icmpInTimeExcds */
-      *uint_ptr = icmpintimeexcds;
+      *uint_ptr = STATS_GET(mib2.icmpintimeexcds);
       break;
     case 5: /* icmpInParmProbs */
-      *uint_ptr = icmpinparmprobs;
+      *uint_ptr = STATS_GET(mib2.icmpinparmprobs);
       break;
     case 6: /* icmpInSrcQuenchs */
-      *uint_ptr = icmpinsrcquenchs;
+      *uint_ptr = STATS_GET(mib2.icmpinsrcquenchs);
       break;
     case 7: /* icmpInRedirects */
-      *uint_ptr = icmpinredirects;
+      *uint_ptr = STATS_GET(mib2.icmpinredirects);
       break;
     case 8: /* icmpInEchos */
-      *uint_ptr = icmpinechos;
+      *uint_ptr = STATS_GET(mib2.icmpinechos);
       break;
     case 9: /* icmpInEchoReps */
-      *uint_ptr = icmpinechoreps;
+      *uint_ptr = STATS_GET(mib2.icmpinechoreps);
       break;
     case 10: /* icmpInTimestamps */
-      *uint_ptr = icmpintimestamps;
+      *uint_ptr = STATS_GET(mib2.icmpintimestamps);
       break;
     case 11: /* icmpInTimestampReps */
-      *uint_ptr = icmpintimestampreps;
+      *uint_ptr = STATS_GET(mib2.icmpintimestampreps);
       break;
     case 12: /* icmpInAddrMasks */
-      *uint_ptr = icmpinaddrmasks;
+      *uint_ptr = STATS_GET(mib2.icmpinaddrmasks);
       break;
     case 13: /* icmpInAddrMaskReps */
-      *uint_ptr = icmpinaddrmaskreps;
+      *uint_ptr = STATS_GET(mib2.icmpinaddrmaskreps);
       break;
     case 14: /* icmpOutMsgs */
-      *uint_ptr = icmpoutmsgs;
+      *uint_ptr = STATS_GET(mib2.icmpoutmsgs);
       break;
     case 15: /* icmpOutErrors */
-      *uint_ptr = icmpouterrors;
+      *uint_ptr = STATS_GET(mib2.icmpouterrors);
       break;
     case 16: /* icmpOutDestUnreachs */
-      *uint_ptr = icmpoutdestunreachs;
+      *uint_ptr = STATS_GET(mib2.icmpoutdestunreachs);
       break;
     case 17: /* icmpOutTimeExcds */
-      *uint_ptr = icmpouttimeexcds;
+      *uint_ptr = STATS_GET(mib2.icmpouttimeexcds);
       break;
     case 18: /* icmpOutParmProbs */
-      *uint_ptr = icmpoutparmprobs;
+      *uint_ptr = STATS_GET(mib2.icmpoutparmprobs);
       break;
     case 19: /* icmpOutSrcQuenchs */
-      *uint_ptr = icmpoutsrcquenchs;
+      *uint_ptr = STATS_GET(mib2.icmpoutsrcquenchs);
       break;
     case 20: /* icmpOutRedirects */
-      *uint_ptr = icmpoutredirects;
+      *uint_ptr = STATS_GET(mib2.icmpoutredirects);
       break;
     case 21: /* icmpOutEchos */
-      *uint_ptr = icmpoutechos;
+      *uint_ptr = STATS_GET(mib2.icmpoutechos);
       break;
     case 22: /* icmpOutEchoReps */
-      *uint_ptr = icmpoutechoreps;
+      *uint_ptr = STATS_GET(mib2.icmpoutechoreps);
       break;
     case 23: /* icmpOutTimestamps */
-      *uint_ptr = icmpouttimestamps;
+      *uint_ptr = STATS_GET(mib2.icmpouttimestamps);
       break;
     case 24: /* icmpOutTimestampReps */
-      *uint_ptr = icmpouttimestampreps;
+      *uint_ptr = STATS_GET(mib2.icmpouttimestampreps);
       break;
     case 25: /* icmpOutAddrMasks */
-      *uint_ptr = icmpoutaddrmasks;
+      *uint_ptr = STATS_GET(mib2.icmpoutaddrmasks);
       break;
     case 26: /* icmpOutAddrMaskReps */
-      *uint_ptr = icmpoutaddrmaskreps;
+      *uint_ptr = STATS_GET(mib2.icmpoutaddrmaskreps);
       break;
     default:
       LWIP_DEBUGF(SNMP_MIB_DEBUG,("icmp_get_value(): unknown id: %d\n", id));
@@ -3691,16 +3297,16 @@ tcp_get_value(struct obj_def *od, u16_t len, void *value)
       *sint_ptr = MEMP_NUM_TCP_PCB;
       break;
     case 5: /* tcpActiveOpens */
-      *uint_ptr = tcpactiveopens;
+      *uint_ptr = STATS_GET(mib2.tcpactiveopens);
       break;
     case 6: /* tcpPassiveOpens */
-      *uint_ptr = tcppassiveopens;
+      *uint_ptr = STATS_GET(mib2.tcppassiveopens);
       break;
     case 7: /* tcpAttemptFails */
-      *uint_ptr = tcpattemptfails;
+      *uint_ptr = STATS_GET(mib2.tcpattemptfails);
       break;
     case 8: /* tcpEstabResets */
-      *uint_ptr = tcpestabresets;
+      *uint_ptr = STATS_GET(mib2.tcpestabresets);
       break;
     case 9: /* tcpCurrEstab */
       {
@@ -3719,19 +3325,19 @@ tcp_get_value(struct obj_def *od, u16_t len, void *value)
       }
       break;
     case 10: /* tcpInSegs */
-      *uint_ptr = tcpinsegs;
+      *uint_ptr = STATS_GET(mib2.tcpinsegs);
       break;
     case 11: /* tcpOutSegs */
-      *uint_ptr = tcpoutsegs;
+      *uint_ptr = STATS_GET(mib2.tcpoutsegs);
       break;
     case 12: /* tcpRetransSegs */
-      *uint_ptr = tcpretranssegs;
+      *uint_ptr = STATS_GET(mib2.tcpretranssegs);
       break;
     case 14: /* tcpInErrs */
-      *uint_ptr = tcpinerrs;
+      *uint_ptr = STATS_GET(mib2.tcpinerrs);
       break;
     case 15: /* tcpOutRsts */
-      *uint_ptr = tcpoutrsts;
+      *uint_ptr = STATS_GET(mib2.tcpoutrsts);
       break;
     default:
       LWIP_DEBUGF(SNMP_MIB_DEBUG,("tcp_get_value(): unknown id: %d\n", id));
@@ -3845,16 +3451,16 @@ udp_get_value(struct obj_def *od, u16_t len, void *value)
   switch (id)
   {
     case 1: /* udpInDatagrams */
-      *uint_ptr = udpindatagrams;
+      *uint_ptr = STATS_GET(mib2.udpindatagrams);
       break;
     case 2: /* udpNoPorts */
-      *uint_ptr = udpnoports;
+      *uint_ptr = STATS_GET(mib2.udpnoports);
       break;
     case 3: /* udpInErrors */
-      *uint_ptr = udpinerrors;
+      *uint_ptr = STATS_GET(mib2.udpinerrors);
       break;
     case 4: /* udpOutDatagrams */
-      *uint_ptr = udpoutdatagrams;
+      *uint_ptr = STATS_GET(mib2.udpoutdatagrams);
       break;
     default:
       LWIP_DEBUGF(SNMP_MIB_DEBUG,("udp_get_value(): unknown id: %d\n", id));
diff --git a/src/core/snmp/msg_in.c b/src/core/snmp/msg_in.c
index e4b7ad8..61c9cd2 100644
--- a/src/core/snmp/msg_in.c
+++ b/src/core/snmp/msg_in.c
@@ -925,7 +925,7 @@ snmp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *addr,
   }
 
   /* accepting request */
-  snmp_inc_snmpinpkts();
+  mib2_inc_snmpinpkts();
   /* record used 'protocol control block' */
   msg_ps->pcb = pcb;
   /* source address (network order) */
@@ -1006,7 +1006,7 @@ snmp_pdu_header_check(struct pbuf *p, u16_t ofs, u16_t pdu_len, u16_t *ofs_ret,
       (pdu_len != (1 + len_octets + len)) ||
       (type != (SNMP_ASN1_UNIV | SNMP_ASN1_CONSTR | SNMP_ASN1_SEQ)))
   {
-    snmp_inc_snmpinasnparseerrs();
+    mib2_inc_snmpinasnparseerrs();
     return ERR_ARG;
   }
   ofs += (1 + len_octets);
@@ -1015,20 +1015,20 @@ snmp_pdu_header_check(struct pbuf *p, u16_t ofs, u16_t pdu_len, u16_t *ofs_ret,
   if ((derr != ERR_OK) || (type != (SNMP_ASN1_UNIV | SNMP_ASN1_PRIMIT | SNMP_ASN1_INTEG)))
   {
     /* can't decode or no integer (version) */
-    snmp_inc_snmpinasnparseerrs();
+    mib2_inc_snmpinasnparseerrs();
     return ERR_ARG;
   }
   derr = snmp_asn1_dec_s32t(p, ofs + 1 + len_octets, len, &version);
   if (derr != ERR_OK)
   {
     /* can't decode */
-    snmp_inc_snmpinasnparseerrs();
+    mib2_inc_snmpinasnparseerrs();
     return ERR_ARG;
   }
   if (version != 0)
   {
     /* not version 1 */
-    snmp_inc_snmpinbadversions();
+    mib2_inc_snmpinbadversions();
     return ERR_ARG;
   }
   m_stat->version = (u8_t)version;
@@ -1038,13 +1038,13 @@ snmp_pdu_header_check(struct pbuf *p, u16_t ofs, u16_t pdu_len, u16_t *ofs_ret,
   if ((derr != ERR_OK) || (type != (SNMP_ASN1_UNIV | SNMP_ASN1_PRIMIT | SNMP_ASN1_OC_STR)))
   {
     /* can't decode or no octet string (community) */
-    snmp_inc_snmpinasnparseerrs();
+    mib2_inc_snmpinasnparseerrs();
     return ERR_ARG;
   }
   derr = snmp_asn1_dec_raw(p, ofs + 1 + len_octets, len, SNMP_COMMUNITY_STR_LEN, m_stat->community);
   if (derr != ERR_OK)
   {
-    snmp_inc_snmpinasnparseerrs();
+    mib2_inc_snmpinasnparseerrs();
     return ERR_ARG;
   }
   /* add zero terminator */
@@ -1060,7 +1060,7 @@ snmp_pdu_header_check(struct pbuf *p, u16_t ofs, u16_t pdu_len, u16_t *ofs_ret,
     if (type == (SNMP_ASN1_CONTXT | SNMP_ASN1_CONSTR | SNMP_ASN1_PDU_SET_REQ))
     {
       /* wrong community for SetRequest PDU */
-      snmp_inc_snmpinbadcommunitynames();
+      mib2_inc_snmpinbadcommunitynames();
       snmp_authfail_trap();
       return ERR_ARG;
     }
@@ -1069,7 +1069,7 @@ snmp_pdu_header_check(struct pbuf *p, u16_t ofs, u16_t pdu_len, u16_t *ofs_ret,
 #endif /* SNMP_COMMUNITY_EXT */
     if (strncmp(snmp_community, (const char*)m_stat->community, SNMP_COMMUNITY_STR_LEN) != 0)
     {
-      snmp_inc_snmpinbadcommunitynames();
+      mib2_inc_snmpinbadcommunitynames();
       snmp_authfail_trap();
       return ERR_ARG;
     }
@@ -1077,38 +1077,38 @@ snmp_pdu_header_check(struct pbuf *p, u16_t ofs, u16_t pdu_len, u16_t *ofs_ret,
   derr = snmp_asn1_dec_length(p, ofs+1, &len_octets, &len);
   if (derr != ERR_OK)
   {
-    snmp_inc_snmpinasnparseerrs();
+    mib2_inc_snmpinasnparseerrs();
     return ERR_ARG;
   }
   switch(type)
   {
     case (SNMP_ASN1_CONTXT | SNMP_ASN1_CONSTR | SNMP_ASN1_PDU_GET_REQ):
       /* GetRequest PDU */
-      snmp_inc_snmpingetrequests();
+      mib2_inc_snmpingetrequests();
       derr = ERR_OK;
       break;
     case (SNMP_ASN1_CONTXT | SNMP_ASN1_CONSTR | SNMP_ASN1_PDU_GET_NEXT_REQ):
       /* GetNextRequest PDU */
-      snmp_inc_snmpingetnexts();
+      mib2_inc_snmpingetnexts();
       derr = ERR_OK;
       break;
     case (SNMP_ASN1_CONTXT | SNMP_ASN1_CONSTR | SNMP_ASN1_PDU_GET_RESP):
       /* GetResponse PDU */
-      snmp_inc_snmpingetresponses();
+      mib2_inc_snmpingetresponses();
       derr = ERR_ARG;
       break;
     case (SNMP_ASN1_CONTXT | SNMP_ASN1_CONSTR | SNMP_ASN1_PDU_SET_REQ):
       /* SetRequest PDU */
-      snmp_inc_snmpinsetrequests();
+      mib2_inc_snmpinsetrequests();
       derr = ERR_OK;
       break;
     case (SNMP_ASN1_CONTXT | SNMP_ASN1_CONSTR | SNMP_ASN1_PDU_TRAP):
       /* Trap PDU */
-      snmp_inc_snmpintraps();
+      mib2_inc_snmpintraps();
       derr = ERR_ARG;
       break;
     default:
-      snmp_inc_snmpinasnparseerrs();
+      mib2_inc_snmpinasnparseerrs();
       derr = ERR_ARG;
       break;
   }
@@ -1122,7 +1122,7 @@ snmp_pdu_header_check(struct pbuf *p, u16_t ofs, u16_t pdu_len, u16_t *ofs_ret,
   if (len != (pdu_len - (ofs - ofs_base)))
   {
     /* decoded PDU length does not equal actual payload length */
-    snmp_inc_snmpinasnparseerrs();
+    mib2_inc_snmpinasnparseerrs();
     return ERR_ARG;
   }
   snmp_asn1_dec_type(p, ofs, &type);
@@ -1130,14 +1130,14 @@ snmp_pdu_header_check(struct pbuf *p, u16_t ofs, u16_t pdu_len, u16_t *ofs_ret,
   if ((derr != ERR_OK) || (type != (SNMP_ASN1_UNIV | SNMP_ASN1_PRIMIT | SNMP_ASN1_INTEG)))
   {
     /* can't decode or no integer (request ID) */
-    snmp_inc_snmpinasnparseerrs();
+    mib2_inc_snmpinasnparseerrs();
     return ERR_ARG;
   }
   derr = snmp_asn1_dec_s32t(p, ofs + 1 + len_octets, len, &m_stat->rid);
   if (derr != ERR_OK)
   {
     /* can't decode */
-    snmp_inc_snmpinasnparseerrs();
+    mib2_inc_snmpinasnparseerrs();
     return ERR_ARG;
   }
   ofs += (1 + len_octets + len);
@@ -1146,7 +1146,7 @@ snmp_pdu_header_check(struct pbuf *p, u16_t ofs, u16_t pdu_len, u16_t *ofs_ret,
   if ((derr != ERR_OK) || (type != (SNMP_ASN1_UNIV | SNMP_ASN1_PRIMIT | SNMP_ASN1_INTEG)))
   {
     /* can't decode or no integer (error-status) */
-    snmp_inc_snmpinasnparseerrs();
+    mib2_inc_snmpinasnparseerrs();
     return ERR_ARG;
   }
   /* must be noError (0) for incoming requests.
@@ -1155,7 +1155,7 @@ snmp_pdu_header_check(struct pbuf *p, u16_t ofs, u16_t pdu_len, u16_t *ofs_ret,
   if (derr != ERR_OK)
   {
     /* can't decode */
-    snmp_inc_snmpinasnparseerrs();
+    mib2_inc_snmpinasnparseerrs();
     return ERR_ARG;
   }
   switch (m_stat->error_status)
@@ -1164,19 +1164,19 @@ snmp_pdu_header_check(struct pbuf *p, u16_t ofs, u16_t pdu_len, u16_t *ofs_ret,
       /* nothing to do */
       break;
     case SNMP_ES_TOOBIG:
-      snmp_inc_snmpintoobigs();
+      mib2_inc_snmpintoobigs();
       break;
     case SNMP_ES_NOSUCHNAME:
-      snmp_inc_snmpinnosuchnames();
+      mib2_inc_snmpinnosuchnames();
       break;
     case SNMP_ES_BADVALUE:
-      snmp_inc_snmpinbadvalues();
+      mib2_inc_snmpinbadvalues();
       break;
     case SNMP_ES_READONLY:
-      snmp_inc_snmpinreadonlys();
+      mib2_inc_snmpinreadonlys();
       break;
     case SNMP_ES_GENERROR:
-      snmp_inc_snmpingenerrs();
+      mib2_inc_snmpingenerrs();
       break;
     default:
       LWIP_DEBUGF(SNMP_MSG_DEBUG, ("snmp_pdu_header_check(): unknown error_status: %d\n", (int)m_stat->error_status));
@@ -1188,7 +1188,7 @@ snmp_pdu_header_check(struct pbuf *p, u16_t ofs, u16_t pdu_len, u16_t *ofs_ret,
   if ((derr != ERR_OK) || (type != (SNMP_ASN1_UNIV | SNMP_ASN1_PRIMIT | SNMP_ASN1_INTEG)))
   {
     /* can't decode or no integer (error-index) */
-    snmp_inc_snmpinasnparseerrs();
+    mib2_inc_snmpinasnparseerrs();
     return ERR_ARG;
   }
   /* must be 0 for incoming requests.
@@ -1197,7 +1197,7 @@ snmp_pdu_header_check(struct pbuf *p, u16_t ofs, u16_t pdu_len, u16_t *ofs_ret,
   if (derr != ERR_OK)
   {
     /* can't decode */
-    snmp_inc_snmpinasnparseerrs();
+    mib2_inc_snmpinasnparseerrs();
     return ERR_ARG;
   }
   ofs += (1 + len_octets + len);
@@ -1219,7 +1219,7 @@ snmp_pdu_dec_varbindlist(struct pbuf *p, u16_t ofs, u16_t *ofs_ret, struct snmp_
   if ((derr != ERR_OK) ||
       (type != (SNMP_ASN1_UNIV | SNMP_ASN1_CONSTR | SNMP_ASN1_SEQ)))
   {
-    snmp_inc_snmpinasnparseerrs();
+    mib2_inc_snmpinasnparseerrs();
     return ERR_ARG;
   }
   ofs += (1 + len_octets);
@@ -1240,7 +1240,7 @@ snmp_pdu_dec_varbindlist(struct pbuf *p, u16_t ofs, u16_t *ofs_ret, struct snmp_
         (type != (SNMP_ASN1_UNIV | SNMP_ASN1_CONSTR | SNMP_ASN1_SEQ)) ||
         (len == 0) || (len > vb_len))
     {
-      snmp_inc_snmpinasnparseerrs();
+      mib2_inc_snmpinasnparseerrs();
       /* free varbinds (if available) */
       snmp_varbind_list_free(&m_stat->invb);
       return ERR_ARG;
@@ -1253,7 +1253,7 @@ snmp_pdu_dec_varbindlist(struct pbuf *p, u16_t ofs, u16_t *ofs_ret, struct snmp_
     if ((derr != ERR_OK) || (type != (SNMP_ASN1_UNIV | SNMP_ASN1_PRIMIT | SNMP_ASN1_OBJ_ID)))
     {
       /* can't decode object name length */
-      snmp_inc_snmpinasnparseerrs();
+      mib2_inc_snmpinasnparseerrs();
       /* free varbinds (if available) */
       snmp_varbind_list_free(&m_stat->invb);
       return ERR_ARG;
@@ -1262,7 +1262,7 @@ snmp_pdu_dec_varbindlist(struct pbuf *p, u16_t ofs, u16_t *ofs_ret, struct snmp_
     if (derr != ERR_OK)
     {
       /* can't decode object name */
-      snmp_inc_snmpinasnparseerrs();
+      mib2_inc_snmpinasnparseerrs();
       /* free varbinds (if available) */
       snmp_varbind_list_free(&m_stat->invb);
       return ERR_ARG;
@@ -1275,7 +1275,7 @@ snmp_pdu_dec_varbindlist(struct pbuf *p, u16_t ofs, u16_t *ofs_ret, struct snmp_
     if (derr != ERR_OK)
     {
       /* can't decode object value length */
-      snmp_inc_snmpinasnparseerrs();
+      mib2_inc_snmpinasnparseerrs();
       /* free varbinds (if available) */
       snmp_varbind_list_free(&m_stat->invb);
       return ERR_ARG;
@@ -1388,7 +1388,7 @@ snmp_pdu_dec_varbindlist(struct pbuf *p, u16_t ofs, u16_t *ofs_ret, struct snmp_
     }
     if (derr != ERR_OK)
     {
-      snmp_inc_snmpinasnparseerrs();
+      mib2_inc_snmpinasnparseerrs();
       /* free varbinds (if available) */
       snmp_varbind_list_free(&m_stat->invb);
       return ERR_ARG;
@@ -1399,11 +1399,11 @@ snmp_pdu_dec_varbindlist(struct pbuf *p, u16_t ofs, u16_t *ofs_ret, struct snmp_
 
   if (m_stat->rt == SNMP_ASN1_PDU_SET_REQ)
   {
-    snmp_add_snmpintotalsetvars(m_stat->invb.count);
+    mib2_add_snmpintotalsetvars(m_stat->invb.count);
   }
   else
   {
-    snmp_add_snmpintotalreqvars(m_stat->invb.count);
+    mib2_add_snmpintotalreqvars(m_stat->invb.count);
   }
 
   *ofs_ret = ofs;
diff --git a/src/core/snmp/msg_out.c b/src/core/snmp/msg_out.c
index 2d5096c..134690b 100644
--- a/src/core/snmp/msg_out.c
+++ b/src/core/snmp/msg_out.c
@@ -49,8 +49,10 @@
 #include "lwip/udp.h"
 #include "lwip/netif.h"
 #include "lwip/snmp.h"
+#include "lwip/snmp_mib2.h"
 #include "lwip/snmp_asn1.h"
 #include "lwip/snmp_msg.h"
+#include "lwip/sys.h"
 
 #include <string.h>
 
@@ -159,23 +161,23 @@ snmp_send_response(struct snmp_msg_pstat *m_stat)
         /* nothing to do */
         break;
       case SNMP_ES_TOOBIG:
-        snmp_inc_snmpouttoobigs();
+        mib2_inc_snmpouttoobigs();
         break;
       case SNMP_ES_NOSUCHNAME:
-        snmp_inc_snmpoutnosuchnames();
+        mib2_inc_snmpoutnosuchnames();
         break;
       case SNMP_ES_BADVALUE:
-        snmp_inc_snmpoutbadvalues();
+        mib2_inc_snmpoutbadvalues();
         break;
       case SNMP_ES_GENERROR:
-        snmp_inc_snmpoutgenerrs();
+        mib2_inc_snmpoutgenerrs();
         break;
       default:
         LWIP_DEBUGF(SNMP_MSG_DEBUG, ("snmp_send_response(): unknown error_status: %d\n", (int)m_stat->error_status));
         break;
     }
-    snmp_inc_snmpoutgetresponses();
-    snmp_inc_snmpoutpkts();
+    mib2_inc_snmpoutgetresponses();
+    mib2_inc_snmpoutpkts();
 
     /** @todo do we need separate rx and tx pcbs for threaded case? */
     /** connect to the originating source */
@@ -256,9 +258,10 @@ snmp_send_trap(s8_t generic_trap, const struct snmp_obj_id *eoid, s32_t specific
         else
         {
           /* generic (MIB-II) trap */
-          snmp_get_snmpgrpid_ptr(&trap_msg.enterprise);
+          mib2_get_snmpgrpid_ptr(&trap_msg.enterprise);
         }
-        snmp_get_sysuptime(&trap_msg.ts);
+
+        MIB2_COPY_SYSUPTIME_TO(&trap_msg.ts);
 
         /* pass 0, calculate length fields */
         tot_len = snmp_varbind_list_sum(&trap_msg.outvb);
@@ -274,8 +277,8 @@ snmp_send_trap(s8_t generic_trap, const struct snmp_obj_id *eoid, s32_t specific
           ofs = snmp_trap_header_enc(&trap_msg, p);
           snmp_varbind_list_enc(&trap_msg.outvb, p, ofs);
 
-          snmp_inc_snmpouttraps();
-          snmp_inc_snmpoutpkts();
+          mib2_inc_snmpouttraps();
+          mib2_inc_snmpoutpkts();
 
           /** send to the TRAP destination */
           udp_sendto(trap_msg.pcb, p, &trap_msg.dip, SNMP_TRAP_PORT);
@@ -306,7 +309,7 @@ void
 snmp_authfail_trap(void)
 {
   u8_t enable;
-  snmp_get_snmpenableauthentraps(&enable);
+  mib2_get_snmpenableauthentraps(&enable);
   if (enable == 1)
   {
     trap_msg.outvb.head = NULL;
diff --git a/src/core/tcp.c b/src/core/tcp.c
index 188bcf8..ea8481d 100644
--- a/src/core/tcp.c
+++ b/src/core/tcp.c
@@ -47,7 +47,6 @@
 #include "lwip/def.h"
 #include "lwip/mem.h"
 #include "lwip/memp.h"
-#include "lwip/snmp.h"
 #include "lwip/tcp.h"
 #include "lwip/tcp_impl.h"
 #include "lwip/debug.h"
@@ -231,26 +230,26 @@ tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
     TCP_PCB_REMOVE_ACTIVE(pcb);
     memp_free(MEMP_TCP_PCB, pcb);
     pcb = NULL;
-    snmp_inc_tcpattemptfails();
+    MIB2_STATS_INC(mib2.tcpattemptfails);
     break;
   case SYN_RCVD:
     err = tcp_send_fin(pcb);
     if (err == ERR_OK) {
-      snmp_inc_tcpattemptfails();
+      MIB2_STATS_INC(mib2.tcpattemptfails);
       pcb->state = FIN_WAIT_1;
     }
     break;
   case ESTABLISHED:
     err = tcp_send_fin(pcb);
     if (err == ERR_OK) {
-      snmp_inc_tcpestabresets();
+      MIB2_STATS_INC(mib2.tcpestabresets);
       pcb->state = FIN_WAIT_1;
     }
     break;
   case CLOSE_WAIT:
     err = tcp_send_fin(pcb);
     if (err == ERR_OK) {
-      snmp_inc_tcpestabresets();
+      MIB2_STATS_INC(mib2.tcpestabresets);
       pcb->state = LAST_ACK;
     }
     break;
@@ -850,7 +849,7 @@ tcp_connect(struct tcp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port,
       TCP_RMV(&tcp_bound_pcbs, pcb);
     }
     TCP_REG_ACTIVE(pcb);
-    snmp_inc_tcpactiveopens();
+    MIB2_STATS_INC(mib2.tcpactiveopens);
 
     tcp_output(pcb);
   }
diff --git a/src/core/tcp_in.c b/src/core/tcp_in.c
index d718014..3faad15 100644
--- a/src/core/tcp_in.c
+++ b/src/core/tcp_in.c
@@ -53,7 +53,6 @@
 #include "lwip/memp.h"
 #include "lwip/inet_chksum.h"
 #include "lwip/stats.h"
-#include "lwip/snmp.h"
 #include "lwip/ip6.h"
 #include "lwip/ip6_addr.h"
 #include "lwip/inet_chksum.h"
@@ -117,7 +116,7 @@ tcp_input(struct pbuf *p, struct netif *inp)
   PERF_START;
 
   TCP_STATS_INC(tcp.recv);
-  snmp_inc_tcpinsegs();
+  MIB2_STATS_INC(mib2.tcpinsegs);
 
   tcphdr = (struct tcp_hdr *)p->payload;
 
@@ -348,7 +347,7 @@ tcp_input(struct pbuf *p, struct netif *inp)
         /* pcb has been aborted or refused data is still refused and the new
            segment contains data */
         TCP_STATS_INC(tcp.drop);
-        snmp_inc_tcpinerrs();
+        MIB2_STATS_INC(mib2.tcpinerrs);
         goto aborted;
       }
     }
@@ -513,7 +512,7 @@ aborted:
   return;
 dropped:
   TCP_STATS_INC(tcp.drop);
-  snmp_inc_tcpinerrs();
+  MIB2_STATS_INC(mib2.tcpinerrs);
   pbuf_free(p);
 }
 
@@ -601,7 +600,7 @@ tcp_listen_input(struct tcp_pcb_listen *pcb)
       &npcb->remote_ip, PCB_ISIPV6(npcb));
 #endif /* TCP_CALCULATE_EFF_SEND_MSS */
 
-    snmp_inc_tcppassiveopens();
+    MIB2_STATS_INC(mib2.tcppassiveopens);
 
     /* Send a SYN|ACK together with the MSS option. */
     rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
diff --git a/src/core/tcp_out.c b/src/core/tcp_out.c
index a3ad274..e9e77c9 100644
--- a/src/core/tcp_out.c
+++ b/src/core/tcp_out.c
@@ -50,7 +50,6 @@
 #include "lwip/netif.h"
 #include "lwip/inet_chksum.h"
 #include "lwip/stats.h"
-#include "lwip/snmp.h"
 #include "lwip/ip6.h"
 #include "lwip/ip6_addr.h"
 #include "lwip/inet_chksum.h"
@@ -1136,7 +1135,7 @@ tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
   struct netif *netif;
 
   /** @bug Exclude retransmitted segments from this count. */
-  snmp_inc_tcpoutsegs();
+  MIB2_STATS_INC(mib2.tcpoutsegs);
 
   /* The TCP header has already been constructed, but the ackno and
    wnd fields remain. */
@@ -1262,7 +1261,6 @@ tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
 #endif /* TCP_CHECKSUM_ON_COPY */
   }
 #endif /* CHECKSUM_GEN_TCP */
-
   TCP_STATS_INC(tcp.xmit);
 
   NETIF_SET_HWADDRHINT(netif, &(pcb->addr_hint));
@@ -1323,7 +1321,7 @@ tcp_rst(u32_t seqno, u32_t ackno,
   tcphdr->urgp = 0;
 
   TCP_STATS_INC(tcp.xmit);
-  snmp_inc_tcpoutrsts();
+  MIB2_STATS_INC(mib2.tcpoutrsts);
 
   netif = ip_route(IP_IS_V6(remote_ip), local_ip, remote_ip);
   if (netif != NULL) {
@@ -1423,7 +1421,7 @@ tcp_rexmit(struct tcp_pcb *pcb)
   pcb->rttest = 0;
 
   /* Do the actual retransmission. */
-  snmp_inc_tcpretranssegs();
+  MIB2_STATS_INC(mib2.tcpretranssegs);
   /* No need to call tcp_output: we are always called from tcp_input()
      and thus tcp_output directly returns. */
 }
diff --git a/src/core/udp.c b/src/core/udp.c
index c18255a..aceb71e 100644
--- a/src/core/udp.c
+++ b/src/core/udp.c
@@ -62,7 +62,7 @@
 #include "lwip/icmp.h"
 #include "lwip/icmp6.h"
 #include "lwip/stats.h"
-#include "lwip/snmp.h"
+#include "lwip/snmp_mib2.h"
 #include "lwip/dhcp.h"
 
 #include <string.h>
@@ -174,7 +174,7 @@ udp_input(struct pbuf *p, struct netif *inp)
                 ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
     UDP_STATS_INC(udp.lenerr);
     UDP_STATS_INC(udp.drop);
-    snmp_inc_udpinerrors();
+    MIB2_STATS_INC(mib2.udpinerrors);
     pbuf_free(p);
     goto end;
   }
@@ -363,12 +363,12 @@ udp_input(struct pbuf *p, struct netif *inp)
       /* Can we cope with this failing? Just assert for now */
       LWIP_ASSERT("pbuf_header failed\n", 0);
       UDP_STATS_INC(udp.drop);
-      snmp_inc_udpinerrors();
+      MIB2_STATS_INC(mib2.udpinerrors);
       pbuf_free(p);
       goto end;
     }
     if (pcb != NULL) {
-      snmp_inc_udpindatagrams();
+      MIB2_STATS_INC(mib2.udpindatagrams);
 #if SO_REUSE && SO_REUSE_RXTOALL
       if ((broadcast ||
 #if LWIP_IPV6
@@ -463,7 +463,7 @@ udp_input(struct pbuf *p, struct netif *inp)
 #endif /* LWIP_ICMP || LWIP_ICMP6 */
       UDP_STATS_INC(udp.proterr);
       UDP_STATS_INC(udp.drop);
-      snmp_inc_udpnoports();
+      MIB2_STATS_INC(mib2.udpnoports);
       pbuf_free(p);
     }
   } else {
@@ -478,7 +478,7 @@ chkerr:
               ("udp_input: UDP (or UDP Lite) datagram discarded due to failing checksum\n"));
   UDP_STATS_INC(udp.chkerr);
   UDP_STATS_INC(udp.drop);
-  snmp_inc_udpinerrors();
+  MIB2_STATS_INC(mib2.udpinerrors);
   pbuf_free(p);
   PERF_STOP("udp_input");
 #endif /* CHECKSUM_CHECK_UDP */
@@ -881,7 +881,7 @@ udp_sendto_if_src_chksum(struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *d
   NETIF_SET_HWADDRHINT(netif, NULL);
 
   /* TODO: must this be increased even if error occurred? */
-  snmp_inc_udpoutdatagrams();
+  MIB2_STATS_INC(mib2.udpoutdatagrams);
 
   /* did we chain a separate header pbuf earlier? */
   if (q != p) {
@@ -974,7 +974,7 @@ udp_bind(struct udp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
     }
   }
   pcb->local_port = port;
-  snmp_insert_udpidx_tree(pcb);
+  mib2_udp_bind(pcb);
   /* pcb not active yet? */
   if (rebind == 0) {
     /* place the PCB on the active list if not already there */
@@ -1110,7 +1110,7 @@ udp_remove(struct udp_pcb *pcb)
 {
   struct udp_pcb *pcb2;
 
-  snmp_delete_udpidx_tree(pcb);
+  mib2_udp_unbind(pcb);
   /* pcb to be removed is first in list? */
   if (udp_pcbs == pcb) {
     /* make list start at 2nd pcb */
diff --git a/src/include/lwip/api.h b/src/include/lwip/api.h
index c09dee1..7fd9dc7 100644
--- a/src/include/lwip/api.h
+++ b/src/include/lwip/api.h
@@ -297,7 +297,7 @@ err_t   netconn_gethostbyname_addrtype(const char *name, ip_addr_t *addr, u8_t d
 #define netconn_gethostbyname(name, addr) netconn_gethostbyname_addrtype(name, addr, NETCONN_DNS_DEFAULT)
 #else /* LWIP_IPV4 && LWIP_IPV6 */
 err_t   netconn_gethostbyname(const char *name, ip_addr_t *addr);
-#define netconn_gethostbyname_addrtype(name, addr, dns_addrtype netconn_gethostbyname(name, addr)
+#define netconn_gethostbyname_addrtype(name, addr, dns_addrtype) netconn_gethostbyname(name, addr)
 #endif /* LWIP_IPV4 && LWIP_IPV6 */
 #endif /* LWIP_DNS */
 
diff --git a/src/include/lwip/dns.h b/src/include/lwip/dns.h
index cfe5be1..4ee8546 100644
--- a/src/include/lwip/dns.h
+++ b/src/include/lwip/dns.h
@@ -50,6 +50,15 @@ extern "C" {
 #define LWIP_DNS_ADDRTYPE_IPV6      1
 #define LWIP_DNS_ADDRTYPE_IPV4_IPV6 2 /* try to resolve IPv4 first, try IPv6 if IPv4 fails only */
 #define LWIP_DNS_ADDRTYPE_IPV6_IPV4 3 /* try to resolve IPv6 first, try IPv4 if IPv6 fails only */
+#if LWIP_IPV4 && LWIP_IPV6
+#ifndef LWIP_DNS_ADDRTYPE_DEFAULT
+#define LWIP_DNS_ADDRTYPE_DEFAULT   LWIP_DNS_ADDRTYPE_IPV4_IPV6
+#endif
+#elif defined(LWIP_IPV4)
+#define LWIP_DNS_ADDRTYPE_DEFAULT   LWIP_DNS_ADDRTYPE_IPV4
+#else
+#define LWIP_DNS_ADDRTYPE_DEFAULT   LWIP_DNS_ADDRTYPE_IPV6
+#endif
 
 #if DNS_LOCAL_HOSTLIST
 /** struct used for local host-list */
@@ -83,14 +92,9 @@ void           dns_setserver(u8_t numdns, ip_addr_t *dnsserver);
 ip_addr_t      dns_getserver(u8_t numdns);
 err_t          dns_gethostbyname(const char *hostname, ip_addr_t *addr,
                                  dns_found_callback found, void *callback_arg);
-#if LWIP_IPV4 && LWIP_IPV6
 err_t          dns_gethostbyname_addrtype(const char *hostname, ip_addr_t *addr,
                                  dns_found_callback found, void *callback_arg,
                                  u8_t dns_addrtype);
-#else /* LWIP_IPV4 && LWIP_IPV6 */
-#define dns_gethostbyname_addrtype(hostname, addr, found, callback_arg, dns_addrtype) \
-              dns_gethostbyname(hostname, addr, found, callback_arg)
-#endif /* LWIP_IPV4 && LWIP_IPV6 */
 
 
 #if DNS_LOCAL_HOSTLIST && DNS_LOCAL_HOSTLIST_IS_DYNAMIC
diff --git a/src/include/lwip/netif.h b/src/include/lwip/netif.h
index 6c01faf..7bd4cae 100644
--- a/src/include/lwip/netif.h
+++ b/src/include/lwip/netif.h
@@ -270,8 +270,8 @@ struct netif {
   char name[2];
   /** number of this interface */
   u8_t num;
-#if LWIP_SNMP
-  /** link type (from "snmp_ifType" enum from snmp.h) */
+#if MIB2_STATS
+  /** link type (from "snmp_ifType" enum from snmp_mib2.h) */
   u8_t link_type;
   /** (estimate) link speed */
   u32_t link_speed;
@@ -286,7 +286,7 @@ struct netif {
   u32_t ifoutucastpkts;
   u32_t ifoutnucastpkts;
   u32_t ifoutdiscards;
-#endif /* LWIP_SNMP */
+#endif /* MIB2_STATS */
 #if LWIP_IPV4 && LWIP_IGMP
   /** This function could be called to add or delete an entry in the multicast
       filter table of the ethernet MAC.*/
@@ -319,26 +319,6 @@ struct netif {
 #define IF__NETIF_CHECKSUM_ENABLED(netif, chksumflag)
 #endif /* LWIP_CHECKSUM_CTRL_PER_NETIF */
 
-#if LWIP_SNMP
-#define NETIF_INIT_SNMP(netif, type, speed) do { \
-  /* use "snmp_ifType" enum from snmp.h for "type", snmp_ifType_ethernet_csmacd by example */ \
-  (netif)->link_type = (type);  \
-  /* your link speed here (units: bits per second) */  \
-  (netif)->link_speed = (speed);\
-  (netif)->ts = 0;              \
-  (netif)->ifinoctets = 0;      \
-  (netif)->ifinucastpkts = 0;   \
-  (netif)->ifinnucastpkts = 0;  \
-  (netif)->ifindiscards = 0;    \
-  (netif)->ifoutoctets = 0;     \
-  (netif)->ifoutucastpkts = 0;  \
-  (netif)->ifoutnucastpkts = 0; \
-  (netif)->ifoutdiscards = 0; } while(0)
-#else /* LWIP_SNMP */
-#define NETIF_INIT_SNMP(netif, type, speed)
-#endif /* LWIP_SNMP */
-
-
 /** The list of network interfaces. */
 extern struct netif *netif_list;
 /** The default network interface. */
diff --git a/src/include/lwip/opt.h b/src/include/lwip/opt.h
index 0852fe6..c5b2572 100644
--- a/src/include/lwip/opt.h
+++ b/src/include/lwip/opt.h
@@ -865,14 +865,27 @@
    ----------------------------------
 */
 /**
- * LWIP_SNMP==1: Turn on SNMP module. UDP must be available for SNMP
- * transport.
+ * LWIP_SNMP==1: This enables the lwIP SNMP agent. UDP must be available
+ * for SNMP transport.
+ * If you want to use your own SNMP agent, leave this disabled.
+ * To integrate MIB2 of an external agent, you need to enable
+ * LWIP_MIB2_CALLBACKS and MIB2_STATS. This will give you the callbacks
+ * and statistics counters you need to get MIB2 working.
  */
 #ifndef LWIP_SNMP
 #define LWIP_SNMP                       0
 #endif
 
 /**
+ * LWIP_MIB2_CALLBACKS==1: Turn on SNMP MIB2 callbacks.
+ * Turn this on to get callbacks needed to implement MIB2.
+ * Usually MIB2_STATS should be enabled, too.
+ */
+#ifndef LWIP_MIB2_CALLBACKS
+#define LWIP_MIB2_CALLBACKS             LWIP_SNMP
+#endif
+
+/**
  * SNMP_CONCURRENT_REQUESTS: Number of concurrent requests the module will
  * allow. At least one request buffer is required.
  * Does not have to be changed unless external MIBs answer request asynchronously
@@ -1027,9 +1040,8 @@
  *  byte order).
  *
  *  Instead, you can also use an external function:
- *  #define DNS_LOOKUP_LOCAL_EXTERN(x) extern int my_lookup_function(const char *name, ip_addr_t* result, u8_t reqtype)
- *  that provides the IP address, returns 1 if found or 0 if not found and gets
- *  the type of the requested address passed (see LWIP_DNS_ADDRTYPE_*)
+ *  #define DNS_LOOKUP_LOCAL_EXTERN(x) extern u32_t my_lookup_function(const char *name)
+ *  that returns the IP address or INADDR_NONE if not found.
  */
 #ifndef DNS_LOCAL_HOSTLIST
 #define DNS_LOCAL_HOSTLIST              0
@@ -1904,6 +1916,13 @@
 #define ND6_STATS                       (LWIP_IPV6)
 #endif
 
+/**
+ * MIB2_STATS==1: Stats for SNMP MIB2.
+ */
+#ifndef MIB2_STATS
+#define MIB2_STATS                      (LWIP_SNMP)
+#endif
+
 #else
 
 #define LINK_STATS                      0
@@ -1923,6 +1942,7 @@
 #define IP6_FRAG_STATS                  0
 #define MLD6_STATS                      0
 #define ND6_STATS                       0
+#define MIB2_STATS                      0
 
 #endif /* LWIP_STATS */
 
diff --git a/src/include/lwip/pppapi.h b/src/include/lwip/pppapi.h
index 270c5fc..28c8a5f 100644
--- a/src/include/lwip/pppapi.h
+++ b/src/include/lwip/pppapi.h
@@ -35,6 +35,9 @@
 #include "lwip/sys.h"
 #include "lwip/netif.h"
 #include "netif/ppp/ppp.h"
+#if PPPOS_SUPPORT
+#include "netif/ppp/pppos.h"
+#endif /* PPPOS_SUPPORT */
 
 #ifdef __cplusplus
 extern "C" {
@@ -60,7 +63,7 @@ struct pppapi_msg_msg {
 #if PPPOS_SUPPORT
     struct {
       struct netif *pppif;
-      sio_fd_t fd;
+      pppos_output_cb_fn output_cb;
       ppp_link_status_cb_fn link_status_cb;
       void *ctx_cb;
     } serialcreate;
@@ -119,7 +122,7 @@ void pppapi_set_auth(ppp_pcb *pcb, u8_t authtype, const char *user, const char *
 void pppapi_set_notify_phase_callback(ppp_pcb *pcb, ppp_notify_phase_cb_fn notify_phase_cb);
 #endif /* PPP_NOTIFY_PHASE */
 #if PPPOS_SUPPORT
-ppp_pcb *pppapi_pppos_create(struct netif *pppif, sio_fd_t fd, ppp_link_status_cb_fn link_status_cb, void *ctx_cb);
+ppp_pcb *pppapi_pppos_create(struct netif *pppif, pppos_output_cb_fn output_cb, ppp_link_status_cb_fn link_status_cb, void *ctx_cb);
 #endif /* PPPOS_SUPPORT */
 #if PPPOE_SUPPORT
 ppp_pcb *pppapi_pppoe_create(struct netif *pppif, struct netif *ethif, const char *service_name,
diff --git a/src/include/lwip/snmp.h b/src/include/lwip/snmp.h
index ed21f6a..5dcef37 100644
--- a/src/include/lwip/snmp.h
+++ b/src/include/lwip/snmp.h
@@ -34,59 +34,14 @@
 #define LWIP_HDR_SNMP_H
 
 #include "lwip/opt.h"
+#include "lwip/snmp_mib2.h"
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-#include "lwip/ip_addr.h"
-
-struct udp_pcb;
-struct netif;
-
-/**
- * @see RFC1213, "MIB-II, 6. Definitions"
- */
-enum snmp_ifType {
-  snmp_ifType_other=1,                /* none of the following */
-  snmp_ifType_regular1822,
-  snmp_ifType_hdh1822,
-  snmp_ifType_ddn_x25,
-  snmp_ifType_rfc877_x25,
-  snmp_ifType_ethernet_csmacd,
-  snmp_ifType_iso88023_csmacd,
-  snmp_ifType_iso88024_tokenBus,
-  snmp_ifType_iso88025_tokenRing,
-  snmp_ifType_iso88026_man,
-  snmp_ifType_starLan,
-  snmp_ifType_proteon_10Mbit,
-  snmp_ifType_proteon_80Mbit,
-  snmp_ifType_hyperchannel,
-  snmp_ifType_fddi,
-  snmp_ifType_lapb,
-  snmp_ifType_sdlc,
-  snmp_ifType_ds1,                    /* T-1 */
-  snmp_ifType_e1,                     /* european equiv. of T-1 */
-  snmp_ifType_basicISDN,
-  snmp_ifType_primaryISDN,            /* proprietary serial */
-  snmp_ifType_propPointToPointSerial,
-  snmp_ifType_ppp,
-  snmp_ifType_softwareLoopback,
-  snmp_ifType_eon,                    /* CLNP over IP [11] */
-  snmp_ifType_ethernet_3Mbit,
-  snmp_ifType_nsip,                   /* XNS over IP */
-  snmp_ifType_slip,                   /* generic SLIP */
-  snmp_ifType_ultra,                  /* ULTRA technologies */
-  snmp_ifType_ds3,                    /* T-3 */
-  snmp_ifType_sip,                    /* SMDS */
-  snmp_ifType_frame_relay
-};
-
 #if LWIP_SNMP /* don't build if not configured for use in lwipopts.h */
 
-/** SNMP "sysuptime" Interval */
-#define SNMP_SYSUPTIME_INTERVAL 10
-
 /** fixed maximum length for object identifier type */
 #define LWIP_SNMP_OBJ_ID_LEN 32
 
@@ -110,268 +65,22 @@ void snmp_set_community_trap(const char * const community);
 void snmp_set_sysdescr(const u8_t* str, const u8_t* len);
 void snmp_set_sysobjid(const struct snmp_obj_id *oid);
 void snmp_get_sysobjid_ptr(const struct snmp_obj_id **oid);
-void snmp_inc_sysuptime(void);
-void snmp_add_sysuptime(u32_t value);
-void snmp_get_sysuptime(u32_t *value);
 void snmp_set_syscontact(u8_t *ocstr, u8_t *ocstrlen, u8_t bufsize);
 void snmp_set_sysname(u8_t *ocstr, u8_t *ocstrlen, u8_t bufsize);
 void snmp_set_syslocation(u8_t *ocstr, u8_t *ocstrlen, u8_t bufsize);
-
-/* network interface */
-void snmp_add_ifinoctets(struct netif *ni, u32_t value); 
-void snmp_inc_ifinucastpkts(struct netif *ni);
-void snmp_inc_ifinnucastpkts(struct netif *ni);
-void snmp_inc_ifindiscards(struct netif *ni);
-void snmp_add_ifoutoctets(struct netif *ni, u32_t value);
-void snmp_inc_ifoutucastpkts(struct netif *ni);
-void snmp_inc_ifoutnucastpkts(struct netif *ni);
-void snmp_inc_ifoutdiscards(struct netif *ni);
-void snmp_inc_iflist(void);
-void snmp_dec_iflist(void);
-
-#if LWIP_IPV4 && LWIP_ARP
-/* ARP (for atTable and ipNetToMediaTable) */
-void snmp_insert_arpidx_tree(struct netif *ni, ip4_addr_t *ip);
-void snmp_delete_arpidx_tree(struct netif *ni, ip4_addr_t *ip);
-#else /* LWIP_IPV4 && LWIP_ARP */
-#define snmp_insert_arpidx_tree(ni,ip)
-#define snmp_delete_arpidx_tree(ni,ip)
-#endif /* LWIP_IPV4 && LWIP_ARP */
-
-/* IP */
-void snmp_inc_ipinreceives(void);
-void snmp_inc_ipinhdrerrors(void);
-void snmp_inc_ipinaddrerrors(void);
-void snmp_inc_ipforwdatagrams(void);
-void snmp_inc_ipinunknownprotos(void);
-void snmp_inc_ipindiscards(void);
-void snmp_inc_ipindelivers(void);
-void snmp_inc_ipoutrequests(void);
-void snmp_inc_ipoutdiscards(void);
-void snmp_inc_ipoutnoroutes(void);
-void snmp_inc_ipreasmreqds(void);
-void snmp_inc_ipreasmoks(void);
-void snmp_inc_ipreasmfails(void);
-void snmp_inc_ipfragoks(void);
-void snmp_inc_ipfragfails(void);
-void snmp_inc_ipfragcreates(void);
-void snmp_inc_iproutingdiscards(void);
-void snmp_insert_ipaddridx_tree(struct netif *ni);
-void snmp_delete_ipaddridx_tree(struct netif *ni);
-void snmp_insert_iprteidx_tree(u8_t dflt, struct netif *ni);
-void snmp_delete_iprteidx_tree(u8_t dflt, struct netif *ni);
-
-/* ICMP */
-void snmp_inc_icmpinmsgs(void);
-void snmp_inc_icmpinerrors(void);
-void snmp_inc_icmpindestunreachs(void);
-void snmp_inc_icmpintimeexcds(void);
-void snmp_inc_icmpinparmprobs(void);
-void snmp_inc_icmpinsrcquenchs(void);
-void snmp_inc_icmpinredirects(void);
-void snmp_inc_icmpinechos(void);
-void snmp_inc_icmpinechoreps(void);
-void snmp_inc_icmpintimestamps(void);
-void snmp_inc_icmpintimestampreps(void);
-void snmp_inc_icmpinaddrmasks(void);
-void snmp_inc_icmpinaddrmaskreps(void);
-void snmp_inc_icmpoutmsgs(void);
-void snmp_inc_icmpouterrors(void);
-void snmp_inc_icmpoutdestunreachs(void);
-void snmp_inc_icmpouttimeexcds(void);
-void snmp_inc_icmpoutparmprobs(void);
-void snmp_inc_icmpoutsrcquenchs(void);
-void snmp_inc_icmpoutredirects(void); 
-void snmp_inc_icmpoutechos(void);
-void snmp_inc_icmpoutechoreps(void);
-void snmp_inc_icmpouttimestamps(void);
-void snmp_inc_icmpouttimestampreps(void);
-void snmp_inc_icmpoutaddrmasks(void);
-void snmp_inc_icmpoutaddrmaskreps(void);
-
-/* TCP */
-void snmp_inc_tcpactiveopens(void);
-void snmp_inc_tcppassiveopens(void);
-void snmp_inc_tcpattemptfails(void);
-void snmp_inc_tcpestabresets(void);
-void snmp_inc_tcpinsegs(void);
-void snmp_inc_tcpoutsegs(void);
-void snmp_inc_tcpretranssegs(void);
-void snmp_inc_tcpinerrs(void);
-void snmp_inc_tcpoutrsts(void);
-
-/* UDP */
-void snmp_inc_udpindatagrams(void);
-void snmp_inc_udpnoports(void);
-void snmp_inc_udpinerrors(void);
-void snmp_inc_udpoutdatagrams(void);
-void snmp_insert_udpidx_tree(struct udp_pcb *pcb);
-void snmp_delete_udpidx_tree(struct udp_pcb *pcb);
-
-/* SNMP */
-void snmp_inc_snmpinpkts(void);
-void snmp_inc_snmpoutpkts(void);
-void snmp_inc_snmpinbadversions(void);
-void snmp_inc_snmpinbadcommunitynames(void);
-void snmp_inc_snmpinbadcommunityuses(void);
-void snmp_inc_snmpinasnparseerrs(void);
-void snmp_inc_snmpintoobigs(void);
-void snmp_inc_snmpinnosuchnames(void);
-void snmp_inc_snmpinbadvalues(void);
-void snmp_inc_snmpinreadonlys(void);
-void snmp_inc_snmpingenerrs(void);
-void snmp_add_snmpintotalreqvars(u8_t value);
-void snmp_add_snmpintotalsetvars(u8_t value);
-void snmp_inc_snmpingetrequests(void);
-void snmp_inc_snmpingetnexts(void);
-void snmp_inc_snmpinsetrequests(void);
-void snmp_inc_snmpingetresponses(void);
-void snmp_inc_snmpintraps(void);
-void snmp_inc_snmpouttoobigs(void);
-void snmp_inc_snmpoutnosuchnames(void);
-void snmp_inc_snmpoutbadvalues(void);
-void snmp_inc_snmpoutgenerrs(void);
-void snmp_inc_snmpoutgetrequests(void);
-void snmp_inc_snmpoutgetnexts(void);
-void snmp_inc_snmpoutsetrequests(void);
-void snmp_inc_snmpoutgetresponses(void);
-void snmp_inc_snmpouttraps(void);
-void snmp_get_snmpgrpid_ptr(const struct snmp_obj_id **oid);
 void snmp_set_snmpenableauthentraps(u8_t *value);
-void snmp_get_snmpenableauthentraps(u8_t *value);
-
+#else
 /* LWIP_SNMP support not available */
 /* define everything to be empty */
-#else
 
 /* system */
 #define snmp_set_sysdescr(str, len)
-#define snmp_set_sysobjid(oid);
+#define snmp_set_sysobjid(oid)
 #define snmp_get_sysobjid_ptr(oid)
-#define snmp_inc_sysuptime()
-#define snmp_add_sysuptime(value)
-#define snmp_get_sysuptime(value)
-#define snmp_set_syscontact(ocstr, ocstrlen, bufsize);
-#define snmp_set_sysname(ocstr, ocstrlen, bufsize);
-#define snmp_set_syslocation(ocstr, ocstrlen, bufsize);
-
-/* network interface */
-#define snmp_add_ifinoctets(ni,value) 
-#define snmp_inc_ifinucastpkts(ni)
-#define snmp_inc_ifinnucastpkts(ni)
-#define snmp_inc_ifindiscards(ni)
-#define snmp_add_ifoutoctets(ni,value)
-#define snmp_inc_ifoutucastpkts(ni)
-#define snmp_inc_ifoutnucastpkts(ni)
-#define snmp_inc_ifoutdiscards(ni)
-#define snmp_inc_iflist()
-#define snmp_dec_iflist()
-
-/* ARP */
-#define snmp_insert_arpidx_tree(ni,ip)
-#define snmp_delete_arpidx_tree(ni,ip)
-
-/* IP */
-#define snmp_inc_ipinreceives()
-#define snmp_inc_ipinhdrerrors()
-#define snmp_inc_ipinaddrerrors()
-#define snmp_inc_ipforwdatagrams()
-#define snmp_inc_ipinunknownprotos()
-#define snmp_inc_ipindiscards()
-#define snmp_inc_ipindelivers()
-#define snmp_inc_ipoutrequests()
-#define snmp_inc_ipoutdiscards()
-#define snmp_inc_ipoutnoroutes()
-#define snmp_inc_ipreasmreqds()
-#define snmp_inc_ipreasmoks()
-#define snmp_inc_ipreasmfails()
-#define snmp_inc_ipfragoks()
-#define snmp_inc_ipfragfails()
-#define snmp_inc_ipfragcreates()
-#define snmp_inc_iproutingdiscards()
-#define snmp_insert_ipaddridx_tree(ni)
-#define snmp_delete_ipaddridx_tree(ni)
-#define snmp_insert_iprteidx_tree(dflt, ni)
-#define snmp_delete_iprteidx_tree(dflt, ni)
-
-/* ICMP */
-#define snmp_inc_icmpinmsgs()
-#define snmp_inc_icmpinerrors() 
-#define snmp_inc_icmpindestunreachs() 
-#define snmp_inc_icmpintimeexcds()
-#define snmp_inc_icmpinparmprobs() 
-#define snmp_inc_icmpinsrcquenchs() 
-#define snmp_inc_icmpinredirects() 
-#define snmp_inc_icmpinechos() 
-#define snmp_inc_icmpinechoreps()
-#define snmp_inc_icmpintimestamps() 
-#define snmp_inc_icmpintimestampreps()
-#define snmp_inc_icmpinaddrmasks()
-#define snmp_inc_icmpinaddrmaskreps()
-#define snmp_inc_icmpoutmsgs()
-#define snmp_inc_icmpouterrors()
-#define snmp_inc_icmpoutdestunreachs() 
-#define snmp_inc_icmpouttimeexcds() 
-#define snmp_inc_icmpoutparmprobs()
-#define snmp_inc_icmpoutsrcquenchs()
-#define snmp_inc_icmpoutredirects() 
-#define snmp_inc_icmpoutechos() 
-#define snmp_inc_icmpoutechoreps()
-#define snmp_inc_icmpouttimestamps()
-#define snmp_inc_icmpouttimestampreps()
-#define snmp_inc_icmpoutaddrmasks()
-#define snmp_inc_icmpoutaddrmaskreps()
-/* TCP */
-#define snmp_inc_tcpactiveopens()
-#define snmp_inc_tcppassiveopens()
-#define snmp_inc_tcpattemptfails()
-#define snmp_inc_tcpestabresets()
-#define snmp_inc_tcpinsegs()
-#define snmp_inc_tcpoutsegs()
-#define snmp_inc_tcpretranssegs()
-#define snmp_inc_tcpinerrs()
-#define snmp_inc_tcpoutrsts()
-
-/* UDP */
-#define snmp_inc_udpindatagrams()
-#define snmp_inc_udpnoports()
-#define snmp_inc_udpinerrors()
-#define snmp_inc_udpoutdatagrams()
-#define snmp_insert_udpidx_tree(pcb)
-#define snmp_delete_udpidx_tree(pcb)
-
-/* SNMP */
-#define snmp_inc_snmpinpkts()
-#define snmp_inc_snmpoutpkts()
-#define snmp_inc_snmpinbadversions()
-#define snmp_inc_snmpinbadcommunitynames()
-#define snmp_inc_snmpinbadcommunityuses()
-#define snmp_inc_snmpinasnparseerrs()
-#define snmp_inc_snmpintoobigs()
-#define snmp_inc_snmpinnosuchnames()
-#define snmp_inc_snmpinbadvalues()
-#define snmp_inc_snmpinreadonlys()
-#define snmp_inc_snmpingenerrs()
-#define snmp_add_snmpintotalreqvars(value)
-#define snmp_add_snmpintotalsetvars(value)
-#define snmp_inc_snmpingetrequests()
-#define snmp_inc_snmpingetnexts()
-#define snmp_inc_snmpinsetrequests()
-#define snmp_inc_snmpingetresponses()
-#define snmp_inc_snmpintraps()
-#define snmp_inc_snmpouttoobigs()
-#define snmp_inc_snmpoutnosuchnames()
-#define snmp_inc_snmpoutbadvalues()
-#define snmp_inc_snmpoutgenerrs()
-#define snmp_inc_snmpoutgetrequests()
-#define snmp_inc_snmpoutgetnexts()
-#define snmp_inc_snmpoutsetrequests()
-#define snmp_inc_snmpoutgetresponses()
-#define snmp_inc_snmpouttraps()
-#define snmp_get_snmpgrpid_ptr(oid)
+#define snmp_set_syscontact(ocstr, ocstrlen, bufsize)
+#define snmp_set_sysname(ocstr, ocstrlen, bufsize)
+#define snmp_set_syslocation(ocstr, ocstrlen, bufsize)
 #define snmp_set_snmpenableauthentraps(value)
-#define snmp_get_snmpenableauthentraps(value)
-
 #endif /* LWIP_SNMP */
 
 #ifdef __cplusplus
diff --git a/src/include/lwip/snmp_mib2.h b/src/include/lwip/snmp_mib2.h
new file mode 100644
index 0000000..0da02e9
--- /dev/null
+++ b/src/include/lwip/snmp_mib2.h
@@ -0,0 +1,185 @@
+/**
+ * @file
+ * MIB2 callback functions called from throughout the stack to integrate a MIB2
+ * into lwIP (together with MIB2_STATS).
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved. 
+ * 
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ * 
+ * Author: Dirk Ziegelmeier <dziegel@gmx.de>
+ *
+ */
+#ifndef LWIP_HDR_SNMP_MIB2_H
+#define LWIP_HDR_SNMP_MIB2_H
+
+#include "lwip/opt.h"
+#include "lwip/ip_addr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct udp_pcb;
+struct netif;
+
+/* MIB2 statistics functions */
+#if MIB2_STATS  /* don't build if not configured for use in lwipopts.h */
+/**
+ * @see RFC1213, "MIB-II, 6. Definitions"
+ */
+enum snmp_ifType {
+  snmp_ifType_other=1,                /* none of the following */
+  snmp_ifType_regular1822,
+  snmp_ifType_hdh1822,
+  snmp_ifType_ddn_x25,
+  snmp_ifType_rfc877_x25,
+  snmp_ifType_ethernet_csmacd,
+  snmp_ifType_iso88023_csmacd,
+  snmp_ifType_iso88024_tokenBus,
+  snmp_ifType_iso88025_tokenRing,
+  snmp_ifType_iso88026_man,
+  snmp_ifType_starLan,
+  snmp_ifType_proteon_10Mbit,
+  snmp_ifType_proteon_80Mbit,
+  snmp_ifType_hyperchannel,
+  snmp_ifType_fddi,
+  snmp_ifType_lapb,
+  snmp_ifType_sdlc,
+  snmp_ifType_ds1,                    /* T-1 */
+  snmp_ifType_e1,                     /* european equiv. of T-1 */
+  snmp_ifType_basicISDN,
+  snmp_ifType_primaryISDN,            /* proprietary serial */
+  snmp_ifType_propPointToPointSerial,
+  snmp_ifType_ppp,
+  snmp_ifType_softwareLoopback,
+  snmp_ifType_eon,                    /* CLNP over IP [11] */
+  snmp_ifType_ethernet_3Mbit,
+  snmp_ifType_nsip,                   /* XNS over IP */
+  snmp_ifType_slip,                   /* generic SLIP */
+  snmp_ifType_ultra,                  /* ULTRA technologies */
+  snmp_ifType_ds3,                    /* T-3 */
+  snmp_ifType_sip,                    /* SMDS */
+  snmp_ifType_frame_relay
+};
+
+/* This macro has a precision of ~49 days because sys_now returns u32_t. #define your own if you want ~490 days. */
+#ifndef MIB2_COPY_SYSUPTIME_TO
+#define MIB2_COPY_SYSUPTIME_TO(ptrToVal) (*(ptrToVal) = (sys_now() / 10))
+#endif
+
+#define MIB2_STATS_NETIF_INC(n, x)      do { ++(n)->x; } while(0)
+#define MIB2_STATS_NETIF_ADD(n, x, val) do { (n)->x += val; } while(0)
+
+#define MIB2_INIT_NETIF(netif, type, speed) do { \
+  /* use "snmp_ifType" enum from snmp_mib2.h for "type", snmp_ifType_ethernet_csmacd by example */ \
+  (netif)->link_type = (type);  \
+  /* your link speed here (units: bits per second) */  \
+  (netif)->link_speed = (speed);\
+  (netif)->ts = 0;              \
+  (netif)->ifinoctets = 0;      \
+  (netif)->ifinucastpkts = 0;   \
+  (netif)->ifinnucastpkts = 0;  \
+  (netif)->ifindiscards = 0;    \
+  (netif)->ifoutoctets = 0;     \
+  (netif)->ifoutucastpkts = 0;  \
+  (netif)->ifoutnucastpkts = 0; \
+  (netif)->ifoutdiscards = 0; } while(0)
+#else /* MIB2_STATS */
+#ifndef MIB2_COPY_SYSUPTIME_TO
+#define MIB2_COPY_SYSUPTIME_TO(ptrToVal)
+#endif
+#define MIB2_INIT_NETIF(netif, type, speed)
+#define MIB2_STATS_NETIF_INC(n, x)
+#define MIB2_STATS_NETIF_ADD(n, x, val)
+#endif /* MIB2_STATS */
+
+/* LWIP MIB2 callbacks */
+#if LWIP_MIB2_CALLBACKS /* don't build if not configured for use in lwipopts.h */
+/* network interface */
+void mib2_netif_added(struct netif *ni);
+void mib2_netif_removed(struct netif *ni);
+
+#if LWIP_IPV4 && LWIP_ARP
+/* ARP (for atTable and ipNetToMediaTable) */
+void mib2_add_arp_entry(struct netif *ni, ip4_addr_t *ip);
+void mib2_remove_arp_entry(struct netif *ni, ip4_addr_t *ip);
+#else /* LWIP_IPV4 && LWIP_ARP */
+#define mib2_add_arp_entry(ni,ip)
+#define mib2_remove_arp_entry(ni,ip)
+#endif /* LWIP_IPV4 && LWIP_ARP */
+
+/* IP */
+void mib2_add_ip4(struct netif *ni);
+void mib2_remove_ip4(struct netif *ni);
+void mib2_add_route_ip4(u8_t dflt, struct netif *ni);
+void mib2_remove_route_ip4(u8_t dflt, struct netif *ni);
+
+/* UDP */
+void mib2_udp_bind(struct udp_pcb *pcb);
+void mib2_udp_unbind(struct udp_pcb *pcb);
+
+#else /* LWIP_MIB2_CALLBACKS */
+/* LWIP_MIB2_CALLBACKS support not available */
+/* define everything to be empty */
+
+/* network interface */
+#define mib2_netif_added(ni)
+#define mib2_netif_removed(ni)
+
+/* ARP */
+#define mib2_add_arp_entry(ni,ip)
+#define mib2_remove_arp_entry(ni,ip)
+
+/* IP */
+#define mib2_add_ip4(ni)
+#define mib2_remove_ip4(ni)
+#define mib2_add_route_ip4(dflt, ni)
+#define mib2_remove_route_ip4(dflt, ni)
+
+/* UDP */
+#define mib2_udp_bind(pcb)
+#define mib2_udp_unbind(pcb)
+#endif /* LWIP_MIB2_CALLBACKS */
+
+/* for source-code compatibility reasons only, can be removed (not used internally) */
+#define NETIF_INIT_SNMP                MIB2_INIT_NETIF
+#define snmp_add_ifinoctets(ni,value)  MIB2_STATS_NETIF_ADD(ni, ifinoctets, value)
+#define snmp_inc_ifinucastpkts(ni)     MIB2_STATS_NETIF_INC(ni, ifinucastpkts)
+#define snmp_inc_ifinnucastpkts(ni)    MIB2_STATS_NETIF_INC(ni, ifinnucastpkts)
+#define snmp_inc_ifindiscards(ni)      MIB2_STATS_NETIF_INC(ni, ifindiscards)
+#define snmp_add_ifoutoctets(ni,value) MIB2_STATS_NETIF_ADD(ni, ifoutoctets, value)
+#define snmp_inc_ifoutucastpkts(ni)    MIB2_STATS_NETIF_INC(ni, ifoutucastpkts)
+#define snmp_inc_ifoutnucastpkts(ni)   MIB2_STATS_NETIF_INC(ni, ifoutnucastpkts)
+#define snmp_inc_ifoutdiscards(ni)     MIB2_STATS_NETIF_INC(ni, ifoutdiscards)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_SNMP_MIB2_H */
diff --git a/src/include/lwip/snmp_structs.h b/src/include/lwip/snmp_structs.h
index c829345..4ed2866 100644
--- a/src/include/lwip/snmp_structs.h
+++ b/src/include/lwip/snmp_structs.h
@@ -259,6 +259,37 @@ const struct mib_node* snmp_expand_tree(const struct mib_node *node, u8_t ident_
 u8_t snmp_iso_prefix_tst(u8_t ident_len, s32_t *ident);
 u8_t snmp_iso_prefix_expand(u8_t ident_len, s32_t *ident, struct snmp_obj_id *oidret);
 
+/* SNMP stack internal MIB2 statistics */
+void mib2_inc_snmpinpkts(void);
+void mib2_inc_snmpoutpkts(void);
+void mib2_inc_snmpinbadversions(void);
+void mib2_inc_snmpinbadcommunitynames(void);
+void mib2_inc_snmpinbadcommunityuses(void);
+void mib2_inc_snmpinasnparseerrs(void);
+void mib2_inc_snmpintoobigs(void);
+void mib2_inc_snmpinnosuchnames(void);
+void mib2_inc_snmpinbadvalues(void);
+void mib2_inc_snmpinreadonlys(void);
+void mib2_inc_snmpingenerrs(void);
+void mib2_add_snmpintotalreqvars(u8_t value);
+void mib2_add_snmpintotalsetvars(u8_t value);
+void mib2_inc_snmpingetrequests(void);
+void mib2_inc_snmpingetnexts(void);
+void mib2_inc_snmpinsetrequests(void);
+void mib2_inc_snmpingetresponses(void);
+void mib2_inc_snmpintraps(void);
+void mib2_inc_snmpouttoobigs(void);
+void mib2_inc_snmpoutnosuchnames(void);
+void mib2_inc_snmpoutbadvalues(void);
+void mib2_inc_snmpoutgenerrs(void);
+void mib2_inc_snmpoutgetrequests(void);
+void mib2_inc_snmpoutgetnexts(void);
+void mib2_inc_snmpoutsetrequests(void);
+void mib2_inc_snmpoutgetresponses(void);
+void mib2_inc_snmpouttraps(void);
+void mib2_get_snmpgrpid_ptr(const struct snmp_obj_id **oid);
+void mib2_get_snmpenableauthentraps(u8_t *value);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/include/lwip/stats.h b/src/include/lwip/stats.h
index 6385318..d1731c0 100644
--- a/src/include/lwip/stats.h
+++ b/src/include/lwip/stats.h
@@ -110,6 +110,72 @@ struct stats_sys {
   struct stats_syselem mbox;
 };
 
+struct stats_mib2 {
+  /* IP */
+  u32_t ipinhdrerrors;
+  u32_t ipinaddrerrors;
+  u32_t ipinunknownprotos;
+  u32_t ipindiscards;
+  u32_t ipindelivers;
+  u32_t ipoutrequests;
+  u32_t ipoutdiscards;
+  u32_t ipoutnoroutes;
+  u32_t ipreasmoks; /* @todo: never incremented */
+  u32_t ipreasmfails;
+  u32_t ipfragoks;
+  u32_t ipfragfails; /* @todo: never incremented */
+  u32_t ipfragcreates;
+  u32_t iproutingdiscards; /* @todo: never incremented */
+  u32_t ipreasmreqds;
+  u32_t ipforwdatagrams;
+  u32_t ipinreceives;
+
+  /* TCP */
+  u32_t tcpactiveopens;
+  u32_t tcppassiveopens;
+  u32_t tcpattemptfails;
+  u32_t tcpestabresets;
+  u32_t tcpoutsegs;
+  u32_t tcpretranssegs;
+  u32_t tcpinsegs;
+  u32_t tcpinerrs;
+  u32_t tcpoutrsts;
+
+  /* UDP */
+  u32_t udpindatagrams;
+  u32_t udpnoports;
+  u32_t udpinerrors;
+  u32_t udpoutdatagrams;
+
+  /* ICMP */
+  u32_t icmpinmsgs;
+  u32_t icmpinerrors;
+  u32_t icmpindestunreachs; /* @todo: never incremented */
+  u32_t icmpintimeexcds; /* @todo: never incremented */
+  u32_t icmpinparmprobs; /* @todo: never incremented */
+  u32_t icmpinsrcquenchs; /* @todo: never incremented */
+  u32_t icmpinredirects; /* @todo: never incremented */
+  u32_t icmpinechos; /* @todo: never incremented */
+  u32_t icmpinechoreps; /* @todo: never incremented */
+  u32_t icmpintimestamps; /* @todo: never incremented */
+  u32_t icmpintimestampreps; /* @todo: never incremented */
+  u32_t icmpinaddrmasks; /* @todo: never incremented */
+  u32_t icmpinaddrmaskreps; /* @todo: never incremented */
+  u32_t icmpoutmsgs;
+  u32_t icmpouterrors; /* @todo: never incremented */
+  u32_t icmpoutdestunreachs; /* @todo: never incremented */
+  u32_t icmpouttimeexcds;
+  u32_t icmpoutparmprobs; /* @todo: never incremented */
+  u32_t icmpoutsrcquenchs; /* @todo: never incremented */
+  u32_t icmpoutredirects; /* @todo: never incremented */
+  u32_t icmpoutechos; /* @todo: never incremented */
+  u32_t icmpoutechoreps;
+  u32_t icmpouttimestamps; /* @todo: never incremented */
+  u32_t icmpouttimestampreps; /* @todo: never incremented */
+  u32_t icmpoutaddrmasks; /* @todo: never incremented */
+  u32_t icmpoutaddrmaskreps; /* @todo: never incremented */
+};
+
 struct stats_ {
 #if LINK_STATS
   struct stats_proto link;
@@ -159,6 +225,9 @@ struct stats_ {
 #if ND6_STATS
   struct stats_proto nd6;
 #endif
+#if MIB2_STATS
+  struct stats_mib2 mib2;
+#endif
 };
 
 extern struct stats_ lwip_stats;
@@ -172,6 +241,7 @@ void stats_init(void);
                                     lwip_stats.x.max = lwip_stats.x.used; \
                                 } \
                              } while(0)
+#define STATS_GET(x) lwip_stats.x
 #else /* LWIP_STATS */
 #define stats_init()
 #define STATS_INC(x)
@@ -323,6 +393,12 @@ void stats_init(void);
 #define ND6_STATS_DISPLAY()
 #endif
 
+#if MIB2_STATS
+#define MIB2_STATS_INC(x) STATS_INC(x)
+#else
+#define MIB2_STATS_INC(x)
+#endif
+
 /* Display of statistics */
 #if LWIP_STATS_DISPLAY
 void stats_display(void);
diff --git a/src/include/netif/ppp/chap-new.h b/src/include/netif/ppp/chap-new.h
index 9e4b864..9b7c048 100644
--- a/src/include/netif/ppp/chap-new.h
+++ b/src/include/netif/ppp/chap-new.h
@@ -140,7 +140,7 @@ struct chap_digest_type {
 #endif /* PPP_SERVER */
 	void (*make_response)(ppp_pcb *pcb, unsigned char *response, int id, const char *our_name,
 		const unsigned char *challenge, const char *secret, int secret_len,
-		const unsigned char *priv);
+		unsigned char *priv);
 	int (*check_success)(ppp_pcb *pcb, unsigned char *pkt, int len, unsigned char *priv);
 	void (*handle_failure)(ppp_pcb *pcb, unsigned char *pkt, int len);
 };
diff --git a/src/include/netif/ppp/fsm.h b/src/include/netif/ppp/fsm.h
index fda2d6e..fc0a4b1 100644
--- a/src/include/netif/ppp/fsm.h
+++ b/src/include/netif/ppp/fsm.h
@@ -168,7 +168,7 @@ void fsm_open(fsm *f);
 void fsm_close(fsm *f, const char *reason);
 void fsm_input(fsm *f, u_char *inpacket, int l);
 void fsm_protreject(fsm *f);
-void fsm_sdata(fsm *f, u_char code, u_char id, u_char *data, int datalen);
+void fsm_sdata(fsm *f, u_char code, u_char id, const u_char *data, int datalen);
 
 
 #endif /* FSM_H */
diff --git a/src/include/netif/ppp/mppe.h b/src/include/netif/ppp/mppe.h
index 49e4cfb..9308695 100644
--- a/src/include/netif/ppp/mppe.h
+++ b/src/include/netif/ppp/mppe.h
@@ -101,7 +101,7 @@
 /* The reverse of the above */
 #define MPPE_CI_TO_OPTS(ci, opts)		\
     do {					\
-	u_char *ptr = ci; /* u_char[4] */	\
+	const u_char *ptr = ci; /* u_char[4] */	\
 						\
 	opts = 0;				\
 						\
diff --git a/src/include/netif/ppp/polarssl/des.h b/src/include/netif/ppp/polarssl/des.h
index 86417cd..d0858bd 100644
--- a/src/include/netif/ppp/polarssl/des.h
+++ b/src/include/netif/ppp/polarssl/des.h
@@ -80,7 +80,7 @@ void des_setkey_dec( des_context *ctx, unsigned char key[8] );
  * \param output   64-bit output block
  */
 void des_crypt_ecb( des_context *ctx,
-                    unsigned char input[8],
+                    const unsigned char input[8],
                     unsigned char output[8] );
 
 #ifdef __cplusplus
diff --git a/src/include/netif/ppp/polarssl/md4.h b/src/include/netif/ppp/polarssl/md4.h
index 46ebf5c..a382f85 100644
--- a/src/include/netif/ppp/polarssl/md4.h
+++ b/src/include/netif/ppp/polarssl/md4.h
@@ -68,7 +68,7 @@ void md4_starts( md4_context *ctx );
  * \param input    buffer holding the  data
  * \param ilen     length of the input data
  */
-void md4_update( md4_context *ctx, unsigned char *input, int ilen );
+void md4_update( md4_context *ctx, const unsigned char *input, int ilen );
 
 /**
  * \brief          MD4 final digest
diff --git a/src/include/netif/ppp/polarssl/md5.h b/src/include/netif/ppp/polarssl/md5.h
index 3587b4c..a299d98 100644
--- a/src/include/netif/ppp/polarssl/md5.h
+++ b/src/include/netif/ppp/polarssl/md5.h
@@ -68,7 +68,7 @@ void md5_starts( md5_context *ctx );
  * \param input    buffer holding the  data
  * \param ilen     length of the input data
  */
-void md5_update( md5_context *ctx, unsigned char *input, int ilen );
+void md5_update( md5_context *ctx, const unsigned char *input, int ilen );
 
 /**
  * \brief          MD5 final digest
diff --git a/src/include/netif/ppp/polarssl/sha1.h b/src/include/netif/ppp/polarssl/sha1.h
index 9d33163..56d947c 100644
--- a/src/include/netif/ppp/polarssl/sha1.h
+++ b/src/include/netif/ppp/polarssl/sha1.h
@@ -68,7 +68,7 @@ void sha1_starts( sha1_context *ctx );
  * \param input    buffer holding the  data
  * \param ilen     length of the input data
  */
-void sha1_update( sha1_context *ctx, unsigned char *input, int ilen );
+void sha1_update( sha1_context *ctx, const unsigned char *input, int ilen );
 
 /**
  * \brief          SHA-1 final digest
diff --git a/src/include/netif/ppp/ppp_impl.h b/src/include/netif/ppp/ppp_impl.h
index caf499a..47423bc 100644
--- a/src/include/netif/ppp/ppp_impl.h
+++ b/src/include/netif/ppp/ppp_impl.h
@@ -151,8 +151,6 @@ struct link_callbacks {
   void (*send_config)(ppp_pcb *pcb, void *ctx, u32_t accm, int pcomp, int accomp);
   /* confire the receive-side characteristics of the PPP interface */
   void (*recv_config)(ppp_pcb *pcb, void *ctx, u32_t accm, int pcomp, int accomp);
-  /* Get and set parameters for the given connection. */
-  err_t (*ioctl)(ppp_pcb *pcb, void *ctx, int cmd, void *arg);
 };
 
 /*
@@ -290,7 +288,7 @@ struct protent {
     void (*close) (ppp_pcb *pcb, const char *reason);
 #if PRINTPKT_SUPPORT
     /* Print a packet in readable form */
-    int  (*printpkt) (u_char *pkt, int len,
+    int  (*printpkt) (const u_char *pkt, int len,
 			  void (*printer) (void *, const char *, ...),
 			  void *arg);
 #endif /* PRINTPKT_SUPPORT */
@@ -389,10 +387,8 @@ int ppp_init(void);
  */
 
 /* Create a new PPP control block */
-ppp_pcb *ppp_new(struct netif *pppif, ppp_link_status_cb_fn link_status_cb, void *ctx_cb);
-
-/* Set link callback functions */
-void ppp_link_set_callbacks(ppp_pcb *pcb, const struct link_callbacks *callbacks, void *ctx);
+ppp_pcb *ppp_new(struct netif *pppif, const struct link_callbacks *callbacks, void *link_ctx_cb,
+                 ppp_link_status_cb_fn link_status_cb, void *ctx_cb);
 
 /* Set a PPP PCB to its initial state */
 void ppp_clear(ppp_pcb *pcb);
diff --git a/src/include/netif/ppp/pppos.h b/src/include/netif/ppp/pppos.h
index e172139..39b2b7d 100644
--- a/src/include/netif/ppp/pppos.h
+++ b/src/include/netif/ppp/pppos.h
@@ -55,6 +55,9 @@ enum {
   PDDATA       /* Process data byte. */
 };
 
+/* PPPoS serial output callback function prototype */
+typedef u32_t (*pppos_output_cb_fn)(ppp_pcb *pcb, u8_t *data, u32_t len, void *ctx);
+
 /*
  * Extended asyncmap - allows any character to be escaped.
  */
@@ -67,7 +70,7 @@ typedef struct pppos_pcb_s pppos_pcb;
 struct pppos_pcb_s {
   /* -- below are data that will NOT be cleared between two sessions */
   ppp_pcb *ppp;                    /* PPP PCB */
-  sio_fd_t fd;                     /* File device ID of port. */
+  pppos_output_cb_fn output_cb;    /* PPP serial output callback */
 
   /* -- below are data that will be cleared between two sessions
    *
@@ -92,7 +95,7 @@ struct pppos_pcb_s {
 };
 
 /* Create a new PPPoS session. */
-ppp_pcb *pppos_create(struct netif *pppif, sio_fd_t fd,
+ppp_pcb *pppos_create(struct netif *pppif, pppos_output_cb_fn output_cb,
        ppp_link_status_cb_fn link_status_cb, void *ctx_cb);
 
 #if !NO_SYS && !PPP_INPROC_IRQ_SAFE
diff --git a/src/netif/etharp.c b/src/netif/etharp.c
index 353ac0f..cd3c24f 100644
--- a/src/netif/etharp.c
+++ b/src/netif/etharp.c
@@ -51,7 +51,7 @@
 #include "lwip/def.h"
 #include "lwip/ip.h"
 #include "lwip/stats.h"
-#include "lwip/snmp.h"
+#include "lwip/snmp_mib2.h"
 #include "lwip/dhcp.h"
 #include "lwip/autoip.h"
 #include "netif/etharp.h"
@@ -184,7 +184,7 @@ static void
 etharp_free_entry(int i)
 {
   /* remove from SNMP ARP index tree */
-  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
+  mib2_remove_arp_entry(arp_table[i].netif, &arp_table[i].ipaddr);
   /* and empty packet queue */
   if (arp_table[i].q != NULL) {
     /* remove all queued packets */
@@ -512,7 +512,7 @@ etharp_update_arp_entry(struct netif *netif, const ip4_addr_t *ipaddr, struct et
   /* record network interface */
   arp_table[i].netif = netif;
   /* insert in SNMP ARP index tree */
-  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);
+  mib2_add_arp_entry(netif, &arp_table[i].ipaddr);
 
   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
   /* update address */
diff --git a/src/netif/ppp/ccp.c b/src/netif/ppp/ccp.c
index 9a04394..935e176 100644
--- a/src/netif/ppp/ccp.c
+++ b/src/netif/ppp/ccp.c
@@ -173,7 +173,7 @@ static void ccp_lowerdown(ppp_pcb *pcb);
 static void ccp_input(ppp_pcb *pcb, u_char *pkt, int len);
 static void ccp_protrej(ppp_pcb *pcb);
 #if PRINTPKT_SUPPORT
-static int ccp_printpkt(u_char *p, int plen, void (*printer) (void *, const char *, ...), void *arg);
+static int ccp_printpkt(const u_char *p, int plen, void (*printer) (void *, const char *, ...), void *arg);
 #endif /* PRINTPKT_SUPPORT */
 #if PPP_DATAINPUT
 static void ccp_datainput(ppp_pcb *pcb, u_char *pkt, int len);
@@ -1519,8 +1519,8 @@ static const char* const ccp_codenames[] = {
     "ResetReq", "ResetAck",
 };
 
-static int ccp_printpkt(u_char *p, int plen, void (*printer) (void *, const char *, ...), void *arg) {
-    u_char *p0, *optend;
+static int ccp_printpkt(const u_char *p, int plen, void (*printer) (void *, const char *, ...), void *arg) {
+    const u_char *p0, *optend;
     int code, id, len;
     int optlen;
 
diff --git a/src/netif/ppp/chap-md5.c b/src/netif/ppp/chap-md5.c
index 842a449..4a2bb05 100644
--- a/src/netif/ppp/chap-md5.c
+++ b/src/netif/ppp/chap-md5.c
@@ -97,7 +97,7 @@ static int chap_md5_verify_response(ppp_pcb *pcb, int id, const char *name,
 
 static void chap_md5_make_response(ppp_pcb *pcb, unsigned char *response, int id, const char *our_name,
 		       const unsigned char *challenge, const char *secret, int secret_len,
-		       const unsigned char *private_) {
+		       unsigned char *private_) {
 	md5_context ctx;
 	unsigned char idbyte = id;
 	int challenge_len = *challenge++;
@@ -107,8 +107,8 @@ static void chap_md5_make_response(ppp_pcb *pcb, unsigned char *response, int id
 
 	md5_starts(&ctx);
 	md5_update(&ctx, &idbyte, 1);
-	md5_update(&ctx, (u_char *)secret, secret_len);
-	md5_update(&ctx, (unsigned char *)challenge, challenge_len);
+	md5_update(&ctx, (const u_char *)secret, secret_len);
+	md5_update(&ctx, challenge, challenge_len);
 	md5_finish(&ctx, &response[1]);
 	response[0] = MD5_HASH_SIZE;
 }
diff --git a/src/netif/ppp/chap-new.c b/src/netif/ppp/chap-new.c
index 10c97db..4661b98 100644
--- a/src/netif/ppp/chap-new.c
+++ b/src/netif/ppp/chap-new.c
@@ -104,7 +104,7 @@ static void chap_handle_status(ppp_pcb *pcb, int code, int id,
 static void chap_protrej(ppp_pcb *pcb);
 static void chap_input(ppp_pcb *pcb, unsigned char *pkt, int pktlen);
 #if PRINTPKT_SUPPORT
-static int chap_print_pkt(unsigned char *p, int plen,
+static int chap_print_pkt(const unsigned char *p, int plen,
 		void (*printer) (void *, const char *, ...), void *arg);
 #endif /* PRINTPKT_SUPPORT */
 
@@ -590,7 +590,7 @@ static const char* const chap_code_names[] = {
 	"Challenge", "Response", "Success", "Failure"
 };
 
-static int chap_print_pkt(unsigned char *p, int plen,
+static int chap_print_pkt(const unsigned char *p, int plen,
 	       void (*printer) (void *, const char *, ...), void *arg) {
 	int code, id, len;
 	int clen, nlen;
diff --git a/src/netif/ppp/chap_ms.c b/src/netif/ppp/chap_ms.c
index 0ac8382..d35db5e 100644
--- a/src/netif/ppp/chap_ms.c
+++ b/src/netif/ppp/chap_ms.c
@@ -168,32 +168,32 @@ extern void set_mppe_enc_types(int, int);
 #define MS_CHAP2_AUTHENTICATEE 0
 #define MS_CHAP2_AUTHENTICATOR 1
 
-static void	ascii2unicode (char[], int, u_char[]);
+static void	ascii2unicode (const char[], int, u_char[]);
 static void	NTPasswordHash (u_char *, int, u_char[MD4_SIGNATURE_SIZE]);
-static void	ChallengeResponse (u_char *, u_char *, u_char[24]);
-static void	ChallengeHash (u_char[16], u_char *, char *, u_char[8]);
-static void	ChapMS_NT (u_char *, char *, int, u_char[24]);
-static void	ChapMS2_NT (u_char *, u_char[16], char *, char *, int,
+static void	ChallengeResponse (const u_char *, const u_char *, u_char[24]);
+static void	ChallengeHash (const u_char[16], const u_char *, const char *, u_char[8]);
+static void	ChapMS_NT (const u_char *, const char *, int, u_char[24]);
+static void	ChapMS2_NT (const u_char *, const u_char[16], const char *, const char *, int,
 				u_char[24]);
 static void	GenerateAuthenticatorResponsePlain
-			(char*, int, u_char[24], u_char[16], u_char *,
-			     char *, u_char[41]);
+			(const char*, int, u_char[24], const u_char[16], const u_char *,
+			     const char *, u_char[41]);
 #ifdef MSLANMAN
 static void	ChapMS_LANMan (u_char *, char *, int, u_char *);
 #endif
 
-static void GenerateAuthenticatorResponse(u_char PasswordHashHash[MD4_SIGNATURE_SIZE],
-			u_char NTResponse[24], u_char PeerChallenge[16],
-			u_char *rchallenge, char *username,
+static void GenerateAuthenticatorResponse(const u_char PasswordHashHash[MD4_SIGNATURE_SIZE],
+			u_char NTResponse[24], const u_char PeerChallenge[16],
+			const u_char *rchallenge, const char *username,
 			u_char authResponse[MS_AUTH_RESPONSE_LENGTH+1]);
 
 #if MPPE_SUPPORT
-static void	Set_Start_Key (ppp_pcb *pcb, u_char *, char *, int);
-static void	SetMasterKeys (ppp_pcb *pcb, char *, int, u_char[24], int);
+static void	Set_Start_Key (ppp_pcb *pcb, const u_char *, const char *, int);
+static void	SetMasterKeys (ppp_pcb *pcb, const char *, int, u_char[24], int);
 #endif /* MPPE_SUPPORT */
 
-static void ChapMS (ppp_pcb *pcb, u_char *, char *, int, u_char *);
-static void ChapMS2 (ppp_pcb *pcb, u_char *, u_char *, char *, char *, int,
+static void ChapMS (ppp_pcb *pcb, const u_char *, const char *, int, u_char *);
+static void ChapMS2 (ppp_pcb *pcb, const u_char *, const u_char *, const char *, const char *, int,
 		  u_char *, u_char[MS_AUTH_RESPONSE_LENGTH+1], int);
 
 #ifdef MSLANMAN
@@ -391,28 +391,28 @@ static int chapms2_verify_response(ppp_pcb *pcb, int id, const char *name,
 
 static void chapms_make_response(ppp_pcb *pcb, unsigned char *response, int id, const char *our_name,
 		     const unsigned char *challenge, const char *secret, int secret_len,
-		     const unsigned char *private_) {
+		     unsigned char *private_) {
 	LWIP_UNUSED_ARG(id);
 	LWIP_UNUSED_ARG(our_name);
 	LWIP_UNUSED_ARG(private_);
 	challenge++;	/* skip length, should be 8 */
 	*response++ = MS_CHAP_RESPONSE_LEN;
-	ChapMS(pcb, (u_char*)challenge, (char*)secret, secret_len, response);
+	ChapMS(pcb, challenge, secret, secret_len, response);
 }
 
 static void chapms2_make_response(ppp_pcb *pcb, unsigned char *response, int id, const char *our_name,
 		      const unsigned char *challenge, const char *secret, int secret_len,
-		      const unsigned char *private_) {
+		      unsigned char *private_) {
 	LWIP_UNUSED_ARG(id);
 	challenge++;	/* skip length, should be 16 */
 	*response++ = MS_CHAP2_RESPONSE_LEN;
-	ChapMS2(pcb, (u_char*)challenge,
+	ChapMS2(pcb, challenge,
 #ifdef DEBUGMPPEKEY
 		mschap2_peer_challenge,
 #else
 		NULL,
 #endif
-		(char*)our_name, (char*)secret, secret_len, response, (u_char*)private_,
+		our_name, secret, secret_len, response, private_,
 		MS_CHAP2_AUTHENTICATEE);
 }
 
@@ -511,8 +511,8 @@ print_msg:
 		ppp_error("MS-CHAP authentication failed: %v", p);
 }
 
-static void ChallengeResponse(u_char *challenge,
-		  u_char PasswordHash[MD4_SIGNATURE_SIZE],
+static void ChallengeResponse(const u_char *challenge,
+		  const u_char PasswordHash[MD4_SIGNATURE_SIZE],
 		  u_char response[24]) {
     u_char    ZPasswordHash[21];
     des_context des;
@@ -543,11 +543,11 @@ static void ChallengeResponse(u_char *challenge,
 #endif
 }
 
-static void ChallengeHash(u_char PeerChallenge[16], u_char *rchallenge,
-	      char *username, u_char Challenge[8]) {
+static void ChallengeHash(const u_char PeerChallenge[16], const u_char *rchallenge,
+	      const char *username, u_char Challenge[8]) {
     sha1_context	sha1Context;
     u_char	sha1Hash[SHA1_SIGNATURE_SIZE];
-    char	*user;
+    const char	*user;
 
     /* remove domain from "domain\username" */
     if ((user = strrchr(username, '\\')) != NULL)
@@ -558,7 +558,7 @@ static void ChallengeHash(u_char PeerChallenge[16], u_char *rchallenge,
     sha1_starts(&sha1Context);
     sha1_update(&sha1Context, PeerChallenge, 16);
     sha1_update(&sha1Context, rchallenge, 16);
-    sha1_update(&sha1Context, (unsigned char *)user, strlen(user));
+    sha1_update(&sha1Context, (const unsigned char*)user, strlen(user));
     sha1_finish(&sha1Context, sha1Hash);
 
     MEMCPY(Challenge, sha1Hash, 8);
@@ -571,7 +571,7 @@ static void ChallengeHash(u_char PeerChallenge[16], u_char *rchallenge,
  * is assumed by all M$ CHAP RFCs.  (Unicode byte ordering
  * is machine-dependent.)
  */
-static void ascii2unicode(char ascii[], int ascii_len, u_char unicode[]) {
+static void ascii2unicode(const char ascii[], int ascii_len, u_char unicode[]) {
     int i;
 
     BZERO(unicode, ascii_len * 2);
@@ -587,7 +587,7 @@ static void NTPasswordHash(u_char *secret, int secret_len, u_char hash[MD4_SIGNA
     md4_finish(&md4Context, hash);
 }
 
-static void ChapMS_NT(u_char *rchallenge, char *secret, int secret_len,
+static void ChapMS_NT(const u_char *rchallenge, const char *secret, int secret_len,
 	  u_char NTResponse[24]) {
     u_char	unicodePassword[MAX_NT_PASSWORD * 2];
     u_char	PasswordHash[MD4_SIGNATURE_SIZE];
@@ -599,8 +599,8 @@ static void ChapMS_NT(u_char *rchallenge, char *secret, int secret_len,
     ChallengeResponse(rchallenge, PasswordHash, NTResponse);
 }
 
-static void ChapMS2_NT(u_char *rchallenge, u_char PeerChallenge[16], char *username,
-	   char *secret, int secret_len, u_char NTResponse[24]) {
+static void ChapMS2_NT(const u_char *rchallenge, const u_char PeerChallenge[16], const char *username,
+	   const char *secret, int secret_len, u_char NTResponse[24]) {
     u_char	unicodePassword[MAX_NT_PASSWORD * 2];
     u_char	PasswordHash[MD4_SIGNATURE_SIZE];
     u_char	Challenge[8];
@@ -643,9 +643,9 @@ static void ChapMS_LANMan(u_char *rchallenge, char *secret, int secret_len,
 #endif
 
 
-static void GenerateAuthenticatorResponse(u_char PasswordHashHash[MD4_SIGNATURE_SIZE],
-			      u_char NTResponse[24], u_char PeerChallenge[16],
-			      u_char *rchallenge, char *username,
+static void GenerateAuthenticatorResponse(const u_char PasswordHashHash[MD4_SIGNATURE_SIZE],
+			      u_char NTResponse[24], const u_char PeerChallenge[16],
+			      const u_char *rchallenge, const char *username,
 			      u_char authResponse[MS_AUTH_RESPONSE_LENGTH+1]) {
     /*
      * "Magic" constants used in response generation, from RFC 2759.
@@ -670,7 +670,7 @@ static void GenerateAuthenticatorResponse(u_char PasswordHashHash[MD4_SIGNATURE_
     sha1_starts(&sha1Context);
     sha1_update(&sha1Context, PasswordHashHash, MD4_SIGNATURE_SIZE);
     sha1_update(&sha1Context, NTResponse, 24);
-    sha1_update(&sha1Context, (unsigned char *)Magic1, sizeof(Magic1));
+    sha1_update(&sha1Context, Magic1, sizeof(Magic1));
     sha1_finish(&sha1Context, Digest);
 
     ChallengeHash(PeerChallenge, rchallenge, username, Challenge);
@@ -678,7 +678,7 @@ static void GenerateAuthenticatorResponse(u_char PasswordHashHash[MD4_SIGNATURE_
     sha1_starts(&sha1Context);
     sha1_update(&sha1Context, Digest, sizeof(Digest));
     sha1_update(&sha1Context, Challenge, sizeof(Challenge));
-    sha1_update(&sha1Context, (unsigned char *)Magic2, sizeof(Magic2));
+    sha1_update(&sha1Context, Magic2, sizeof(Magic2));
     sha1_finish(&sha1Context, Digest);
 
     /* Convert to ASCII hex string. */
@@ -687,10 +687,10 @@ static void GenerateAuthenticatorResponse(u_char PasswordHashHash[MD4_SIGNATURE_
 }
 
 
-static void GenerateAuthenticatorResponsePlain
-		(char *secret, int secret_len,
-		 u_char NTResponse[24], u_char PeerChallenge[16],
-		 u_char *rchallenge, char *username,
+static void GenerateAuthenticatorResponsePlain(
+		 const char *secret, int secret_len,
+		 u_char NTResponse[24], const u_char PeerChallenge[16],
+		 const u_char *rchallenge, const char *username,
 		 u_char authResponse[MS_AUTH_RESPONSE_LENGTH+1]) {
     u_char	unicodePassword[MAX_NT_PASSWORD * 2];
     u_char	PasswordHash[MD4_SIGNATURE_SIZE];
@@ -711,7 +711,7 @@ static void GenerateAuthenticatorResponsePlain
 /*
  * Set mppe_xxxx_key from MS-CHAP credentials. (see RFC 3079)
  */
-static void Set_Start_Key(ppp_pcb *pcb, u_char *rchallenge, char *secret, int secret_len) {
+static void Set_Start_Key(ppp_pcb *pcb, const u_char *rchallenge, const char *secret, int secret_len) {
     u_char	unicodePassword[MAX_NT_PASSWORD * 2];
     u_char	PasswordHash[MD4_SIGNATURE_SIZE];
     u_char	PasswordHashHash[MD4_SIGNATURE_SIZE];
@@ -739,7 +739,7 @@ static void Set_Start_Key(ppp_pcb *pcb, u_char *rchallenge, char *secret, int se
 /*
  * Set mppe_xxxx_key from MS-CHAPv2 credentials. (see RFC 3079)
  */
-static void SetMasterKeys(ppp_pcb *pcb, char *secret, int secret_len, u_char NTResponse[24], int IsServer) {
+static void SetMasterKeys(ppp_pcb *pcb, const char *secret, int secret_len, u_char NTResponse[24], int IsServer) {
     u_char	unicodePassword[MAX_NT_PASSWORD * 2];
     u_char	PasswordHash[MD4_SIGNATURE_SIZE];
     u_char	PasswordHashHash[MD4_SIGNATURE_SIZE];
@@ -786,7 +786,7 @@ static void SetMasterKeys(ppp_pcb *pcb, char *secret, int secret_len, u_char NTR
     sha1_starts(&sha1Context);
     sha1_update(&sha1Context, PasswordHashHash, MD4_SIGNATURE_SIZE);
     sha1_update(&sha1Context, NTResponse, 24);
-    sha1_update(&sha1Context, (unsigned char *)Magic1, sizeof(Magic1));
+    sha1_update(&sha1Context, Magic1, sizeof(Magic1));
     sha1_finish(&sha1Context, MasterKey);
 
     /*
@@ -798,9 +798,9 @@ static void SetMasterKeys(ppp_pcb *pcb, char *secret, int secret_len, u_char NTR
 	s = Magic2;
     sha1_starts(&sha1Context);
     sha1_update(&sha1Context, MasterKey, 16);
-    sha1_update(&sha1Context, (unsigned char *)mppe_sha1_pad1, SHA1_PAD_SIZE);
-    sha1_update(&sha1Context, (unsigned char *)s, 84);
-    sha1_update(&sha1Context, (unsigned char *)mppe_sha1_pad2, SHA1_PAD_SIZE);
+    sha1_update(&sha1Context, mppe_sha1_pad1, SHA1_PAD_SIZE);
+    sha1_update(&sha1Context, s, 84);
+    sha1_update(&sha1Context, mppe_sha1_pad2, SHA1_PAD_SIZE);
     sha1_finish(&sha1Context, Digest);
 
     mppe_set_key(pcb, &pcb->mppe_comp, Digest);
@@ -814,9 +814,9 @@ static void SetMasterKeys(ppp_pcb *pcb, char *secret, int secret_len, u_char NTR
 	s = Magic3;
     sha1_starts(&sha1Context);
     sha1_update(&sha1Context, MasterKey, 16);
-    sha1_update(&sha1Context, (unsigned char *)mppe_sha1_pad1, SHA1_PAD_SIZE);
-    sha1_update(&sha1Context, (unsigned char *)s, 84);
-    sha1_update(&sha1Context, (unsigned char *)mppe_sha1_pad2, SHA1_PAD_SIZE);
+    sha1_update(&sha1Context, mppe_sha1_pad1, SHA1_PAD_SIZE);
+    sha1_update(&sha1Context, s, 84);
+    sha1_update(&sha1Context, mppe_sha1_pad2, SHA1_PAD_SIZE);
     sha1_finish(&sha1Context, Digest);
 
     mppe_set_key(pcb, &pcb->mppe_decomp, Digest);
@@ -827,7 +827,7 @@ static void SetMasterKeys(ppp_pcb *pcb, char *secret, int secret_len, u_char NTR
 #endif /* MPPE_SUPPORT */
 
 
-static void ChapMS(ppp_pcb *pcb, u_char *rchallenge, char *secret, int secret_len,
+static void ChapMS(ppp_pcb *pcb, const u_char *rchallenge, const char *secret, int secret_len,
        unsigned char *response) {
 #if !MPPE_SUPPORT
     LWIP_UNUSED_ARG(pcb);
@@ -862,8 +862,8 @@ static void ChapMS(ppp_pcb *pcb, u_char *rchallenge, char *secret, int secret_le
  * The PeerChallenge field of response is then used for calculation of the
  * Authenticator Response.
  */
-static void ChapMS2(ppp_pcb *pcb, u_char *rchallenge, u_char *PeerChallenge,
-	char *user, char *secret, int secret_len, unsigned char *response,
+static void ChapMS2(ppp_pcb *pcb, const u_char *rchallenge, const u_char *PeerChallenge,
+	const char *user, const char *secret, int secret_len, unsigned char *response,
 	u_char authResponse[], int authenticator) {
     /* ARGSUSED */
     LWIP_UNUSED_ARG(authenticator);
diff --git a/src/netif/ppp/eap.c b/src/netif/ppp/eap.c
index 373cb9d..717c8df 100644
--- a/src/netif/ppp/eap.c
+++ b/src/netif/ppp/eap.c
@@ -108,7 +108,7 @@ static void eap_protrej(ppp_pcb *pcb);
 static void eap_lowerup(ppp_pcb *pcb);
 static void eap_lowerdown(ppp_pcb *pcb);
 #if PRINTPKT_SUPPORT
-static int  eap_printpkt(u_char *inp, int inlen,
+static int  eap_printpkt(const u_char *inp, int inlen,
     void (*)(void *arg, const char *fmt, ...), void *arg);
 #endif /* PRINTPKT_SUPPORT */
 
@@ -2135,9 +2135,9 @@ static const char* const eap_typenames[] = {
 	"Cisco", "Nokia", "SRP"
 };
 
-static int eap_printpkt(u_char *inp, int inlen, void (*printer) (void *, const char *, ...), void *arg) {
+static int eap_printpkt(const u_char *inp, int inlen, void (*printer) (void *, const char *, ...), void *arg) {
 	int code, id, len, rtype, vallen;
-	u_char *pstart;
+	const u_char *pstart;
 	u32_t uval;
 
 	if (inlen < EAP_HEADERLEN)
diff --git a/src/netif/ppp/ecp.c b/src/netif/ppp/ecp.c
index 43cbe97..4f1dee3 100644
--- a/src/netif/ppp/ecp.c
+++ b/src/netif/ppp/ecp.c
@@ -91,7 +91,7 @@ static void ecp_input (int unit, u_char *pkt, int len);
 static void ecp_protrej (int unit);
 */
 #if PRINTPKT_SUPPORT
-static int  ecp_printpkt (u_char *pkt, int len,
+static int  ecp_printpkt (const u_char *pkt, int len,
 			      void (*printer) (void *, char *, ...),
 			      void *arg);
 #endif /* PRINTPKT_SUPPORT */
@@ -179,7 +179,7 @@ ecp_init(unit)
 #if PRINTPKT_SUPPORT
 static int
 ecp_printpkt(p, plen, printer, arg)
-    u_char *p;
+    const u_char *p;
     int plen;
     void (*printer) (void *, char *, ...);
     void *arg;
diff --git a/src/netif/ppp/fsm.c b/src/netif/ppp/fsm.c
index 3e63e2f..9237d3d 100644
--- a/src/netif/ppp/fsm.c
+++ b/src/netif/ppp/fsm.c
@@ -208,7 +208,7 @@ static void terminate_layer(fsm *f, int nextstate) {
     /* Init restart counter and send Terminate-Request */
     f->retransmits = pcb->settings.fsm_max_term_transmits;
     fsm_sdata(f, TERMREQ, f->reqid = ++f->id,
-	      (u_char *) f->term_reason, f->term_reason_len);
+	      (const u_char *) f->term_reason, f->term_reason_len);
 
     if (f->retransmits == 0) {
 	/*
@@ -280,7 +280,7 @@ static void fsm_timeout(void *arg) {
 	} else {
 	    /* Send Terminate-Request */
 	    fsm_sdata(f, TERMREQ, f->reqid = ++f->id,
-		      (u_char *) f->term_reason, f->term_reason_len);
+		      (const u_char *) f->term_reason, f->term_reason_len);
 	    TIMEOUT(fsm_timeout, f, pcb->settings.fsm_timeout_time);
 	    --f->retransmits;
 	}
@@ -767,7 +767,7 @@ static void fsm_sconfreq(fsm *f, int retransmit) {
  *
  * Used for all packets sent to our peer by this module.
  */
-void fsm_sdata(fsm *f, u_char code, u_char id, u_char *data, int datalen) {
+void fsm_sdata(fsm *f, u_char code, u_char id, const u_char *data, int datalen) {
     ppp_pcb *pcb = f->pcb;
     struct pbuf *p;
     u_char *outp;
diff --git a/src/netif/ppp/ipcp.c b/src/netif/ppp/ipcp.c
index b694c75..d19561a 100644
--- a/src/netif/ppp/ipcp.c
+++ b/src/netif/ppp/ipcp.c
@@ -264,7 +264,7 @@ static void ipcp_lowerdown(ppp_pcb *pcb);
 static void ipcp_input(ppp_pcb *pcb, u_char *p, int len);
 static void ipcp_protrej(ppp_pcb *pcb);
 #if PRINTPKT_SUPPORT
-static int ipcp_printpkt(u_char *p, int plen,
+static int ipcp_printpkt(const u_char *p, int plen,
 		void (*printer) (void *, const char *, ...), void *arg);
 #endif /* PRINTPKT_SUPPORT */
 #if PPP_OPTIONS
@@ -2226,10 +2226,10 @@ static const char* const ipcp_codenames[] = {
     "TermReq", "TermAck", "CodeRej"
 };
 
-static int ipcp_printpkt(u_char *p, int plen,
+static int ipcp_printpkt(const u_char *p, int plen,
 		void (*printer) (void *, const char *, ...), void *arg) {
     int code, id, len, olen;
-    u_char *pstart, *optend;
+    const u_char *pstart, *optend;
 #if VJ_SUPPORT
     u_short cishort;
 #endif /* VJ_SUPPORT */
diff --git a/src/netif/ppp/ipv6cp.c b/src/netif/ppp/ipv6cp.c
index ca0b1b5..48ad727 100644
--- a/src/netif/ppp/ipv6cp.c
+++ b/src/netif/ppp/ipv6cp.c
@@ -264,7 +264,7 @@ static void ipv6_check_options(void);
 static int  ipv6_demand_conf(int u);
 #endif /* DEMAND_SUPPORT */
 #if PRINTPKT_SUPPORT
-static int ipv6cp_printpkt(u_char *p, int plen,
+static int ipv6cp_printpkt(const u_char *p, int plen,
 		void (*printer)(void *, const char *, ...), void *arg);
 #endif /* PRINTPKT_SUPPORT */
 #if DEMAND_SUPPORT
@@ -1398,10 +1398,10 @@ static const char* const ipv6cp_codenames[] = {
     "TermReq", "TermAck", "CodeRej"
 };
 
-static int ipv6cp_printpkt(u_char *p, int plen,
+static int ipv6cp_printpkt(const u_char *p, int plen,
 		void (*printer)(void *, const char *, ...), void *arg) {
     int code, id, len, olen;
-    u_char *pstart, *optend;
+    const u_char *pstart, *optend;
 #ifdef IPV6CP_COMP
     u_short cishort;
 #endif /* IPV6CP_COMP */
diff --git a/src/netif/ppp/lcp.c b/src/netif/ppp/lcp.c
index 8ccead0..572fa03 100644
--- a/src/netif/ppp/lcp.c
+++ b/src/netif/ppp/lcp.c
@@ -268,7 +268,7 @@ static void lcp_init(ppp_pcb *pcb);
 static void lcp_input(ppp_pcb *pcb, u_char *p, int len);
 static void lcp_protrej(ppp_pcb *pcb);
 #if PRINTPKT_SUPPORT
-static int lcp_printpkt(u_char *p, int plen,
+static int lcp_printpkt(const u_char *p, int plen,
 		void (*printer) (void *, const char *, ...), void *arg);
 #endif /* PRINTPKT_SUPPORT */
 
@@ -2377,10 +2377,10 @@ static const char* const lcp_codenames[] = {
     "TimeRem"
 };
 
-static int lcp_printpkt(u_char *p, int plen,
+static int lcp_printpkt(const u_char *p, int plen,
 		void (*printer) (void *, const char *, ...), void *arg) {
     int code, id, len, olen, i;
-    u_char *pstart, *optend;
+    const u_char *pstart, *optend;
     u_short cishort;
     u32_t cilong;
 
diff --git a/src/netif/ppp/mppe.c b/src/netif/ppp/mppe.c
index 1996f80..67ca8e4 100644
--- a/src/netif/ppp/mppe.c
+++ b/src/netif/ppp/mppe.c
@@ -80,9 +80,9 @@ static void mppe_rekey(ppp_mppe_state * state, int initial_key)
 	 */
 	sha1_starts(&sha1);
 	sha1_update(&sha1, state->master_key, state->keylen);
-	sha1_update(&sha1, (unsigned char *)mppe_sha1_pad1, SHA1_PAD_SIZE);
+	sha1_update(&sha1, mppe_sha1_pad1, SHA1_PAD_SIZE);
 	sha1_update(&sha1, state->session_key, state->keylen);
-	sha1_update(&sha1, (unsigned char *)mppe_sha1_pad2, SHA1_PAD_SIZE);
+	sha1_update(&sha1, mppe_sha1_pad2, SHA1_PAD_SIZE);
 	sha1_finish(&sha1, sha1_digest);
 	MEMCPY(state->session_key, sha1_digest, state->keylen);
 
@@ -202,6 +202,8 @@ mppe_compress(ppp_pcb *pcb, ppp_mppe_state *state, struct pbuf **pb, u16_t proto
 	u8_t *pl;
 	err_t err;
 
+	LWIP_UNUSED_ARG(pcb);
+
 	/* TCP stack requires that we don't change the packet payload, therefore we copy
 	 * the whole packet before encryption.
 	 */
diff --git a/src/netif/ppp/polarssl/des.c b/src/netif/ppp/polarssl/des.c
index 38f3a74..0d6af84 100644
--- a/src/netif/ppp/polarssl/des.c
+++ b/src/netif/ppp/polarssl/des.c
@@ -394,7 +394,7 @@ void des_setkey_dec( des_context *ctx, unsigned char key[8] )
  * DES-ECB block encryption/decryption
  */
 void des_crypt_ecb( des_context *ctx,
-                    unsigned char input[8],
+                    const unsigned char input[8],
                     unsigned char output[8] )
 {
     int i;
diff --git a/src/netif/ppp/polarssl/md4.c b/src/netif/ppp/polarssl/md4.c
index 64d7766..b134cba 100644
--- a/src/netif/ppp/polarssl/md4.c
+++ b/src/netif/ppp/polarssl/md4.c
@@ -83,7 +83,7 @@ void md4_starts( md4_context *ctx )
     ctx->state[3] = 0x10325476;
 }
 
-static void md4_process( md4_context *ctx, unsigned char data[64] )
+static void md4_process( md4_context *ctx, const unsigned char data[64] )
 {
     unsigned long X[16], A, B, C, D;
 
@@ -189,7 +189,7 @@ static void md4_process( md4_context *ctx, unsigned char data[64] )
 /*
  * MD4 process buffer
  */
-void md4_update( md4_context *ctx, unsigned char *input, int ilen )
+void md4_update( md4_context *ctx, const unsigned char *input, int ilen )
 {
     int fill;
     unsigned long left;
@@ -209,7 +209,7 @@ void md4_update( md4_context *ctx, unsigned char *input, int ilen )
     if( left && ilen >= fill )
     {
         MEMCPY( (void *) (ctx->buffer + left),
-                (void *) input, fill );
+                input, fill );
         md4_process( ctx, ctx->buffer );
         input += fill;
         ilen  -= fill;
@@ -226,7 +226,7 @@ void md4_update( md4_context *ctx, unsigned char *input, int ilen )
     if( ilen > 0 )
     {
         MEMCPY( (void *) (ctx->buffer + left),
-                (void *) input, ilen );
+                input, ilen );
     }
 }
 
@@ -257,7 +257,7 @@ void md4_finish( md4_context *ctx, unsigned char output[16] )
     last = ctx->total[0] & 0x3F;
     padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );
 
-    md4_update( ctx, (unsigned char *) md4_padding, padn );
+    md4_update( ctx, md4_padding, padn );
     md4_update( ctx, msglen, 8 );
 
     PUT_ULONG_LE( ctx->state[0], output,  0 );
diff --git a/src/netif/ppp/polarssl/md5.c b/src/netif/ppp/polarssl/md5.c
index 9d0dae0..ba103c4 100644
--- a/src/netif/ppp/polarssl/md5.c
+++ b/src/netif/ppp/polarssl/md5.c
@@ -82,7 +82,7 @@ void md5_starts( md5_context *ctx )
     ctx->state[3] = 0x10325476;
 }
 
-static void md5_process( md5_context *ctx, unsigned char data[64] )
+static void md5_process( md5_context *ctx, const unsigned char data[64] )
 {
     unsigned long X[16], A, B, C, D;
 
@@ -208,7 +208,7 @@ static void md5_process( md5_context *ctx, unsigned char data[64] )
 /*
  * MD5 process buffer
  */
-void md5_update( md5_context *ctx, unsigned char *input, int ilen )
+void md5_update( md5_context *ctx, const unsigned char *input, int ilen )
 {
     int fill;
     unsigned long left;
@@ -228,7 +228,7 @@ void md5_update( md5_context *ctx, unsigned char *input, int ilen )
     if( left && ilen >= fill )
     {
         MEMCPY( (void *) (ctx->buffer + left),
-                (void *) input, fill );
+                input, fill );
         md5_process( ctx, ctx->buffer );
         input += fill;
         ilen  -= fill;
@@ -245,7 +245,7 @@ void md5_update( md5_context *ctx, unsigned char *input, int ilen )
     if( ilen > 0 )
     {
         MEMCPY( (void *) (ctx->buffer + left),
-                (void *) input, ilen );
+                input, ilen );
     }
 }
 
@@ -276,7 +276,7 @@ void md5_finish( md5_context *ctx, unsigned char output[16] )
     last = ctx->total[0] & 0x3F;
     padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );
 
-    md5_update( ctx, (unsigned char *) md5_padding, padn );
+    md5_update( ctx, md5_padding, padn );
     md5_update( ctx, msglen, 8 );
 
     PUT_ULONG_LE( ctx->state[0], output,  0 );
diff --git a/src/netif/ppp/polarssl/sha1.c b/src/netif/ppp/polarssl/sha1.c
index 89d4991..313b756 100644
--- a/src/netif/ppp/polarssl/sha1.c
+++ b/src/netif/ppp/polarssl/sha1.c
@@ -83,7 +83,7 @@ void sha1_starts( sha1_context *ctx )
     ctx->state[4] = 0xC3D2E1F0;
 }
 
-static void sha1_process( sha1_context *ctx, unsigned char data[64] )
+static void sha1_process( sha1_context *ctx, const unsigned char data[64] )
 {
     unsigned long temp, W[16], A, B, C, D, E;
 
@@ -242,7 +242,7 @@ static void sha1_process( sha1_context *ctx, unsigned char data[64] )
 /*
  * SHA-1 process buffer
  */
-void sha1_update( sha1_context *ctx, unsigned char *input, int ilen )
+void sha1_update( sha1_context *ctx, const unsigned char *input, int ilen )
 {
     int fill;
     unsigned long left;
@@ -262,7 +262,7 @@ void sha1_update( sha1_context *ctx, unsigned char *input, int ilen )
     if( left && ilen >= fill )
     {
         MEMCPY( (void *) (ctx->buffer + left),
-                (void *) input, fill );
+                input, fill );
         sha1_process( ctx, ctx->buffer );
         input += fill;
         ilen  -= fill;
@@ -279,7 +279,7 @@ void sha1_update( sha1_context *ctx, unsigned char *input, int ilen )
     if( ilen > 0 )
     {
         MEMCPY( (void *) (ctx->buffer + left),
-                (void *) input, ilen );
+                input, ilen );
     }
 }
 
@@ -310,7 +310,7 @@ void sha1_finish( sha1_context *ctx, unsigned char output[20] )
     last = ctx->total[0] & 0x3F;
     padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );
 
-    sha1_update( ctx, (unsigned char *) sha1_padding, padn );
+    sha1_update( ctx, sha1_padding, padn );
     sha1_update( ctx, msglen, 8 );
 
     PUT_ULONG_BE( ctx->state[0], output,  0 );
diff --git a/src/netif/ppp/ppp.c b/src/netif/ppp/ppp.c
index 26480c1..29370dd 100644
--- a/src/netif/ppp/ppp.c
+++ b/src/netif/ppp/ppp.c
@@ -87,7 +87,7 @@
 #include "lwip/sys.h"
 #include "lwip/tcpip.h"
 #include "lwip/api.h"
-#include "lwip/snmp.h"
+#include "lwip/snmp_mib2.h"
 #include "lwip/sio.h"
 #include "lwip/sys.h"
 #include "lwip/ip4.h" /* for ip4_input() */
@@ -388,9 +388,7 @@ ppp_ioctl(ppp_pcb *pcb, u8_t cmd, void *arg)
       return ERR_OK;
 
     default:
-      if (pcb->link_cb->ioctl) {
-        return pcb->link_cb->ioctl(pcb, pcb->link_ctx_cb, cmd, arg);
-      }
+      goto fail;
   }
 
 fail:
@@ -503,7 +501,7 @@ static err_t ppp_netif_output(struct netif *netif, struct pbuf *pb, u16_t protoc
         PPPDEBUG(LOG_WARNING, ("pppos_netif_output[%d]: bad IP packet\n", pcb->netif->num));
         LINK_STATS_INC(link.proterr);
         LINK_STATS_INC(link.drop);
-        snmp_inc_ifoutdiscards(pcb->netif);
+        MIB2_STATS_NETIF_INC(pcb->netif, ifoutdiscards);
         return ERR_VAL;
     }
   }
@@ -521,7 +519,7 @@ static err_t ppp_netif_output(struct netif *netif, struct pbuf *pb, u16_t protoc
       if ((err = mppe_compress(pcb, &pcb->mppe_comp, &pb, protocol)) != ERR_OK) {
         LINK_STATS_INC(link.memerr);
         LINK_STATS_INC(link.drop);
-        snmp_inc_ifoutdiscards(netif);
+        MIB2_STATS_NETIF_INC(netif, ifoutdiscards);
         return err;
       }
 
@@ -540,7 +538,7 @@ static err_t ppp_netif_output(struct netif *netif, struct pbuf *pb, u16_t protoc
 err_rte_drop:
   LINK_STATS_INC(link.rterr);
   LINK_STATS_INC(link.drop);
-  snmp_inc_ifoutdiscards(netif);
+  MIB2_STATS_NETIF_INC(netif, ifoutdiscards);
   return ERR_RTE;
 }
 
@@ -569,7 +567,7 @@ int ppp_init(void) {
  * Return a new PPP connection control block pointer
  * on success or a null pointer on failure.
  */
-ppp_pcb *ppp_new(struct netif *pppif, ppp_link_status_cb_fn link_status_cb, void *ctx_cb) {
+ppp_pcb *ppp_new(struct netif *pppif, const struct link_callbacks *callbacks, void *link_ctx_cb, ppp_link_status_cb_fn link_status_cb, void *ctx_cb) {
   ppp_pcb *pcb;
 
   /* PPP is single-threaded: without a callback,
@@ -639,17 +637,14 @@ ppp_pcb *ppp_new(struct netif *pppif, ppp_link_status_cb_fn link_status_cb, void
     return NULL;
   }
 
+  pcb->link_cb = callbacks;
+  pcb->link_ctx_cb = link_ctx_cb;
   pcb->link_status_cb = link_status_cb;
   pcb->ctx_cb = ctx_cb;
   new_phase(pcb, PPP_PHASE_DEAD);
   return pcb;
 }
 
-void ppp_link_set_callbacks(ppp_pcb *pcb, const struct link_callbacks *callbacks, void *ctx) {
-  pcb->link_cb = callbacks;
-  pcb->link_ctx_cb = ctx;
-}
-
 /* Set a PPP PCB to its initial state */
 void ppp_clear(ppp_pcb *pcb) {
   const struct protent *protp;
@@ -727,8 +722,8 @@ void ppp_input(ppp_pcb *pcb, struct pbuf *pb) {
   pbuf_header(pb, -(s16_t)sizeof(protocol));
 
   LINK_STATS_INC(link.recv);
-  snmp_inc_ifinucastpkts(pcb->netif);
-  snmp_add_ifinoctets(pcb->netif, pb->tot_len);
+  MIB2_STATS_NETIF_INC(pcb->netif, ifinucastpkts);
+  MIB2_STATS_NETIF_ADD(pcb->netif, ifinoctets, pb->tot_len);
 
   /*
    * Toss all non-LCP packets unless LCP is OPEN.
@@ -908,7 +903,7 @@ void ppp_input(ppp_pcb *pcb, struct pbuf *pb) {
 
 drop:
   LINK_STATS_INC(link.drop);
-  snmp_inc_ifindiscards(pcb->netif);
+  MIB2_STATS_NETIF_INC(pcb->netif, ifindiscards);
 
 out:
   pbuf_free(pb);
diff --git a/src/netif/ppp/pppoe.c b/src/netif/ppp/pppoe.c
index 1dfa515..ede5292 100644
--- a/src/netif/ppp/pppoe.c
+++ b/src/netif/ppp/pppoe.c
@@ -79,7 +79,7 @@
 #include "lwip/timers.h"
 #include "lwip/memp.h"
 #include "lwip/stats.h"
-#include "lwip/snmp.h"
+#include "lwip/snmp_mib2.h"
 
 #include "netif/ppp/ppp_impl.h"
 #include "netif/ppp/lcp.h"
@@ -156,7 +156,6 @@ static const struct link_callbacks pppoe_callbacks = {
   pppoe_write,
   pppoe_netif_output,
   NULL,
-  NULL,
   NULL
 };
 
@@ -175,29 +174,25 @@ ppp_pcb *pppoe_create(struct netif *pppif,
   LWIP_UNUSED_ARG(service_name);
   LWIP_UNUSED_ARG(concentrator_name);
 
-  ppp = ppp_new(pppif, link_status_cb, ctx_cb);
-  if (ppp == NULL) {
+  sc = (struct pppoe_softc *)memp_malloc(MEMP_PPPOE_IF);
+  if (sc == NULL) {
     return NULL;
   }
 
-  sc = (struct pppoe_softc *)memp_malloc(MEMP_PPPOE_IF);
-  if (sc == NULL) {
-    ppp_free(ppp);
+  ppp = ppp_new(pppif, &pppoe_callbacks, sc, link_status_cb, ctx_cb);
+  if (ppp == NULL) {
+    memp_free(MEMP_PPPOE_IF, sc);
     return NULL;
   }
-  memset(sc, 0, sizeof(struct pppoe_softc));
 
+  memset(sc, 0, sizeof(struct pppoe_softc));
   /* changed to real address later */
   MEMCPY(&sc->sc_dest, ethbroadcast.addr, sizeof(sc->sc_dest));
-
   sc->pcb = ppp;
   sc->sc_ethif = ethif;
-
   /* put the new interface at the head of the list */
   sc->next = pppoe_softc_list;
   pppoe_softc_list = sc;
-
-  ppp_link_set_callbacks(ppp, &pppoe_callbacks, sc);
   return ppp;
 }
 
@@ -206,11 +201,11 @@ static err_t pppoe_write(ppp_pcb *ppp, void *ctx, struct pbuf *p) {
   struct pppoe_softc *sc = (struct pppoe_softc *)ctx;
   struct pbuf *ph; /* Ethernet + PPPoE header */
   err_t ret;
-#if LWIP_SNMP
+#if MIB2_STATS
   u16_t tot_len;
-#else /* LWIP_SNMP */
+#else /* MIB2_STATS */
   LWIP_UNUSED_ARG(ppp);
-#endif /* LWIP_SNMP */
+#endif /* MIB2_STATS */
 
   /* skip address & flags */
   pbuf_header(p, -(s16_t)2);
@@ -219,26 +214,26 @@ static err_t pppoe_write(ppp_pcb *ppp, void *ctx, struct pbuf *p) {
   if(!ph) {
     LINK_STATS_INC(link.memerr);
     LINK_STATS_INC(link.proterr);
-    snmp_inc_ifoutdiscards(ppp->netif);
+    MIB2_STATS_NETIF_INC(ppp->netif, ifoutdiscards);
     pbuf_free(p);
     return ERR_MEM;
   }
 
   pbuf_header(ph, -(s16_t)PPPOE_HEADERLEN); /* hide PPPoE header */
   pbuf_cat(ph, p);
-#if LWIP_SNMP
+#if MIB2_STATS
   tot_len = ph->tot_len;
-#endif /* LWIP_SNMP */
+#endif /* MIB2_STATS */
 
   ret = pppoe_xmit(sc, ph);
   if (ret != ERR_OK) {
     LINK_STATS_INC(link.err);
-    snmp_inc_ifoutdiscards(ppp->netif);
+    MIB2_STATS_NETIF_INC(ppp->netif, ifoutdiscards);
     return ret;
   }
 
-  snmp_add_ifoutoctets(ppp->netif, (u16_t)tot_len);
-  snmp_inc_ifoutucastpkts(ppp->netif);
+  MIB2_STATS_NETIF_ADD(ppp->netif, ifoutoctets, (u16_t)tot_len);
+  MIB2_STATS_NETIF_INC(ppp->netif, ifoutucastpkts);
   LINK_STATS_INC(link.xmit);
   return ERR_OK;
 }
@@ -249,18 +244,18 @@ static err_t pppoe_netif_output(ppp_pcb *ppp, void *ctx, struct pbuf *p, u_short
   struct pbuf *pb;
   u8_t *pl;
   err_t err;
-#if LWIP_SNMP
+#if MIB2_STATS
   u16_t tot_len;
-#else /* LWIP_SNMP */
+#else /* MIB2_STATS */
   LWIP_UNUSED_ARG(ppp);
-#endif /* LWIP_SNMP */
+#endif /* MIB2_STATS */
 
   /* @todo: try to use pbuf_header() here! */
   pb = pbuf_alloc(PBUF_LINK, PPPOE_HEADERLEN + sizeof(protocol), PBUF_RAM);
   if(!pb) {
     LINK_STATS_INC(link.memerr);
     LINK_STATS_INC(link.proterr);
-    snmp_inc_ifoutdiscards(ppp->netif);
+    MIB2_STATS_NETIF_INC(ppp->netif, ifoutdiscards);
     return ERR_MEM;
   }
 
@@ -270,18 +265,18 @@ static err_t pppoe_netif_output(ppp_pcb *ppp, void *ctx, struct pbuf *p, u_short
   PUTSHORT(protocol, pl);
 
   pbuf_chain(pb, p);
-#if LWIP_SNMP
+#if MIB2_STATS
   tot_len = pb->tot_len;
-#endif /* LWIP_SNMP */
+#endif /* MIB2_STATS */
 
   if( (err = pppoe_xmit(sc, pb)) != ERR_OK) {
     LINK_STATS_INC(link.err);
-    snmp_inc_ifoutdiscards(ppp->netif);
+    MIB2_STATS_NETIF_INC(ppp->netif, ifoutdiscards);
     return err;
   }
 
-  snmp_add_ifoutoctets(ppp->netif, tot_len);
-  snmp_inc_ifoutucastpkts(ppp->netif);
+  MIB2_STATS_NETIF_ADD(ppp->netif, ifoutoctets, tot_len);
+  MIB2_STATS_NETIF_INC(ppp->netif, ifoutucastpkts);
   LINK_STATS_INC(link.xmit);
   return ERR_OK;
 }
diff --git a/src/netif/ppp/pppol2tp.c b/src/netif/ppp/pppol2tp.c
index 333d136..c9defe1 100644
--- a/src/netif/ppp/pppol2tp.c
+++ b/src/netif/ppp/pppol2tp.c
@@ -57,7 +57,7 @@
 #include "lwip/memp.h"
 #include "lwip/netif.h"
 #include "lwip/udp.h"
-#include "lwip/snmp.h"
+#include "lwip/snmp_mib2.h"
 
 #include "netif/ppp/ppp_impl.h"
 #include "netif/ppp/lcp.h"
@@ -107,7 +107,6 @@ static const struct link_callbacks pppol2tp_callbacks = {
   pppol2tp_write,
   pppol2tp_netif_output,
   NULL,
-  NULL,
   NULL
 };
 
@@ -125,16 +124,16 @@ ppp_pcb *pppol2tp_create(struct netif *pppif,
     goto ipaddr_check_failed;
   }
 
-  ppp = ppp_new(pppif, link_status_cb, ctx_cb);
-  if (ppp == NULL) {
-    goto ppp_new_failed;
-  }
-
   l2tp = (pppol2tp_pcb *)memp_malloc(MEMP_PPPOL2TP_PCB);
   if (l2tp == NULL) {
     goto memp_malloc_l2tp_failed;
   }
 
+  ppp = ppp_new(pppif, &pppol2tp_callbacks, l2tp, link_status_cb, ctx_cb);
+  if (ppp == NULL) {
+    goto ppp_new_failed;
+  }
+
 #if LWIP_IPV6
   if (IP_IS_V6_VAL(*ipaddr)) {
     udp = udp_new_ip6();
@@ -158,14 +157,13 @@ ppp_pcb *pppol2tp_create(struct netif *pppif,
   l2tp->secret_len = secret_len;
 #endif /* PPPOL2TP_AUTH_SUPPORT */
 
-  ppp_link_set_callbacks(ppp, &pppol2tp_callbacks, l2tp);
   return ppp;
 
 udp_new_failed:
-  memp_free(MEMP_PPPOL2TP_PCB, l2tp);
-memp_malloc_l2tp_failed:
   ppp_free(ppp);
 ppp_new_failed:
+  memp_free(MEMP_PPPOL2TP_PCB, l2tp);
+memp_malloc_l2tp_failed:
 ipaddr_check_failed:
   return NULL;
 }
@@ -175,36 +173,36 @@ static err_t pppol2tp_write(ppp_pcb *ppp, void *ctx, struct pbuf *p) {
   pppol2tp_pcb *l2tp = (pppol2tp_pcb *)ctx;
   struct pbuf *ph; /* UDP + L2TP header */
   err_t ret;
-#if LWIP_SNMP
+#if MIB2_STATS
   u16_t tot_len;
-#else /* LWIP_SNMP */
+#else /* MIB2_STATS */
   LWIP_UNUSED_ARG(ppp);
-#endif /* LWIP_SNMP */
+#endif /* MIB2_STATS */
 
   ph = pbuf_alloc(PBUF_TRANSPORT, (u16_t)(PPPOL2TP_OUTPUT_DATA_HEADER_LEN), PBUF_RAM);
   if(!ph) {
     LINK_STATS_INC(link.memerr);
     LINK_STATS_INC(link.proterr);
-    snmp_inc_ifoutdiscards(ppp->netif);
+    MIB2_STATS_NETIF_INC(ppp->netif, ifoutdiscards);
     pbuf_free(p);
     return ERR_MEM;
   }
 
   pbuf_header(ph, -(s16_t)PPPOL2TP_OUTPUT_DATA_HEADER_LEN); /* hide L2TP header */
   pbuf_cat(ph, p);
-#if LWIP_SNMP
+#if MIB2_STATS
   tot_len = ph->tot_len;
-#endif /* LWIP_SNMP */
+#endif /* MIB2_STATS */
 
   ret = pppol2tp_xmit(l2tp, ph);
   if (ret != ERR_OK) {
     LINK_STATS_INC(link.err);
-    snmp_inc_ifoutdiscards(ppp->netif);
+    MIB2_STATS_NETIF_INC(ppp->netif, ifoutdiscards);
     return ret;
   }
 
-  snmp_add_ifoutoctets(ppp->netif, (u16_t)tot_len);
-  snmp_inc_ifoutucastpkts(ppp->netif);
+  MIB2_STATS_NETIF_ADD(ppp->netif, ifoutoctets, (u16_t)tot_len);
+  MIB2_STATS_NETIF_INC(ppp->netif, ifoutucastpkts);
   LINK_STATS_INC(link.xmit);
   return ERR_OK;
 }
@@ -215,18 +213,18 @@ static err_t pppol2tp_netif_output(ppp_pcb *ppp, void *ctx, struct pbuf *p, u_sh
   struct pbuf *pb;
   u8_t *pl;
   err_t err;
-#if LWIP_SNMP
+#if MIB2_STATS
   u16_t tot_len;
-#else /* LWIP_SNMP */
+#else /* MIB2_STATS */
   LWIP_UNUSED_ARG(ppp);
-#endif /* LWIP_SNMP */
+#endif /* MIB2_STATS */
 
   /* @todo: try to use pbuf_header() here! */
   pb = pbuf_alloc(PBUF_TRANSPORT, PPPOL2TP_OUTPUT_DATA_HEADER_LEN + sizeof(protocol), PBUF_RAM);
   if(!pb) {
     LINK_STATS_INC(link.memerr);
     LINK_STATS_INC(link.proterr);
-    snmp_inc_ifoutdiscards(ppp->netif);
+    MIB2_STATS_NETIF_INC(ppp->netif, ifoutdiscards);
     return ERR_MEM;
   }
 
@@ -236,18 +234,18 @@ static err_t pppol2tp_netif_output(ppp_pcb *ppp, void *ctx, struct pbuf *p, u_sh
   PUTSHORT(protocol, pl);
 
   pbuf_chain(pb, p);
-#if LWIP_SNMP
+#if MIB2_STATS
   tot_len = pb->tot_len;
-#endif /* LWIP_SNMP */
+#endif /* MIB2_STATS */
 
   if( (err = pppol2tp_xmit(l2tp, pb)) != ERR_OK) {
     LINK_STATS_INC(link.err);
-    snmp_inc_ifoutdiscards(ppp->netif);
+    MIB2_STATS_NETIF_INC(ppp->netif, ifoutdiscards);
     return err;
   }
 
-  snmp_add_ifoutoctets(ppp->netif, tot_len);
-  snmp_inc_ifoutucastpkts(ppp->netif);
+  MIB2_STATS_NETIF_ADD(ppp->netif, ifoutoctets, tot_len);
+  MIB2_STATS_NETIF_INC(ppp->netif, ifoutucastpkts);
   LINK_STATS_INC(link.xmit);
   return ERR_OK;
 }
diff --git a/src/netif/ppp/pppos.c b/src/netif/ppp/pppos.c
index dc418e9..9541122 100644
--- a/src/netif/ppp/pppos.c
+++ b/src/netif/ppp/pppos.c
@@ -41,10 +41,9 @@
 #include "lwip/sys.h"
 #include "lwip/memp.h"
 #include "lwip/netif.h"
-#include "lwip/snmp.h"
+#include "lwip/snmp_mib2.h"
 #include "lwip/tcpip.h"
 #include "lwip/api.h"
-#include "lwip/sio.h"
 #include "lwip/ip4.h" /* for ip4_input() */
 
 #include "netif/ppp/ppp_impl.h"
@@ -62,7 +61,6 @@ static void pppos_disconnect(ppp_pcb *ppp, void *ctx);
 static err_t pppos_destroy(ppp_pcb *ppp, void *ctx);
 static void pppos_send_config(ppp_pcb *ppp, void *ctx, u32_t accm, int pcomp, int accomp);
 static void pppos_recv_config(ppp_pcb *ppp, void *ctx, u32_t accm, int pcomp, int accomp);
-static err_t pppos_ioctl(ppp_pcb *pcb, void *ctx, int cmd, void *arg);
 
 /* Prototypes for procedures local to this file. */
 #if PPP_INPROC_IRQ_SAFE
@@ -84,8 +82,7 @@ static const struct link_callbacks pppos_callbacks = {
   pppos_write,
   pppos_netif_output,
   pppos_send_config,
-  pppos_recv_config,
-  pppos_ioctl
+  pppos_recv_config
 };
 
 /* PPP's Asynchronous-Control-Character-Map.  The mask array is used
@@ -170,26 +167,25 @@ ppp_get_fcs(u8_t byte)
  *
  * Return 0 on success, an error code on failure.
  */
-ppp_pcb *pppos_create(struct netif *pppif, sio_fd_t fd,
+ppp_pcb *pppos_create(struct netif *pppif, pppos_output_cb_fn output_cb,
        ppp_link_status_cb_fn link_status_cb, void *ctx_cb)
 {
   pppos_pcb *pppos;
   ppp_pcb *ppp;
 
-  ppp = ppp_new(pppif, link_status_cb, ctx_cb);
-  if (ppp == NULL) {
+  pppos = (pppos_pcb *)memp_malloc(MEMP_PPPOS_PCB);
+  if (pppos == NULL) {
     return NULL;
   }
 
-  pppos = (pppos_pcb *)memp_malloc(MEMP_PPPOS_PCB);
-  if (pppos == NULL) {
-    ppp_free(ppp);
+  ppp = ppp_new(pppif, &pppos_callbacks, pppos, link_status_cb, ctx_cb);
+  if (ppp == NULL) {
+    memp_free(MEMP_PPPOS_PCB, pppos);
     return NULL;
   }
 
   pppos->ppp = ppp;
-  pppos->fd = fd;
-  ppp_link_set_callbacks(ppp, &pppos_callbacks, pppos);
+  pppos->output_cb = output_cb;
   return ppp;
 }
 
@@ -211,7 +207,7 @@ pppos_write(ppp_pcb *ppp, void *ctx, struct pbuf *p)
     PPPDEBUG(LOG_WARNING, ("pppos_write[%d]: alloc fail\n", ppp->netif->num));
     LINK_STATS_INC(link.memerr);
     LINK_STATS_INC(link.drop);
-    snmp_inc_ifoutdiscards(ppp->netif);
+    MIB2_STATS_NETIF_INC(ppp->netif, ifoutdiscards);
     pbuf_free(p);
     return ERR_MEM;
   }
@@ -257,7 +253,7 @@ pppos_netif_output(ppp_pcb *ppp, void *ctx, struct pbuf *pb, u16_t protocol)
     PPPDEBUG(LOG_WARNING, ("pppos_netif_output[%d]: alloc fail\n", ppp->netif->num));
     LINK_STATS_INC(link.memerr);
     LINK_STATS_INC(link.drop);
-    snmp_inc_ifoutdiscards(ppp->netif);
+    MIB2_STATS_NETIF_INC(ppp->netif, ifoutdiscards);
     return ERR_MEM;
   }
 
@@ -575,7 +571,7 @@ pppos_input(ppp_pcb *ppp, u8_t *s, int l)
             PPPDEBUG(LOG_ERR, ("pppos_input[%d]: tcpip_callback() failed, dropping packet\n", ppp->netif->num));
             pbuf_free(inp);
             LINK_STATS_INC(link.drop);
-            snmp_inc_ifindiscards(ppp->netif);
+            MIB2_STATS_NETIF_INC(ppp->netif, ifindiscards);
           }
 #else /* PPP_INPROC_IRQ_SAFE */
           ppp_input(ppp, inp);
@@ -736,7 +732,7 @@ static void pppos_input_callback(void *arg) {
 
 drop:
   LINK_STATS_INC(link.drop);
-  snmp_inc_ifindiscards(ppp->netif);
+  MIB2_STATS_NETIF_INC(ppp->netif, ifindiscards);
   pbuf_free(pb);
 }
 #endif /* PPP_INPROC_IRQ_SAFE */
@@ -783,27 +779,6 @@ pppos_recv_config(ppp_pcb *ppp, void *ctx, u32_t accm, int pcomp, int accomp)
             pppos->in_accm[0], pppos->in_accm[1], pppos->in_accm[2], pppos->in_accm[3]));
 }
 
-static err_t
-pppos_ioctl(ppp_pcb *pcb, void *ctx, int cmd, void *arg)
-{
-  pppos_pcb *pppos = (pppos_pcb *)ctx;
-  LWIP_UNUSED_ARG(pcb);
-
-  switch(cmd) {
-    case PPPCTLG_FD:            /* Get the fd associated with the ppp */
-      if (!arg) {
-        goto fail;
-      }
-      *(sio_fd_t *)arg = pppos->fd;
-      return ERR_OK;
-
-    default: ;
-  }
-
-fail:
-  return ERR_VAL;
-}
-
 /*
  * Drop the input packet.
  */
@@ -838,7 +813,7 @@ pppos_input_drop(pppos_pcb *pppos)
 #endif /* VJ_SUPPORT */
 
   LINK_STATS_INC(link.drop);
-  snmp_inc_ifindiscards(pppos->ppp->netif);
+  MIB2_STATS_NETIF_INC(pppos->ppp->netif, ifindiscards);
 }
 
 /*
@@ -858,7 +833,7 @@ pppos_output_append(pppos_pcb *pppos, err_t err, struct pbuf *nb, u8_t c, u8_t a
    * Sure we don't quite fill the buffer if the character doesn't
    * get escaped but is one character worth complicating this? */
   if ((PBUF_POOL_BUFSIZE - nb->len) < 2) {
-    u32_t l = sio_write(pppos->fd, (u8_t*)nb->payload, nb->len);
+    u32_t l = pppos->output_cb(pppos->ppp, (u8_t*)nb->payload, nb->len, pppos->ppp->ctx_cb);
     if (l != nb->len) {
       return ERR_IF;
     }
@@ -884,9 +859,7 @@ pppos_output_append(pppos_pcb *pppos, err_t err, struct pbuf *nb, u8_t c, u8_t a
 static err_t
 pppos_output_last(pppos_pcb *pppos, err_t err, struct pbuf *nb, u16_t *fcs)
 {
-#if LWIP_SNMP
   ppp_pcb *ppp = pppos->ppp;
-#endif /* LWIP_SNMP */
 
   /* Add FCS and trailing flag. */
   err = pppos_output_append(pppos, err,  nb, ~(*fcs) & 0xFF, 1, NULL);
@@ -899,7 +872,7 @@ pppos_output_last(pppos_pcb *pppos, err_t err, struct pbuf *nb, u16_t *fcs)
 
   /* Send remaining buffer if not empty */
   if (nb->len > 0) {
-    u32_t l = sio_write(pppos->fd, (u8_t*)nb->payload, nb->len);
+    u32_t l = pppos->output_cb(ppp, (u8_t*)nb->payload, nb->len, ppp->ctx_cb);
     if (l != nb->len) {
       err = ERR_IF;
       goto failed;
@@ -907,8 +880,8 @@ pppos_output_last(pppos_pcb *pppos, err_t err, struct pbuf *nb, u16_t *fcs)
   }
 
   pppos->last_xmit = sys_jiffies();
-  snmp_add_ifoutoctets(ppp->netif, nb->tot_len);
-  snmp_inc_ifoutucastpkts(ppp->netif);
+  MIB2_STATS_NETIF_ADD(ppp->netif, ifoutoctets, nb->tot_len);
+  MIB2_STATS_NETIF_INC(ppp->netif, ifoutucastpkts);
   LINK_STATS_INC(link.xmit);
   pbuf_free(nb);
   return ERR_OK;
@@ -917,7 +890,7 @@ failed:
   pppos->last_xmit = 0; /* prepend PPP_FLAG to next packet */
   LINK_STATS_INC(link.err);
   LINK_STATS_INC(link.drop);
-  snmp_inc_ifoutdiscards(ppp->netif);
+  MIB2_STATS_NETIF_INC(ppp->netif, ifoutdiscards);
   pbuf_free(nb);
   return err;
 }
diff --git a/src/netif/ppp/upap.c b/src/netif/ppp/upap.c
index 756e711..f1fece3 100644
--- a/src/netif/ppp/upap.c
+++ b/src/netif/ppp/upap.c
@@ -86,7 +86,7 @@ static void upap_lowerdown(ppp_pcb *pcb);
 static void upap_input(ppp_pcb *pcb, u_char *inpacket, int l);
 static void upap_protrej(ppp_pcb *pcb);
 #if PRINTPKT_SUPPORT
-static int upap_printpkt(u_char *p, int plen, void (*printer) (void *, const char *, ...), void *arg);
+static int upap_printpkt(const u_char *p, int plen, void (*printer) (void *, const char *, ...), void *arg);
 #endif /* PRINTPKT_SUPPORT */
 
 const struct protent pap_protent = {
@@ -599,11 +599,11 @@ static const char* const upap_codenames[] = {
     "AuthReq", "AuthAck", "AuthNak"
 };
 
-static int upap_printpkt(u_char *p, int plen, void (*printer) (void *, const char *, ...), void *arg) {
+static int upap_printpkt(const u_char *p, int plen, void (*printer) (void *, const char *, ...), void *arg) {
     int code, id, len;
     int mlen, ulen, wlen;
     char *user, *pwd, *msg;
-    u_char *pstart;
+    const u_char *pstart;
 
     if (plen < UPAP_HEADERLEN)
 	return 0;
diff --git a/src/netif/ppp/utils.c b/src/netif/ppp/utils.c
index afa6fd4..cf68e34 100644
--- a/src/netif/ppp/utils.c
+++ b/src/netif/ppp/utils.c
@@ -73,7 +73,7 @@ static void ppp_logit(int level, const char *fmt, va_list args);
 static void ppp_log_write(int level, char *buf);
 #if PRINTPKT_SUPPORT
 static void ppp_vslp_printer(void *arg, const char *fmt, ...);
-static void ppp_format_packet(u_char *p, int len,
+static void ppp_format_packet(const u_char *p, int len,
 		void (*printer) (void *, const char *, ...), void *arg);
 
 struct buffer_info {
@@ -141,7 +141,7 @@ int ppp_vslprintf(char *buf, int buflen, const char *fmt, va_list args) {
     unsigned long val = 0;
     const char *f;
     char *str, *buf0;
-    unsigned char *p;
+    const unsigned char *p;
     char num[32];
 #if 0 /* need port */
     time_t t;
@@ -285,11 +285,11 @@ int ppp_vslprintf(char *buf, int buflen, const char *fmt, va_list args) {
 	    quoted = c == 'q';
 	    p = va_arg(args, unsigned char *);
 	    if (p == NULL)
-		p = (unsigned char *)"<NULL>";
+		p = (const unsigned char *)"<NULL>";
 	    if (fillch == '0' && prec >= 0) {
 		n = prec;
 	    } else {
-		n = strlen((char *)p);
+		n = strlen((const char *)p);
 		if (prec >= 0 && n > prec)
 		    n = prec;
 	    }
@@ -443,7 +443,7 @@ log_packet(p, len, prefix, level)
  * ppp_format_packet - make a readable representation of a packet,
  * calling `printer(arg, format, ...)' to output it.
  */
-static void ppp_format_packet(u_char *p, int len,
+static void ppp_format_packet(const u_char *p, int len,
 		void (*printer) (void *, const char *, ...), void *arg) {
     int i, n;
     u_short proto;
diff --git a/src/netif/slipif.c b/src/netif/slipif.c
index f1765de..8321208 100644
--- a/src/netif/slipif.c
+++ b/src/netif/slipif.c
@@ -63,7 +63,7 @@
 #include "lwip/def.h"
 #include "lwip/pbuf.h"
 #include "lwip/stats.h"
-#include "lwip/snmp.h"
+#include "lwip/snmp_mib2.h"
 #include "lwip/sys.h"
 #include "lwip/sio.h"
 
@@ -396,7 +396,7 @@ slipif_init(struct netif *netif)
   netif->state = priv;
 
   /* initialize the snmp variables and counters inside the struct netif */
-  NETIF_INIT_SNMP(netif, snmp_ifType_slip, SLIP_SIO_SPEED(priv->sd));
+  MIB2_INIT_NETIF(netif, snmp_ifType_slip, SLIP_SIO_SPEED(priv->sd));
 
 #if SLIP_USE_RX_THREAD
   /* Create a thread to poll the serial line. */
-- 
1.9.1


From 6dbb6ed1ba99dcfccecdeb4bd1a5ae584551439a Mon Sep 17 00:00:00 2001
From: Jay Doyle <jay.doyle@vecna.com>
Date: Thu, 15 Oct 2015 14:17:36 -0400
Subject: [PATCH 33/33] change create task

---
 ports/sys_arch.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/ports/sys_arch.c b/ports/sys_arch.c
index f01a047..bcd82e3 100644
--- a/ports/sys_arch.c
+++ b/ports/sys_arch.c
@@ -274,8 +274,8 @@ sys_thread_new(const char *name, lwip_thread_fn function, void *arg, int stack_s
     rtems_build_name('L', 'W', 'I', 'P'),
     prio,
     stack_size,
-    RTEMS_PREEMPT,
-    0,
+    RTEMS_DEFAULT_MODES,
+    RTEMS_DEFAULT_ATTRIBUTES,
     &id
     );
 
-- 
1.9.1

